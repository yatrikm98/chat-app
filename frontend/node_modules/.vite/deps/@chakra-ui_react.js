import {
  require_jsx_runtime
} from "./chunk-MJNCUEZK.js";
import {
  _extends,
  require_hoist_non_react_statics_cjs
} from "./chunk-M5HWIYJV.js";
import {
  createCache,
  getRegisteredStyles,
  insertStyles,
  memoize,
  registerStyles,
  serializeStyles,
  weakMemoize
} from "./chunk-6755MQAY.js";
import {
  require_react_dom
} from "./chunk-HE4GKDYE.js";
import {
  require_react
} from "./chunk-UGC3UZ7L.js";
import {
  __commonJS,
  __export,
  __toESM
} from "./chunk-G3PMV62Z.js";

// node_modules/fast-safe-stringify/index.js
var require_fast_safe_stringify = __commonJS({
  "node_modules/fast-safe-stringify/index.js"(exports, module) {
    module.exports = stringify2;
    stringify2.default = stringify2;
    stringify2.stable = deterministicStringify;
    stringify2.stableStringify = deterministicStringify;
    var LIMIT_REPLACE_NODE = "[...]";
    var CIRCULAR_REPLACE_NODE = "[Circular]";
    var arr = [];
    var replacerStack = [];
    function defaultOptions2() {
      return {
        depthLimit: Number.MAX_SAFE_INTEGER,
        edgesLimit: Number.MAX_SAFE_INTEGER
      };
    }
    function stringify2(obj, replacer, spacer, options) {
      if (typeof options === "undefined") {
        options = defaultOptions2();
      }
      decirc(obj, "", 0, [], void 0, 0, options);
      var res;
      try {
        if (replacerStack.length === 0) {
          res = JSON.stringify(obj, replacer, spacer);
        } else {
          res = JSON.stringify(obj, replaceGetterValues(replacer), spacer);
        }
      } catch (_) {
        return JSON.stringify("[unable to serialize, circular reference is too complex to analyze]");
      } finally {
        while (arr.length !== 0) {
          var part = arr.pop();
          if (part.length === 4) {
            Object.defineProperty(part[0], part[1], part[3]);
          } else {
            part[0][part[1]] = part[2];
          }
        }
      }
      return res;
    }
    function setReplace(replace2, val, k, parent) {
      var propertyDescriptor = Object.getOwnPropertyDescriptor(parent, k);
      if (propertyDescriptor.get !== void 0) {
        if (propertyDescriptor.configurable) {
          Object.defineProperty(parent, k, { value: replace2 });
          arr.push([parent, k, val, propertyDescriptor]);
        } else {
          replacerStack.push([val, k, replace2]);
        }
      } else {
        parent[k] = replace2;
        arr.push([parent, k, val]);
      }
    }
    function decirc(val, k, edgeIndex, stack, parent, depth, options) {
      depth += 1;
      var i;
      if (typeof val === "object" && val !== null) {
        for (i = 0; i < stack.length; i++) {
          if (stack[i] === val) {
            setReplace(CIRCULAR_REPLACE_NODE, val, k, parent);
            return;
          }
        }
        if (typeof options.depthLimit !== "undefined" && depth > options.depthLimit) {
          setReplace(LIMIT_REPLACE_NODE, val, k, parent);
          return;
        }
        if (typeof options.edgesLimit !== "undefined" && edgeIndex + 1 > options.edgesLimit) {
          setReplace(LIMIT_REPLACE_NODE, val, k, parent);
          return;
        }
        stack.push(val);
        if (Array.isArray(val)) {
          for (i = 0; i < val.length; i++) {
            decirc(val[i], i, i, stack, val, depth, options);
          }
        } else {
          var keys = Object.keys(val);
          for (i = 0; i < keys.length; i++) {
            var key = keys[i];
            decirc(val[key], key, i, stack, val, depth, options);
          }
        }
        stack.pop();
      }
    }
    function compareFunction(a2, b2) {
      if (a2 < b2) {
        return -1;
      }
      if (a2 > b2) {
        return 1;
      }
      return 0;
    }
    function deterministicStringify(obj, replacer, spacer, options) {
      if (typeof options === "undefined") {
        options = defaultOptions2();
      }
      var tmp = deterministicDecirc(obj, "", 0, [], void 0, 0, options) || obj;
      var res;
      try {
        if (replacerStack.length === 0) {
          res = JSON.stringify(tmp, replacer, spacer);
        } else {
          res = JSON.stringify(tmp, replaceGetterValues(replacer), spacer);
        }
      } catch (_) {
        return JSON.stringify("[unable to serialize, circular reference is too complex to analyze]");
      } finally {
        while (arr.length !== 0) {
          var part = arr.pop();
          if (part.length === 4) {
            Object.defineProperty(part[0], part[1], part[3]);
          } else {
            part[0][part[1]] = part[2];
          }
        }
      }
      return res;
    }
    function deterministicDecirc(val, k, edgeIndex, stack, parent, depth, options) {
      depth += 1;
      var i;
      if (typeof val === "object" && val !== null) {
        for (i = 0; i < stack.length; i++) {
          if (stack[i] === val) {
            setReplace(CIRCULAR_REPLACE_NODE, val, k, parent);
            return;
          }
        }
        try {
          if (typeof val.toJSON === "function") {
            return;
          }
        } catch (_) {
          return;
        }
        if (typeof options.depthLimit !== "undefined" && depth > options.depthLimit) {
          setReplace(LIMIT_REPLACE_NODE, val, k, parent);
          return;
        }
        if (typeof options.edgesLimit !== "undefined" && edgeIndex + 1 > options.edgesLimit) {
          setReplace(LIMIT_REPLACE_NODE, val, k, parent);
          return;
        }
        stack.push(val);
        if (Array.isArray(val)) {
          for (i = 0; i < val.length; i++) {
            deterministicDecirc(val[i], i, i, stack, val, depth, options);
          }
        } else {
          var tmp = {};
          var keys = Object.keys(val).sort(compareFunction);
          for (i = 0; i < keys.length; i++) {
            var key = keys[i];
            deterministicDecirc(val[key], key, i, stack, val, depth, options);
            tmp[key] = val[key];
          }
          if (typeof parent !== "undefined") {
            arr.push([parent, k, val]);
            parent[k] = tmp;
          } else {
            return tmp;
          }
        }
        stack.pop();
      }
    }
    function replaceGetterValues(replacer) {
      replacer = typeof replacer !== "undefined" ? replacer : function(k, v) {
        return v;
      };
      return function(key, val) {
        if (replacerStack.length > 0) {
          for (var i = 0; i < replacerStack.length; i++) {
            var part = replacerStack[i];
            if (part[1] === key && part[0] === val) {
              val = part[2];
              replacerStack.splice(i, 1);
              break;
            }
          }
        }
        return replacer.call(this, key, val);
      };
    }
  }
});

// node_modules/@chakra-ui/react/dist/esm/components/color-swatch/index.js
var import_jsx_runtime5 = __toESM(require_jsx_runtime(), 1);
var import_react9 = __toESM(require_react(), 1);

// node_modules/@chakra-ui/react/dist/esm/utils/cx.js
var cx = (...classNames) => classNames.filter(Boolean).map((r) => r.trim()).join(" ");

// node_modules/@chakra-ui/react/dist/esm/styled-system/create-recipe-context.js
var import_jsx_runtime3 = __toESM(require_jsx_runtime(), 1);
var import_react7 = __toESM(require_react(), 1);

// node_modules/@chakra-ui/react/dist/esm/create-context.js
var import_react = __toESM(require_react(), 1);
function getErrorMessage(hook, provider) {
  return `${hook} returned \`undefined\`. Seems you forgot to wrap component within ${provider}`;
}
function createContext(options = {}) {
  const {
    name,
    strict = true,
    hookName = "useContext",
    providerName = "Provider",
    errorMessage,
    defaultValue
  } = options;
  const Context = (0, import_react.createContext)(defaultValue);
  Context.displayName = name;
  function useContext$1() {
    var _a8;
    const context = (0, import_react.useContext)(Context);
    if (!context && strict) {
      const error = new Error(
        errorMessage ?? getErrorMessage(hookName, providerName)
      );
      error.name = "ContextError";
      (_a8 = Error.captureStackTrace) == null ? void 0 : _a8.call(Error, error, useContext$1);
      throw error;
    }
    return context;
  }
  return [Context.Provider, useContext$1, Context];
}

// node_modules/@chakra-ui/react/dist/esm/utils/call-all.js
function callAll(...fns) {
  return function mergedFn(...args) {
    fns.forEach((fn) => fn == null ? void 0 : fn(...args));
  };
}

// node_modules/@chakra-ui/react/dist/esm/merge-props.js
var clsx = (...args) => args.map((str) => {
  var _a8;
  return (_a8 = str == null ? void 0 : str.trim) == null ? void 0 : _a8.call(str);
}).filter(Boolean).join(" ");
var eventRegex = /^on[A-Z]/;
function mergeProps(...args) {
  let result = {};
  for (let props43 of args) {
    for (let key in result) {
      if (eventRegex.test(key) && typeof result[key] === "function" && typeof props43[key] === "function") {
        result[key] = callAll(result[key], props43[key]);
        continue;
      }
      if (key === "className" || key === "class") {
        result[key] = clsx(result[key], props43[key]);
        continue;
      }
      if (key === "style") {
        result[key] = Object.assign({}, result[key] ?? {}, props43[key] ?? {});
        continue;
      }
      result[key] = props43[key] !== void 0 ? props43[key] : result[key];
    }
    for (let key in props43) {
      if (result[key] === void 0) {
        result[key] = props43[key];
      }
    }
  }
  return result;
}

// node_modules/@chakra-ui/react/dist/esm/styled-system/empty.js
var EMPTY_STYLES = Object.freeze({});
var EMPTY_SLOT_STYLES = Object.freeze(
  {}
);

// node_modules/@chakra-ui/react/dist/esm/styled-system/factory.js
var import_jsx_runtime2 = __toESM(require_jsx_runtime(), 1);

// node_modules/@emotion/is-prop-valid/dist/emotion-is-prop-valid.esm.js
var reactPropsRegex = /^((children|dangerouslySetInnerHTML|key|ref|autoFocus|defaultValue|defaultChecked|innerHTML|suppressContentEditableWarning|suppressHydrationWarning|valueLink|abbr|accept|acceptCharset|accessKey|action|allow|allowUserMedia|allowPaymentRequest|allowFullScreen|allowTransparency|alt|async|autoComplete|autoPlay|capture|cellPadding|cellSpacing|challenge|charSet|checked|cite|classID|className|cols|colSpan|content|contentEditable|contextMenu|controls|controlsList|coords|crossOrigin|data|dateTime|decoding|default|defer|dir|disabled|disablePictureInPicture|disableRemotePlayback|download|draggable|encType|enterKeyHint|fetchpriority|fetchPriority|form|formAction|formEncType|formMethod|formNoValidate|formTarget|frameBorder|headers|height|hidden|high|href|hrefLang|htmlFor|httpEquiv|id|inputMode|integrity|is|keyParams|keyType|kind|label|lang|list|loading|loop|low|marginHeight|marginWidth|max|maxLength|media|mediaGroup|method|min|minLength|multiple|muted|name|nonce|noValidate|open|optimum|pattern|placeholder|playsInline|poster|preload|profile|radioGroup|readOnly|referrerPolicy|rel|required|reversed|role|rows|rowSpan|sandbox|scope|scoped|scrolling|seamless|selected|shape|size|sizes|slot|span|spellCheck|src|srcDoc|srcLang|srcSet|start|step|style|summary|tabIndex|target|title|translate|type|useMap|value|width|wmode|wrap|about|datatype|inlist|prefix|property|resource|typeof|vocab|autoCapitalize|autoCorrect|autoSave|color|incremental|fallback|inert|itemProp|itemScope|itemType|itemID|itemRef|on|option|results|security|unselectable|accentHeight|accumulate|additive|alignmentBaseline|allowReorder|alphabetic|amplitude|arabicForm|ascent|attributeName|attributeType|autoReverse|azimuth|baseFrequency|baselineShift|baseProfile|bbox|begin|bias|by|calcMode|capHeight|clip|clipPathUnits|clipPath|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|contentScriptType|contentStyleType|cursor|cx|cy|d|decelerate|descent|diffuseConstant|direction|display|divisor|dominantBaseline|dur|dx|dy|edgeMode|elevation|enableBackground|end|exponent|externalResourcesRequired|fill|fillOpacity|fillRule|filter|filterRes|filterUnits|floodColor|floodOpacity|focusable|fontFamily|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontVariant|fontWeight|format|from|fr|fx|fy|g1|g2|glyphName|glyphOrientationHorizontal|glyphOrientationVertical|glyphRef|gradientTransform|gradientUnits|hanging|horizAdvX|horizOriginX|ideographic|imageRendering|in|in2|intercept|k|k1|k2|k3|k4|kernelMatrix|kernelUnitLength|kerning|keyPoints|keySplines|keyTimes|lengthAdjust|letterSpacing|lightingColor|limitingConeAngle|local|markerEnd|markerMid|markerStart|markerHeight|markerUnits|markerWidth|mask|maskContentUnits|maskUnits|mathematical|mode|numOctaves|offset|opacity|operator|order|orient|orientation|origin|overflow|overlinePosition|overlineThickness|panose1|paintOrder|pathLength|patternContentUnits|patternTransform|patternUnits|pointerEvents|points|pointsAtX|pointsAtY|pointsAtZ|preserveAlpha|preserveAspectRatio|primitiveUnits|r|radius|refX|refY|renderingIntent|repeatCount|repeatDur|requiredExtensions|requiredFeatures|restart|result|rotate|rx|ry|scale|seed|shapeRendering|slope|spacing|specularConstant|specularExponent|speed|spreadMethod|startOffset|stdDeviation|stemh|stemv|stitchTiles|stopColor|stopOpacity|strikethroughPosition|strikethroughThickness|string|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|surfaceScale|systemLanguage|tableValues|targetX|targetY|textAnchor|textDecoration|textRendering|textLength|to|transform|u1|u2|underlinePosition|underlineThickness|unicode|unicodeBidi|unicodeRange|unitsPerEm|vAlphabetic|vHanging|vIdeographic|vMathematical|values|vectorEffect|version|vertAdvY|vertOriginX|vertOriginY|viewBox|viewTarget|visibility|widths|wordSpacing|writingMode|x|xHeight|x1|x2|xChannelSelector|xlinkActuate|xlinkArcrole|xlinkHref|xlinkRole|xlinkShow|xlinkTitle|xlinkType|xmlBase|xmlns|xmlnsXlink|xmlLang|xmlSpace|y|y1|y2|yChannelSelector|z|zoomAndPan|for|class|autofocus)|(([Dd][Aa][Tt][Aa]|[Aa][Rr][Ii][Aa]|x)-.*))$/;
var isPropValid = memoize(
  function(prop) {
    return reactPropsRegex.test(prop) || prop.charCodeAt(0) === 111 && prop.charCodeAt(1) === 110 && prop.charCodeAt(2) < 91;
  }
  /* Z+1 */
);

// node_modules/@emotion/react/dist/emotion-element-489459f2.browser.development.esm.js
var React2 = __toESM(require_react());
var import_react2 = __toESM(require_react());

// node_modules/@emotion/react/_isolated-hnrs/dist/emotion-react-_isolated-hnrs.browser.development.esm.js
var import_hoist_non_react_statics = __toESM(require_hoist_non_react_statics_cjs());

// node_modules/@emotion/use-insertion-effect-with-fallbacks/dist/emotion-use-insertion-effect-with-fallbacks.browser.esm.js
var React = __toESM(require_react());
var syncFallback = function syncFallback2(create) {
  return create();
};
var useInsertionEffect2 = React["useInsertionEffect"] ? React["useInsertionEffect"] : false;
var useInsertionEffectAlwaysWithSyncFallback = useInsertionEffect2 || syncFallback;
var useInsertionEffectWithLayoutFallback = useInsertionEffect2 || React.useLayoutEffect;

// node_modules/@emotion/react/dist/emotion-element-489459f2.browser.development.esm.js
var EmotionCacheContext = React2.createContext(
  // we're doing this to avoid preconstruct's dead code elimination in this one case
  // because this module is primarily intended for the browser and node
  // but it's also required in react native and similar environments sometimes
  // and we could have a special build just for that
  // but this is much easier and the native packages
  // might use a different theme context in the future anyway
  typeof HTMLElement !== "undefined" ? createCache({
    key: "css"
  }) : null
);
{
  EmotionCacheContext.displayName = "EmotionCacheContext";
}
var CacheProvider = EmotionCacheContext.Provider;
var withEmotionCache = function withEmotionCache2(func) {
  return (0, import_react2.forwardRef)(function(props43, ref) {
    var cache2 = (0, import_react2.useContext)(EmotionCacheContext);
    return func(props43, cache2, ref);
  });
};
var ThemeContext = React2.createContext({});
{
  ThemeContext.displayName = "EmotionThemeContext";
}
var getTheme = function getTheme2(outerTheme, theme) {
  if (typeof theme === "function") {
    var mergedTheme = theme(outerTheme);
    if (mergedTheme == null || typeof mergedTheme !== "object" || Array.isArray(mergedTheme)) {
      throw new Error("[ThemeProvider] Please return an object from your theme function, i.e. theme={() => ({})}!");
    }
    return mergedTheme;
  }
  if (theme == null || typeof theme !== "object" || Array.isArray(theme)) {
    throw new Error("[ThemeProvider] Please make your theme prop a plain object");
  }
  return _extends({}, outerTheme, theme);
};
var createCacheWithTheme = weakMemoize(function(outerTheme) {
  return weakMemoize(function(theme) {
    return getTheme(outerTheme, theme);
  });
});
var hasOwn = {}.hasOwnProperty;
var getLastPart = function getLastPart2(functionName) {
  var parts46 = functionName.split(".");
  return parts46[parts46.length - 1];
};
var getFunctionNameFromStackTraceLine = function getFunctionNameFromStackTraceLine2(line) {
  var match4 = /^\s+at\s+([A-Za-z0-9$.]+)\s/.exec(line);
  if (match4) return getLastPart(match4[1]);
  match4 = /^([A-Za-z0-9$.]+)@/.exec(line);
  if (match4) return getLastPart(match4[1]);
  return void 0;
};
var internalReactFunctionNames = /* @__PURE__ */ new Set(["renderWithHooks", "processChild", "finishClassComponent", "renderToString"]);
var sanitizeIdentifier = function sanitizeIdentifier2(identifier) {
  return identifier.replace(/\$/g, "-");
};
var getLabelFromStackTrace = function getLabelFromStackTrace2(stackTrace) {
  if (!stackTrace) return void 0;
  var lines = stackTrace.split("\n");
  for (var i = 0; i < lines.length; i++) {
    var functionName = getFunctionNameFromStackTraceLine(lines[i]);
    if (!functionName) continue;
    if (internalReactFunctionNames.has(functionName)) break;
    if (/^[A-Z]/.test(functionName)) return sanitizeIdentifier(functionName);
  }
  return void 0;
};
var typePropName = "__EMOTION_TYPE_PLEASE_DO_NOT_USE__";
var labelPropName = "__EMOTION_LABEL_PLEASE_DO_NOT_USE__";
var createEmotionProps = function createEmotionProps2(type, props43) {
  if (typeof props43.css === "string" && // check if there is a css declaration
  props43.css.indexOf(":") !== -1) {
    throw new Error("Strings are not allowed as css prop values, please wrap it in a css template literal from '@emotion/react' like this: css`" + props43.css + "`");
  }
  var newProps = {};
  for (var _key in props43) {
    if (hasOwn.call(props43, _key)) {
      newProps[_key] = props43[_key];
    }
  }
  newProps[typePropName] = type;
  if (typeof globalThis !== "undefined" && !!globalThis.EMOTION_RUNTIME_AUTO_LABEL && !!props43.css && (typeof props43.css !== "object" || !("name" in props43.css) || typeof props43.css.name !== "string" || props43.css.name.indexOf("-") === -1)) {
    var label = getLabelFromStackTrace(new Error().stack);
    if (label) newProps[labelPropName] = label;
  }
  return newProps;
};
var Insertion = function Insertion2(_ref) {
  var cache2 = _ref.cache, serialized = _ref.serialized, isStringTag = _ref.isStringTag;
  registerStyles(cache2, serialized, isStringTag);
  useInsertionEffectAlwaysWithSyncFallback(function() {
    return insertStyles(cache2, serialized, isStringTag);
  });
  return null;
};
var Emotion = withEmotionCache(function(props43, cache2, ref) {
  var cssProp = props43.css;
  if (typeof cssProp === "string" && cache2.registered[cssProp] !== void 0) {
    cssProp = cache2.registered[cssProp];
  }
  var WrappedComponent = props43[typePropName];
  var registeredStyles = [cssProp];
  var className = "";
  if (typeof props43.className === "string") {
    className = getRegisteredStyles(cache2.registered, registeredStyles, props43.className);
  } else if (props43.className != null) {
    className = props43.className + " ";
  }
  var serialized = serializeStyles(registeredStyles, void 0, React2.useContext(ThemeContext));
  if (serialized.name.indexOf("-") === -1) {
    var labelFromStack = props43[labelPropName];
    if (labelFromStack) {
      serialized = serializeStyles([serialized, "label:" + labelFromStack + ";"]);
    }
  }
  className += cache2.key + "-" + serialized.name;
  var newProps = {};
  for (var _key2 in props43) {
    if (hasOwn.call(props43, _key2) && _key2 !== "css" && _key2 !== typePropName && _key2 !== labelPropName) {
      newProps[_key2] = props43[_key2];
    }
  }
  newProps.className = className;
  if (ref) {
    newProps.ref = ref;
  }
  return React2.createElement(React2.Fragment, null, React2.createElement(Insertion, {
    cache: cache2,
    serialized,
    isStringTag: typeof WrappedComponent === "string"
  }), React2.createElement(WrappedComponent, newProps));
});
{
  Emotion.displayName = "EmotionCssPropInternal";
}
var Emotion$1 = Emotion;

// node_modules/@emotion/react/dist/emotion-react.browser.development.esm.js
var React3 = __toESM(require_react());
var import_hoist_non_react_statics2 = __toESM(require_hoist_non_react_statics_cjs());
var isDevelopment = true;
var pkg = {
  name: "@emotion/react",
  version: "11.14.0",
  main: "dist/emotion-react.cjs.js",
  module: "dist/emotion-react.esm.js",
  types: "dist/emotion-react.cjs.d.ts",
  exports: {
    ".": {
      types: {
        "import": "./dist/emotion-react.cjs.mjs",
        "default": "./dist/emotion-react.cjs.js"
      },
      development: {
        "edge-light": {
          module: "./dist/emotion-react.development.edge-light.esm.js",
          "import": "./dist/emotion-react.development.edge-light.cjs.mjs",
          "default": "./dist/emotion-react.development.edge-light.cjs.js"
        },
        worker: {
          module: "./dist/emotion-react.development.edge-light.esm.js",
          "import": "./dist/emotion-react.development.edge-light.cjs.mjs",
          "default": "./dist/emotion-react.development.edge-light.cjs.js"
        },
        workerd: {
          module: "./dist/emotion-react.development.edge-light.esm.js",
          "import": "./dist/emotion-react.development.edge-light.cjs.mjs",
          "default": "./dist/emotion-react.development.edge-light.cjs.js"
        },
        browser: {
          module: "./dist/emotion-react.browser.development.esm.js",
          "import": "./dist/emotion-react.browser.development.cjs.mjs",
          "default": "./dist/emotion-react.browser.development.cjs.js"
        },
        module: "./dist/emotion-react.development.esm.js",
        "import": "./dist/emotion-react.development.cjs.mjs",
        "default": "./dist/emotion-react.development.cjs.js"
      },
      "edge-light": {
        module: "./dist/emotion-react.edge-light.esm.js",
        "import": "./dist/emotion-react.edge-light.cjs.mjs",
        "default": "./dist/emotion-react.edge-light.cjs.js"
      },
      worker: {
        module: "./dist/emotion-react.edge-light.esm.js",
        "import": "./dist/emotion-react.edge-light.cjs.mjs",
        "default": "./dist/emotion-react.edge-light.cjs.js"
      },
      workerd: {
        module: "./dist/emotion-react.edge-light.esm.js",
        "import": "./dist/emotion-react.edge-light.cjs.mjs",
        "default": "./dist/emotion-react.edge-light.cjs.js"
      },
      browser: {
        module: "./dist/emotion-react.browser.esm.js",
        "import": "./dist/emotion-react.browser.cjs.mjs",
        "default": "./dist/emotion-react.browser.cjs.js"
      },
      module: "./dist/emotion-react.esm.js",
      "import": "./dist/emotion-react.cjs.mjs",
      "default": "./dist/emotion-react.cjs.js"
    },
    "./jsx-runtime": {
      types: {
        "import": "./jsx-runtime/dist/emotion-react-jsx-runtime.cjs.mjs",
        "default": "./jsx-runtime/dist/emotion-react-jsx-runtime.cjs.js"
      },
      development: {
        "edge-light": {
          module: "./jsx-runtime/dist/emotion-react-jsx-runtime.development.edge-light.esm.js",
          "import": "./jsx-runtime/dist/emotion-react-jsx-runtime.development.edge-light.cjs.mjs",
          "default": "./jsx-runtime/dist/emotion-react-jsx-runtime.development.edge-light.cjs.js"
        },
        worker: {
          module: "./jsx-runtime/dist/emotion-react-jsx-runtime.development.edge-light.esm.js",
          "import": "./jsx-runtime/dist/emotion-react-jsx-runtime.development.edge-light.cjs.mjs",
          "default": "./jsx-runtime/dist/emotion-react-jsx-runtime.development.edge-light.cjs.js"
        },
        workerd: {
          module: "./jsx-runtime/dist/emotion-react-jsx-runtime.development.edge-light.esm.js",
          "import": "./jsx-runtime/dist/emotion-react-jsx-runtime.development.edge-light.cjs.mjs",
          "default": "./jsx-runtime/dist/emotion-react-jsx-runtime.development.edge-light.cjs.js"
        },
        browser: {
          module: "./jsx-runtime/dist/emotion-react-jsx-runtime.browser.development.esm.js",
          "import": "./jsx-runtime/dist/emotion-react-jsx-runtime.browser.development.cjs.mjs",
          "default": "./jsx-runtime/dist/emotion-react-jsx-runtime.browser.development.cjs.js"
        },
        module: "./jsx-runtime/dist/emotion-react-jsx-runtime.development.esm.js",
        "import": "./jsx-runtime/dist/emotion-react-jsx-runtime.development.cjs.mjs",
        "default": "./jsx-runtime/dist/emotion-react-jsx-runtime.development.cjs.js"
      },
      "edge-light": {
        module: "./jsx-runtime/dist/emotion-react-jsx-runtime.edge-light.esm.js",
        "import": "./jsx-runtime/dist/emotion-react-jsx-runtime.edge-light.cjs.mjs",
        "default": "./jsx-runtime/dist/emotion-react-jsx-runtime.edge-light.cjs.js"
      },
      worker: {
        module: "./jsx-runtime/dist/emotion-react-jsx-runtime.edge-light.esm.js",
        "import": "./jsx-runtime/dist/emotion-react-jsx-runtime.edge-light.cjs.mjs",
        "default": "./jsx-runtime/dist/emotion-react-jsx-runtime.edge-light.cjs.js"
      },
      workerd: {
        module: "./jsx-runtime/dist/emotion-react-jsx-runtime.edge-light.esm.js",
        "import": "./jsx-runtime/dist/emotion-react-jsx-runtime.edge-light.cjs.mjs",
        "default": "./jsx-runtime/dist/emotion-react-jsx-runtime.edge-light.cjs.js"
      },
      browser: {
        module: "./jsx-runtime/dist/emotion-react-jsx-runtime.browser.esm.js",
        "import": "./jsx-runtime/dist/emotion-react-jsx-runtime.browser.cjs.mjs",
        "default": "./jsx-runtime/dist/emotion-react-jsx-runtime.browser.cjs.js"
      },
      module: "./jsx-runtime/dist/emotion-react-jsx-runtime.esm.js",
      "import": "./jsx-runtime/dist/emotion-react-jsx-runtime.cjs.mjs",
      "default": "./jsx-runtime/dist/emotion-react-jsx-runtime.cjs.js"
    },
    "./_isolated-hnrs": {
      types: {
        "import": "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.cjs.mjs",
        "default": "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.cjs.js"
      },
      development: {
        "edge-light": {
          module: "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.development.edge-light.esm.js",
          "import": "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.development.edge-light.cjs.mjs",
          "default": "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.development.edge-light.cjs.js"
        },
        worker: {
          module: "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.development.edge-light.esm.js",
          "import": "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.development.edge-light.cjs.mjs",
          "default": "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.development.edge-light.cjs.js"
        },
        workerd: {
          module: "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.development.edge-light.esm.js",
          "import": "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.development.edge-light.cjs.mjs",
          "default": "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.development.edge-light.cjs.js"
        },
        browser: {
          module: "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.browser.development.esm.js",
          "import": "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.browser.development.cjs.mjs",
          "default": "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.browser.development.cjs.js"
        },
        module: "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.development.esm.js",
        "import": "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.development.cjs.mjs",
        "default": "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.development.cjs.js"
      },
      "edge-light": {
        module: "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.edge-light.esm.js",
        "import": "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.edge-light.cjs.mjs",
        "default": "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.edge-light.cjs.js"
      },
      worker: {
        module: "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.edge-light.esm.js",
        "import": "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.edge-light.cjs.mjs",
        "default": "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.edge-light.cjs.js"
      },
      workerd: {
        module: "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.edge-light.esm.js",
        "import": "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.edge-light.cjs.mjs",
        "default": "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.edge-light.cjs.js"
      },
      browser: {
        module: "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.browser.esm.js",
        "import": "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.browser.cjs.mjs",
        "default": "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.browser.cjs.js"
      },
      module: "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.esm.js",
      "import": "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.cjs.mjs",
      "default": "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.cjs.js"
    },
    "./jsx-dev-runtime": {
      types: {
        "import": "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.cjs.mjs",
        "default": "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.cjs.js"
      },
      development: {
        "edge-light": {
          module: "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.development.edge-light.esm.js",
          "import": "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.development.edge-light.cjs.mjs",
          "default": "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.development.edge-light.cjs.js"
        },
        worker: {
          module: "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.development.edge-light.esm.js",
          "import": "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.development.edge-light.cjs.mjs",
          "default": "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.development.edge-light.cjs.js"
        },
        workerd: {
          module: "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.development.edge-light.esm.js",
          "import": "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.development.edge-light.cjs.mjs",
          "default": "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.development.edge-light.cjs.js"
        },
        browser: {
          module: "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.browser.development.esm.js",
          "import": "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.browser.development.cjs.mjs",
          "default": "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.browser.development.cjs.js"
        },
        module: "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.development.esm.js",
        "import": "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.development.cjs.mjs",
        "default": "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.development.cjs.js"
      },
      "edge-light": {
        module: "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.edge-light.esm.js",
        "import": "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.edge-light.cjs.mjs",
        "default": "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.edge-light.cjs.js"
      },
      worker: {
        module: "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.edge-light.esm.js",
        "import": "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.edge-light.cjs.mjs",
        "default": "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.edge-light.cjs.js"
      },
      workerd: {
        module: "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.edge-light.esm.js",
        "import": "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.edge-light.cjs.mjs",
        "default": "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.edge-light.cjs.js"
      },
      browser: {
        module: "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.browser.esm.js",
        "import": "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.browser.cjs.mjs",
        "default": "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.browser.cjs.js"
      },
      module: "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.esm.js",
      "import": "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.cjs.mjs",
      "default": "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.cjs.js"
    },
    "./package.json": "./package.json",
    "./types/css-prop": "./types/css-prop.d.ts",
    "./macro": {
      types: {
        "import": "./macro.d.mts",
        "default": "./macro.d.ts"
      },
      "default": "./macro.js"
    }
  },
  imports: {
    "#is-development": {
      development: "./src/conditions/true.ts",
      "default": "./src/conditions/false.ts"
    },
    "#is-browser": {
      "edge-light": "./src/conditions/false.ts",
      workerd: "./src/conditions/false.ts",
      worker: "./src/conditions/false.ts",
      browser: "./src/conditions/true.ts",
      "default": "./src/conditions/is-browser.ts"
    }
  },
  files: [
    "src",
    "dist",
    "jsx-runtime",
    "jsx-dev-runtime",
    "_isolated-hnrs",
    "types/css-prop.d.ts",
    "macro.*"
  ],
  sideEffects: false,
  author: "Emotion Contributors",
  license: "MIT",
  scripts: {
    "test:typescript": "dtslint types"
  },
  dependencies: {
    "@babel/runtime": "^7.18.3",
    "@emotion/babel-plugin": "^11.13.5",
    "@emotion/cache": "^11.14.0",
    "@emotion/serialize": "^1.3.3",
    "@emotion/use-insertion-effect-with-fallbacks": "^1.2.0",
    "@emotion/utils": "^1.4.2",
    "@emotion/weak-memoize": "^0.4.0",
    "hoist-non-react-statics": "^3.3.1"
  },
  peerDependencies: {
    react: ">=16.8.0"
  },
  peerDependenciesMeta: {
    "@types/react": {
      optional: true
    }
  },
  devDependencies: {
    "@definitelytyped/dtslint": "0.0.112",
    "@emotion/css": "11.13.5",
    "@emotion/css-prettifier": "1.2.0",
    "@emotion/server": "11.11.0",
    "@emotion/styled": "11.14.0",
    "@types/hoist-non-react-statics": "^3.3.5",
    "html-tag-names": "^1.1.2",
    react: "16.14.0",
    "svg-tag-names": "^1.1.1",
    typescript: "^5.4.5"
  },
  repository: "https://github.com/emotion-js/emotion/tree/main/packages/react",
  publishConfig: {
    access: "public"
  },
  "umd:main": "dist/emotion-react.umd.min.js",
  preconstruct: {
    entrypoints: [
      "./index.ts",
      "./jsx-runtime.ts",
      "./jsx-dev-runtime.ts",
      "./_isolated-hnrs.ts"
    ],
    umdName: "emotionReact",
    exports: {
      extra: {
        "./types/css-prop": "./types/css-prop.d.ts",
        "./macro": {
          types: {
            "import": "./macro.d.mts",
            "default": "./macro.d.ts"
          },
          "default": "./macro.js"
        }
      }
    }
  }
};
var jsx = function jsx2(type, props43) {
  var args = arguments;
  if (props43 == null || !hasOwn.call(props43, "css")) {
    return React3.createElement.apply(void 0, args);
  }
  var argsLength = args.length;
  var createElementArgArray = new Array(argsLength);
  createElementArgArray[0] = Emotion$1;
  createElementArgArray[1] = createEmotionProps(type, props43);
  for (var i = 2; i < argsLength; i++) {
    createElementArgArray[i] = args[i];
  }
  return React3.createElement.apply(null, createElementArgArray);
};
(function(_jsx) {
  var JSX;
  /* @__PURE__ */ (function(_JSX) {
  })(JSX || (JSX = _jsx.JSX || (_jsx.JSX = {})));
})(jsx || (jsx = {}));
var warnedAboutCssPropForGlobal = false;
var Global = withEmotionCache(function(props43, cache2) {
  if (!warnedAboutCssPropForGlobal && // check for className as well since the user is
  // probably using the custom createElement which
  // means it will be turned into a className prop
  // I don't really want to add it to the type since it shouldn't be used
  ("className" in props43 && props43.className || "css" in props43 && props43.css)) {
    console.error("It looks like you're using the css prop on Global, did you mean to use the styles prop instead?");
    warnedAboutCssPropForGlobal = true;
  }
  var styles = props43.styles;
  var serialized = serializeStyles([styles], void 0, React3.useContext(ThemeContext));
  var sheetRef = React3.useRef();
  useInsertionEffectWithLayoutFallback(function() {
    var key = cache2.key + "-global";
    var sheet = new cache2.sheet.constructor({
      key,
      nonce: cache2.sheet.nonce,
      container: cache2.sheet.container,
      speedy: cache2.sheet.isSpeedy
    });
    var rehydrating = false;
    var node = document.querySelector('style[data-emotion="' + key + " " + serialized.name + '"]');
    if (cache2.sheet.tags.length) {
      sheet.before = cache2.sheet.tags[0];
    }
    if (node !== null) {
      rehydrating = true;
      node.setAttribute("data-emotion", key);
      sheet.hydrate([node]);
    }
    sheetRef.current = [sheet, rehydrating];
    return function() {
      sheet.flush();
    };
  }, [cache2]);
  useInsertionEffectWithLayoutFallback(function() {
    var sheetRefCurrent = sheetRef.current;
    var sheet = sheetRefCurrent[0], rehydrating = sheetRefCurrent[1];
    if (rehydrating) {
      sheetRefCurrent[1] = false;
      return;
    }
    if (serialized.next !== void 0) {
      insertStyles(cache2, serialized.next, true);
    }
    if (sheet.tags.length) {
      var element = sheet.tags[sheet.tags.length - 1].nextElementSibling;
      sheet.before = element;
      sheet.flush();
    }
    cache2.insert("", serialized, sheet, false);
  }, [cache2, serialized.name]);
  return null;
});
{
  Global.displayName = "EmotionGlobal";
}
var classnames = function classnames2(args) {
  var len = args.length;
  var i = 0;
  var cls = "";
  for (; i < len; i++) {
    var arg = args[i];
    if (arg == null) continue;
    var toAdd = void 0;
    switch (typeof arg) {
      case "boolean":
        break;
      case "object": {
        if (Array.isArray(arg)) {
          toAdd = classnames2(arg);
        } else {
          if (arg.styles !== void 0 && arg.name !== void 0) {
            console.error("You have passed styles created with `css` from `@emotion/react` package to the `cx`.\n`cx` is meant to compose class names (strings) so you should convert those styles to a class name by passing them to the `css` received from <ClassNames/> component.");
          }
          toAdd = "";
          for (var k in arg) {
            if (arg[k] && k) {
              toAdd && (toAdd += " ");
              toAdd += k;
            }
          }
        }
        break;
      }
      default: {
        toAdd = arg;
      }
    }
    if (toAdd) {
      cls && (cls += " ");
      cls += toAdd;
    }
  }
  return cls;
};
function merge(registered, css2, className) {
  var registeredStyles = [];
  var rawClassName = getRegisteredStyles(registered, registeredStyles, className);
  if (registeredStyles.length < 2) {
    return className;
  }
  return rawClassName + css2(registeredStyles);
}
var Insertion3 = function Insertion4(_ref) {
  var cache2 = _ref.cache, serializedArr = _ref.serializedArr;
  useInsertionEffectAlwaysWithSyncFallback(function() {
    for (var i = 0; i < serializedArr.length; i++) {
      insertStyles(cache2, serializedArr[i], false);
    }
  });
  return null;
};
var ClassNames = withEmotionCache(function(props43, cache2) {
  var hasRendered = false;
  var serializedArr = [];
  var css2 = function css3() {
    if (hasRendered && isDevelopment) {
      throw new Error("css can only be used during render");
    }
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    var serialized = serializeStyles(args, cache2.registered);
    serializedArr.push(serialized);
    registerStyles(cache2, serialized, false);
    return cache2.key + "-" + serialized.name;
  };
  var cx2 = function cx3() {
    if (hasRendered && isDevelopment) {
      throw new Error("cx can only be used during render");
    }
    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }
    return merge(cache2.registered, css2, classnames(args));
  };
  var content = {
    css: css2,
    cx: cx2,
    theme: React3.useContext(ThemeContext)
  };
  var ele = props43.children(content);
  hasRendered = true;
  return React3.createElement(React3.Fragment, null, React3.createElement(Insertion3, {
    cache: cache2,
    serializedArr
  }), ele);
});
{
  ClassNames.displayName = "EmotionClassNames";
}
{
  isBrowser2 = typeof document !== "undefined";
  isTestEnv = typeof jest !== "undefined" || typeof vi !== "undefined";
  if (isBrowser2 && !isTestEnv) {
    globalContext = typeof globalThis !== "undefined" ? globalThis : isBrowser2 ? window : global;
    globalKey = "__EMOTION_REACT_" + pkg.version.split(".")[0] + "__";
    if (globalContext[globalKey]) {
      console.warn("You are loading @emotion/react when it is already loaded. Running multiple instances may cause problems. This can happen if multiple versions are used, or if multiple builds of the same version are used.");
    }
    globalContext[globalKey] = true;
  }
}
var isBrowser2;
var isTestEnv;
var globalContext;
var globalKey;

// node_modules/@chakra-ui/react/dist/esm/styled-system/factory.js
var React5 = __toESM(require_react(), 1);

// node_modules/@chakra-ui/react/dist/esm/merge-refs.js
function assignRef(ref, value) {
  if (ref == null) return;
  if (typeof ref === "function") {
    ref(value);
    return;
  }
  try {
    ref.current = value;
  } catch (error) {
    throw new Error(`Cannot assign value '${value}' to ref '${ref}'`);
  }
}
function mergeRefs(...refs) {
  return (node) => {
    refs.forEach((ref) => {
      assignRef(ref, node);
    });
  };
}

// node_modules/@chakra-ui/react/dist/esm/utils/compact.js
function compact(object) {
  const clone2 = Object.assign({}, object);
  for (let key in clone2) {
    if (clone2[key] === void 0) delete clone2[key];
  }
  return clone2;
}

// node_modules/@chakra-ui/react/dist/esm/utils/interop.js
function interopDefault(mod2) {
  return mod2.default || mod2;
}

// node_modules/@chakra-ui/react/dist/esm/utils/ref.js
var React4 = __toESM(require_react(), 1);

// node_modules/@chakra-ui/react/dist/esm/utils/is.js
var isObject = (v) => v != null && typeof v === "object" && !Array.isArray(v);
var isCssVar = (v) => /^var\(--.+\)$/.test(v);
var isString = (v) => typeof v === "string";
var isFunction = (v) => typeof v === "function";

// node_modules/@chakra-ui/react/dist/esm/utils/ref.js
function getElementRef(el) {
  var _a8;
  const version2 = React4.version;
  if (!isString(version2)) return el == null ? void 0 : el.ref;
  if (version2.startsWith("18.")) return el == null ? void 0 : el.ref;
  return (_a8 = el == null ? void 0 : el.props) == null ? void 0 : _a8.ref;
}

// node_modules/@chakra-ui/react/dist/esm/utils/uniq.js
var uniq = (...items) => {
  const set = items.reduce((acc, curr) => {
    if (curr != null) curr.forEach((item) => acc.add(item));
    return acc;
  }, /* @__PURE__ */ new Set([]));
  return Array.from(set);
};

// node_modules/@chakra-ui/react/dist/esm/styled-system/provider.js
var import_jsx_runtime = __toESM(require_jsx_runtime(), 1);
var [ChakraContextProvider, useChakraContext] = createContext({
  name: "ChakraContext",
  strict: true,
  providerName: "<ChakraProvider />"
});
function ChakraProvider(props43) {
  const { value: sys, children } = props43;
  return (0, import_jsx_runtime.jsxs)(ChakraContextProvider, { value: sys, children: [
    !sys._config.disableLayers && (0, import_jsx_runtime.jsx)(Global, { styles: sys.layers.atRule }),
    (0, import_jsx_runtime.jsx)(Global, { styles: sys._global }),
    children
  ] });
}

// node_modules/@chakra-ui/react/dist/esm/styled-system/use-resolved-props.js
var import_react4 = __toESM(require_react(), 1);

// node_modules/@chakra-ui/react/dist/esm/utils/split-props.js
var splitPropFn = (props43, predicate) => {
  const rest = {};
  const result = {};
  const allKeys = Object.keys(props43);
  for (const key of allKeys) {
    if (predicate(key)) {
      result[key] = props43[key];
    } else {
      rest[key] = props43[key];
    }
  }
  return [result, rest];
};
var splitProps = (props43, keys) => {
  const predicate = isFunction(keys) ? keys : (key) => keys.includes(key);
  return splitPropFn(props43, predicate);
};

// node_modules/@chakra-ui/react/dist/esm/styled-system/use-resolved-props.js
var htmlProps = /* @__PURE__ */ new Set([
  "htmlWidth",
  "htmlHeight",
  "htmlSize",
  "htmlTranslate"
]);
function isHtmlProp(prop) {
  return typeof prop === "string" && htmlProps.has(prop);
}
function useResolvedProps(inProps, cvaRecipe, shouldForwardProps) {
  const { css: css2, isValidProperty } = useChakraContext();
  const { children, ...props43 } = inProps;
  const result = (0, import_react4.useMemo)(() => {
    const [forwardedProps, restProps_B] = splitProps(
      props43,
      (key) => shouldForwardProps(key, cvaRecipe.variantKeys)
    );
    const [variantProps, restProps_C] = splitProps(
      restProps_B,
      cvaRecipe.variantKeys
    );
    const [styleProps, elementProps] = splitProps(restProps_C, isValidProperty);
    return {
      forwardedProps,
      variantProps,
      styleProps,
      elementProps
    };
  }, [cvaRecipe.variantKeys, shouldForwardProps, props43, isValidProperty]);
  const { css: cssStyles, ...propStyles } = result.styleProps;
  const cvaStyles = (0, import_react4.useMemo)(() => {
    const variantProps = { ...result.variantProps };
    if (!cvaRecipe.variantKeys.includes("colorPalette")) {
      variantProps.colorPalette = props43.colorPalette;
    }
    if (!cvaRecipe.variantKeys.includes("orientation")) {
      variantProps.orientation = props43.orientation;
    }
    return cvaRecipe(variantProps);
  }, [cvaRecipe, result.variantProps, props43.colorPalette, props43.orientation]);
  const styles = (0, import_react4.useMemo)(() => {
    return css2(cvaStyles, ...toArray(cssStyles), propStyles);
  }, [css2, cvaStyles, cssStyles, propStyles]);
  return {
    styles,
    props: {
      ...result.forwardedProps,
      ...result.elementProps,
      children
    }
  };
}
var toArray = (val) => {
  const res = Array.isArray(val) ? val : [val];
  return res.filter(Boolean).flat();
};

// node_modules/@chakra-ui/react/dist/esm/styled-system/factory.js
var isPropValid2 = interopDefault(isPropValid);
var testOmitPropsOnStringTag = isPropValid2;
var testOmitPropsOnComponent = (key) => key !== "theme";
var composeShouldForwardProps = (tag, options, isReal) => {
  let shouldForwardProp;
  if (options) {
    const optionsShouldForwardProp = options.shouldForwardProp;
    shouldForwardProp = tag.__emotion_forwardProp && optionsShouldForwardProp ? (propName) => tag.__emotion_forwardProp(propName) && optionsShouldForwardProp(propName) : optionsShouldForwardProp;
  }
  if (typeof shouldForwardProp !== "function" && isReal) {
    shouldForwardProp = tag.__emotion_forwardProp;
  }
  return shouldForwardProp;
};
var isBrowser = typeof document !== "undefined";
var Insertion5 = ({ cache: cache2, serialized, isStringTag }) => {
  registerStyles(cache2, serialized, isStringTag);
  const rules = useInsertionEffectAlwaysWithSyncFallback(
    () => insertStyles(cache2, serialized, isStringTag)
  );
  if (!isBrowser && rules !== void 0) {
    let serializedNames = serialized.name;
    let next2 = serialized.next;
    while (next2 !== void 0) {
      serializedNames = cx(serializedNames, next2.name);
      next2 = next2.next;
    }
    return (0, import_jsx_runtime2.jsx)(
      "style",
      {
        ...{
          [`data-emotion`]: cx(cache2.key, serializedNames),
          dangerouslySetInnerHTML: { __html: rules },
          nonce: cache2.sheet.nonce
        }
      }
    );
  }
  return null;
};
var exceptionPropMap = {
  path: ["d"],
  text: ["x", "y"],
  circle: ["cx", "cy", "r"],
  rect: ["width", "height", "x", "y", "rx", "ry"],
  ellipse: ["cx", "cy", "rx", "ry"],
  g: ["transform"],
  stop: ["offset", "stopOpacity"]
};
var hasProp = (obj, prop) => {
  return Object.prototype.hasOwnProperty.call(obj, prop);
};
var createStyled = (tag, configOrCva = {}, options = {}) => {
  if (true) {
    if (tag === void 0) {
      throw new Error(
        "You are trying to create a styled element with an undefined component.\nYou may have forgotten to import it."
      );
    }
  }
  if (hasProp(exceptionPropMap, tag)) {
    options.forwardProps || (options.forwardProps = []);
    const props43 = exceptionPropMap[tag];
    options.forwardProps = uniq([...options.forwardProps, ...props43]);
  }
  const isReal = tag.__emotion_real === tag;
  const baseTag = isReal && tag.__emotion_base || tag;
  let identifierName;
  let targetClassName;
  if (options !== void 0) {
    identifierName = options.label;
    targetClassName = options.target;
  }
  let styles = [];
  const Styled = withEmotionCache((inProps, cache2, ref) => {
    var _a8;
    const { cva, isValidProperty } = useChakraContext();
    const cvaFn = configOrCva.__cva__ ? configOrCva : cva(configOrCva);
    const cvaRecipe = mergeCva(tag.__emotion_cva, cvaFn);
    const createShouldForwardProps = (props210) => {
      return (prop, variantKeys) => {
        if (props210.includes(prop)) return true;
        return !(variantKeys == null ? void 0 : variantKeys.includes(prop)) && !isValidProperty(prop);
      };
    };
    if (!options.shouldForwardProp && options.forwardProps) {
      options.shouldForwardProp = createShouldForwardProps(options.forwardProps);
    }
    const fallbackShouldForwardProp = (prop, variantKeys) => {
      const emotionSfp = typeof tag === "string" && tag.charCodeAt(0) > 96 ? testOmitPropsOnStringTag : testOmitPropsOnComponent;
      const chakraSfp = !(variantKeys == null ? void 0 : variantKeys.includes(prop)) && !isValidProperty(prop);
      return emotionSfp(prop) && chakraSfp;
    };
    const shouldForwardProp = composeShouldForwardProps(tag, options, isReal) || fallbackShouldForwardProp;
    const propsWithDefault = React5.useMemo(
      () => Object.assign({}, options.defaultProps, compact(inProps)),
      [inProps]
    );
    const { props: props43, styles: styleProps } = useResolvedProps(
      propsWithDefault,
      cvaRecipe,
      shouldForwardProp
    );
    let className = "";
    let classInterpolations = [styleProps];
    let mergedProps = props43;
    if (props43.theme == null) {
      mergedProps = {};
      for (let key in props43) {
        mergedProps[key] = props43[key];
      }
      mergedProps.theme = React5.useContext(ThemeContext);
    }
    if (typeof props43.className === "string") {
      className = getRegisteredStyles(
        cache2.registered,
        classInterpolations,
        props43.className
      );
    } else if (props43.className != null) {
      className = cx(className, props43.className);
    }
    const serialized = serializeStyles(
      styles.concat(classInterpolations),
      cache2.registered,
      mergedProps
    );
    className = cx(className, `${cache2.key}-${serialized.name}`);
    if (targetClassName !== void 0) {
      className = cx(className, targetClassName);
    }
    const shouldUseAs = !shouldForwardProp("as");
    let FinalTag = shouldUseAs && props43.as || baseTag;
    let finalProps = {};
    for (let prop in props43) {
      if (shouldUseAs && prop === "as") continue;
      if (isHtmlProp(prop)) {
        const nativeProp = prop.replace("html", "").toLowerCase();
        finalProps[nativeProp] = props43[prop];
        continue;
      }
      if (shouldForwardProp(prop)) {
        finalProps[prop] = props43[prop];
      }
    }
    finalProps.className = className.trim();
    finalProps.ref = ref;
    const forwardAsChild = options.forwardAsChild || ((_a8 = options.forwardProps) == null ? void 0 : _a8.includes("asChild"));
    if (props43.asChild && !forwardAsChild) {
      const child = React5.Children.only(props43.children);
      FinalTag = child.type;
      finalProps.children = null;
      Reflect.deleteProperty(finalProps, "asChild");
      finalProps = mergeProps(finalProps, child.props);
      finalProps.ref = mergeRefs(ref, getElementRef(child));
    }
    if (finalProps.as && forwardAsChild) {
      finalProps.as = void 0;
      return (0, import_jsx_runtime2.jsxs)(React5.Fragment, { children: [
        (0, import_jsx_runtime2.jsx)(
          Insertion5,
          {
            cache: cache2,
            serialized,
            isStringTag: typeof FinalTag === "string"
          }
        ),
        (0, import_jsx_runtime2.jsx)(FinalTag, { asChild: true, ...finalProps, children: (0, import_jsx_runtime2.jsx)(props43.as, { children: finalProps.children }) })
      ] });
    }
    return (0, import_jsx_runtime2.jsxs)(React5.Fragment, { children: [
      (0, import_jsx_runtime2.jsx)(
        Insertion5,
        {
          cache: cache2,
          serialized,
          isStringTag: typeof FinalTag === "string"
        }
      ),
      (0, import_jsx_runtime2.jsx)(FinalTag, { ...finalProps })
    ] });
  });
  Styled.displayName = identifierName !== void 0 ? identifierName : `chakra(${typeof baseTag === "string" ? baseTag : baseTag.displayName || baseTag.name || "Component"})`;
  Styled.__emotion_real = Styled;
  Styled.__emotion_base = baseTag;
  Styled.__emotion_forwardProp = options.shouldForwardProp;
  Styled.__emotion_cva = configOrCva;
  Object.defineProperty(Styled, "toString", {
    value() {
      if (targetClassName === void 0 && true) {
        return "NO_COMPONENT_SELECTOR";
      }
      return `.${targetClassName}`;
    }
  });
  return Styled;
};
var styledFn = createStyled.bind();
var cache = /* @__PURE__ */ new Map();
var chakraImpl = new Proxy(styledFn, {
  apply(_, __, args) {
    return styledFn(...args);
  },
  get(_, el) {
    if (!cache.has(el)) {
      cache.set(el, styledFn(el));
    }
    return cache.get(el);
  }
});
var chakra = chakraImpl;
var mergeCva = (cvaA, cvaB) => {
  if (cvaA && !cvaB) return cvaA;
  if (!cvaA && cvaB) return cvaB;
  return cvaA.merge(cvaB);
};

// node_modules/@chakra-ui/react/dist/esm/styled-system/use-recipe.js
var import_react6 = __toESM(require_react(), 1);
function useRecipe(options) {
  const { key, recipe: recipeProp } = options;
  const sys = useChakraContext();
  return (0, import_react6.useMemo)(() => {
    const recipe = recipeProp || (key != null ? sys.getRecipe(key) : {});
    return sys.cva(structuredClone(recipe));
  }, [key, recipeProp, sys]);
}

// node_modules/@chakra-ui/react/dist/esm/styled-system/create-recipe-context.js
var upperFirst = (str) => str.charAt(0).toUpperCase() + str.slice(1);
function createRecipeContext(options) {
  const { key: recipeKey, recipe: recipeConfig } = options;
  const contextName = upperFirst(
    recipeKey || recipeConfig.className || "Component"
  );
  const [PropsProvider63, usePropsContext2] = createContext({
    strict: false,
    name: `${contextName}PropsContext`,
    providerName: `${contextName}PropsContext`
  });
  function useRecipeResult6(props43) {
    const { unstyled, ...restProps } = props43;
    const recipe = useRecipe({
      key: recipeKey,
      recipe: restProps.recipe || recipeConfig
    });
    const [variantProps, otherProps] = (0, import_react7.useMemo)(
      () => recipe.splitVariantProps(restProps),
      [recipe, restProps]
    );
    const styles = unstyled ? EMPTY_STYLES : recipe(variantProps);
    return {
      styles,
      className: recipe.className,
      props: otherProps
    };
  }
  const withContext62 = (Component, options2) => {
    const SuperComponent = chakra(Component, {}, options2);
    const StyledComponent = (0, import_react7.forwardRef)((inProps, ref) => {
      const propsContext = usePropsContext2();
      const props43 = (0, import_react7.useMemo)(
        () => mergeProps(propsContext, inProps),
        [inProps, propsContext]
      );
      const { styles, className, props: localProps } = useRecipeResult6(props43);
      return (0, import_jsx_runtime3.jsx)(
        SuperComponent,
        {
          ...localProps,
          ref,
          css: [styles, props43.css],
          className: cx(className, props43.className)
        }
      );
    });
    StyledComponent.displayName = Component.displayName || Component.name;
    return StyledComponent;
  };
  function withPropsProvider2() {
    return PropsProvider63;
  }
  return {
    withContext: withContext62,
    PropsProvider: PropsProvider63,
    withPropsProvider: withPropsProvider2,
    usePropsContext: usePropsContext2,
    useRecipeResult: useRecipeResult6
  };
}

// node_modules/@chakra-ui/react/dist/esm/components/grid/grid.js
var import_jsx_runtime4 = __toESM(require_jsx_runtime(), 1);
var import_react8 = __toESM(require_react(), 1);
var Grid = (0, import_react8.forwardRef)(
  function Grid2(props43, ref) {
    const {
      templateAreas,
      column,
      row,
      autoFlow,
      autoRows,
      templateRows,
      autoColumns,
      templateColumns,
      inline: inline2,
      ...rest
    } = props43;
    return (0, import_jsx_runtime4.jsx)(
      chakra.div,
      {
        ...rest,
        ref,
        css: [
          {
            display: inline2 ? "inline-grid" : "grid",
            gridTemplateAreas: templateAreas,
            gridAutoColumns: autoColumns,
            gridColumn: column,
            gridRow: row,
            gridAutoFlow: autoFlow,
            gridAutoRows: autoRows,
            gridTemplateRows: templateRows,
            gridTemplateColumns: templateColumns
          },
          props43.css
        ]
      }
    );
  }
);

// node_modules/@chakra-ui/react/dist/esm/components/color-swatch/index.js
var { withPropsProvider, useRecipeResult } = createRecipeContext({
  key: "colorSwatch"
});
var ColorSwatch = (0, import_react9.forwardRef)(
  function ColorSwatch2(props43, ref) {
    const { value, ...restProps } = props43;
    const { styles, className, props: localProps } = useRecipeResult(restProps);
    return (0, import_jsx_runtime5.jsx)(
      chakra.span,
      {
        ...localProps,
        ref,
        "data-value": value,
        css: [styles, { "--color": value }, props43.css],
        className: cx(className, props43.className)
      }
    );
  }
);
var ColorSwatchPropsProvider = withPropsProvider();
var ColorSwatchMix = (props43) => {
  const { items, ...restProps } = props43;
  if (items.length > 4) {
    throw new Error("ColorSwatchMix doesn't support more than 4 colors");
  }
  const isThreeColors = items.length === 3;
  return (0, import_jsx_runtime5.jsx)(ColorSwatch, { overflow: "hidden", ...restProps, value: "transparent", children: (0, import_jsx_runtime5.jsx)(Grid, { templateColumns: "var(--swatch-size) var(--swatch-size)", children: items.map((item, index) => {
    const isLast = index === items.length - 1;
    return (0, import_jsx_runtime5.jsx)(
      ColorSwatch,
      {
        size: "inherit",
        rounded: "none",
        value: item,
        boxShadow: "none",
        gridColumn: isThreeColors && isLast ? "span 2 / span 2" : void 0,
        width: isThreeColors && isLast ? "unset" : void 0
      },
      item
    );
  }) }) });
};

// node_modules/@ark-ui/react/dist/components/download-trigger/download-trigger.js
var import_jsx_runtime6 = __toESM(require_jsx_runtime(), 1);

// node_modules/@zag-js/file-utils/dist/index.mjs
var getItemEntry = (item) => typeof item.getAsEntry === "function" ? item.getAsEntry() : typeof item.webkitGetAsEntry === "function" ? item.webkitGetAsEntry() : null;
var isDirectoryEntry = (entry) => entry.isDirectory;
var isFileEntry = (entry) => entry.isFile;
var addRelativePath = (file, path) => {
  Object.defineProperty(file, "relativePath", { value: path ? `${path}/${file.name}` : file.name });
  return file;
};
var getFileEntries = (items, traverseDirectories) => Promise.all(
  Array.from(items).filter((item) => item.kind === "file").map((item) => {
    const entry = getItemEntry(item);
    if (!entry) return null;
    if (isDirectoryEntry(entry) && traverseDirectories) {
      return getDirectoryFiles(entry.createReader(), `${entry.name}`);
    }
    if (isFileEntry(entry)) {
      return new Promise((resolve) => {
        entry.file((file) => {
          resolve(addRelativePath(file, ""));
        });
      });
    }
  }).filter((b2) => b2)
);
var getDirectoryFiles = (reader, path = "") => new Promise((resolve) => {
  const entryPromises = [];
  const readDirectoryEntries = () => {
    reader.readEntries((entries) => {
      if (entries.length === 0) {
        resolve(Promise.all(entryPromises).then((entries2) => entries2.flat()));
        return;
      }
      const promises = entries.map((entry) => {
        if (!entry) return null;
        if (isDirectoryEntry(entry)) {
          return getDirectoryFiles(entry.createReader(), `${path}${entry.name}`);
        }
        if (isFileEntry(entry)) {
          return new Promise((resolve2) => {
            entry.file((file) => {
              resolve2(addRelativePath(file, path));
            });
          });
        }
      }).filter((b2) => b2);
      entryPromises.push(Promise.all(promises));
      readDirectoryEntries();
    });
  };
  readDirectoryEntries();
});
function isMSEdge(win) {
  return Boolean(win.navigator && win.navigator.msSaveOrOpenBlob);
}
function downloadFile(options) {
  const { file, win, type, name } = options;
  const doc = win.document;
  const obj = typeof file === "string" ? new Blob([file], { type }) : file;
  const fileName = file instanceof File ? name || file.name : name;
  if (isMSEdge(win)) {
    win.navigator.msSaveOrOpenBlob(obj, fileName || "file-download");
    return;
  }
  const url = win.URL.createObjectURL(obj);
  const anchor = doc.createElement("a");
  anchor.style.display = "none";
  anchor.href = url;
  anchor.rel = "noopener";
  anchor.download = fileName || "file-download";
  doc.documentElement.appendChild(anchor);
  anchor.click();
  setTimeout(() => {
    win.URL.revokeObjectURL(url);
    anchor.remove();
  }, 0);
}
function isMIMEType(v) {
  return v === "audio/*" || v === "video/*" || v === "image/*" || v === "text/*" || /\w+\/[-+.\w]+/g.test(v);
}
function isExt(v) {
  return /^.*\.[\w]+$/.test(v);
}
var isValidMIME = (v) => isMIMEType(v) || isExt(v);
function getAcceptAttrString(accept) {
  if (accept == null) return;
  if (typeof accept === "string") {
    return accept;
  }
  if (Array.isArray(accept)) {
    return accept.filter(isValidMIME).join(",");
  }
  return Object.entries(accept).reduce((a2, [mimeType, ext]) => [...a2, mimeType, ...ext], []).filter(isValidMIME).join(",");
}
var isFileEqual = (file1, file2) => {
  return file1.name === file2.name && file1.size === file2.size && file1.type === file2.type;
};
var isDefined = (v) => v !== void 0 && v !== null;
function isValidFileSize(file, minSize, maxSize) {
  if (isDefined(file.size)) {
    if (isDefined(minSize) && isDefined(maxSize)) {
      if (file.size > maxSize) return [false, "FILE_TOO_LARGE"];
      if (file.size < minSize) return [false, "FILE_TOO_SMALL"];
    } else if (isDefined(minSize) && file.size < minSize) {
      return [false, "FILE_TOO_SMALL"];
    } else if (isDefined(maxSize) && file.size > maxSize) {
      return [false, "FILE_TOO_LARGE"];
    }
  }
  return [true, null];
}
function isFileAccepted(file, accept) {
  if (file && accept) {
    const types = Array.isArray(accept) ? accept : typeof accept === "string" ? accept.split(",") : [];
    if (types.length === 0) return true;
    const fileName = file.name || "";
    const mimeType = (file.type || "").toLowerCase();
    const baseMimeType = mimeType.replace(/\/.*$/, "");
    return types.some((type) => {
      const validType = type.trim().toLowerCase();
      if (validType.charAt(0) === ".") {
        return fileName.toLowerCase().endsWith(validType);
      }
      if (validType.endsWith("/*")) {
        return baseMimeType === validType.replace(/\/.*$/, "");
      }
      return mimeType === validType;
    });
  }
  return true;
}
function isValidFileType(file, accept) {
  const isAcceptable = file.type === "application/x-moz-file" || isFileAccepted(file, accept);
  return [isAcceptable, isAcceptable ? null : "FILE_INVALID_TYPE"];
}

// node_modules/@zag-js/utils/dist/index.mjs
function toArray2(v) {
  if (v == null) return [];
  return Array.isArray(v) ? v : [v];
}
var fromLength = (length) => Array.from(Array(length).keys());
var first = (v) => v[0];
var last = (v) => v[v.length - 1];
var has = (v, t) => v.indexOf(t) !== -1;
var add = (v, ...items) => v.concat(items);
var remove = (v, ...items) => v.filter((t) => !items.includes(t));
var removeAt = (v, i) => v.filter((_, idx) => idx !== i);
var uniq2 = (v) => Array.from(new Set(v));
var diff = (a2, b2) => {
  const set = new Set(b2);
  return a2.filter((t) => !set.has(t));
};
var addOrRemove = (v, item) => {
  if (has(v, item)) return remove(v, item);
  return add(v, item);
};
function nextIndex(v, idx, opts = {}) {
  const { step = 1, loop = true } = opts;
  const next2 = idx + step;
  const len = v.length;
  const last2 = len - 1;
  if (idx === -1) return step > 0 ? 0 : last2;
  if (next2 < 0) return loop ? last2 : 0;
  if (next2 >= len) return loop ? 0 : idx > len ? len : idx;
  return next2;
}
function next(v, idx, opts = {}) {
  return v[nextIndex(v, idx, opts)];
}
function prevIndex(v, idx, opts = {}) {
  const { step = 1, loop = true } = opts;
  return nextIndex(v, idx, { step: -step, loop });
}
function prev(v, index, opts = {}) {
  return v[prevIndex(v, index, opts)];
}
var chunk = (v, size3) => {
  const res = [];
  return v.reduce((rows, value, index) => {
    var _a8;
    if (index % size3 === 0) rows.push([value]);
    else (_a8 = last(rows)) == null ? void 0 : _a8.push(value);
    return rows;
  }, res);
};
function flatArray(arr) {
  return arr.reduce((flat, item) => {
    if (Array.isArray(item)) {
      return flat.concat(flatArray(item));
    }
    return flat.concat(item);
  }, []);
}
var isArrayLike = (value) => (value == null ? void 0 : value.constructor.name) === "Array";
var isArrayEqual = (a2, b2) => {
  if (a2.length !== b2.length) return false;
  for (let i = 0; i < a2.length; i++) {
    if (!isEqual(a2[i], b2[i])) return false;
  }
  return true;
};
var isEqual = (a2, b2) => {
  if (Object.is(a2, b2)) return true;
  if (a2 == null && b2 != null || a2 != null && b2 == null) return false;
  if (typeof (a2 == null ? void 0 : a2.isEqual) === "function" && typeof (b2 == null ? void 0 : b2.isEqual) === "function") {
    return a2.isEqual(b2);
  }
  if (typeof a2 === "function" && typeof b2 === "function") {
    return a2.toString() === b2.toString();
  }
  if (isArrayLike(a2) && isArrayLike(b2)) {
    return isArrayEqual(Array.from(a2), Array.from(b2));
  }
  if (!(typeof a2 === "object") || !(typeof b2 === "object")) return false;
  const keys = Object.keys(b2 ?? /* @__PURE__ */ Object.create(null));
  const length = keys.length;
  for (let i = 0; i < length; i++) {
    const hasKey = Reflect.has(a2, keys[i]);
    if (!hasKey) return false;
  }
  for (let i = 0; i < length; i++) {
    const key = keys[i];
    if (!isEqual(a2[key], b2[key])) return false;
  }
  return true;
};
var isArray = (v) => Array.isArray(v);
var isBoolean = (v) => v === true || v === false;
var isObjectLike = (v) => v != null && typeof v === "object";
var isObject2 = (v) => isObjectLike(v) && !isArray(v);
var isNumber = (v) => typeof v === "number" && !Number.isNaN(v);
var isString2 = (v) => typeof v === "string";
var isFunction2 = (v) => typeof v === "function";
var isNull = (v) => v == null;
var hasProp2 = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop);
var fnToString = Function.prototype.toString;
var objectCtorString = fnToString.call(Object);
var runIfFn = (v, ...a2) => {
  const res = typeof v === "function" ? v(...a2) : v;
  return res ?? void 0;
};
var cast = (v) => v;
var identity = (v) => v();
var noop = () => {
};
var callAll2 = (...fns) => (...a2) => {
  fns.forEach(function(fn) {
    fn == null ? void 0 : fn(...a2);
  });
};
var uuid = /* @__PURE__ */ (() => {
  let id = 0;
  return () => {
    id++;
    return id.toString(36);
  };
})();
function match(key, record, ...args) {
  var _a8;
  if (key in record) {
    const fn = record[key];
    return isFunction2(fn) ? fn(...args) : fn;
  }
  const error = new Error(`No matching key: ${JSON.stringify(key)} in ${JSON.stringify(Object.keys(record))}`);
  (_a8 = Error.captureStackTrace) == null ? void 0 : _a8.call(Error, error, match);
  throw error;
}
var tryCatch = (fn, fallback4) => {
  var _a8;
  try {
    return fn();
  } catch (error) {
    if (error instanceof Error) {
      (_a8 = Error.captureStackTrace) == null ? void 0 : _a8.call(Error, error, tryCatch);
    }
    return fallback4 == null ? void 0 : fallback4();
  }
};
function throttle(fn, wait = 0) {
  let lastCall = 0;
  let timeout = null;
  return (...args) => {
    const now = Date.now();
    const timeSinceLastCall = now - lastCall;
    if (timeSinceLastCall >= wait) {
      if (timeout) {
        clearTimeout(timeout);
        timeout = null;
      }
      fn(...args);
      lastCall = now;
    } else if (!timeout) {
      timeout = setTimeout(() => {
        fn(...args);
        lastCall = Date.now();
        timeout = null;
      }, wait - timeSinceLastCall);
    }
  };
}
var { floor, abs, round, min, max, pow, sign } = Math;
var isNaN2 = (v) => Number.isNaN(v);
var nan = (v) => isNaN2(v) ? 0 : v;
var mod = (v, m) => (v % m + m) % m;
var wrap = (v, vmax) => (v % vmax + vmax) % vmax;
var getMinValueAtIndex = (i, v, vmin) => i === 0 ? vmin : v[i - 1];
var getMaxValueAtIndex = (i, v, vmax) => i === v.length - 1 ? vmax : v[i + 1];
var isValueAtMax = (v, vmax) => nan(v) >= vmax;
var isValueAtMin = (v, vmin) => nan(v) <= vmin;
var isValueWithinRange = (v, vmin, vmax) => nan(v) >= vmin && nan(v) <= vmax;
var roundValue = (v, vmin, step) => round((nan(v) - vmin) / step) * step + vmin;
var clampValue = (v, vmin, vmax) => min(max(nan(v), vmin), vmax);
var getValuePercent = (v, vmin, vmax) => (nan(v) - vmin) / (vmax - vmin);
var getPercentValue = (p, vmin, vmax, step) => clampValue(roundValue(p * (vmax - vmin) + vmin, vmin, step), vmin, vmax);
var roundToStepPrecision = (v, step) => {
  let rv = v;
  let ss = step.toString();
  let pi = ss.indexOf(".");
  let p = pi >= 0 ? ss.length - pi : 0;
  if (p > 0) {
    let pw = pow(10, p);
    rv = round(rv * pw) / pw;
  }
  return rv;
};
var roundToDpr = (v, dpr) => typeof dpr === "number" ? floor(v * dpr + 0.5) / dpr : round(v);
var snapValueToStep = (v, vmin, vmax, step) => {
  const min23 = vmin != null ? Number(vmin) : 0;
  const max22 = Number(vmax);
  const remainder = (v - min23) % step;
  let snapped = abs(remainder) * 2 >= step ? v + sign(remainder) * (step - abs(remainder)) : v - remainder;
  snapped = roundToStepPrecision(snapped, step);
  if (!isNaN2(min23) && snapped < min23) {
    snapped = min23;
  } else if (!isNaN2(max22) && snapped > max22) {
    const stepsInRange = floor((max22 - min23) / step);
    const largestValidStep = min23 + stepsInRange * step;
    snapped = stepsInRange <= 0 || largestValidStep < min23 ? max22 : largestValidStep;
  }
  return roundToStepPrecision(snapped, step);
};
var setValueAtIndex = (vs, i, v) => {
  if (vs[i] === v) return vs;
  return [...vs.slice(0, i), v, ...vs.slice(i + 1)];
};
function getValueSetterAtIndex(index, ctx) {
  const minValueAtIndex = getMinValueAtIndex(index, ctx.values, ctx.min);
  const maxValueAtIndex = getMaxValueAtIndex(index, ctx.values, ctx.max);
  let nextValues = ctx.values.slice();
  return function setValue(value) {
    let nextValue = snapValueToStep(value, minValueAtIndex, maxValueAtIndex, ctx.step);
    nextValues = setValueAtIndex(nextValues, index, value);
    nextValues[index] = nextValue;
    return nextValues;
  };
}
function getNextStepValue(index, ctx) {
  const nextValue = ctx.values[index] + ctx.step;
  return getValueSetterAtIndex(index, ctx)(nextValue);
}
function getPreviousStepValue(index, ctx) {
  const nextValue = ctx.values[index] - ctx.step;
  return getValueSetterAtIndex(index, ctx)(nextValue);
}
var getClosestValueIndex = (vs, t) => {
  let i = vs.findIndex((v) => t - v < 0);
  if (i === 0) return i;
  if (i === -1) return vs.length - 1;
  let vLeft = vs[i - 1];
  let vRight = vs[i];
  if (abs(vLeft - t) < abs(vRight - t)) return i - 1;
  return i;
};
var getValueRanges = (vs, vmin, vmax, gap) => vs.map((v, i) => ({
  min: i === 0 ? vmin : vs[i - 1] + gap,
  max: i === vs.length - 1 ? vmax : vs[i + 1] - gap,
  value: v
}));
var getValueTransformer = (va, vb) => {
  const [a2, b2] = va;
  const [c, d] = vb;
  return (v) => a2 === b2 || c === d ? c : c + (d - c) / (b2 - a2) * (v - a2);
};
var toFixedNumber = (v, d = 0, b2 = 10) => {
  const pow2 = Math.pow(b2, d);
  return round(v * pow2) / pow2;
};
var countDecimals = (value) => {
  if (!Number.isFinite(value)) return 0;
  let e = 1, p = 0;
  while (Math.round(value * e) / e !== value) {
    e *= 10;
    p += 1;
  }
  return p;
};
var decimalOp = (a2, op, b2) => {
  let result = op === "+" ? a2 + b2 : a2 - b2;
  if (a2 % 1 !== 0 || b2 % 1 !== 0) {
    const multiplier = 10 ** Math.max(countDecimals(a2), countDecimals(b2));
    a2 = Math.round(a2 * multiplier);
    b2 = Math.round(b2 * multiplier);
    result = op === "+" ? a2 + b2 : a2 - b2;
    result /= multiplier;
  }
  return result;
};
var incrementValue = (v, s) => decimalOp(nan(v), "+", s);
var decrementValue = (v, s) => decimalOp(nan(v), "-", s);
var toPx = (v) => v != null ? `${v}px` : void 0;
function compact2(obj) {
  if (!isPlainObject2(obj) || obj === void 0) return obj;
  const keys = Reflect.ownKeys(obj).filter((key) => typeof key === "string");
  const filtered = {};
  for (const key of keys) {
    const value = obj[key];
    if (value !== void 0) {
      filtered[key] = compact2(value);
    }
  }
  return filtered;
}
var isPlainObject2 = (v) => {
  return v && typeof v === "object" && v.constructor === Object;
};
function pick(obj, keys) {
  const filtered = {};
  for (const key of keys) {
    const value = obj[key];
    if (value !== void 0) {
      filtered[key] = value;
    }
  }
  return filtered;
}
function splitProps2(props43, keys) {
  const rest = {};
  const result = {};
  const keySet = new Set(keys);
  for (const key in props43) {
    if (keySet.has(key)) {
      result[key] = props43[key];
    } else {
      rest[key] = props43[key];
    }
  }
  return [result, rest];
}
var createSplitProps = (keys) => {
  return function split(props43) {
    return splitProps2(props43, keys);
  };
};
function setRafInterval(callback, interval) {
  let start = performance.now();
  let handle;
  function loop(now) {
    handle = requestAnimationFrame(loop);
    const delta = now - start;
    if (delta >= interval) {
      start = now - delta % interval;
      callback({ startMs: start, deltaMs: delta });
    }
  }
  handle = requestAnimationFrame(loop);
  return () => cancelAnimationFrame(handle);
}
function setRafTimeout(callback, delay2) {
  const start = performance.now();
  let handle;
  function loop(now) {
    handle = requestAnimationFrame(loop);
    const delta = now - start;
    if (delta >= delay2) {
      callback();
    }
  }
  handle = requestAnimationFrame(loop);
  return () => cancelAnimationFrame(handle);
}
function warn(...a2) {
  const m = a2.length === 1 ? a2[0] : a2[1];
  const c = a2.length === 2 ? a2[0] : true;
  if (c && true) {
    console.warn(m);
  }
}
function invariant(...a2) {
  const m = a2.length === 1 ? a2[0] : a2[1];
  const c = a2.length === 2 ? a2[0] : true;
  if (c && true) {
    throw new Error(m);
  }
}
function ensure(c, m) {
  if (c == null) throw new Error(m());
}
function ensureProps(props43, keys, scope) {
  let missingKeys = [];
  for (const key of keys) {
    if (props43[key] == null) missingKeys.push(key);
  }
  if (missingKeys.length > 0)
    throw new Error(`[zag-js${scope ? ` > ${scope}` : ""}] missing required props: ${missingKeys.join(", ")}`);
}

// node_modules/@ark-ui/react/dist/components/download-trigger/download-trigger.js
var import_react12 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/utils/create-context.js
var import_react10 = __toESM(require_react(), 1);
function getErrorMessage2(hook, provider) {
  return `${hook} returned \`undefined\`. Seems you forgot to wrap component within ${provider}`;
}
function createContext3(options = {}) {
  const {
    name,
    strict = true,
    hookName = "useContext",
    providerName = "Provider",
    errorMessage,
    defaultValue
  } = options;
  const Context = (0, import_react10.createContext)(defaultValue);
  Context.displayName = name;
  function useContext$1() {
    var _a8;
    const context = (0, import_react10.useContext)(Context);
    if (!context && strict) {
      const error = new Error(errorMessage ?? getErrorMessage2(hookName, providerName));
      error.name = "ContextError";
      (_a8 = Error.captureStackTrace) == null ? void 0 : _a8.call(Error, error, useContext$1);
      throw error;
    }
    return context;
  }
  return [Context.Provider, useContext$1, Context];
}

// node_modules/@ark-ui/react/dist/providers/environment/use-environment-context.js
var [EnvironmentContextProvider, useEnvironmentContext] = createContext3({
  name: "EnvironmentContext",
  hookName: "useEnvironmentContext",
  providerName: "<EnvironmentProvider />",
  strict: false,
  defaultValue: {
    getRootNode: () => document,
    getDocument: () => document,
    getWindow: () => window
  }
});

// node_modules/@zag-js/dom-query/dist/index.mjs
function isCaretAtStart(input) {
  if (!input) return false;
  try {
    return input.selectionStart === 0 && input.selectionEnd === 0;
  } catch {
    return input.value === "";
  }
}
function setCaretToEnd(input) {
  if (!input) return;
  const start = input.selectionStart ?? 0;
  const end = input.selectionEnd ?? 0;
  if (Math.abs(end - start) !== 0) return;
  if (start !== 0) return;
  input.setSelectionRange(input.value.length, input.value.length);
}
var clamp = (value) => Math.max(0, Math.min(1, value));
var wrap2 = (v, idx) => {
  return v.map((_, index) => v[(Math.max(idx, 0) + index) % v.length]);
};
var pipe = (...fns) => (arg) => fns.reduce((acc, fn) => fn(acc), arg);
var noop2 = () => void 0;
var isObject3 = (v) => typeof v === "object" && v !== null;
var MAX_Z_INDEX = 2147483647;
var dataAttr = (guard) => guard ? "" : void 0;
var ariaAttr = (guard) => guard ? "true" : void 0;
var ELEMENT_NODE = 1;
var DOCUMENT_NODE = 9;
var DOCUMENT_FRAGMENT_NODE = 11;
var isHTMLElement = (el) => isObject3(el) && el.nodeType === ELEMENT_NODE && typeof el.nodeName === "string";
var isDocument = (el) => isObject3(el) && el.nodeType === DOCUMENT_NODE;
var isWindow = (el) => isObject3(el) && el === el.window;
var getNodeName = (node) => {
  if (isHTMLElement(node)) return node.localName || "";
  return "#document";
};
function isRootElement(node) {
  return ["html", "body", "#document"].includes(getNodeName(node));
}
var isNode = (el) => isObject3(el) && el.nodeType !== void 0;
var isShadowRoot = (el) => isNode(el) && el.nodeType === DOCUMENT_FRAGMENT_NODE && "host" in el;
var isInputElement = (el) => isHTMLElement(el) && el.localName === "input";
var isAnchorElement = (el) => !!(el == null ? void 0 : el.matches("a[href]"));
var isElementVisible = (el) => {
  if (!isHTMLElement(el)) return false;
  return el.offsetWidth > 0 || el.offsetHeight > 0 || el.getClientRects().length > 0;
};
var TEXTAREA_SELECT_REGEX = /(textarea|select)/;
function isEditableElement(el) {
  if (el == null || !isHTMLElement(el)) return false;
  try {
    return isInputElement(el) && el.selectionStart != null || TEXTAREA_SELECT_REGEX.test(el.localName) || el.isContentEditable || el.getAttribute("contenteditable") === "true" || el.getAttribute("contenteditable") === "";
  } catch {
    return false;
  }
}
function contains(parent, child) {
  var _a8;
  if (!parent || !child) return false;
  if (!isHTMLElement(parent) || !isHTMLElement(child)) return false;
  const rootNode = (_a8 = child.getRootNode) == null ? void 0 : _a8.call(child);
  if (parent === child) return true;
  if (parent.contains(child)) return true;
  if (rootNode && isShadowRoot(rootNode)) {
    let next2 = child;
    while (next2) {
      if (parent === next2) return true;
      next2 = next2.parentNode || next2.host;
    }
  }
  return false;
}
function getDocument(el) {
  if (isDocument(el)) return el;
  if (isWindow(el)) return el.document;
  return (el == null ? void 0 : el.ownerDocument) ?? document;
}
function getDocumentElement(el) {
  return getDocument(el).documentElement;
}
function getWindow(el) {
  var _a8;
  if (isShadowRoot(el)) return getWindow(el.host);
  if (isDocument(el)) return el.defaultView ?? window;
  if (isHTMLElement(el)) return ((_a8 = el.ownerDocument) == null ? void 0 : _a8.defaultView) ?? window;
  return window;
}
function getActiveElement(rootNode) {
  let activeElement = rootNode.activeElement;
  while (activeElement == null ? void 0 : activeElement.shadowRoot) {
    const el = activeElement.shadowRoot.activeElement;
    if (el === activeElement) break;
    else activeElement = el;
  }
  return activeElement;
}
function getParentNode(node) {
  if (getNodeName(node) === "html") return node;
  const result = node.assignedSlot || node.parentNode || isShadowRoot(node) && node.host || getDocumentElement(node);
  return isShadowRoot(result) ? result.host : result;
}
var styleCache = /* @__PURE__ */ new WeakMap();
function getComputedStyle2(el) {
  if (!styleCache.has(el)) {
    styleCache.set(el, getWindow(el).getComputedStyle(el));
  }
  return styleCache.get(el);
}
function getDataUrl(svg, opts) {
  const { type, quality = 0.92, background } = opts;
  if (!svg) throw new Error("[zag-js > getDataUrl]: Could not find the svg element");
  const win = getWindow(svg);
  const doc = win.document;
  const svgBounds = svg.getBoundingClientRect();
  const svgClone = svg.cloneNode(true);
  if (!svgClone.hasAttribute("viewBox")) {
    svgClone.setAttribute("viewBox", `0 0 ${svgBounds.width} ${svgBounds.height}`);
  }
  const serializer = new win.XMLSerializer();
  const source = '<?xml version="1.0" standalone="no"?>\r\n' + serializer.serializeToString(svgClone);
  const svgString = "data:image/svg+xml;charset=utf-8," + encodeURIComponent(source);
  if (type === "image/svg+xml") {
    return Promise.resolve(svgString).then((str) => {
      svgClone.remove();
      return str;
    });
  }
  const dpr = win.devicePixelRatio || 1;
  const canvas = doc.createElement("canvas");
  const image = new win.Image();
  image.src = svgString;
  canvas.width = svgBounds.width * dpr;
  canvas.height = svgBounds.height * dpr;
  const context = canvas.getContext("2d");
  if (type === "image/jpeg" || background) {
    context.fillStyle = background || "white";
    context.fillRect(0, 0, canvas.width, canvas.height);
  }
  return new Promise((resolve) => {
    image.onload = () => {
      context == null ? void 0 : context.drawImage(image, 0, 0, canvas.width, canvas.height);
      resolve(canvas.toDataURL(type, quality));
      svgClone.remove();
    };
  });
}
var isDom = () => typeof document !== "undefined";
function getPlatform() {
  const agent = navigator.userAgentData;
  return (agent == null ? void 0 : agent.platform) ?? navigator.platform;
}
function getUserAgent() {
  const ua2 = navigator.userAgentData;
  if (ua2 && Array.isArray(ua2.brands)) {
    return ua2.brands.map(({ brand, version: version2 }) => `${brand}/${version2}`).join(" ");
  }
  return navigator.userAgent;
}
var pt = (v) => isDom() && v.test(getPlatform());
var ua = (v) => isDom() && v.test(getUserAgent());
var vn = (v) => isDom() && v.test(navigator.vendor);
var isTouchDevice = () => isDom() && !!navigator.maxTouchPoints;
var isIPhone = () => pt(/^iPhone/i);
var isIPad = () => pt(/^iPad/i) || isMac() && navigator.maxTouchPoints > 1;
var isIos = () => isIPhone() || isIPad();
var isApple = () => isMac() || isIos();
var isMac = () => pt(/^Mac/i);
var isSafari = () => isApple() && vn(/apple/i);
var isFirefox = () => ua(/Firefox/i);
var isAndroid = () => ua(/Android/i);
function getBeforeInputValue(event) {
  const { selectionStart, selectionEnd, value } = event.currentTarget;
  return value.slice(0, selectionStart) + event.data + value.slice(selectionEnd);
}
function getComposedPath(event) {
  var _a8, _b7, _c6;
  return ((_a8 = event.composedPath) == null ? void 0 : _a8.call(event)) ?? ((_c6 = (_b7 = event.nativeEvent) == null ? void 0 : _b7.composedPath) == null ? void 0 : _c6.call(_b7));
}
function getEventTarget(event) {
  const composedPath = getComposedPath(event);
  return (composedPath == null ? void 0 : composedPath[0]) ?? event.target;
}
var isSelfTarget = (event) => {
  return contains(event.currentTarget, getEventTarget(event));
};
function isOpeningInNewTab(event) {
  const element = event.currentTarget;
  if (!element) return false;
  const validElement = element.matches("a[href], button[type='submit'], input[type='submit']");
  if (!validElement) return false;
  const isMiddleClick = event.button === 1;
  const isModKeyClick = isCtrlOrMetaKey(event);
  return isMiddleClick || isModKeyClick;
}
function isDownloadingEvent(event) {
  const element = event.currentTarget;
  if (!element) return false;
  const localName = element.localName;
  if (!event.altKey) return false;
  if (localName === "a") return true;
  if (localName === "button" && element.type === "submit") return true;
  if (localName === "input" && element.type === "submit") return true;
  return false;
}
function isComposingEvent(event) {
  return getNativeEvent(event).isComposing || event.keyCode === 229;
}
function isCtrlOrMetaKey(e) {
  if (isMac()) return e.metaKey;
  return e.ctrlKey;
}
function isPrintableKey(e) {
  return e.key.length === 1 && !e.ctrlKey && !e.metaKey;
}
function isVirtualClick(e) {
  if (e.mozInputSource === 0 && e.isTrusted) return true;
  if (isAndroid() && e.pointerType) {
    return e.type === "click" && e.buttons === 1;
  }
  return e.detail === 0 && !e.pointerType;
}
var isLeftClick = (e) => e.button === 0;
var isContextMenuEvent = (e) => {
  return e.button === 2 || isMac() && e.ctrlKey && e.button === 0;
};
var isModifierKey = (e) => e.ctrlKey || e.altKey || e.metaKey;
var isTouchEvent = (event) => "touches" in event && event.touches.length > 0;
var keyMap = {
  Up: "ArrowUp",
  Down: "ArrowDown",
  Esc: "Escape",
  " ": "Space",
  ",": "Comma",
  Left: "ArrowLeft",
  Right: "ArrowRight"
};
var rtlKeyMap = {
  ArrowLeft: "ArrowRight",
  ArrowRight: "ArrowLeft"
};
function getEventKey(event, options = {}) {
  const { dir = "ltr", orientation = "horizontal" } = options;
  let key = event.key;
  key = keyMap[key] ?? key;
  const isRtl = dir === "rtl" && orientation === "horizontal";
  if (isRtl && key in rtlKeyMap) key = rtlKeyMap[key];
  return key;
}
function getNativeEvent(event) {
  return event.nativeEvent ?? event;
}
var pageKeys = /* @__PURE__ */ new Set(["PageUp", "PageDown"]);
var arrowKeys = /* @__PURE__ */ new Set(["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"]);
function getEventStep(event) {
  if (event.ctrlKey || event.metaKey) {
    return 0.1;
  } else {
    const isPageKey = pageKeys.has(event.key);
    const isSkipKey = isPageKey || event.shiftKey && arrowKeys.has(event.key);
    return isSkipKey ? 10 : 1;
  }
}
function getEventPoint(event, type = "client") {
  const point = isTouchEvent(event) ? event.touches[0] || event.changedTouches[0] : event;
  return { x: point[`${type}X`], y: point[`${type}Y`] };
}
var addDomEvent = (target, eventName, handler, options) => {
  const node = typeof target === "function" ? target() : target;
  node == null ? void 0 : node.addEventListener(eventName, handler, options);
  return () => {
    node == null ? void 0 : node.removeEventListener(eventName, handler, options);
  };
};
function getDescriptor(el, options) {
  const { type = "HTMLInputElement", property = "value" } = options;
  const proto = getWindow(el)[type].prototype;
  return Object.getOwnPropertyDescriptor(proto, property) ?? {};
}
function getElementType(el) {
  if (el.localName === "input") return "HTMLInputElement";
  if (el.localName === "textarea") return "HTMLTextAreaElement";
  if (el.localName === "select") return "HTMLSelectElement";
}
function setElementValue(el, value, property = "value") {
  var _a8;
  if (!el) return;
  const type = getElementType(el);
  if (type) {
    const descriptor = getDescriptor(el, { type, property });
    (_a8 = descriptor.set) == null ? void 0 : _a8.call(el, value);
  }
  el.setAttribute(property, value);
}
function setElementChecked(el, checked) {
  var _a8;
  if (!el) return;
  const descriptor = getDescriptor(el, { type: "HTMLInputElement", property: "checked" });
  (_a8 = descriptor.set) == null ? void 0 : _a8.call(el, checked);
  if (checked) el.setAttribute("checked", "");
  else el.removeAttribute("checked");
}
function dispatchInputValueEvent(el, options) {
  const { value, bubbles = true } = options;
  if (!el) return;
  const win = getWindow(el);
  if (!(el instanceof win.HTMLInputElement)) return;
  setElementValue(el, `${value}`);
  el.dispatchEvent(new win.Event("input", { bubbles }));
}
function dispatchInputCheckedEvent(el, options) {
  const { checked, bubbles = true } = options;
  if (!el) return;
  const win = getWindow(el);
  if (!(el instanceof win.HTMLInputElement)) return;
  setElementChecked(el, checked);
  el.dispatchEvent(new win.Event("click", { bubbles }));
}
function getClosestForm(el) {
  return isFormElement(el) ? el.form : el.closest("form");
}
function isFormElement(el) {
  return el.matches("textarea, input, select, button");
}
function trackFormReset(el, callback) {
  if (!el) return;
  const form = getClosestForm(el);
  const onReset = (e) => {
    if (e.defaultPrevented) return;
    callback();
  };
  form == null ? void 0 : form.addEventListener("reset", onReset, { passive: true });
  return () => form == null ? void 0 : form.removeEventListener("reset", onReset);
}
function trackFieldsetDisabled(el, callback) {
  const fieldset = el == null ? void 0 : el.closest("fieldset");
  if (!fieldset) return;
  callback(fieldset.disabled);
  const win = getWindow(fieldset);
  const obs = new win.MutationObserver(() => callback(fieldset.disabled));
  obs.observe(fieldset, {
    attributes: true,
    attributeFilter: ["disabled"]
  });
  return () => obs.disconnect();
}
function trackFormControl(el, options) {
  if (!el) return;
  const { onFieldsetDisabledChange, onFormReset } = options;
  const cleanups = [trackFormReset(el, onFormReset), trackFieldsetDisabled(el, onFieldsetDisabledChange)];
  return () => cleanups.forEach((cleanup) => cleanup == null ? void 0 : cleanup());
}
var isFrame = (el) => isHTMLElement(el) && el.tagName === "IFRAME";
var hasTabIndex = (el) => !Number.isNaN(parseInt(el.getAttribute("tabindex") || "0", 10));
var hasNegativeTabIndex = (el) => parseInt(el.getAttribute("tabindex") || "0", 10) < 0;
var focusableSelector = "input:not([type='hidden']):not([disabled]), select:not([disabled]), textarea:not([disabled]), a[href], button:not([disabled]), [tabindex], iframe, object, embed, area[href], audio[controls], video[controls], [contenteditable]:not([contenteditable='false']), details > summary:first-of-type";
var getFocusables = (container, includeContainer = false) => {
  if (!container) return [];
  const elements = Array.from(container.querySelectorAll(focusableSelector));
  const include = includeContainer == true || includeContainer == "if-empty" && elements.length === 0;
  if (include && isHTMLElement(container) && isFocusable(container)) {
    elements.unshift(container);
  }
  const focusableElements = elements.filter(isFocusable);
  focusableElements.forEach((element, i) => {
    if (isFrame(element) && element.contentDocument) {
      const frameBody = element.contentDocument.body;
      focusableElements.splice(i, 1, ...getFocusables(frameBody));
    }
  });
  return focusableElements;
};
function isFocusable(element) {
  if (!element || element.closest("[inert]")) return false;
  return element.matches(focusableSelector) && isElementVisible(element);
}
function getTabbables(container, includeContainer) {
  if (!container) return [];
  const elements = Array.from(container.querySelectorAll(focusableSelector));
  const tabbableElements = elements.filter(isTabbable);
  if (includeContainer && isTabbable(container)) {
    tabbableElements.unshift(container);
  }
  tabbableElements.forEach((element, i) => {
    if (isFrame(element) && element.contentDocument) {
      const frameBody = element.contentDocument.body;
      const allFrameTabbable = getTabbables(frameBody);
      tabbableElements.splice(i, 1, ...allFrameTabbable);
    }
  });
  if (!tabbableElements.length && includeContainer) {
    return elements;
  }
  return tabbableElements;
}
function isTabbable(el) {
  if (el != null && el.tabIndex > 0) return true;
  return isFocusable(el) && !hasNegativeTabIndex(el);
}
function getTabbableEdges(container, includeContainer) {
  const elements = getTabbables(container, includeContainer);
  const first2 = elements[0] || null;
  const last2 = elements[elements.length - 1] || null;
  return [first2, last2];
}
function getNextTabbable(container, current) {
  const tabbables = getTabbables(container);
  const doc = (container == null ? void 0 : container.ownerDocument) || document;
  const currentElement = current ?? doc.activeElement;
  if (!currentElement) return null;
  const index = tabbables.indexOf(currentElement);
  return tabbables[index + 1] || null;
}
function getTabIndex(node) {
  if (node.tabIndex < 0) {
    if ((/^(audio|video|details)$/.test(node.localName) || isEditableElement(node)) && !hasTabIndex(node)) {
      return 0;
    }
  }
  return node.tabIndex;
}
function getInitialFocus(options) {
  const { root, getInitialEl, filter, enabled = true } = options;
  if (!enabled) return;
  let node = null;
  node || (node = typeof getInitialEl === "function" ? getInitialEl() : getInitialEl);
  node || (node = root == null ? void 0 : root.querySelector("[data-autofocus],[autofocus]"));
  if (!node) {
    const tabbables = getTabbables(root);
    node = filter ? tabbables.filter(filter)[0] : tabbables[0];
  }
  return node || root || void 0;
}
function isValidTabEvent(event) {
  const container = event.currentTarget;
  if (!container) return false;
  const [firstTabbable, lastTabbable] = getTabbableEdges(container);
  const doc = container.ownerDocument || document;
  if (doc.activeElement === firstTabbable && event.shiftKey) return false;
  if (doc.activeElement === lastTabbable && !event.shiftKey) return false;
  if (!firstTabbable && !lastTabbable) return false;
  return true;
}
function nextTick(fn) {
  const set = /* @__PURE__ */ new Set();
  function raf22(fn2) {
    const id = globalThis.requestAnimationFrame(fn2);
    set.add(() => globalThis.cancelAnimationFrame(id));
  }
  raf22(() => raf22(fn));
  return function cleanup() {
    set.forEach((fn2) => fn2());
  };
}
function raf(fn) {
  let cleanup;
  const id = globalThis.requestAnimationFrame(() => {
    cleanup = fn();
  });
  return () => {
    globalThis.cancelAnimationFrame(id);
    cleanup == null ? void 0 : cleanup();
  };
}
function queueBeforeEvent(el, type, cb) {
  const cancelTimer = raf(() => {
    el.removeEventListener(type, exec, true);
    cb();
  });
  const exec = () => {
    cancelTimer();
    cb();
  };
  el.addEventListener(type, exec, { once: true, capture: true });
  return cancelTimer;
}
function observeAttributesImpl(node, options) {
  if (!node) return;
  const { attributes, callback: fn } = options;
  const win = node.ownerDocument.defaultView || window;
  const obs = new win.MutationObserver((changes) => {
    for (const change of changes) {
      if (change.type === "attributes" && change.attributeName && attributes.includes(change.attributeName)) {
        fn(change);
      }
    }
  });
  obs.observe(node, { attributes: true, attributeFilter: attributes });
  return () => obs.disconnect();
}
function observeAttributes(nodeOrFn, options) {
  const { defer } = options;
  const func = defer ? raf : (v) => v();
  const cleanups = [];
  cleanups.push(
    func(() => {
      const node = typeof nodeOrFn === "function" ? nodeOrFn() : nodeOrFn;
      cleanups.push(observeAttributesImpl(node, options));
    })
  );
  return () => {
    cleanups.forEach((fn) => fn == null ? void 0 : fn());
  };
}
function observeChildrenImpl(node, options) {
  const { callback: fn } = options;
  if (!node) return;
  const win = node.ownerDocument.defaultView || window;
  const obs = new win.MutationObserver(fn);
  obs.observe(node, { childList: true, subtree: true });
  return () => obs.disconnect();
}
function observeChildren(nodeOrFn, options) {
  const { defer } = options;
  const func = defer ? raf : (v) => v();
  const cleanups = [];
  cleanups.push(
    func(() => {
      const node = typeof nodeOrFn === "function" ? nodeOrFn() : nodeOrFn;
      cleanups.push(observeChildrenImpl(node, options));
    })
  );
  return () => {
    cleanups.forEach((fn) => fn == null ? void 0 : fn());
  };
}
function clickIfLink(el) {
  const click = () => el.click();
  if (isFirefox()) {
    queueBeforeEvent(el, "keyup", click);
  } else {
    queueMicrotask(click);
  }
}
function getNearestOverflowAncestor(el) {
  const parentNode = getParentNode(el);
  if (isRootElement(parentNode)) return getDocument(parentNode).body;
  if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) return parentNode;
  return getNearestOverflowAncestor(parentNode);
}
function getOverflowAncestors(el, list = []) {
  const scrollableAncestor = getNearestOverflowAncestor(el);
  const isBody = scrollableAncestor === el.ownerDocument.body;
  const win = getWindow(scrollableAncestor);
  if (isBody) {
    return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : []);
  }
  return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, []));
}
var OVERFLOW_RE = /auto|scroll|overlay|hidden|clip/;
function isOverflowElement(el) {
  const win = getWindow(el);
  const { overflow, overflowX, overflowY, display } = win.getComputedStyle(el);
  return OVERFLOW_RE.test(overflow + overflowY + overflowX) && !["inline", "contents"].includes(display);
}
function isScrollable(el) {
  return el.scrollHeight > el.clientHeight || el.scrollWidth > el.clientWidth;
}
function scrollIntoView(el, options) {
  const { rootEl, ...scrollOptions } = options || {};
  if (!el || !rootEl) return;
  if (!isOverflowElement(rootEl) || !isScrollable(rootEl)) return;
  el.scrollIntoView(scrollOptions);
}
function getRelativePoint(point, element) {
  const { left, top, width, height } = element.getBoundingClientRect();
  const offset4 = { x: point.x - left, y: point.y - top };
  const percent = { x: clamp(offset4.x / width), y: clamp(offset4.y / height) };
  function getPercentValue2(options = {}) {
    const { dir = "ltr", orientation = "horizontal", inverted } = options;
    const invertX = typeof inverted === "object" ? inverted.x : inverted;
    const invertY = typeof inverted === "object" ? inverted.y : inverted;
    if (orientation === "horizontal") {
      return dir === "rtl" || invertX ? 1 - percent.x : percent.x;
    }
    return invertY ? 1 - percent.y : percent.y;
  }
  return { offset: offset4, percent, getPercentValue: getPercentValue2 };
}
function requestPointerLock(doc, fn) {
  const body = doc.body;
  const supported = "pointerLockElement" in doc || "mozPointerLockElement" in doc;
  const isLocked = () => !!doc.pointerLockElement;
  function onPointerChange() {
    fn == null ? void 0 : fn(isLocked());
  }
  function onPointerError(event) {
    if (isLocked()) fn == null ? void 0 : fn(false);
    console.error("PointerLock error occurred:", event);
    doc.exitPointerLock();
  }
  if (!supported) return;
  try {
    body.requestPointerLock();
  } catch {
  }
  const cleanup = [
    addDomEvent(doc, "pointerlockchange", onPointerChange, false),
    addDomEvent(doc, "pointerlockerror", onPointerError, false)
  ];
  return () => {
    cleanup.forEach((cleanup2) => cleanup2());
    doc.exitPointerLock();
  };
}
var state = "default";
var userSelect = "";
var elementMap = /* @__PURE__ */ new WeakMap();
function disableTextSelectionImpl(options = {}) {
  const { target, doc } = options;
  const docNode = doc ?? document;
  const rootEl = docNode.documentElement;
  if (isIos()) {
    if (state === "default") {
      userSelect = rootEl.style.webkitUserSelect;
      rootEl.style.webkitUserSelect = "none";
    }
    state = "disabled";
  } else if (target) {
    elementMap.set(target, target.style.userSelect);
    target.style.userSelect = "none";
  }
  return () => restoreTextSelection({ target, doc: docNode });
}
function restoreTextSelection(options = {}) {
  const { target, doc } = options;
  const docNode = doc ?? document;
  const rootEl = docNode.documentElement;
  if (isIos()) {
    if (state !== "disabled") return;
    state = "restoring";
    setTimeout(() => {
      nextTick(() => {
        if (state === "restoring") {
          if (rootEl.style.webkitUserSelect === "none") {
            rootEl.style.webkitUserSelect = userSelect || "";
          }
          userSelect = "";
          state = "default";
        }
      });
    }, 300);
  } else {
    if (target && elementMap.has(target)) {
      const prevUserSelect = elementMap.get(target);
      if (target.style.userSelect === "none") {
        target.style.userSelect = prevUserSelect ?? "";
      }
      if (target.getAttribute("style") === "") {
        target.removeAttribute("style");
      }
      elementMap.delete(target);
    }
  }
}
function disableTextSelection(options = {}) {
  const { defer, target, ...restOptions } = options;
  const func = defer ? raf : (v) => v();
  const cleanups = [];
  cleanups.push(
    func(() => {
      const node = typeof target === "function" ? target() : target;
      cleanups.push(disableTextSelectionImpl({ ...restOptions, target: node }));
    })
  );
  return () => {
    cleanups.forEach((fn) => fn == null ? void 0 : fn());
  };
}
function trackPointerMove(doc, handlers) {
  const { onPointerMove, onPointerUp } = handlers;
  const handleMove = (event) => {
    const point = getEventPoint(event);
    const distance = Math.sqrt(point.x ** 2 + point.y ** 2);
    const moveBuffer = event.pointerType === "touch" ? 10 : 5;
    if (distance < moveBuffer) return;
    if (event.pointerType === "mouse" && event.button === 0) {
      onPointerUp();
      return;
    }
    onPointerMove({ point, event });
  };
  const cleanups = [
    addDomEvent(doc, "pointermove", handleMove, false),
    addDomEvent(doc, "pointerup", onPointerUp, false),
    addDomEvent(doc, "pointercancel", onPointerUp, false),
    addDomEvent(doc, "contextmenu", onPointerUp, false),
    disableTextSelection({ doc })
  ];
  return () => {
    cleanups.forEach((cleanup) => cleanup());
  };
}
function trackPress(options) {
  const {
    pointerNode,
    keyboardNode = pointerNode,
    onPress,
    onPressStart,
    onPressEnd,
    isValidKey: isValidKey2 = (e) => e.key === "Enter"
  } = options;
  if (!pointerNode) return noop2;
  const win = getWindow(pointerNode);
  const doc = getDocument(pointerNode);
  let removeStartListeners = noop2;
  let removeEndListeners = noop2;
  let removeAccessibleListeners = noop2;
  const getInfo = (event) => ({
    point: getEventPoint(event),
    event
  });
  function startPress(event) {
    onPressStart == null ? void 0 : onPressStart(getInfo(event));
  }
  function cancelPress(event) {
    onPressEnd == null ? void 0 : onPressEnd(getInfo(event));
  }
  const startPointerPress = (startEvent) => {
    removeEndListeners();
    const endPointerPress = (endEvent) => {
      const target = getEventTarget(endEvent);
      if (contains(pointerNode, target)) {
        onPress == null ? void 0 : onPress(getInfo(endEvent));
      } else {
        onPressEnd == null ? void 0 : onPressEnd(getInfo(endEvent));
      }
    };
    const removePointerUpListener = addDomEvent(win, "pointerup", endPointerPress, { passive: !onPress, once: true });
    const removePointerCancelListener = addDomEvent(win, "pointercancel", cancelPress, {
      passive: !onPressEnd,
      once: true
    });
    removeEndListeners = pipe(removePointerUpListener, removePointerCancelListener);
    if (doc.activeElement === keyboardNode && startEvent.pointerType === "mouse") {
      startEvent.preventDefault();
    }
    startPress(startEvent);
  };
  const removePointerListener = addDomEvent(pointerNode, "pointerdown", startPointerPress, { passive: !onPressStart });
  const removeFocusListener = addDomEvent(keyboardNode, "focus", startAccessiblePress);
  removeStartListeners = pipe(removePointerListener, removeFocusListener);
  function startAccessiblePress() {
    const handleKeydown = (keydownEvent) => {
      if (!isValidKey2(keydownEvent)) return;
      const handleKeyup = (keyupEvent) => {
        if (!isValidKey2(keyupEvent)) return;
        const evt2 = new win.PointerEvent("pointerup");
        const info = getInfo(evt2);
        onPress == null ? void 0 : onPress(info);
        onPressEnd == null ? void 0 : onPressEnd(info);
      };
      removeEndListeners();
      removeEndListeners = addDomEvent(keyboardNode, "keyup", handleKeyup);
      const evt = new win.PointerEvent("pointerdown");
      startPress(evt);
    };
    const handleBlur = () => {
      const evt = new win.PointerEvent("pointercancel");
      cancelPress(evt);
    };
    const removeKeydownListener = addDomEvent(keyboardNode, "keydown", handleKeydown);
    const removeBlurListener = addDomEvent(keyboardNode, "blur", handleBlur);
    removeAccessibleListeners = pipe(removeKeydownListener, removeBlurListener);
  }
  return () => {
    removeStartListeners();
    removeEndListeners();
    removeAccessibleListeners();
  };
}
function proxyTabFocusImpl(container, options = {}) {
  const { triggerElement, onFocus, onFocusEnter } = options;
  const doc = (container == null ? void 0 : container.ownerDocument) || document;
  const body = doc.body;
  function onKeyDown(event) {
    if (event.key !== "Tab") return;
    let elementToFocus = null;
    const [firstTabbable, lastTabbable] = getTabbableEdges(container, true);
    const nextTabbableAfterTrigger = getNextTabbable(body, triggerElement);
    const noTabbableElements = !firstTabbable && !lastTabbable;
    if (event.shiftKey && nextTabbableAfterTrigger === doc.activeElement) {
      onFocusEnter == null ? void 0 : onFocusEnter();
      elementToFocus = lastTabbable;
    } else if (event.shiftKey && (doc.activeElement === firstTabbable || noTabbableElements)) {
      elementToFocus = triggerElement;
    } else if (!event.shiftKey && doc.activeElement === triggerElement) {
      onFocusEnter == null ? void 0 : onFocusEnter();
      elementToFocus = firstTabbable;
    } else if (!event.shiftKey && (doc.activeElement === lastTabbable || noTabbableElements)) {
      elementToFocus = nextTabbableAfterTrigger;
    }
    if (!elementToFocus) return;
    event.preventDefault();
    if (typeof onFocus === "function") {
      onFocus(elementToFocus);
    } else {
      elementToFocus.focus();
    }
  }
  return addDomEvent(doc, "keydown", onKeyDown, true);
}
function proxyTabFocus(container, options) {
  const { defer, triggerElement, ...restOptions } = options;
  const func = defer ? raf : (v) => v();
  const cleanups = [];
  cleanups.push(
    func(() => {
      const node = typeof container === "function" ? container() : container;
      const trigger = typeof triggerElement === "function" ? triggerElement() : triggerElement;
      cleanups.push(proxyTabFocusImpl(node, { triggerElement: trigger, ...restOptions }));
    })
  );
  return () => {
    cleanups.forEach((fn) => fn == null ? void 0 : fn());
  };
}
function queryAll(root, selector) {
  return Array.from((root == null ? void 0 : root.querySelectorAll(selector)) ?? []);
}
function query(root, selector) {
  return (root == null ? void 0 : root.querySelector(selector)) ?? null;
}
var defaultItemToId = (v) => v.id;
function itemById(v, id, itemToId = defaultItemToId) {
  return v.find((item) => itemToId(item) === id);
}
function indexOfId(v, id, itemToId = defaultItemToId) {
  const item = itemById(v, id, itemToId);
  return item ? v.indexOf(item) : -1;
}
function nextById(v, id, loop = true) {
  let idx = indexOfId(v, id);
  idx = loop ? (idx + 1) % v.length : Math.min(idx + 1, v.length - 1);
  return v[idx];
}
function prevById(v, id, loop = true) {
  let idx = indexOfId(v, id);
  if (idx === -1) return loop ? v[v.length - 1] : null;
  idx = loop ? (idx - 1 + v.length) % v.length : Math.max(0, idx - 1);
  return v[idx];
}
function trackElementRect(elements, options) {
  const { onEntry, measure, box = "border-box" } = options;
  const elems = (Array.isArray(elements) ? elements : [elements]).filter(isHTMLElement);
  const win = getWindow(elems[0]);
  const trigger = (entries) => {
    const rects = elems.map((el) => measure(el));
    onEntry({ rects, entries });
  };
  trigger([]);
  const obs = new win.ResizeObserver(trigger);
  elems.forEach((el) => obs.observe(el, { box }));
  return () => obs.disconnect();
}
var sanitize = (str) => str.split("").map((char) => {
  const code = char.charCodeAt(0);
  if (code > 0 && code < 128) return char;
  if (code >= 128 && code <= 255) return `/x${code.toString(16)}`.replace("/", "\\");
  return "";
}).join("").trim();
var getValueText = (el) => {
  var _a8;
  return sanitize(((_a8 = el.dataset) == null ? void 0 : _a8.valuetext) ?? el.textContent ?? "");
};
var match2 = (valueText, query2) => {
  return valueText.trim().toLowerCase().startsWith(query2.toLowerCase());
};
function getByText(v, text, currentId, itemToId = defaultItemToId) {
  const index = currentId ? indexOfId(v, currentId, itemToId) : -1;
  let items = currentId ? wrap2(v, index) : v;
  const isSingleKey = text.length === 1;
  if (isSingleKey) {
    items = items.filter((item) => itemToId(item) !== currentId);
  }
  return items.find((item) => match2(getValueText(item), text));
}
function setStyle(el, style) {
  if (!el) return noop2;
  const prev2 = Object.keys(style).reduce((acc, key) => {
    acc[key] = el.style.getPropertyValue(key);
    return acc;
  }, {});
  Object.assign(el.style, style);
  return () => {
    Object.assign(el.style, prev2);
    if (el.style.length === 0) {
      el.removeAttribute("style");
    }
  };
}
function setStyleProperty(el, prop, value) {
  if (!el) return noop2;
  const prev2 = el.style.getPropertyValue(prop);
  el.style.setProperty(prop, value);
  return () => {
    el.style.setProperty(prop, prev2);
    if (el.style.length === 0) {
      el.removeAttribute("style");
    }
  };
}
function getByTypeaheadImpl(baseItems, options) {
  const { state: state2, activeId, key, timeout = 350, itemToId } = options;
  const search = state2.keysSoFar + key;
  const isRepeated = search.length > 1 && Array.from(search).every((char) => char === search[0]);
  const query2 = isRepeated ? search[0] : search;
  let items = baseItems.slice();
  const next2 = getByText(items, query2, activeId, itemToId);
  function cleanup() {
    clearTimeout(state2.timer);
    state2.timer = -1;
  }
  function update(value) {
    state2.keysSoFar = value;
    cleanup();
    if (value !== "") {
      state2.timer = +setTimeout(() => {
        update("");
        cleanup();
      }, timeout);
    }
  }
  update(search);
  return next2;
}
var getByTypeahead = Object.assign(getByTypeaheadImpl, {
  defaultOptions: { keysSoFar: "", timer: -1 },
  isValidEvent: isValidTypeaheadEvent
});
function isValidTypeaheadEvent(event) {
  return event.key.length === 1 && !event.ctrlKey && !event.metaKey;
}
var visuallyHiddenStyle = {
  border: "0",
  clip: "rect(0 0 0 0)",
  height: "1px",
  margin: "-1px",
  overflow: "hidden",
  padding: "0",
  position: "absolute",
  width: "1px",
  whiteSpace: "nowrap",
  wordWrap: "normal"
};
var fps = 1e3 / 60;
function waitForElement(query2, cb) {
  const el = query2();
  if (isHTMLElement(el) && el.isConnected) {
    cb(el);
    return () => void 0;
  } else {
    const timerId = setInterval(() => {
      const el2 = query2();
      if (isHTMLElement(el2) && el2.isConnected) {
        cb(el2);
        clearInterval(timerId);
      }
    }, fps);
    return () => clearInterval(timerId);
  }
}
function waitForElements(queries, cb) {
  const cleanups = [];
  queries == null ? void 0 : queries.forEach((query2) => {
    const clean = waitForElement(query2, cb);
    cleanups.push(clean);
  });
  return () => {
    cleanups.forEach((fn) => fn());
  };
}

// node_modules/@zag-js/core/dist/index.mjs
var clsx2 = (...args) => args.map((str) => {
  var _a8;
  return (_a8 = str == null ? void 0 : str.trim) == null ? void 0 : _a8.call(str);
}).filter(Boolean).join(" ");
var CSS_REGEX = /((?:--)?(?:\w+-?)+)\s*:\s*([^;]*)/g;
var serialize = (style) => {
  const res = {};
  let match4;
  while (match4 = CSS_REGEX.exec(style)) {
    res[match4[1]] = match4[2];
  }
  return res;
};
var css = (a2, b2) => {
  if (isString2(a2)) {
    if (isString2(b2)) return `${a2};${b2}`;
    a2 = serialize(a2);
  } else if (isString2(b2)) {
    b2 = serialize(b2);
  }
  return Object.assign({}, a2 ?? {}, b2 ?? {});
};
function mergeProps2(...args) {
  let result = {};
  for (let props43 of args) {
    for (let key in result) {
      if (key.startsWith("on") && typeof result[key] === "function" && typeof props43[key] === "function") {
        result[key] = callAll2(props43[key], result[key]);
        continue;
      }
      if (key === "className" || key === "class") {
        result[key] = clsx2(result[key], props43[key]);
        continue;
      }
      if (key === "style") {
        result[key] = css(result[key], props43[key]);
        continue;
      }
      result[key] = props43[key] !== void 0 ? props43[key] : result[key];
    }
    for (let key in props43) {
      if (result[key] === void 0) {
        result[key] = props43[key];
      }
    }
  }
  return result;
}
function memo(getDeps, fn, opts) {
  let deps = [];
  let result;
  return (depArgs) => {
    var _a8;
    const newDeps = getDeps(depArgs);
    const depsChanged = newDeps.length !== deps.length || newDeps.some((dep, index) => !isEqual(deps[index], dep));
    if (!depsChanged) return result;
    deps = newDeps;
    result = fn(...newDeps);
    (_a8 = opts == null ? void 0 : opts.onChange) == null ? void 0 : _a8.call(opts, result);
    return result;
  };
}
function createGuards() {
  return {
    and: (...guards3) => {
      return function andGuard(params) {
        return guards3.every((str) => params.guard(str));
      };
    },
    or: (...guards3) => {
      return function orGuard(params) {
        return guards3.some((str) => params.guard(str));
      };
    },
    not: (guard) => {
      return function notGuard(params) {
        return !params.guard(guard);
      };
    }
  };
}
function createMachine(config) {
  return config;
}
function setup() {
  return {
    guards: createGuards(),
    createMachine: (config) => {
      return createMachine(config);
    },
    choose: (transitions) => {
      return function chooseFn({ choose: choose4 }) {
        var _a8;
        return (_a8 = choose4(transitions)) == null ? void 0 : _a8.actions;
      };
    }
  };
}
var MachineStatus = ((MachineStatus2) => {
  MachineStatus2["NotStarted"] = "Not Started";
  MachineStatus2["Started"] = "Started";
  MachineStatus2["Stopped"] = "Stopped";
  return MachineStatus2;
})(MachineStatus || {});
var INIT_STATE = "__init__";
function createScope(props43) {
  const getRootNode = () => {
    var _a8;
    return ((_a8 = props43.getRootNode) == null ? void 0 : _a8.call(props43)) ?? document;
  };
  const getDoc = () => getDocument(getRootNode());
  const getWin = () => getDoc().defaultView ?? window;
  const getActiveElementFn = () => getActiveElement(getRootNode());
  const isActiveElement = (elem) => elem === getActiveElementFn();
  const getById = (id) => getRootNode().getElementById(id);
  return {
    ...props43,
    getRootNode,
    getDoc,
    getWin,
    getActiveElement: getActiveElementFn,
    isActiveElement,
    getById
  };
}

// node_modules/@ark-ui/react/dist/components/factory.js
var import_react11 = __toESM(require_react());

// node_modules/@ark-ui/react/dist/utils/compose-refs.js
function composeRefs(...refs) {
  return (node) => {
    const cleanUps = [];
    for (const ref of refs) {
      if (typeof ref === "function") {
        const cb = ref(node);
        if (typeof cb === "function") {
          cleanUps.push(cb);
        }
      } else if (ref) {
        ref.current = node;
      }
    }
    if (cleanUps.length) {
      return () => {
        for (const cleanUp of cleanUps) {
          cleanUp();
        }
      };
    }
  };
}

// node_modules/@ark-ui/react/dist/components/factory.js
function getRef(element) {
  var _a8, _b7;
  let getter = (_a8 = Object.getOwnPropertyDescriptor(element.props, "ref")) == null ? void 0 : _a8.get;
  let mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
  if (mayWarn) {
    return element.ref;
  }
  getter = (_b7 = Object.getOwnPropertyDescriptor(element, "ref")) == null ? void 0 : _b7.get;
  mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
  if (mayWarn) {
    return element.props.ref;
  }
  return element.props.ref || element.ref;
}
var withAsChild = (Component) => {
  const Comp = (0, import_react11.memo)(
    (0, import_react11.forwardRef)((props43, ref) => {
      const { asChild, children, ...restProps } = props43;
      if (!asChild) {
        return (0, import_react11.createElement)(Component, { ...restProps, ref }, children);
      }
      const onlyChild = import_react11.Children.only(children);
      if (!(0, import_react11.isValidElement)(onlyChild)) {
        return null;
      }
      const childRef = getRef(onlyChild);
      return (0, import_react11.cloneElement)(onlyChild, {
        ...mergeProps2(restProps, onlyChild.props),
        ref: ref ? composeRefs(ref, childRef) : childRef
      });
    })
  );
  Comp.displayName = Component.displayName || Component.name;
  return Comp;
};
var jsxFactory = () => {
  const cache2 = /* @__PURE__ */ new Map();
  return new Proxy(withAsChild, {
    apply(_target, _thisArg, argArray) {
      return withAsChild(argArray[0]);
    },
    get(_, element) {
      const asElement = element;
      if (!cache2.has(asElement)) {
        cache2.set(asElement, withAsChild(asElement));
      }
      return cache2.get(asElement);
    }
  });
};
var ark = jsxFactory();

// node_modules/@ark-ui/react/dist/components/download-trigger/download-trigger.js
var DownloadTrigger = (0, import_react12.forwardRef)((props43, ref) => {
  const { fileName, data, mimeType, ...rest } = props43;
  const { getWindow: getWindow3 } = useEnvironmentContext();
  const download = (data2) => {
    downloadFile({ file: data2, name: fileName, type: mimeType, win: getWindow3() });
  };
  const onClick = (e) => {
    var _a8;
    (_a8 = props43.onClick) == null ? void 0 : _a8.call(props43, e);
    if (e.defaultPrevented) return;
    if (isFunction2(data)) {
      const maybePromise = data();
      if (maybePromise instanceof Promise) {
        maybePromise.then((data2) => download(data2));
      } else {
        download(maybePromise);
      }
    } else {
      download(data);
    }
  };
  return (0, import_jsx_runtime6.jsx)(ark.button, { ref, ...rest, type: "button", onClick });
});
DownloadTrigger.displayName = "DownloadTrigger";

// node_modules/@chakra-ui/react/dist/esm/components/download-trigger/index.js
var { withContext } = createRecipeContext({ key: "downloadTrigger" });
var DownloadTrigger2 = withContext(DownloadTrigger, { forwardAsChild: true });

// node_modules/@ark-ui/react/dist/components/format/format-byte.js
var import_jsx_runtime7 = __toESM(require_jsx_runtime(), 1);

// node_modules/@zag-js/i18n-utils/dist/index.mjs
function i18nCache(Ins) {
  const formatterCache = /* @__PURE__ */ new Map();
  return function create(locale, options) {
    const cacheKey = locale + (options ? Object.entries(options).sort((a2, b2) => a2[0] < b2[0] ? -1 : 1).join() : "");
    if (formatterCache.has(cacheKey)) {
      return formatterCache.get(cacheKey);
    }
    let formatter = new Ins(locale, options);
    formatterCache.set(cacheKey, formatter);
    return formatter;
  };
}
var collatorCache = i18nCache(Intl.Collator);
function createFilter(options) {
  const { locale, ...rest } = options || {};
  const collator = collatorCache(locale || "en-US", { usage: "search", ...rest });
  function normalize4(string) {
    string = string.normalize("NFC");
    if (collator.resolvedOptions().ignorePunctuation) {
      string = string.replace(new RegExp("\\p{P}", "gu"), "");
    }
    return string;
  }
  function startsWith(string, substring) {
    if (substring.length === 0) return true;
    string = normalize4(string);
    substring = normalize4(substring);
    return collator.compare(string.slice(0, substring.length), substring) === 0;
  }
  function endsWith2(string, substring) {
    if (substring.length === 0) return true;
    string = normalize4(string);
    substring = normalize4(substring);
    return collator.compare(string.slice(-substring.length), substring) === 0;
  }
  function contains2(string, substring) {
    if (substring.length === 0) return true;
    string = normalize4(string);
    substring = normalize4(substring);
    let scan = 0;
    let sliceLen = substring.length;
    for (; scan + sliceLen <= string.length; scan++) {
      let slice = string.slice(scan, scan + sliceLen);
      if (collator.compare(substring, slice) === 0) {
        return true;
      }
    }
    return false;
  }
  return {
    startsWith,
    endsWith: endsWith2,
    contains: contains2
  };
}
var getNumberFormatter = i18nCache(Intl.NumberFormat);
function formatNumber(v, locale, options = {}) {
  const formatter = getNumberFormatter(locale, options);
  return formatter.format(v);
}
var bitPrefixes = ["", "kilo", "mega", "giga", "tera"];
var bytePrefixes = ["", "kilo", "mega", "giga", "tera", "peta"];
var formatBytes = (bytes, locale = "en-US", options = {}) => {
  if (isNaN(bytes)) return "";
  if (bytes === 0) return "0 B";
  const { unit = "byte", unitDisplay = "short" } = options;
  const prefix = unit === "bit" ? bitPrefixes : bytePrefixes;
  const index = Math.max(0, Math.min(Math.floor(Math.log10(bytes) / 3), prefix.length - 1));
  const _unit = prefix[index] + unit;
  const _unitDisplay = unitDisplay || "short";
  const v = parseFloat((bytes / Math.pow(1e3, index)).toPrecision(3));
  return formatNumber(v, locale, {
    style: "unit",
    unit: _unit,
    unitDisplay: _unitDisplay
  });
};
var getListFormatter = i18nCache(Intl.ListFormat);
var getRelativeTimeFormatter = i18nCache(Intl.RelativeTimeFormat);
function formatRelativeTime(value, locale, options = {}) {
  const rtf = getRelativeTimeFormatter(locale, options);
  const now = /* @__PURE__ */ new Date();
  const diff3 = getDistance(now, value);
  if (diff3.years > 0) return rtf.format(diff3.years * diff3.sign, "year");
  if (diff3.months > 0) return rtf.format(diff3.months * diff3.sign, "month");
  if (diff3.weeks > 0) return rtf.format(diff3.weeks * diff3.sign, "week");
  if (diff3.days > 0) return rtf.format(diff3.days * diff3.sign, "day");
  if (diff3.hours > 0) return rtf.format(diff3.hours * diff3.sign, "hour");
  if (diff3.minutes > 0) return rtf.format(diff3.minutes * diff3.sign, "minute");
  return rtf.format(diff3.seconds * diff3.sign, "second");
}
var SECOND_TO_MS = 1e3;
var MINUTE_TO_MS = 1e3 * 60;
var HOUR_TO_MS = 1e3 * 60 * 60;
var DAY_TO_MS = 1e3 * 60 * 60 * 24;
var WEEK_TO_MS = 1e3 * 60 * 60 * 24 * 7;
var MONTH_TO_MS = 1e3 * 60 * 60 * 24 * 30;
var YEAR_TO_MS = 1e3 * 60 * 60 * 24 * 365;
function getDistance(startDate, endDate) {
  const endTime = endDate.getTime();
  const startTime = startDate.getTime();
  const distance = Math.abs(endTime - startTime);
  return {
    sign: Math.sign(endTime - startTime),
    days: Math.floor(distance / DAY_TO_MS),
    hours: Math.floor(distance % DAY_TO_MS / HOUR_TO_MS),
    minutes: Math.floor(distance % HOUR_TO_MS / MINUTE_TO_MS),
    seconds: Math.floor(distance % MINUTE_TO_MS / SECOND_TO_MS),
    weeks: Math.floor(distance / WEEK_TO_MS),
    months: Math.floor(distance / MONTH_TO_MS),
    years: Math.floor(distance / YEAR_TO_MS)
  };
}
var RTL_SCRIPTS = /* @__PURE__ */ new Set([
  "Avst",
  "Arab",
  "Armi",
  "Syrc",
  "Samr",
  "Mand",
  "Thaa",
  "Mend",
  "Nkoo",
  "Adlm",
  "Rohg",
  "Hebr"
]);
var RTL_LANGS = /* @__PURE__ */ new Set([
  "ae",
  "ar",
  "arc",
  "bcc",
  "bqi",
  "ckb",
  "dv",
  "fa",
  "glk",
  "he",
  "ku",
  "mzn",
  "nqo",
  "pnb",
  "ps",
  "sd",
  "ug",
  "ur",
  "yi"
]);
function isRTL(locale) {
  if (Intl.Locale) {
    const script = new Intl.Locale(locale).maximize().script ?? "";
    return RTL_SCRIPTS.has(script);
  }
  const lang = locale.split("-")[0];
  return RTL_LANGS.has(lang);
}

// node_modules/@ark-ui/react/dist/components/format/format-byte.js
var import_react13 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/providers/locale/use-locale-context.js
var [LocaleContextProvider, useLocaleContext] = createContext3({
  name: "LocaleContext",
  hookName: "useLocaleContext",
  providerName: "<LocaleProvider />",
  strict: false,
  defaultValue: { dir: "ltr", locale: "en-US" }
});

// node_modules/@ark-ui/react/dist/components/format/format-byte.js
var FormatByte = (props43) => {
  const { locale } = useLocaleContext();
  const text = (0, import_react13.useMemo)(() => {
    const { value, ...intlOptions } = props43;
    return formatBytes(value, locale, intlOptions);
  }, [props43, locale]);
  return (0, import_jsx_runtime7.jsx)(import_jsx_runtime7.Fragment, { children: text });
};
FormatByte.displayName = "FormatByte";

// node_modules/@ark-ui/react/dist/components/format/format-number.js
var import_jsx_runtime8 = __toESM(require_jsx_runtime(), 1);
var import_react14 = __toESM(require_react(), 1);
var FormatNumber = (props43) => {
  const { locale } = useLocaleContext();
  const text = (0, import_react14.useMemo)(() => {
    const { value, ...intlOptions } = props43;
    return formatNumber(value, locale, intlOptions);
  }, [props43, locale]);
  return (0, import_jsx_runtime8.jsx)(import_jsx_runtime8.Fragment, { children: text });
};
FormatNumber.displayName = "FormatNumber";

// node_modules/@ark-ui/react/dist/components/format/format-relative-time.js
var import_jsx_runtime9 = __toESM(require_jsx_runtime(), 1);
var import_react15 = __toESM(require_react(), 1);
var FormatRelativeTime = (props43) => {
  const { locale } = useLocaleContext();
  const text = (0, import_react15.useMemo)(() => {
    const { value, ...intlOptions } = props43;
    return formatRelativeTime(value, locale, intlOptions);
  }, [props43, locale]);
  return (0, import_jsx_runtime9.jsx)(import_jsx_runtime9.Fragment, { children: text });
};
FormatRelativeTime.displayName = "FormatRelativeTime";

// node_modules/@ark-ui/react/dist/components/format/format.js
var format_exports = {};
__export(format_exports, {
  Byte: () => FormatByte,
  Number: () => FormatNumber,
  RelativeTime: () => FormatRelativeTime
});

// node_modules/@chakra-ui/react/dist/esm/components/format/index.js
var FormatNumber2 = format_exports.Number;
var FormatByte2 = format_exports.Byte;

// node_modules/@ark-ui/react/dist/components/presence/presence.js
var import_jsx_runtime11 = __toESM(require_jsx_runtime(), 1);
var import_react20 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/utils/create-split-props.js
var createSplitProps2 = () => (props43, keys) => keys.reduce(
  (previousValue, currentValue) => {
    const [target, source] = previousValue;
    const key = currentValue;
    if (source[key] !== void 0) {
      target[key] = source[key];
    }
    delete source[key];
    return [target, source];
  },
  [{}, { ...props43 }]
);

// node_modules/@ark-ui/react/dist/components/presence/split-presence-props.js
var splitPresenceProps = (props43) => createSplitProps2()(props43, [
  "immediate",
  "lazyMount",
  "onExitComplete",
  "present",
  "skipAnimationOnMount",
  "unmountOnExit"
]);

// node_modules/@zag-js/types/dist/index.mjs
function createNormalizer(fn) {
  return new Proxy({}, {
    get(_target, key) {
      if (key === "style")
        return (props43) => {
          return fn({ style: props43 }).style;
        };
      return fn;
    }
  });
}
var createProps = () => (props43) => Array.from(new Set(props43));

// node_modules/@zag-js/presence/dist/index.mjs
function connect(service, _normalize) {
  const { state: state2, send, context } = service;
  const present = state2.matches("mounted", "unmountSuspended");
  return {
    skip: !context.get("initial"),
    present,
    setNode(node) {
      if (!node) return;
      send({ type: "NODE.SET", node });
    },
    unmount() {
      send({ type: "UNMOUNT" });
    }
  };
}
var machine = createMachine({
  props({ props: props210 }) {
    return { ...props210, present: !!props210.present };
  },
  initialState({ prop }) {
    return prop("present") ? "mounted" : "unmounted";
  },
  refs() {
    return {
      node: null,
      styles: null
    };
  },
  context({ bindable }) {
    return {
      unmountAnimationName: bindable(() => ({ defaultValue: null })),
      prevAnimationName: bindable(() => ({ defaultValue: null })),
      present: bindable(() => ({ defaultValue: false })),
      initial: bindable(() => ({
        sync: true,
        defaultValue: false
      }))
    };
  },
  exit: ["clearInitial", "cleanupNode"],
  watch({ track, action, prop }) {
    track([() => prop("present")], () => {
      action(["setInitial", "syncPresence"]);
    });
  },
  on: {
    "NODE.SET": {
      actions: ["setNode", "setStyles"]
    }
  },
  states: {
    mounted: {
      on: {
        UNMOUNT: {
          target: "unmounted",
          actions: ["clearPrevAnimationName", "invokeOnExitComplete"]
        },
        "UNMOUNT.SUSPEND": {
          target: "unmountSuspended"
        }
      }
    },
    unmountSuspended: {
      effects: ["trackAnimationEvents"],
      on: {
        MOUNT: {
          target: "mounted",
          actions: ["setPrevAnimationName"]
        },
        UNMOUNT: {
          target: "unmounted",
          actions: ["clearPrevAnimationName", "invokeOnExitComplete"]
        }
      }
    },
    unmounted: {
      on: {
        MOUNT: {
          target: "mounted",
          actions: ["setPrevAnimationName"]
        }
      }
    }
  },
  implementations: {
    actions: {
      setInitial: ({ context }) => {
        if (context.get("initial")) return;
        queueMicrotask(() => {
          context.set("initial", true);
        });
      },
      clearInitial: ({ context }) => {
        context.set("initial", false);
      },
      cleanupNode: ({ refs }) => {
        refs.set("node", null);
        refs.set("styles", null);
      },
      invokeOnExitComplete: ({ prop }) => {
        var _a8;
        (_a8 = prop("onExitComplete")) == null ? void 0 : _a8();
      },
      setNode: ({ refs, event }) => {
        refs.set("node", event.node);
      },
      setStyles: ({ refs, event }) => {
        refs.set("styles", getComputedStyle2(event.node));
      },
      syncPresence: ({ context, refs, send, prop }) => {
        const presentProp = prop("present");
        if (presentProp) {
          return send({ type: "MOUNT", src: "presence.changed" });
        }
        const node = refs.get("node");
        if (!presentProp && (node == null ? void 0 : node.ownerDocument.visibilityState) === "hidden") {
          return send({ type: "UNMOUNT", src: "visibilitychange" });
        }
        raf(() => {
          var _a8, _b7;
          const animationName = getAnimationName(refs.get("styles"));
          context.set("unmountAnimationName", animationName);
          if (animationName === "none" || animationName === context.get("prevAnimationName") || ((_a8 = refs.get("styles")) == null ? void 0 : _a8.display) === "none" || ((_b7 = refs.get("styles")) == null ? void 0 : _b7.animationDuration) === "0s") {
            send({ type: "UNMOUNT", src: "presence.changed" });
          } else {
            send({ type: "UNMOUNT.SUSPEND" });
          }
        });
      },
      setPrevAnimationName: ({ context, refs }) => {
        raf(() => {
          context.set("prevAnimationName", getAnimationName(refs.get("styles")));
        });
      },
      clearPrevAnimationName: ({ context }) => {
        context.set("prevAnimationName", null);
      }
    },
    effects: {
      trackAnimationEvents: ({ context, refs, send }) => {
        const node = refs.get("node");
        if (!node) return;
        const onStart = (event) => {
          var _a8, _b7;
          const target = ((_b7 = (_a8 = event.composedPath) == null ? void 0 : _a8.call(event)) == null ? void 0 : _b7[0]) ?? event.target;
          if (target === node) {
            context.set("prevAnimationName", getAnimationName(refs.get("styles")));
          }
        };
        const onEnd = (event) => {
          const animationName = getAnimationName(refs.get("styles"));
          const target = getEventTarget(event);
          if (target === node && animationName === context.get("unmountAnimationName")) {
            send({ type: "UNMOUNT", src: "animationend" });
          }
        };
        node.addEventListener("animationstart", onStart);
        node.addEventListener("animationcancel", onEnd);
        node.addEventListener("animationend", onEnd);
        const cleanupStyles = setStyle(node, { animationFillMode: "forwards" });
        return () => {
          node.removeEventListener("animationstart", onStart);
          node.removeEventListener("animationcancel", onEnd);
          node.removeEventListener("animationend", onEnd);
          nextTick(() => cleanupStyles());
        };
      }
    }
  }
});
function getAnimationName(styles) {
  return (styles == null ? void 0 : styles.animationName) || "none";
}
var props = createProps()(["onExitComplete", "present", "immediate"]);

// node_modules/@zag-js/react/dist/index.mjs
var React6 = __toESM(require_react(), 1);
var import_react16 = __toESM(require_react(), 1);
var import_react_dom = __toESM(require_react_dom(), 1);
var import_jsx_runtime10 = __toESM(require_jsx_runtime(), 1);
var useSafeLayoutEffect = typeof globalThis.document !== "undefined" ? import_react16.useLayoutEffect : import_react16.useEffect;
function useBindable(props43) {
  const initial = props43().value ?? props43().defaultValue;
  const eq = props43().isEqual ?? Object.is;
  const [initialValue] = (0, import_react16.useState)(initial);
  const [value, setValue] = (0, import_react16.useState)(initialValue);
  const controlled = props43().value !== void 0;
  const valueRef = (0, import_react16.useRef)(value);
  valueRef.current = controlled ? props43().value : value;
  const prevValue = (0, import_react16.useRef)(valueRef.current);
  useSafeLayoutEffect(() => {
    prevValue.current = valueRef.current;
  }, [value, props43().value]);
  const setFn = (value2) => {
    var _a8, _b7;
    const prev2 = prevValue.current;
    const next2 = isFunction2(value2) ? value2(prev2) : value2;
    if (props43().debug) {
      console.log(`[bindable > ${props43().debug}] setValue`, { next: next2, prev: prev2 });
    }
    if (!controlled) setValue(next2);
    if (!eq(next2, prev2)) {
      (_b7 = (_a8 = props43()).onChange) == null ? void 0 : _b7.call(_a8, next2, prev2);
    }
  };
  function get() {
    return controlled ? props43().value : value;
  }
  return {
    initial: initialValue,
    ref: valueRef,
    get,
    set(value2) {
      const exec = props43().sync ? import_react_dom.flushSync : identity;
      exec(() => setFn(value2));
    },
    invoke(nextValue, prevValue2) {
      var _a8, _b7;
      (_b7 = (_a8 = props43()).onChange) == null ? void 0 : _b7.call(_a8, nextValue, prevValue2);
    },
    hash(value2) {
      var _a8, _b7;
      return ((_b7 = (_a8 = props43()).hash) == null ? void 0 : _b7.call(_a8, value2)) ?? String(value2);
    }
  };
}
useBindable.cleanup = (fn) => {
  (0, import_react16.useEffect)(() => fn, []);
};
useBindable.ref = (defaultValue) => {
  const value = (0, import_react16.useRef)(defaultValue);
  return {
    get: () => value.current,
    set: (next2) => {
      value.current = next2;
    }
  };
};
function useRefs(refs) {
  const ref = (0, import_react16.useRef)(refs);
  return {
    get(key) {
      return ref.current[key];
    },
    set(key, value) {
      ref.current[key] = value;
    }
  };
}
var useTrack = (deps, effect) => {
  const render = (0, import_react16.useRef)(false);
  const called = (0, import_react16.useRef)(false);
  (0, import_react16.useEffect)(() => {
    const mounted = render.current;
    const run = mounted && called.current;
    if (run) return effect();
    called.current = true;
  }, [...(deps ?? []).map((d) => typeof d === "function" ? d() : d)]);
  (0, import_react16.useEffect)(() => {
    render.current = true;
    return () => {
      render.current = false;
    };
  }, []);
};
function useMachine(machine44, userProps = {}) {
  var _a8, _b7, _c6, _d6;
  const scope = (0, import_react16.useMemo)(() => {
    const { id, ids, getRootNode } = userProps;
    return createScope({ id, ids, getRootNode });
  }, [userProps]);
  const debug = (...args) => {
    if (machine44.debug) console.log(...args);
  };
  const props43 = ((_a8 = machine44.props) == null ? void 0 : _a8.call(machine44, { props: compact2(userProps), scope })) ?? userProps;
  const prop = useProp(props43);
  const context = (_b7 = machine44.context) == null ? void 0 : _b7.call(machine44, {
    prop,
    bindable: useBindable,
    scope,
    flush,
    getContext() {
      return ctx;
    },
    getComputed() {
      return computed;
    },
    getRefs() {
      return refs;
    }
  });
  const contextRef = useLiveRef(context);
  const ctx = {
    get(key) {
      var _a9;
      return (_a9 = contextRef.current) == null ? void 0 : _a9[key].ref.current;
    },
    set(key, value) {
      var _a9;
      (_a9 = contextRef.current) == null ? void 0 : _a9[key].set(value);
    },
    initial(key) {
      var _a9;
      return (_a9 = contextRef.current) == null ? void 0 : _a9[key].initial;
    },
    hash(key) {
      var _a9, _b8;
      const current = (_a9 = contextRef.current) == null ? void 0 : _a9[key].get();
      return (_b8 = contextRef.current) == null ? void 0 : _b8[key].hash(current);
    }
  };
  const effects = (0, import_react16.useRef)(/* @__PURE__ */ new Map());
  const transitionRef = (0, import_react16.useRef)(null);
  const previousEventRef = (0, import_react16.useRef)(null);
  const eventRef = (0, import_react16.useRef)({ type: "" });
  const getEvent = () => ({
    ...eventRef.current,
    current() {
      return eventRef.current;
    },
    previous() {
      return previousEventRef.current;
    }
  });
  const getState = () => ({
    ...state2,
    matches(...values) {
      return values.includes(state2.ref.current);
    },
    hasTag(tag) {
      var _a9, _b8;
      return !!((_b8 = (_a9 = machine44.states[state2.ref.current]) == null ? void 0 : _a9.tags) == null ? void 0 : _b8.includes(tag));
    }
  });
  const refs = useRefs(((_c6 = machine44.refs) == null ? void 0 : _c6.call(machine44, { prop, context: ctx })) ?? {});
  const getParams = () => ({
    state: getState(),
    context: ctx,
    event: getEvent(),
    prop,
    send,
    action,
    guard,
    track: useTrack,
    refs,
    computed,
    flush,
    scope,
    choose: choose4
  });
  const action = (keys) => {
    const strs = isFunction2(keys) ? keys(getParams()) : keys;
    if (!strs) return;
    const fns = strs.map((s) => {
      var _a9, _b8;
      const fn = (_b8 = (_a9 = machine44.implementations) == null ? void 0 : _a9.actions) == null ? void 0 : _b8[s];
      if (!fn) warn(`[zag-js] No implementation found for action "${JSON.stringify(s)}"`);
      return fn;
    });
    for (const fn of fns) {
      fn == null ? void 0 : fn(getParams());
    }
  };
  const guard = (str) => {
    var _a9, _b8;
    if (isFunction2(str)) return str(getParams());
    return (_b8 = (_a9 = machine44.implementations) == null ? void 0 : _a9.guards) == null ? void 0 : _b8[str](getParams());
  };
  const effect = (keys) => {
    const strs = isFunction2(keys) ? keys(getParams()) : keys;
    if (!strs) return;
    const fns = strs.map((s) => {
      var _a9, _b8;
      const fn = (_b8 = (_a9 = machine44.implementations) == null ? void 0 : _a9.effects) == null ? void 0 : _b8[s];
      if (!fn) warn(`[zag-js] No implementation found for effect "${JSON.stringify(s)}"`);
      return fn;
    });
    const cleanups = [];
    for (const fn of fns) {
      const cleanup = fn == null ? void 0 : fn(getParams());
      if (cleanup) cleanups.push(cleanup);
    }
    return () => cleanups.forEach((fn) => fn == null ? void 0 : fn());
  };
  const choose4 = (transitions) => {
    return toArray2(transitions).find((t) => {
      let result = !t.guard;
      if (isString2(t.guard)) result = !!guard(t.guard);
      else if (isFunction2(t.guard)) result = t.guard(getParams());
      return result;
    });
  };
  const computed = (key) => {
    ensure(machine44.computed, () => `[zag-js] No computed object found on machine`);
    const fn = machine44.computed[key];
    return fn({
      context: ctx,
      event: getEvent(),
      prop,
      refs,
      scope,
      computed
    });
  };
  const state2 = useBindable(() => ({
    defaultValue: machine44.initialState({ prop }),
    onChange(nextState, prevState) {
      var _a9, _b8, _c7, _d7;
      if (prevState) {
        const exitEffects = effects.current.get(prevState);
        exitEffects == null ? void 0 : exitEffects();
        effects.current.delete(prevState);
      }
      if (prevState) {
        action((_a9 = machine44.states[prevState]) == null ? void 0 : _a9.exit);
      }
      action((_b8 = transitionRef.current) == null ? void 0 : _b8.actions);
      const cleanup = effect((_c7 = machine44.states[nextState]) == null ? void 0 : _c7.effects);
      if (cleanup) effects.current.set(nextState, cleanup);
      if (prevState === INIT_STATE) {
        action(machine44.entry);
        const cleanup2 = effect(machine44.effects);
        if (cleanup2) effects.current.set(INIT_STATE, cleanup2);
      }
      action((_d7 = machine44.states[nextState]) == null ? void 0 : _d7.entry);
    }
  }));
  const hydratedStateRef = (0, import_react16.useRef)(void 0);
  const statusRef = (0, import_react16.useRef)(MachineStatus.NotStarted);
  useSafeLayoutEffect(() => {
    queueMicrotask(() => {
      const started = statusRef.current === MachineStatus.Started;
      statusRef.current = MachineStatus.Started;
      debug(started ? "rehydrating..." : "initializing...");
      const initialState = hydratedStateRef.current ?? state2.initial;
      state2.invoke(initialState, started ? state2.get() : INIT_STATE);
    });
    const fns = effects.current;
    const currentState = state2.ref.current;
    return () => {
      debug("unmounting...");
      hydratedStateRef.current = currentState;
      statusRef.current = MachineStatus.Stopped;
      fns.forEach((fn) => fn == null ? void 0 : fn());
      effects.current = /* @__PURE__ */ new Map();
      transitionRef.current = null;
      queueMicrotask(() => {
        action(machine44.exit);
      });
    };
  }, []);
  const getCurrentState = () => {
    if ("ref" in state2) return state2.ref.current;
    return state2.get();
  };
  const send = (event) => {
    queueMicrotask(() => {
      var _a9, _b8;
      if (statusRef.current !== MachineStatus.Started) return;
      previousEventRef.current = eventRef.current;
      eventRef.current = event;
      debug("send", event);
      let currentState = getCurrentState();
      const transitions = (
        // @ts-ignore
        ((_a9 = machine44.states[currentState].on) == null ? void 0 : _a9[event.type]) ?? // @ts-ignore
        ((_b8 = machine44.on) == null ? void 0 : _b8[event.type])
      );
      const transition = choose4(transitions);
      if (!transition) return;
      transitionRef.current = transition;
      const target = transition.target ?? currentState;
      debug("transition", transition);
      const changed = target !== currentState;
      if (changed) {
        (0, import_react_dom.flushSync)(() => state2.set(target));
      } else if (transition.reenter && !changed) {
        state2.invoke(currentState, currentState);
      } else {
        action(transition.actions ?? []);
      }
    });
  };
  (_d6 = machine44.watch) == null ? void 0 : _d6.call(machine44, getParams());
  return {
    state: getState(),
    send,
    context: ctx,
    prop,
    scope,
    refs,
    computed,
    event: getEvent(),
    getStatus: () => statusRef.current
  };
}
function useLiveRef(value) {
  const ref = (0, import_react16.useRef)(value);
  ref.current = value;
  return ref;
}
function useProp(value) {
  const ref = useLiveRef(value);
  return function get(key) {
    return ref.current[key];
  };
}
function flush(fn) {
  queueMicrotask(() => {
    (0, import_react_dom.flushSync)(() => fn());
  });
}
var normalizeProps = createNormalizer((v) => v);

// node_modules/@ark-ui/react/dist/components/presence/use-presence.js
var import_react19 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/utils/use-event.js
var import_react17 = __toESM(require_react(), 1);
function useEvent(callback, opts = {}) {
  const { sync = false } = opts;
  const callbackRef = useLatestRef(callback);
  return (0, import_react17.useCallback)(
    // biome-ignore lint/suspicious/noExplicitAny: <explanation>
    (...args) => {
      var _a8;
      if (sync) return queueMicrotask(() => {
        var _a9;
        return (_a9 = callbackRef.current) == null ? void 0 : _a9.call(callbackRef, ...args);
      });
      return (_a8 = callbackRef.current) == null ? void 0 : _a8.call(callbackRef, ...args);
    },
    [sync, callbackRef]
  );
}
function useLatestRef(value) {
  const ref = (0, import_react17.useRef)(value);
  ref.current = value;
  return ref;
}

// node_modules/@ark-ui/react/dist/components/presence/use-presence.js
var usePresence = (props43 = {}) => {
  const { lazyMount, unmountOnExit, present, skipAnimationOnMount = false, ...rest } = props43;
  const wasEverPresent = (0, import_react19.useRef)(false);
  const machineProps = {
    ...rest,
    present,
    onExitComplete: useEvent(props43.onExitComplete)
  };
  const service = useMachine(machine, machineProps);
  const api = connect(service, normalizeProps);
  if (api.present) {
    wasEverPresent.current = true;
  }
  const unmounted = !api.present && !wasEverPresent.current && lazyMount || unmountOnExit && !api.present && wasEverPresent.current;
  const getPresenceProps = () => ({
    "data-state": api.skip && skipAnimationOnMount ? void 0 : present ? "open" : "closed",
    hidden: !api.present
  });
  return {
    ref: api.setNode,
    getPresenceProps,
    present: api.present,
    unmounted
  };
};

// node_modules/@ark-ui/react/dist/components/presence/presence.js
var Presence = (0, import_react20.forwardRef)((props43, ref) => {
  const [presenceProps, localProps] = splitPresenceProps(props43);
  const presence = usePresence(presenceProps);
  if (presence.unmounted) {
    return null;
  }
  return (0, import_jsx_runtime11.jsx)(
    ark.div,
    {
      ...localProps,
      ...presence.getPresenceProps(),
      "data-scope": "presence",
      "data-part": "root",
      ref: composeRefs(presence.ref, ref)
    }
  );
});
Presence.displayName = "Presence";

// node_modules/@ark-ui/react/dist/components/presence/use-presence-context.js
var [PresenceProvider, usePresenceContext] = createContext3({
  name: "PresenceContext",
  hookName: "usePresenceContext",
  providerName: "<PresenceProvider />"
});

// node_modules/@chakra-ui/react/dist/esm/components/presence/index.js
var Presence2 = chakra(Presence);

// node_modules/@chakra-ui/react/dist/esm/components/theme.js
var import_jsx_runtime12 = __toESM(require_jsx_runtime(), 1);
var import_react21 = __toESM(require_react(), 1);
var Theme = (0, import_react21.forwardRef)(
  function Theme2(props43, ref) {
    const {
      appearance,
      style,
      className,
      hasBackground = true,
      ...rest
    } = props43;
    return (0, import_jsx_runtime12.jsx)(
      chakra.div,
      {
        color: "fg",
        bg: hasBackground ? "bg" : void 0,
        colorPalette: "gray",
        ...rest,
        className: cx("chakra-theme", appearance, className),
        style: { ...style, colorScheme: appearance },
        ref
      }
    );
  }
);

// node_modules/@chakra-ui/react/dist/esm/hooks/use-media-query.js
var import_react23 = __toESM(require_react(), 1);

// node_modules/@chakra-ui/react/dist/esm/hooks/use-callback-ref.js
var import_react22 = __toESM(require_react(), 1);
function useCallbackRef(callback, deps = []) {
  const callbackRef = (0, import_react22.useRef)(() => {
    throw new Error("Cannot call an event handler while rendering.");
  });
  (0, import_react22.useInsertionEffect)(() => {
    callbackRef.current = callback;
  });
  return (0, import_react22.useCallback)((...args) => {
    var _a8;
    return (_a8 = callbackRef.current) == null ? void 0 : _a8.call(callbackRef, ...args);
  }, deps);
}

// node_modules/@chakra-ui/react/dist/esm/hooks/use-media-query.js
function listen(query2, callback) {
  try {
    query2.addEventListener("change", callback);
    return () => query2.removeEventListener("change", callback);
  } catch (e) {
    query2.addListener(callback);
    return () => query2.removeListener(callback);
  }
}
function useMediaQuery(query2, options = {}) {
  const { fallback: _fallback = [], ssr = true, getWindow: getWindow3 } = options;
  const getWin = useCallbackRef(getWindow3);
  const queries = Array.isArray(query2) ? query2 : [query2];
  const fallback4 = _fallback == null ? void 0 : _fallback.filter((v) => v != null);
  const [value, setValue] = (0, import_react23.useState)(() => {
    return queries.map((query22, index) => {
      if (!ssr) {
        const { media, matches } = ((getWindow3 == null ? void 0 : getWindow3()) ?? window).matchMedia(query22);
        return { media, matches };
      }
      return { media: query22, matches: !!fallback4[index] };
    });
  });
  (0, import_react23.useEffect)(() => {
    const win = getWin() ?? window;
    setValue((prev2) => {
      const current = queries.map((query22) => {
        const { media, matches } = win.matchMedia(query22);
        return { media, matches };
      });
      return prev2.every(
        (v, i) => v.matches === current[i].matches && v.media === current[i].media
      ) ? prev2 : current;
    });
    const mql = queries.map((query22) => win.matchMedia(query22));
    const handler = (evt) => {
      setValue((prev2) => {
        return prev2.slice().map((item) => {
          if (item.media === evt.media) return { ...item, matches: evt.matches };
          return item;
        });
      });
    };
    const cleanups = mql.map((v) => listen(v, handler));
    return () => cleanups.forEach((fn) => fn());
  }, [getWin]);
  return value.map((item) => item.matches);
}

// node_modules/@chakra-ui/react/dist/esm/hooks/use-breakpoint.js
function useBreakpoint(options = {}) {
  var _a8;
  options.fallback || (options.fallback = "base");
  const sys = useChakraContext();
  let fallbackPassed = false;
  const allBreakpoints = sys.breakpoints.values;
  const breakpoints2 = allBreakpoints.map(({ min: min4, name: breakpoint }) => {
    const item = {
      breakpoint,
      query: `(min-width: ${min4})`,
      fallback: !fallbackPassed
    };
    if (breakpoint === options.fallback) {
      fallbackPassed = true;
    }
    return item;
  }).filter(({ breakpoint }) => {
    var _a9;
    return !!((_a9 = options.breakpoints) == null ? void 0 : _a9.includes(breakpoint));
  });
  const fallback4 = breakpoints2.map(({ fallback: fallback22 }) => fallback22);
  const values = useMediaQuery(
    breakpoints2.map((bp) => bp.query),
    { fallback: fallback4, ssr: options.ssr }
  );
  const index = values.lastIndexOf(true);
  return ((_a8 = breakpoints2[index]) == null ? void 0 : _a8.breakpoint) ?? options.fallback;
}
function useBreakpointValue(value, opts) {
  const sys = useChakraContext();
  const normalized = sys.normalizeValue(value);
  const breakpoint = useBreakpoint({
    breakpoints: Object.keys(normalized),
    ...opts
  });
  return normalized[breakpoint];
}

// node_modules/@chakra-ui/react/dist/esm/hooks/use-const.js
var import_react24 = __toESM(require_react(), 1);
function useConst(init) {
  const ref = (0, import_react24.useRef)(null);
  if (ref.current === null) {
    ref.current = typeof init === "function" ? init() : init;
  }
  return ref.current;
}

// node_modules/@chakra-ui/react/dist/esm/hooks/use-controllable-state.js
var import_react25 = __toESM(require_react(), 1);
function useControllableProp(prop, state2) {
  const controlled = typeof prop !== "undefined";
  const value = controlled ? prop : state2;
  return (0, import_react25.useMemo)(() => [controlled, value], [controlled, value]);
}
function useControllableState(props43) {
  const {
    value: valueProp,
    defaultValue,
    onChange,
    shouldUpdate = (prev2, next2) => prev2 !== next2
  } = props43;
  const onChangeProp = useCallbackRef(onChange);
  const shouldUpdateProp = useCallbackRef(shouldUpdate);
  const [uncontrolledState, setUncontrolledState] = (0, import_react25.useState)(defaultValue);
  const controlled = valueProp !== void 0;
  const value = controlled ? valueProp : uncontrolledState;
  const setValue = useCallbackRef(
    (next2) => {
      const setter = next2;
      const nextValue = typeof next2 === "function" ? setter(value) : next2;
      if (!shouldUpdateProp(value, nextValue)) {
        return;
      }
      if (!controlled) {
        setUncontrolledState(nextValue);
      }
      onChangeProp(nextValue);
    },
    [controlled, onChangeProp, value, shouldUpdateProp]
  );
  return [value, setValue];
}

// node_modules/@chakra-ui/react/dist/esm/hooks/use-disclosure.js
var import_react26 = __toESM(require_react(), 1);
function useDisclosure(props43 = {}) {
  const handleOpen = useCallbackRef(props43.onOpen);
  const handleClose = useCallbackRef(props43.onClose);
  const [openState, setOpen] = (0, import_react26.useState)(props43.defaultOpen || false);
  const open = props43.open !== void 0 ? props43.open : openState;
  const controlled = props43.open !== void 0;
  const onClose = (0, import_react26.useCallback)(() => {
    if (!controlled) setOpen(false);
    handleClose == null ? void 0 : handleClose();
  }, [controlled, handleClose]);
  const onOpen = (0, import_react26.useCallback)(() => {
    if (!controlled) setOpen(true);
    handleOpen == null ? void 0 : handleOpen();
  }, [controlled, handleOpen]);
  const onToggle = (0, import_react26.useCallback)(() => {
    if (open) {
      onClose();
    } else {
      onOpen();
    }
  }, [open, onOpen, onClose]);
  return {
    open,
    onOpen,
    onClose,
    onToggle,
    setOpen
  };
}

// node_modules/@ark-ui/react/dist/components/accordion/use-accordion-context.js
var [AccordionProvider, useAccordionContext] = createContext3({
  name: "AccordionContext",
  hookName: "useAccordionContext",
  providerName: "<AccordionProvider />"
});

// node_modules/@ark-ui/react/dist/components/accordion/accordion-context.js
var AccordionContext = (props43) => props43.children(useAccordionContext());

// node_modules/@ark-ui/react/dist/components/accordion/accordion-item.js
var import_jsx_runtime14 = __toESM(require_jsx_runtime(), 1);
var import_react32 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/accordion/use-accordion-item-context.js
var [AccordionItemProvider, useAccordionItemContext] = createContext3({
  name: "AccordionItemContext",
  hookName: "useAccordionItemContext",
  providerName: "<AccordionItemProvider />"
});

// node_modules/@ark-ui/react/dist/components/collapsible/collapsible-root.js
var import_jsx_runtime13 = __toESM(require_jsx_runtime(), 1);
var import_react30 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/collapsible/split-collapsible-props.js
var splitCollapsibleProps = (props43) => createSplitProps2()(props43, [
  "defaultOpen",
  "disabled",
  "id",
  "ids",
  "lazyMount",
  "onExitComplete",
  "onOpenChange",
  "open",
  "unmountOnExit"
]);

// node_modules/@zag-js/anatomy/dist/index.mjs
var createAnatomy = (name, parts46 = []) => ({
  parts: (...values) => {
    if (isEmpty(parts46)) {
      return createAnatomy(name, values);
    }
    throw new Error("createAnatomy().parts(...) should only be called once. Did you mean to use .extendWith(...) ?");
  },
  extendWith: (...values) => createAnatomy(name, [...parts46, ...values]),
  rename: (newName) => createAnatomy(newName, parts46),
  keys: () => parts46,
  build: () => [...new Set(parts46)].reduce(
    (prev2, part) => Object.assign(prev2, {
      [part]: {
        selector: [
          `&[data-scope="${toKebabCase(name)}"][data-part="${toKebabCase(part)}"]`,
          `& [data-scope="${toKebabCase(name)}"][data-part="${toKebabCase(part)}"]`
        ].join(", "),
        attrs: { "data-scope": toKebabCase(name), "data-part": toKebabCase(part) }
      }
    }),
    {}
  )
});
var toKebabCase = (value) => value.replace(/([A-Z])([A-Z])/g, "$1-$2").replace(/([a-z])([A-Z])/g, "$1-$2").replace(/[\s_]+/g, "-").toLowerCase();
var isEmpty = (v) => v.length === 0;

// node_modules/@zag-js/collapsible/dist/index.mjs
var anatomy = createAnatomy("collapsible").parts("root", "trigger", "content", "indicator");
var parts = anatomy.build();
var getRootId = (ctx) => {
  var _a8;
  return ((_a8 = ctx.ids) == null ? void 0 : _a8.root) ?? `collapsible:${ctx.id}`;
};
var getContentId = (ctx) => {
  var _a8;
  return ((_a8 = ctx.ids) == null ? void 0 : _a8.content) ?? `collapsible:${ctx.id}:content`;
};
var getTriggerId = (ctx) => {
  var _a8;
  return ((_a8 = ctx.ids) == null ? void 0 : _a8.trigger) ?? `collapsible:${ctx.id}:trigger`;
};
var getContentEl = (ctx) => ctx.getById(getContentId(ctx));
function connect2(service, normalize4) {
  const { state: state2, send, context, scope, prop } = service;
  const visible = state2.matches("open") || state2.matches("closing");
  const open = state2.matches("open");
  const { width, height } = context.get("size");
  const disabled = !!prop("disabled");
  const skip = !context.get("initial") && open;
  const dir = "ltr";
  return {
    disabled,
    visible,
    open,
    measureSize() {
      send({ type: "size.measure" });
    },
    setOpen(nextOpen) {
      const open2 = state2.matches("open");
      if (open2 === nextOpen) return;
      send({ type: nextOpen ? "open" : "close" });
    },
    getRootProps() {
      return normalize4.element({
        ...parts.root.attrs,
        "data-state": open ? "open" : "closed",
        dir,
        id: getRootId(scope)
      });
    },
    getContentProps() {
      return normalize4.element({
        ...parts.content.attrs,
        "data-collapsible": "",
        "data-state": skip ? void 0 : open ? "open" : "closed",
        id: getContentId(scope),
        "data-disabled": dataAttr(disabled),
        hidden: !visible,
        style: {
          "--height": height != null ? `${height}px` : void 0,
          "--width": width != null ? `${width}px` : void 0
        }
      });
    },
    getTriggerProps() {
      return normalize4.element({
        ...parts.trigger.attrs,
        id: getTriggerId(scope),
        dir,
        type: "button",
        "data-state": open ? "open" : "closed",
        "data-disabled": dataAttr(disabled),
        "aria-controls": getContentId(scope),
        "aria-expanded": visible || false,
        onClick(event) {
          if (event.defaultPrevented) return;
          if (disabled) return;
          send({ type: open ? "close" : "open" });
        }
      });
    },
    getIndicatorProps() {
      return normalize4.element({
        ...parts.indicator.attrs,
        dir,
        "data-state": open ? "open" : "closed",
        "data-disabled": dataAttr(disabled)
      });
    }
  };
}
var machine2 = createMachine({
  initialState({ prop }) {
    const open = prop("open") || prop("defaultOpen");
    return open ? "open" : "closed";
  },
  context({ bindable }) {
    return {
      size: bindable(() => ({
        defaultValue: { height: 0, width: 0 },
        sync: true
      })),
      initial: bindable(() => ({
        defaultValue: false
      }))
    };
  },
  refs() {
    return {
      cleanup: void 0,
      stylesRef: void 0
    };
  },
  watch({ track, prop, action }) {
    track([() => prop("open")], () => {
      action(["setInitial", "computeSize", "toggleVisibility"]);
    });
  },
  exit: ["clearInitial", "cleanupNode"],
  states: {
    closed: {
      on: {
        "controlled.open": {
          target: "open"
        },
        open: [
          {
            guard: "isOpenControlled",
            actions: ["invokeOnOpen"]
          },
          {
            target: "open",
            actions: ["setInitial", "computeSize", "invokeOnOpen"]
          }
        ]
      }
    },
    closing: {
      effects: ["trackExitAnimation"],
      on: {
        "controlled.close": {
          target: "closed"
        },
        "controlled.open": {
          target: "open"
        },
        open: [
          {
            guard: "isOpenControlled",
            actions: ["invokeOnOpen"]
          },
          {
            target: "open",
            actions: ["setInitial", "invokeOnOpen"]
          }
        ],
        close: [
          {
            guard: "isOpenControlled",
            actions: ["invokeOnExitComplete"]
          },
          {
            target: "closed",
            actions: ["setInitial", "computeSize", "invokeOnExitComplete"]
          }
        ],
        "animation.end": {
          target: "closed",
          actions: ["invokeOnExitComplete", "clearInitial"]
        }
      }
    },
    open: {
      effects: ["trackEnterAnimation"],
      on: {
        "controlled.close": {
          target: "closing"
        },
        close: [
          {
            guard: "isOpenControlled",
            actions: ["invokeOnClose"]
          },
          {
            target: "closing",
            actions: ["setInitial", "computeSize", "invokeOnClose"]
          }
        ],
        "size.measure": {
          actions: ["measureSize"]
        },
        "animation.end": {
          actions: ["clearInitial"]
        }
      }
    }
  },
  implementations: {
    guards: {
      isOpenControlled: ({ prop }) => prop("open") != void 0
    },
    effects: {
      trackEnterAnimation: ({ send, scope }) => {
        let cleanup;
        const rafCleanup = raf(() => {
          const contentEl = getContentEl(scope);
          if (!contentEl) return;
          const animationName = getComputedStyle2(contentEl).animationName;
          const hasNoAnimation = !animationName || animationName === "none";
          if (hasNoAnimation) {
            send({ type: "animation.end" });
            return;
          }
          const onEnd = (event) => {
            const target = getEventTarget(event);
            if (target === contentEl) {
              send({ type: "animation.end" });
            }
          };
          contentEl.addEventListener("animationend", onEnd);
          cleanup = () => {
            contentEl.removeEventListener("animationend", onEnd);
          };
        });
        return () => {
          rafCleanup();
          cleanup == null ? void 0 : cleanup();
        };
      },
      trackExitAnimation: ({ send, scope }) => {
        let cleanup;
        const rafCleanup = raf(() => {
          const contentEl = getContentEl(scope);
          if (!contentEl) return;
          const animationName = getComputedStyle2(contentEl).animationName;
          const hasNoAnimation = !animationName || animationName === "none";
          if (hasNoAnimation) {
            send({ type: "animation.end" });
            return;
          }
          const onEnd = (event) => {
            const target = getEventTarget(event);
            if (target === contentEl) {
              send({ type: "animation.end" });
            }
          };
          contentEl.addEventListener("animationend", onEnd);
          const restoreStyles = setStyle(contentEl, {
            animationFillMode: "forwards"
          });
          cleanup = () => {
            contentEl.removeEventListener("animationend", onEnd);
            nextTick(() => restoreStyles());
          };
        });
        return () => {
          rafCleanup();
          cleanup == null ? void 0 : cleanup();
        };
      }
    },
    actions: {
      setInitial: ({ context, flush: flush2 }) => {
        flush2(() => {
          context.set("initial", true);
        });
      },
      clearInitial: ({ context }) => {
        context.set("initial", false);
      },
      cleanupNode: ({ refs }) => {
        refs.set("stylesRef", null);
      },
      measureSize: ({ context, scope }) => {
        const contentEl = getContentEl(scope);
        if (!contentEl) return;
        const { height, width } = contentEl.getBoundingClientRect();
        context.set("size", { height, width });
      },
      computeSize: ({ refs, scope, context }) => {
        var _a8;
        (_a8 = refs.get("cleanup")) == null ? void 0 : _a8();
        const rafCleanup = raf(() => {
          const contentEl = getContentEl(scope);
          if (!contentEl) return;
          const hidden = contentEl.hidden;
          contentEl.style.animationName = "none";
          contentEl.style.animationDuration = "0s";
          contentEl.hidden = false;
          const rect = contentEl.getBoundingClientRect();
          context.set("size", { height: rect.height, width: rect.width });
          if (context.get("initial")) {
            contentEl.style.animationName = "";
            contentEl.style.animationDuration = "";
          }
          contentEl.hidden = hidden;
        });
        refs.set("cleanup", rafCleanup);
      },
      invokeOnOpen: ({ prop }) => {
        var _a8;
        (_a8 = prop("onOpenChange")) == null ? void 0 : _a8({ open: true });
      },
      invokeOnClose: ({ prop }) => {
        var _a8;
        (_a8 = prop("onOpenChange")) == null ? void 0 : _a8({ open: false });
      },
      invokeOnExitComplete: ({ prop }) => {
        var _a8;
        (_a8 = prop("onExitComplete")) == null ? void 0 : _a8();
      },
      toggleVisibility: ({ prop, send }) => {
        send({ type: prop("open") ? "controlled.open" : "controlled.close" });
      }
    }
  }
});
var props2 = createProps()([
  "dir",
  "disabled",
  "getRootNode",
  "id",
  "ids",
  "onExitComplete",
  "onOpenChange",
  "defaultOpen",
  "open"
]);
var splitProps3 = createSplitProps(props2);

// node_modules/@ark-ui/react/dist/components/collapsible/use-collapsible.js
var import_react28 = __toESM(require_react(), 1);
var useCollapsible = (props43 = {}) => {
  const { lazyMount, unmountOnExit, ...collapsibleProps } = props43;
  const id = (0, import_react28.useId)();
  const wasVisible = (0, import_react28.useRef)(false);
  const { dir } = useLocaleContext();
  const { getRootNode } = useEnvironmentContext();
  const machineProps = {
    id,
    dir,
    getRootNode,
    ...collapsibleProps
  };
  const service = useMachine(machine2, machineProps);
  const api = connect2(service, normalizeProps);
  if (api.visible) {
    wasVisible.current = true;
  }
  const isUnmounted = !api.visible && !wasVisible.current && lazyMount || unmountOnExit && !api.visible && wasVisible.current;
  return { ...api, isUnmounted };
};

// node_modules/@ark-ui/react/dist/components/collapsible/use-collapsible-context.js
var [CollapsibleProvider, useCollapsibleContext] = createContext3({
  name: "CollapsibleContext",
  hookName: "useCollapsibleContext",
  providerName: "<CollapsibleProvider />"
});

// node_modules/@ark-ui/react/dist/components/collapsible/collapsible-root.js
var CollapsibleRoot = (0, import_react30.forwardRef)((props43, ref) => {
  const [useCollapsibleProps, localProps] = splitCollapsibleProps(props43);
  const collapsible = useCollapsible(useCollapsibleProps);
  const mergedProps = mergeProps2(collapsible.getRootProps(), localProps);
  return (0, import_jsx_runtime13.jsx)(CollapsibleProvider, { value: collapsible, children: (0, import_jsx_runtime13.jsx)(ark.div, { ...mergedProps, ref }) });
});
CollapsibleRoot.displayName = "CollapsibleRoot";

// node_modules/@zag-js/color-utils/dist/index.mjs
var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => __defNormalProp(obj, key + "", value);
var generateRGB_R = (orientation, dir, zValue) => {
  const maskImage = `linear-gradient(to ${orientation[Number(!dir)]}, transparent, #000)`;
  const result = {
    areaStyles: {
      backgroundImage: `linear-gradient(to ${orientation[Number(dir)]},rgb(${zValue},0,0),rgb(${zValue},255,0))`
    },
    areaGradientStyles: {
      backgroundImage: `linear-gradient(to ${orientation[Number(dir)]},rgb(${zValue},0,255),rgb(${zValue},255,255))`,
      WebkitMaskImage: maskImage,
      maskImage
    }
  };
  return result;
};
var generateRGB_G = (orientation, dir, zValue) => {
  const maskImage = `linear-gradient(to ${orientation[Number(!dir)]}, transparent, #000)`;
  const result = {
    areaStyles: {
      backgroundImage: `linear-gradient(to ${orientation[Number(dir)]},rgb(0,${zValue},0),rgb(255,${zValue},0))`
    },
    areaGradientStyles: {
      backgroundImage: `linear-gradient(to ${orientation[Number(dir)]},rgb(0,${zValue},255),rgb(255,${zValue},255))`,
      WebkitMaskImage: maskImage,
      maskImage
    }
  };
  return result;
};
var generateRGB_B = (orientation, dir, zValue) => {
  const maskImage = `linear-gradient(to ${orientation[Number(!dir)]}, transparent, #000)`;
  const result = {
    areaStyles: {
      backgroundImage: `linear-gradient(to ${orientation[Number(dir)]},rgb(0,0,${zValue}),rgb(255,0,${zValue}))`
    },
    areaGradientStyles: {
      backgroundImage: `linear-gradient(to ${orientation[Number(dir)]},rgb(0,255,${zValue}),rgb(255,255,${zValue}))`,
      WebkitMaskImage: maskImage,
      maskImage
    }
  };
  return result;
};
var generateHSL_H = (orientation, dir, zValue) => {
  const result = {
    areaStyles: {},
    areaGradientStyles: {
      background: [
        `linear-gradient(to ${orientation[Number(dir)]}, hsla(0,0%,0%,1) 0%, hsla(0,0%,0%,0) 50%, hsla(0,0%,100%,0) 50%, hsla(0,0%,100%,1) 100%)`,
        `linear-gradient(to ${orientation[Number(!dir)]},hsl(0,0%,50%),hsla(0,0%,50%,0))`,
        `hsl(${zValue}, 100%, 50%)`
      ].join(",")
    }
  };
  return result;
};
var generateHSL_S = (orientation, dir, alphaValue) => {
  const result = {
    areaStyles: {},
    areaGradientStyles: {
      background: [
        `linear-gradient(to ${orientation[Number(!dir)]}, hsla(0,0%,0%,${alphaValue}) 0%, hsla(0,0%,0%,0) 50%, hsla(0,0%,100%,0) 50%, hsla(0,0%,100%,${alphaValue}) 100%)`,
        `linear-gradient(to ${orientation[Number(dir)]},hsla(0,100%,50%,${alphaValue}),hsla(60,100%,50%,${alphaValue}),hsla(120,100%,50%,${alphaValue}),hsla(180,100%,50%,${alphaValue}),hsla(240,100%,50%,${alphaValue}),hsla(300,100%,50%,${alphaValue}),hsla(359,100%,50%,${alphaValue}))`,
        "hsl(0, 0%, 50%)"
      ].join(",")
    }
  };
  return result;
};
var generateHSL_L = (orientation, dir, zValue) => {
  const result = {
    areaStyles: {},
    areaGradientStyles: {
      backgroundImage: [
        `linear-gradient(to ${orientation[Number(!dir)]},hsl(0,0%,${zValue}%),hsla(0,0%,${zValue}%,0))`,
        `linear-gradient(to ${orientation[Number(dir)]},hsl(0,100%,${zValue}%),hsl(60,100%,${zValue}%),hsl(120,100%,${zValue}%),hsl(180,100%,${zValue}%),hsl(240,100%,${zValue}%),hsl(300,100%,${zValue}%),hsl(360,100%,${zValue}%))`
      ].join(",")
    }
  };
  return result;
};
var generateHSB_H = (orientation, dir, zValue) => {
  const result = {
    areaStyles: {},
    areaGradientStyles: {
      background: [
        `linear-gradient(to ${orientation[Number(dir)]},hsl(0,0%,0%),hsla(0,0%,0%,0))`,
        `linear-gradient(to ${orientation[Number(!dir)]},hsl(0,0%,100%),hsla(0,0%,100%,0))`,
        `hsl(${zValue}, 100%, 50%)`
      ].join(",")
    }
  };
  return result;
};
var generateHSB_S = (orientation, dir, alphaValue) => {
  const result = {
    areaStyles: {},
    areaGradientStyles: {
      background: [
        `linear-gradient(to ${orientation[Number(!dir)]},hsla(0,0%,0%,${alphaValue}),hsla(0,0%,0%,0))`,
        `linear-gradient(to ${orientation[Number(dir)]},hsla(0,100%,50%,${alphaValue}),hsla(60,100%,50%,${alphaValue}),hsla(120,100%,50%,${alphaValue}),hsla(180,100%,50%,${alphaValue}),hsla(240,100%,50%,${alphaValue}),hsla(300,100%,50%,${alphaValue}),hsla(359,100%,50%,${alphaValue}))`,
        `linear-gradient(to ${orientation[Number(!dir)]},hsl(0,0%,0%),hsl(0,0%,100%))`
      ].join(",")
    }
  };
  return result;
};
var generateHSB_B = (orientation, dir, alphaValue) => {
  const result = {
    areaStyles: {},
    areaGradientStyles: {
      background: [
        `linear-gradient(to ${orientation[Number(!dir)]},hsla(0,0%,100%,${alphaValue}),hsla(0,0%,100%,0))`,
        `linear-gradient(to ${orientation[Number(dir)]},hsla(0,100%,50%,${alphaValue}),hsla(60,100%,50%,${alphaValue}),hsla(120,100%,50%,${alphaValue}),hsla(180,100%,50%,${alphaValue}),hsla(240,100%,50%,${alphaValue}),hsla(300,100%,50%,${alphaValue}),hsla(359,100%,50%,${alphaValue}))`,
        "#000"
      ].join(",")
    }
  };
  return result;
};
function getColorAreaGradient(color, options) {
  const { xChannel, yChannel, dir: dirProp = "ltr" } = options;
  const { zChannel } = color.getColorAxes({ xChannel, yChannel });
  const zValue = color.getChannelValue(zChannel);
  const { minValue: zMin, maxValue: zMax } = color.getChannelRange(zChannel);
  const orientation = ["top", dirProp === "rtl" ? "left" : "right"];
  let dir = false;
  let background = { areaStyles: {}, areaGradientStyles: {} };
  let alphaValue = (zValue - zMin) / (zMax - zMin);
  let isHSL = color.getFormat() === "hsla";
  switch (zChannel) {
    case "red": {
      dir = xChannel === "green";
      background = generateRGB_R(orientation, dir, zValue);
      break;
    }
    case "green": {
      dir = xChannel === "red";
      background = generateRGB_G(orientation, dir, zValue);
      break;
    }
    case "blue": {
      dir = xChannel === "red";
      background = generateRGB_B(orientation, dir, zValue);
      break;
    }
    case "hue": {
      dir = xChannel !== "saturation";
      if (isHSL) {
        background = generateHSL_H(orientation, dir, zValue);
      } else {
        background = generateHSB_H(orientation, dir, zValue);
      }
      break;
    }
    case "saturation": {
      dir = xChannel === "hue";
      if (isHSL) {
        background = generateHSL_S(orientation, dir, alphaValue);
      } else {
        background = generateHSB_S(orientation, dir, alphaValue);
      }
      break;
    }
    case "brightness": {
      dir = xChannel === "hue";
      background = generateHSB_B(orientation, dir, alphaValue);
      break;
    }
    case "lightness": {
      dir = xChannel === "hue";
      background = generateHSL_L(orientation, dir, zValue);
      break;
    }
  }
  return background;
}
var isEqualObject = (a2, b2) => {
  if (Object.keys(a2).length !== Object.keys(b2).length) return false;
  for (let key in a2) if (a2[key] !== b2[key]) return false;
  return true;
};
var Color = class {
  toHexInt() {
    return this.toFormat("rgba").toHexInt();
  }
  getChannelValue(channel) {
    if (channel in this) return this[channel];
    throw new Error("Unsupported color channel: " + channel);
  }
  getChannelValuePercent(channel, valueToCheck) {
    const value = valueToCheck ?? this.getChannelValue(channel);
    const { minValue, maxValue: maxValue2 } = this.getChannelRange(channel);
    return getValuePercent(value, minValue, maxValue2);
  }
  getChannelPercentValue(channel, percentToCheck) {
    const { minValue, maxValue: maxValue2, step } = this.getChannelRange(channel);
    const percentValue = getPercentValue(percentToCheck, minValue, maxValue2, step);
    return snapValueToStep(percentValue, minValue, maxValue2, step);
  }
  withChannelValue(channel, value) {
    const { minValue, maxValue: maxValue2 } = this.getChannelRange(channel);
    if (channel in this) {
      let clone2 = this.clone();
      clone2[channel] = clampValue(value, minValue, maxValue2);
      return clone2;
    }
    throw new Error("Unsupported color channel: " + channel);
  }
  getColorAxes(xyChannels) {
    let { xChannel, yChannel } = xyChannels;
    let xCh = xChannel || this.getChannels().find((c) => c !== yChannel);
    let yCh = yChannel || this.getChannels().find((c) => c !== xCh);
    let zCh = this.getChannels().find((c) => c !== xCh && c !== yCh);
    return { xChannel: xCh, yChannel: yCh, zChannel: zCh };
  }
  incrementChannel(channel, stepSize) {
    const { minValue, maxValue: maxValue2, step } = this.getChannelRange(channel);
    const value = snapValueToStep(
      clampValue(this.getChannelValue(channel) + stepSize, minValue, maxValue2),
      minValue,
      maxValue2,
      step
    );
    return this.withChannelValue(channel, value);
  }
  decrementChannel(channel, stepSize) {
    return this.incrementChannel(channel, -stepSize);
  }
  isEqual(color) {
    const isSame = isEqualObject(this.toJSON(), color.toJSON());
    return isSame && this.getChannelValue("alpha") === color.getChannelValue("alpha");
  }
};
var _RGBColor = class _RGBColor2 extends Color {
  constructor(red, green, blue, alpha) {
    super();
    this.red = red;
    this.green = green;
    this.blue = blue;
    this.alpha = alpha;
  }
  static parse(value) {
    let colors2 = [];
    if (/^#[\da-f]+$/i.test(value) && [4, 5, 7, 9].includes(value.length)) {
      const values = (value.length < 6 ? value.replace(/[^#]/gi, "$&$&") : value).slice(1).split("");
      while (values.length > 0) {
        colors2.push(parseInt(values.splice(0, 2).join(""), 16));
      }
      colors2[3] = colors2[3] !== void 0 ? colors2[3] / 255 : void 0;
    }
    const match4 = value.match(/^rgba?\((.*)\)$/);
    if (match4 == null ? void 0 : match4[1]) {
      colors2 = match4[1].split(",").map((value2) => Number(value2.trim())).map((num, i) => clampValue(num, 0, i < 3 ? 255 : 1));
    }
    return colors2.length < 3 ? void 0 : new _RGBColor2(colors2[0], colors2[1], colors2[2], colors2[3] ?? 1);
  }
  toString(format) {
    switch (format) {
      case "hex":
        return "#" + (this.red.toString(16).padStart(2, "0") + this.green.toString(16).padStart(2, "0") + this.blue.toString(16).padStart(2, "0")).toUpperCase();
      case "hexa":
        return "#" + (this.red.toString(16).padStart(2, "0") + this.green.toString(16).padStart(2, "0") + this.blue.toString(16).padStart(2, "0") + Math.round(this.alpha * 255).toString(16).padStart(2, "0")).toUpperCase();
      case "rgb":
        return `rgb(${this.red}, ${this.green}, ${this.blue})`;
      case "css":
      case "rgba":
        return `rgba(${this.red}, ${this.green}, ${this.blue}, ${this.alpha})`;
      case "hsl":
        return this.toHSL().toString("hsl");
      case "hsb":
        return this.toHSB().toString("hsb");
      default:
        return this.toFormat(format).toString(format);
    }
  }
  toFormat(format) {
    switch (format) {
      case "rgba":
        return this;
      case "hsba":
        return this.toHSB();
      case "hsla":
        return this.toHSL();
      default:
        throw new Error("Unsupported color conversion: rgb -> " + format);
    }
  }
  toHexInt() {
    return this.red << 16 | this.green << 8 | this.blue;
  }
  /**
   * Converts an RGB color value to HSB.
   * Conversion formula adapted from https://en.wikipedia.org/wiki/HSL_and_HSV#From_RGB.
   * @returns An HSBColor object.
   */
  toHSB() {
    const red = this.red / 255;
    const green = this.green / 255;
    const blue = this.blue / 255;
    const min4 = Math.min(red, green, blue);
    const brightness = Math.max(red, green, blue);
    const chroma = brightness - min4;
    const saturation = brightness === 0 ? 0 : chroma / brightness;
    let hue = 0;
    if (chroma !== 0) {
      switch (brightness) {
        case red:
          hue = (green - blue) / chroma + (green < blue ? 6 : 0);
          break;
        case green:
          hue = (blue - red) / chroma + 2;
          break;
        case blue:
          hue = (red - green) / chroma + 4;
          break;
      }
      hue /= 6;
    }
    return new HSBColor(
      toFixedNumber(hue * 360, 2),
      toFixedNumber(saturation * 100, 2),
      toFixedNumber(brightness * 100, 2),
      toFixedNumber(this.alpha, 2)
    );
  }
  /**
   * Converts an RGB color value to HSL.
   * Conversion formula adapted from https://en.wikipedia.org/wiki/HSL_and_HSV#From_RGB.
   * @returns An HSLColor object.
   */
  toHSL() {
    const red = this.red / 255;
    const green = this.green / 255;
    const blue = this.blue / 255;
    const min4 = Math.min(red, green, blue);
    const max4 = Math.max(red, green, blue);
    const lightness = (max4 + min4) / 2;
    const chroma = max4 - min4;
    let hue = -1;
    let saturation = -1;
    if (chroma === 0) {
      hue = saturation = 0;
    } else {
      saturation = chroma / (lightness < 0.5 ? max4 + min4 : 2 - max4 - min4);
      switch (max4) {
        case red:
          hue = (green - blue) / chroma + (green < blue ? 6 : 0);
          break;
        case green:
          hue = (blue - red) / chroma + 2;
          break;
        case blue:
          hue = (red - green) / chroma + 4;
          break;
      }
      hue /= 6;
    }
    return new HSLColor(
      toFixedNumber(hue * 360, 2),
      toFixedNumber(saturation * 100, 2),
      toFixedNumber(lightness * 100, 2),
      toFixedNumber(this.alpha, 2)
    );
  }
  clone() {
    return new _RGBColor2(this.red, this.green, this.blue, this.alpha);
  }
  getChannelFormatOptions(channel) {
    switch (channel) {
      case "red":
      case "green":
      case "blue":
        return { style: "decimal" };
      case "alpha":
        return { style: "percent" };
      default:
        throw new Error("Unknown color channel: " + channel);
    }
  }
  formatChannelValue(channel, locale) {
    let options = this.getChannelFormatOptions(channel);
    let value = this.getChannelValue(channel);
    return new Intl.NumberFormat(locale, options).format(value);
  }
  getChannelRange(channel) {
    switch (channel) {
      case "red":
      case "green":
      case "blue":
        return { minValue: 0, maxValue: 255, step: 1, pageSize: 17 };
      case "alpha":
        return { minValue: 0, maxValue: 1, step: 0.01, pageSize: 0.1 };
      default:
        throw new Error("Unknown color channel: " + channel);
    }
  }
  toJSON() {
    return { r: this.red, g: this.green, b: this.blue, a: this.alpha };
  }
  getFormat() {
    return "rgba";
  }
  getChannels() {
    return _RGBColor2.colorChannels;
  }
};
__publicField(_RGBColor, "colorChannels", ["red", "green", "blue"]);
var RGBColor = _RGBColor;
var HSL_REGEX = /hsl\(([-+]?\d+(?:.\d+)?\s*,\s*[-+]?\d+(?:.\d+)?%\s*,\s*[-+]?\d+(?:.\d+)?%)\)|hsla\(([-+]?\d+(?:.\d+)?\s*,\s*[-+]?\d+(?:.\d+)?%\s*,\s*[-+]?\d+(?:.\d+)?%\s*,\s*[-+]?\d(.\d+)?)\)/;
var _HSLColor = class _HSLColor2 extends Color {
  constructor(hue, saturation, lightness, alpha) {
    super();
    this.hue = hue;
    this.saturation = saturation;
    this.lightness = lightness;
    this.alpha = alpha;
  }
  static parse(value) {
    let m;
    if (m = value.match(HSL_REGEX)) {
      const [h, s, l2, a2] = (m[1] ?? m[2]).split(",").map((n) => Number(n.trim().replace("%", "")));
      return new _HSLColor2(mod(h, 360), clampValue(s, 0, 100), clampValue(l2, 0, 100), clampValue(a2 ?? 1, 0, 1));
    }
  }
  toString(format) {
    switch (format) {
      case "hex":
        return this.toRGB().toString("hex");
      case "hexa":
        return this.toRGB().toString("hexa");
      case "hsl":
        return `hsl(${this.hue}, ${toFixedNumber(this.saturation, 2)}%, ${toFixedNumber(this.lightness, 2)}%)`;
      case "css":
      case "hsla":
        return `hsla(${this.hue}, ${toFixedNumber(this.saturation, 2)}%, ${toFixedNumber(this.lightness, 2)}%, ${this.alpha})`;
      case "hsb":
        return this.toHSB().toString("hsb");
      case "rgb":
        return this.toRGB().toString("rgb");
      default:
        return this.toFormat(format).toString(format);
    }
  }
  toFormat(format) {
    switch (format) {
      case "hsla":
        return this;
      case "hsba":
        return this.toHSB();
      case "rgba":
        return this.toRGB();
      default:
        throw new Error("Unsupported color conversion: hsl -> " + format);
    }
  }
  /**
   * Converts a HSL color to HSB.
   * Conversion formula adapted from https://en.wikipedia.org/wiki/HSL_and_HSV#HSL_to_HSV.
   * @returns An HSBColor object.
   */
  toHSB() {
    let saturation = this.saturation / 100;
    let lightness = this.lightness / 100;
    let brightness = lightness + saturation * Math.min(lightness, 1 - lightness);
    saturation = brightness === 0 ? 0 : 2 * (1 - lightness / brightness);
    return new HSBColor(
      toFixedNumber(this.hue, 2),
      toFixedNumber(saturation * 100, 2),
      toFixedNumber(brightness * 100, 2),
      toFixedNumber(this.alpha, 2)
    );
  }
  /**
   * Converts a HSL color to RGB.
   * Conversion formula adapted from https://en.wikipedia.org/wiki/HSL_and_HSV#HSL_to_RGB_alternative.
   * @returns An RGBColor object.
   */
  toRGB() {
    let hue = this.hue;
    let saturation = this.saturation / 100;
    let lightness = this.lightness / 100;
    let a2 = saturation * Math.min(lightness, 1 - lightness);
    let fn = (n, k = (n + hue / 30) % 12) => lightness - a2 * Math.max(Math.min(k - 3, 9 - k, 1), -1);
    return new RGBColor(
      Math.round(fn(0) * 255),
      Math.round(fn(8) * 255),
      Math.round(fn(4) * 255),
      toFixedNumber(this.alpha, 2)
    );
  }
  clone() {
    return new _HSLColor2(this.hue, this.saturation, this.lightness, this.alpha);
  }
  getChannelFormatOptions(channel) {
    switch (channel) {
      case "hue":
        return { style: "unit", unit: "degree", unitDisplay: "narrow" };
      case "saturation":
      case "lightness":
      case "alpha":
        return { style: "percent" };
      default:
        throw new Error("Unknown color channel: " + channel);
    }
  }
  formatChannelValue(channel, locale) {
    let options = this.getChannelFormatOptions(channel);
    let value = this.getChannelValue(channel);
    if (channel === "saturation" || channel === "lightness") {
      value /= 100;
    }
    return new Intl.NumberFormat(locale, options).format(value);
  }
  getChannelRange(channel) {
    switch (channel) {
      case "hue":
        return { minValue: 0, maxValue: 360, step: 1, pageSize: 15 };
      case "saturation":
      case "lightness":
        return { minValue: 0, maxValue: 100, step: 1, pageSize: 10 };
      case "alpha":
        return { minValue: 0, maxValue: 1, step: 0.01, pageSize: 0.1 };
      default:
        throw new Error("Unknown color channel: " + channel);
    }
  }
  toJSON() {
    return { h: this.hue, s: this.saturation, l: this.lightness, a: this.alpha };
  }
  getFormat() {
    return "hsla";
  }
  getChannels() {
    return _HSLColor2.colorChannels;
  }
};
__publicField(_HSLColor, "colorChannels", ["hue", "saturation", "lightness"]);
var HSLColor = _HSLColor;
var HSB_REGEX = /hsb\(([-+]?\d+(?:.\d+)?\s*,\s*[-+]?\d+(?:.\d+)?%\s*,\s*[-+]?\d+(?:.\d+)?%)\)|hsba\(([-+]?\d+(?:.\d+)?\s*,\s*[-+]?\d+(?:.\d+)?%\s*,\s*[-+]?\d+(?:.\d+)?%\s*,\s*[-+]?\d(.\d+)?)\)/;
var _HSBColor = class _HSBColor2 extends Color {
  constructor(hue, saturation, brightness, alpha) {
    super();
    this.hue = hue;
    this.saturation = saturation;
    this.brightness = brightness;
    this.alpha = alpha;
  }
  static parse(value) {
    let m;
    if (m = value.match(HSB_REGEX)) {
      const [h, s, b2, a2] = (m[1] ?? m[2]).split(",").map((n) => Number(n.trim().replace("%", "")));
      return new _HSBColor2(mod(h, 360), clampValue(s, 0, 100), clampValue(b2, 0, 100), clampValue(a2 ?? 1, 0, 1));
    }
  }
  toString(format) {
    switch (format) {
      case "css":
        return this.toHSL().toString("css");
      case "hex":
        return this.toRGB().toString("hex");
      case "hexa":
        return this.toRGB().toString("hexa");
      case "hsb":
        return `hsb(${this.hue}, ${toFixedNumber(this.saturation, 2)}%, ${toFixedNumber(this.brightness, 2)}%)`;
      case "hsba":
        return `hsba(${this.hue}, ${toFixedNumber(this.saturation, 2)}%, ${toFixedNumber(this.brightness, 2)}%, ${this.alpha})`;
      case "hsl":
        return this.toHSL().toString("hsl");
      case "rgb":
        return this.toRGB().toString("rgb");
      default:
        return this.toFormat(format).toString(format);
    }
  }
  toFormat(format) {
    switch (format) {
      case "hsba":
        return this;
      case "hsla":
        return this.toHSL();
      case "rgba":
        return this.toRGB();
      default:
        throw new Error("Unsupported color conversion: hsb -> " + format);
    }
  }
  /**
   * Converts a HSB color to HSL.
   * Conversion formula adapted from https://en.wikipedia.org/wiki/HSL_and_HSV#HSV_to_HSL.
   * @returns An HSLColor object.
   */
  toHSL() {
    let saturation = this.saturation / 100;
    let brightness = this.brightness / 100;
    let lightness = brightness * (1 - saturation / 2);
    saturation = lightness === 0 || lightness === 1 ? 0 : (brightness - lightness) / Math.min(lightness, 1 - lightness);
    return new HSLColor(
      toFixedNumber(this.hue, 2),
      toFixedNumber(saturation * 100, 2),
      toFixedNumber(lightness * 100, 2),
      toFixedNumber(this.alpha, 2)
    );
  }
  /**
   * Converts a HSV color value to RGB.
   * Conversion formula adapted from https://en.wikipedia.org/wiki/HSL_and_HSV#HSV_to_RGB_alternative.
   * @returns An RGBColor object.
   */
  toRGB() {
    let hue = this.hue;
    let saturation = this.saturation / 100;
    let brightness = this.brightness / 100;
    let fn = (n, k = (n + hue / 60) % 6) => brightness - saturation * brightness * Math.max(Math.min(k, 4 - k, 1), 0);
    return new RGBColor(
      Math.round(fn(5) * 255),
      Math.round(fn(3) * 255),
      Math.round(fn(1) * 255),
      toFixedNumber(this.alpha, 2)
    );
  }
  clone() {
    return new _HSBColor2(this.hue, this.saturation, this.brightness, this.alpha);
  }
  getChannelFormatOptions(channel) {
    switch (channel) {
      case "hue":
        return { style: "unit", unit: "degree", unitDisplay: "narrow" };
      case "saturation":
      case "brightness":
      case "alpha":
        return { style: "percent" };
      default:
        throw new Error("Unknown color channel: " + channel);
    }
  }
  formatChannelValue(channel, locale) {
    let options = this.getChannelFormatOptions(channel);
    let value = this.getChannelValue(channel);
    if (channel === "saturation" || channel === "brightness") {
      value /= 100;
    }
    return new Intl.NumberFormat(locale, options).format(value);
  }
  getChannelRange(channel) {
    switch (channel) {
      case "hue":
        return { minValue: 0, maxValue: 360, step: 1, pageSize: 15 };
      case "saturation":
      case "brightness":
        return { minValue: 0, maxValue: 100, step: 1, pageSize: 10 };
      case "alpha":
        return { minValue: 0, maxValue: 1, step: 0.01, pageSize: 0.1 };
      default:
        throw new Error("Unknown color channel: " + channel);
    }
  }
  toJSON() {
    return { h: this.hue, s: this.saturation, b: this.brightness, a: this.alpha };
  }
  getFormat() {
    return "hsba";
  }
  getChannels() {
    return _HSBColor2.colorChannels;
  }
};
__publicField(_HSBColor, "colorChannels", ["hue", "saturation", "brightness"]);
var HSBColor = _HSBColor;
var nativeColors = "aliceblue:f0f8ff,antiquewhite:faebd7,aqua:00ffff,aquamarine:7fffd4,azure:f0ffff,beige:f5f5dc,bisque:ffe4c4,black:000000,blanchedalmond:ffebcd,blue:0000ff,blueviolet:8a2be2,brown:a52a2a,burlywood:deb887,cadetblue:5f9ea0,chartreuse:7fff00,chocolate:d2691e,coral:ff7f50,cornflowerblue:6495ed,cornsilk:fff8dc,crimson:dc143c,cyan:00ffff,darkblue:00008b,darkcyan:008b8b,darkgoldenrod:b8860b,darkgray:a9a9a9,darkgreen:006400,darkkhaki:bdb76b,darkmagenta:8b008b,darkolivegreen:556b2f,darkorange:ff8c00,darkorchid:9932cc,darkred:8b0000,darksalmon:e9967a,darkseagreen:8fbc8f,darkslateblue:483d8b,darkslategray:2f4f4f,darkturquoise:00ced1,darkviolet:9400d3,deeppink:ff1493,deepskyblue:00bfff,dimgray:696969,dodgerblue:1e90ff,firebrick:b22222,floralwhite:fffaf0,forestgreen:228b22,fuchsia:ff00ff,gainsboro:dcdcdc,ghostwhite:f8f8ff,gold:ffd700,goldenrod:daa520,gray:808080,green:008000,greenyellow:adff2f,honeydew:f0fff0,hotpink:ff69b4,indianred:cd5c5c,indigo:4b0082,ivory:fffff0,khaki:f0e68c,lavender:e6e6fa,lavenderblush:fff0f5,lawngreen:7cfc00,lemonchiffon:fffacd,lightblue:add8e6,lightcoral:f08080,lightcyan:e0ffff,lightgoldenrodyellow:fafad2,lightgrey:d3d3d3,lightgreen:90ee90,lightpink:ffb6c1,lightsalmon:ffa07a,lightseagreen:20b2aa,lightskyblue:87cefa,lightslategray:778899,lightsteelblue:b0c4de,lightyellow:ffffe0,lime:00ff00,limegreen:32cd32,linen:faf0e6,magenta:ff00ff,maroon:800000,mediumaquamarine:66cdaa,mediumblue:0000cd,mediumorchid:ba55d3,mediumpurple:9370d8,mediumseagreen:3cb371,mediumslateblue:7b68ee,mediumspringgreen:00fa9a,mediumturquoise:48d1cc,mediumvioletred:c71585,midnightblue:191970,mintcream:f5fffa,mistyrose:ffe4e1,moccasin:ffe4b5,navajowhite:ffdead,navy:000080,oldlace:fdf5e6,olive:808000,olivedrab:6b8e23,orange:ffa500,orangered:ff4500,orchid:da70d6,palegoldenrod:eee8aa,palegreen:98fb98,paleturquoise:afeeee,palevioletred:d87093,papayawhip:ffefd5,peachpuff:ffdab9,peru:cd853f,pink:ffc0cb,plum:dda0dd,powderblue:b0e0e6,purple:800080,rebeccapurple:663399,red:ff0000,rosybrown:bc8f8f,royalblue:4169e1,saddlebrown:8b4513,salmon:fa8072,sandybrown:f4a460,seagreen:2e8b57,seashell:fff5ee,sienna:a0522d,silver:c0c0c0,skyblue:87ceeb,slateblue:6a5acd,slategray:708090,snow:fffafa,springgreen:00ff7f,steelblue:4682b4,tan:d2b48c,teal:008080,thistle:d8bfd8,tomato:ff6347,turquoise:40e0d0,violet:ee82ee,wheat:f5deb3,white:ffffff,whitesmoke:f5f5f5,yellow:ffff00,yellowgreen:9acd32";
var makeMap = (str) => {
  const map2 = /* @__PURE__ */ new Map();
  const list = str.split(",");
  for (let i = 0; i < list.length; i++) {
    const [key, val] = list[i].split(":");
    map2.set(key, `#${val}`);
    if (key.includes("gray")) map2.set(key.replace("gray", "grey"), `#${val}`);
  }
  return map2;
};
var nativeColorMap = makeMap(nativeColors);
var parseColor = (value) => {
  var _a8;
  if (nativeColorMap.has(value)) {
    return parseColor(nativeColorMap.get(value));
  }
  const result = RGBColor.parse(value) || HSBColor.parse(value) || HSLColor.parse(value);
  if (!result) {
    const error = new Error("Invalid color value: " + value);
    (_a8 = Error.captureStackTrace) == null ? void 0 : _a8.call(Error, error, parseColor);
    throw error;
  }
  return result;
};
var normalizeColor = (v) => {
  return typeof v === "string" ? parseColor(v) : v;
};

// node_modules/@floating-ui/utils/dist/floating-ui.utils.mjs
var sides = ["top", "right", "bottom", "left"];
var alignments = ["start", "end"];
var placements = sides.reduce((acc, side) => acc.concat(side, side + "-" + alignments[0], side + "-" + alignments[1]), []);
var min2 = Math.min;
var max2 = Math.max;
var round2 = Math.round;
var floor2 = Math.floor;
var createCoords = (v) => ({
  x: v,
  y: v
});
var oppositeSideMap = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
var oppositeAlignmentMap = {
  start: "end",
  end: "start"
};
function clamp2(start, value, end) {
  return max2(start, min2(value, end));
}
function evaluate(value, param) {
  return typeof value === "function" ? value(param) : value;
}
function getSide(placement) {
  return placement.split("-")[0];
}
function getAlignment(placement) {
  return placement.split("-")[1];
}
function getOppositeAxis(axis) {
  return axis === "x" ? "y" : "x";
}
function getAxisLength(axis) {
  return axis === "y" ? "height" : "width";
}
function getSideAxis(placement) {
  return ["top", "bottom"].includes(getSide(placement)) ? "y" : "x";
}
function getAlignmentAxis(placement) {
  return getOppositeAxis(getSideAxis(placement));
}
function getAlignmentSides(placement, rects, rtl) {
  if (rtl === void 0) {
    rtl = false;
  }
  const alignment = getAlignment(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const length = getAxisLength(alignmentAxis);
  let mainAlignmentSide = alignmentAxis === "x" ? alignment === (rtl ? "end" : "start") ? "right" : "left" : alignment === "start" ? "bottom" : "top";
  if (rects.reference[length] > rects.floating[length]) {
    mainAlignmentSide = getOppositePlacement(mainAlignmentSide);
  }
  return [mainAlignmentSide, getOppositePlacement(mainAlignmentSide)];
}
function getExpandedPlacements(placement) {
  const oppositePlacement = getOppositePlacement(placement);
  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];
}
function getOppositeAlignmentPlacement(placement) {
  return placement.replace(/start|end/g, (alignment) => oppositeAlignmentMap[alignment]);
}
function getSideList(side, isStart, rtl) {
  const lr = ["left", "right"];
  const rl = ["right", "left"];
  const tb = ["top", "bottom"];
  const bt = ["bottom", "top"];
  switch (side) {
    case "top":
    case "bottom":
      if (rtl) return isStart ? rl : lr;
      return isStart ? lr : rl;
    case "left":
    case "right":
      return isStart ? tb : bt;
    default:
      return [];
  }
}
function getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {
  const alignment = getAlignment(placement);
  let list = getSideList(getSide(placement), direction === "start", rtl);
  if (alignment) {
    list = list.map((side) => side + "-" + alignment);
    if (flipAlignment) {
      list = list.concat(list.map(getOppositeAlignmentPlacement));
    }
  }
  return list;
}
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, (side) => oppositeSideMap[side]);
}
function expandPaddingObject(padding) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...padding
  };
}
function getPaddingObject(padding) {
  return typeof padding !== "number" ? expandPaddingObject(padding) : {
    top: padding,
    right: padding,
    bottom: padding,
    left: padding
  };
}
function rectToClientRect(rect) {
  const {
    x,
    y,
    width,
    height
  } = rect;
  return {
    width,
    height,
    top: y,
    left: x,
    right: x + width,
    bottom: y + height,
    x,
    y
  };
}

// node_modules/@floating-ui/core/dist/floating-ui.core.mjs
function computeCoordsFromPlacement(_ref, placement, rtl) {
  let {
    reference,
    floating
  } = _ref;
  const sideAxis = getSideAxis(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const alignLength = getAxisLength(alignmentAxis);
  const side = getSide(placement);
  const isVertical = sideAxis === "y";
  const commonX = reference.x + reference.width / 2 - floating.width / 2;
  const commonY = reference.y + reference.height / 2 - floating.height / 2;
  const commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;
  let coords;
  switch (side) {
    case "top":
      coords = {
        x: commonX,
        y: reference.y - floating.height
      };
      break;
    case "bottom":
      coords = {
        x: commonX,
        y: reference.y + reference.height
      };
      break;
    case "right":
      coords = {
        x: reference.x + reference.width,
        y: commonY
      };
      break;
    case "left":
      coords = {
        x: reference.x - floating.width,
        y: commonY
      };
      break;
    default:
      coords = {
        x: reference.x,
        y: reference.y
      };
  }
  switch (getAlignment(placement)) {
    case "start":
      coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);
      break;
    case "end":
      coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);
      break;
  }
  return coords;
}
var computePosition = async (reference, floating, config) => {
  const {
    placement = "bottom",
    strategy = "absolute",
    middleware = [],
    platform: platform2
  } = config;
  const validMiddleware = middleware.filter(Boolean);
  const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(floating));
  let rects = await platform2.getElementRects({
    reference,
    floating,
    strategy
  });
  let {
    x,
    y
  } = computeCoordsFromPlacement(rects, placement, rtl);
  let statefulPlacement = placement;
  let middlewareData = {};
  let resetCount = 0;
  for (let i = 0; i < validMiddleware.length; i++) {
    const {
      name,
      fn
    } = validMiddleware[i];
    const {
      x: nextX,
      y: nextY,
      data,
      reset
    } = await fn({
      x,
      y,
      initialPlacement: placement,
      placement: statefulPlacement,
      strategy,
      middlewareData,
      rects,
      platform: platform2,
      elements: {
        reference,
        floating
      }
    });
    x = nextX != null ? nextX : x;
    y = nextY != null ? nextY : y;
    middlewareData = {
      ...middlewareData,
      [name]: {
        ...middlewareData[name],
        ...data
      }
    };
    if (reset && resetCount <= 50) {
      resetCount++;
      if (typeof reset === "object") {
        if (reset.placement) {
          statefulPlacement = reset.placement;
        }
        if (reset.rects) {
          rects = reset.rects === true ? await platform2.getElementRects({
            reference,
            floating,
            strategy
          }) : reset.rects;
        }
        ({
          x,
          y
        } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));
      }
      i = -1;
    }
  }
  return {
    x,
    y,
    placement: statefulPlacement,
    strategy,
    middlewareData
  };
};
async function detectOverflow(state2, options) {
  var _await$platform$isEle;
  if (options === void 0) {
    options = {};
  }
  const {
    x,
    y,
    platform: platform2,
    rects,
    elements,
    strategy
  } = state2;
  const {
    boundary = "clippingAncestors",
    rootBoundary = "viewport",
    elementContext = "floating",
    altBoundary = false,
    padding = 0
  } = evaluate(options, state2);
  const paddingObject = getPaddingObject(padding);
  const altContext = elementContext === "floating" ? "reference" : "floating";
  const element = elements[altBoundary ? altContext : elementContext];
  const clippingClientRect = rectToClientRect(await platform2.getClippingRect({
    element: ((_await$platform$isEle = await (platform2.isElement == null ? void 0 : platform2.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || await (platform2.getDocumentElement == null ? void 0 : platform2.getDocumentElement(elements.floating)),
    boundary,
    rootBoundary,
    strategy
  }));
  const rect = elementContext === "floating" ? {
    x,
    y,
    width: rects.floating.width,
    height: rects.floating.height
  } : rects.reference;
  const offsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(elements.floating));
  const offsetScale = await (platform2.isElement == null ? void 0 : platform2.isElement(offsetParent)) ? await (platform2.getScale == null ? void 0 : platform2.getScale(offsetParent)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  };
  const elementClientRect = rectToClientRect(platform2.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform2.convertOffsetParentRelativeRectToViewportRelativeRect({
    elements,
    rect,
    offsetParent,
    strategy
  }) : rect);
  return {
    top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,
    bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,
    left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,
    right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x
  };
}
var arrow = (options) => ({
  name: "arrow",
  options,
  async fn(state2) {
    const {
      x,
      y,
      placement,
      rects,
      platform: platform2,
      elements,
      middlewareData
    } = state2;
    const {
      element,
      padding = 0
    } = evaluate(options, state2) || {};
    if (element == null) {
      return {};
    }
    const paddingObject = getPaddingObject(padding);
    const coords = {
      x,
      y
    };
    const axis = getAlignmentAxis(placement);
    const length = getAxisLength(axis);
    const arrowDimensions = await platform2.getDimensions(element);
    const isYAxis = axis === "y";
    const minProp = isYAxis ? "top" : "left";
    const maxProp = isYAxis ? "bottom" : "right";
    const clientProp = isYAxis ? "clientHeight" : "clientWidth";
    const endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];
    const startDiff = coords[axis] - rects.reference[axis];
    const arrowOffsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(element));
    let clientSize = arrowOffsetParent ? arrowOffsetParent[clientProp] : 0;
    if (!clientSize || !await (platform2.isElement == null ? void 0 : platform2.isElement(arrowOffsetParent))) {
      clientSize = elements.floating[clientProp] || rects.floating[length];
    }
    const centerToReference = endDiff / 2 - startDiff / 2;
    const largestPossiblePadding = clientSize / 2 - arrowDimensions[length] / 2 - 1;
    const minPadding = min2(paddingObject[minProp], largestPossiblePadding);
    const maxPadding = min2(paddingObject[maxProp], largestPossiblePadding);
    const min$1 = minPadding;
    const max4 = clientSize - arrowDimensions[length] - maxPadding;
    const center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;
    const offset4 = clamp2(min$1, center, max4);
    const shouldAddOffset = !middlewareData.arrow && getAlignment(placement) != null && center !== offset4 && rects.reference[length] / 2 - (center < min$1 ? minPadding : maxPadding) - arrowDimensions[length] / 2 < 0;
    const alignmentOffset = shouldAddOffset ? center < min$1 ? center - min$1 : center - max4 : 0;
    return {
      [axis]: coords[axis] + alignmentOffset,
      data: {
        [axis]: offset4,
        centerOffset: center - offset4 - alignmentOffset,
        ...shouldAddOffset && {
          alignmentOffset
        }
      },
      reset: shouldAddOffset
    };
  }
});
var flip = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "flip",
    options,
    async fn(state2) {
      var _middlewareData$arrow, _middlewareData$flip;
      const {
        placement,
        middlewareData,
        rects,
        initialPlacement,
        platform: platform2,
        elements
      } = state2;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = true,
        fallbackPlacements: specifiedFallbackPlacements,
        fallbackStrategy = "bestFit",
        fallbackAxisSideDirection = "none",
        flipAlignment = true,
        ...detectOverflowOptions
      } = evaluate(options, state2);
      if ((_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
        return {};
      }
      const side = getSide(placement);
      const initialSideAxis = getSideAxis(initialPlacement);
      const isBasePlacement = getSide(initialPlacement) === initialPlacement;
      const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
      const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));
      const hasFallbackAxisSideDirection = fallbackAxisSideDirection !== "none";
      if (!specifiedFallbackPlacements && hasFallbackAxisSideDirection) {
        fallbackPlacements.push(...getOppositeAxisPlacements(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));
      }
      const placements2 = [initialPlacement, ...fallbackPlacements];
      const overflow = await detectOverflow(state2, detectOverflowOptions);
      const overflows = [];
      let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];
      if (checkMainAxis) {
        overflows.push(overflow[side]);
      }
      if (checkCrossAxis) {
        const sides2 = getAlignmentSides(placement, rects, rtl);
        overflows.push(overflow[sides2[0]], overflow[sides2[1]]);
      }
      overflowsData = [...overflowsData, {
        placement,
        overflows
      }];
      if (!overflows.every((side2) => side2 <= 0)) {
        var _middlewareData$flip2, _overflowsData$filter;
        const nextIndex2 = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;
        const nextPlacement = placements2[nextIndex2];
        if (nextPlacement) {
          const ignoreCrossAxisOverflow = checkCrossAxis === "alignment" ? initialSideAxis !== getSideAxis(nextPlacement) : false;
          if (!ignoreCrossAxisOverflow || // We leave the current main axis only if every placement on that axis
          // overflows the main axis.
          overflowsData.every((d) => d.overflows[0] > 0 && getSideAxis(d.placement) === initialSideAxis)) {
            return {
              data: {
                index: nextIndex2,
                overflows: overflowsData
              },
              reset: {
                placement: nextPlacement
              }
            };
          }
        }
        let resetPlacement = (_overflowsData$filter = overflowsData.filter((d) => d.overflows[0] <= 0).sort((a2, b2) => a2.overflows[1] - b2.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;
        if (!resetPlacement) {
          switch (fallbackStrategy) {
            case "bestFit": {
              var _overflowsData$filter2;
              const placement2 = (_overflowsData$filter2 = overflowsData.filter((d) => {
                if (hasFallbackAxisSideDirection) {
                  const currentSideAxis = getSideAxis(d.placement);
                  return currentSideAxis === initialSideAxis || // Create a bias to the `y` side axis due to horizontal
                  // reading directions favoring greater width.
                  currentSideAxis === "y";
                }
                return true;
              }).map((d) => [d.placement, d.overflows.filter((overflow2) => overflow2 > 0).reduce((acc, overflow2) => acc + overflow2, 0)]).sort((a2, b2) => a2[1] - b2[1])[0]) == null ? void 0 : _overflowsData$filter2[0];
              if (placement2) {
                resetPlacement = placement2;
              }
              break;
            }
            case "initialPlacement":
              resetPlacement = initialPlacement;
              break;
          }
        }
        if (placement !== resetPlacement) {
          return {
            reset: {
              placement: resetPlacement
            }
          };
        }
      }
      return {};
    }
  };
};
function getSideOffsets(overflow, rect) {
  return {
    top: overflow.top - rect.height,
    right: overflow.right - rect.width,
    bottom: overflow.bottom - rect.height,
    left: overflow.left - rect.width
  };
}
function isAnySideFullyClipped(overflow) {
  return sides.some((side) => overflow[side] >= 0);
}
var hide = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "hide",
    options,
    async fn(state2) {
      const {
        rects
      } = state2;
      const {
        strategy = "referenceHidden",
        ...detectOverflowOptions
      } = evaluate(options, state2);
      switch (strategy) {
        case "referenceHidden": {
          const overflow = await detectOverflow(state2, {
            ...detectOverflowOptions,
            elementContext: "reference"
          });
          const offsets = getSideOffsets(overflow, rects.reference);
          return {
            data: {
              referenceHiddenOffsets: offsets,
              referenceHidden: isAnySideFullyClipped(offsets)
            }
          };
        }
        case "escaped": {
          const overflow = await detectOverflow(state2, {
            ...detectOverflowOptions,
            altBoundary: true
          });
          const offsets = getSideOffsets(overflow, rects.floating);
          return {
            data: {
              escapedOffsets: offsets,
              escaped: isAnySideFullyClipped(offsets)
            }
          };
        }
        default: {
          return {};
        }
      }
    }
  };
};
async function convertValueToCoords(state2, options) {
  const {
    placement,
    platform: platform2,
    elements
  } = state2;
  const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
  const side = getSide(placement);
  const alignment = getAlignment(placement);
  const isVertical = getSideAxis(placement) === "y";
  const mainAxisMulti = ["left", "top"].includes(side) ? -1 : 1;
  const crossAxisMulti = rtl && isVertical ? -1 : 1;
  const rawValue = evaluate(options, state2);
  let {
    mainAxis,
    crossAxis,
    alignmentAxis
  } = typeof rawValue === "number" ? {
    mainAxis: rawValue,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: rawValue.mainAxis || 0,
    crossAxis: rawValue.crossAxis || 0,
    alignmentAxis: rawValue.alignmentAxis
  };
  if (alignment && typeof alignmentAxis === "number") {
    crossAxis = alignment === "end" ? alignmentAxis * -1 : alignmentAxis;
  }
  return isVertical ? {
    x: crossAxis * crossAxisMulti,
    y: mainAxis * mainAxisMulti
  } : {
    x: mainAxis * mainAxisMulti,
    y: crossAxis * crossAxisMulti
  };
}
var offset = function(options) {
  if (options === void 0) {
    options = 0;
  }
  return {
    name: "offset",
    options,
    async fn(state2) {
      var _middlewareData$offse, _middlewareData$arrow;
      const {
        x,
        y,
        placement,
        middlewareData
      } = state2;
      const diffCoords = await convertValueToCoords(state2, options);
      if (placement === ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse.placement) && (_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
        return {};
      }
      return {
        x: x + diffCoords.x,
        y: y + diffCoords.y,
        data: {
          ...diffCoords,
          placement
        }
      };
    }
  };
};
var shift = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "shift",
    options,
    async fn(state2) {
      const {
        x,
        y,
        placement
      } = state2;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = false,
        limiter = {
          fn: (_ref) => {
            let {
              x: x2,
              y: y2
            } = _ref;
            return {
              x: x2,
              y: y2
            };
          }
        },
        ...detectOverflowOptions
      } = evaluate(options, state2);
      const coords = {
        x,
        y
      };
      const overflow = await detectOverflow(state2, detectOverflowOptions);
      const crossAxis = getSideAxis(getSide(placement));
      const mainAxis = getOppositeAxis(crossAxis);
      let mainAxisCoord = coords[mainAxis];
      let crossAxisCoord = coords[crossAxis];
      if (checkMainAxis) {
        const minSide = mainAxis === "y" ? "top" : "left";
        const maxSide = mainAxis === "y" ? "bottom" : "right";
        const min4 = mainAxisCoord + overflow[minSide];
        const max4 = mainAxisCoord - overflow[maxSide];
        mainAxisCoord = clamp2(min4, mainAxisCoord, max4);
      }
      if (checkCrossAxis) {
        const minSide = crossAxis === "y" ? "top" : "left";
        const maxSide = crossAxis === "y" ? "bottom" : "right";
        const min4 = crossAxisCoord + overflow[minSide];
        const max4 = crossAxisCoord - overflow[maxSide];
        crossAxisCoord = clamp2(min4, crossAxisCoord, max4);
      }
      const limitedCoords = limiter.fn({
        ...state2,
        [mainAxis]: mainAxisCoord,
        [crossAxis]: crossAxisCoord
      });
      return {
        ...limitedCoords,
        data: {
          x: limitedCoords.x - x,
          y: limitedCoords.y - y,
          enabled: {
            [mainAxis]: checkMainAxis,
            [crossAxis]: checkCrossAxis
          }
        }
      };
    }
  };
};
var limitShift = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    options,
    fn(state2) {
      const {
        x,
        y,
        placement,
        rects,
        middlewareData
      } = state2;
      const {
        offset: offset4 = 0,
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = true
      } = evaluate(options, state2);
      const coords = {
        x,
        y
      };
      const crossAxis = getSideAxis(placement);
      const mainAxis = getOppositeAxis(crossAxis);
      let mainAxisCoord = coords[mainAxis];
      let crossAxisCoord = coords[crossAxis];
      const rawOffset = evaluate(offset4, state2);
      const computedOffset = typeof rawOffset === "number" ? {
        mainAxis: rawOffset,
        crossAxis: 0
      } : {
        mainAxis: 0,
        crossAxis: 0,
        ...rawOffset
      };
      if (checkMainAxis) {
        const len = mainAxis === "y" ? "height" : "width";
        const limitMin = rects.reference[mainAxis] - rects.floating[len] + computedOffset.mainAxis;
        const limitMax = rects.reference[mainAxis] + rects.reference[len] - computedOffset.mainAxis;
        if (mainAxisCoord < limitMin) {
          mainAxisCoord = limitMin;
        } else if (mainAxisCoord > limitMax) {
          mainAxisCoord = limitMax;
        }
      }
      if (checkCrossAxis) {
        var _middlewareData$offse, _middlewareData$offse2;
        const len = mainAxis === "y" ? "width" : "height";
        const isOriginSide = ["top", "left"].includes(getSide(placement));
        const limitMin = rects.reference[crossAxis] - rects.floating[len] + (isOriginSide ? ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse[crossAxis]) || 0 : 0) + (isOriginSide ? 0 : computedOffset.crossAxis);
        const limitMax = rects.reference[crossAxis] + rects.reference[len] + (isOriginSide ? 0 : ((_middlewareData$offse2 = middlewareData.offset) == null ? void 0 : _middlewareData$offse2[crossAxis]) || 0) - (isOriginSide ? computedOffset.crossAxis : 0);
        if (crossAxisCoord < limitMin) {
          crossAxisCoord = limitMin;
        } else if (crossAxisCoord > limitMax) {
          crossAxisCoord = limitMax;
        }
      }
      return {
        [mainAxis]: mainAxisCoord,
        [crossAxis]: crossAxisCoord
      };
    }
  };
};
var size = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "size",
    options,
    async fn(state2) {
      var _state$middlewareData, _state$middlewareData2;
      const {
        placement,
        rects,
        platform: platform2,
        elements
      } = state2;
      const {
        apply = () => {
        },
        ...detectOverflowOptions
      } = evaluate(options, state2);
      const overflow = await detectOverflow(state2, detectOverflowOptions);
      const side = getSide(placement);
      const alignment = getAlignment(placement);
      const isYAxis = getSideAxis(placement) === "y";
      const {
        width,
        height
      } = rects.floating;
      let heightSide;
      let widthSide;
      if (side === "top" || side === "bottom") {
        heightSide = side;
        widthSide = alignment === (await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating)) ? "start" : "end") ? "left" : "right";
      } else {
        widthSide = side;
        heightSide = alignment === "end" ? "top" : "bottom";
      }
      const maximumClippingHeight = height - overflow.top - overflow.bottom;
      const maximumClippingWidth = width - overflow.left - overflow.right;
      const overflowAvailableHeight = min2(height - overflow[heightSide], maximumClippingHeight);
      const overflowAvailableWidth = min2(width - overflow[widthSide], maximumClippingWidth);
      const noShift = !state2.middlewareData.shift;
      let availableHeight = overflowAvailableHeight;
      let availableWidth = overflowAvailableWidth;
      if ((_state$middlewareData = state2.middlewareData.shift) != null && _state$middlewareData.enabled.x) {
        availableWidth = maximumClippingWidth;
      }
      if ((_state$middlewareData2 = state2.middlewareData.shift) != null && _state$middlewareData2.enabled.y) {
        availableHeight = maximumClippingHeight;
      }
      if (noShift && !alignment) {
        const xMin = max2(overflow.left, 0);
        const xMax = max2(overflow.right, 0);
        const yMin = max2(overflow.top, 0);
        const yMax = max2(overflow.bottom, 0);
        if (isYAxis) {
          availableWidth = width - 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : max2(overflow.left, overflow.right));
        } else {
          availableHeight = height - 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : max2(overflow.top, overflow.bottom));
        }
      }
      await apply({
        ...state2,
        availableWidth,
        availableHeight
      });
      const nextDimensions = await platform2.getDimensions(elements.floating);
      if (width !== nextDimensions.width || height !== nextDimensions.height) {
        return {
          reset: {
            rects: true
          }
        };
      }
      return {};
    }
  };
};

// node_modules/@floating-ui/utils/dist/floating-ui.utils.dom.mjs
function hasWindow() {
  return typeof window !== "undefined";
}
function getNodeName2(node) {
  if (isNode2(node)) {
    return (node.nodeName || "").toLowerCase();
  }
  return "#document";
}
function getWindow2(node) {
  var _node$ownerDocument;
  return (node == null || (_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;
}
function getDocumentElement2(node) {
  var _ref;
  return (_ref = (isNode2(node) ? node.ownerDocument : node.document) || window.document) == null ? void 0 : _ref.documentElement;
}
function isNode2(value) {
  if (!hasWindow()) {
    return false;
  }
  return value instanceof Node || value instanceof getWindow2(value).Node;
}
function isElement(value) {
  if (!hasWindow()) {
    return false;
  }
  return value instanceof Element || value instanceof getWindow2(value).Element;
}
function isHTMLElement2(value) {
  if (!hasWindow()) {
    return false;
  }
  return value instanceof HTMLElement || value instanceof getWindow2(value).HTMLElement;
}
function isShadowRoot2(value) {
  if (!hasWindow() || typeof ShadowRoot === "undefined") {
    return false;
  }
  return value instanceof ShadowRoot || value instanceof getWindow2(value).ShadowRoot;
}
function isOverflowElement2(element) {
  const {
    overflow,
    overflowX,
    overflowY,
    display
  } = getComputedStyle3(element);
  return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !["inline", "contents"].includes(display);
}
function isTableElement(element) {
  return ["table", "td", "th"].includes(getNodeName2(element));
}
function isTopLayer(element) {
  return [":popover-open", ":modal"].some((selector) => {
    try {
      return element.matches(selector);
    } catch (e) {
      return false;
    }
  });
}
function isContainingBlock(elementOrCss) {
  const webkit = isWebKit();
  const css2 = isElement(elementOrCss) ? getComputedStyle3(elementOrCss) : elementOrCss;
  return ["transform", "translate", "scale", "rotate", "perspective"].some((value) => css2[value] ? css2[value] !== "none" : false) || (css2.containerType ? css2.containerType !== "normal" : false) || !webkit && (css2.backdropFilter ? css2.backdropFilter !== "none" : false) || !webkit && (css2.filter ? css2.filter !== "none" : false) || ["transform", "translate", "scale", "rotate", "perspective", "filter"].some((value) => (css2.willChange || "").includes(value)) || ["paint", "layout", "strict", "content"].some((value) => (css2.contain || "").includes(value));
}
function getContainingBlock(element) {
  let currentNode = getParentNode2(element);
  while (isHTMLElement2(currentNode) && !isLastTraversableNode(currentNode)) {
    if (isContainingBlock(currentNode)) {
      return currentNode;
    } else if (isTopLayer(currentNode)) {
      return null;
    }
    currentNode = getParentNode2(currentNode);
  }
  return null;
}
function isWebKit() {
  if (typeof CSS === "undefined" || !CSS.supports) return false;
  return CSS.supports("-webkit-backdrop-filter", "none");
}
function isLastTraversableNode(node) {
  return ["html", "body", "#document"].includes(getNodeName2(node));
}
function getComputedStyle3(element) {
  return getWindow2(element).getComputedStyle(element);
}
function getNodeScroll(element) {
  if (isElement(element)) {
    return {
      scrollLeft: element.scrollLeft,
      scrollTop: element.scrollTop
    };
  }
  return {
    scrollLeft: element.scrollX,
    scrollTop: element.scrollY
  };
}
function getParentNode2(node) {
  if (getNodeName2(node) === "html") {
    return node;
  }
  const result = (
    // Step into the shadow DOM of the parent of a slotted node.
    node.assignedSlot || // DOM Element detected.
    node.parentNode || // ShadowRoot detected.
    isShadowRoot2(node) && node.host || // Fallback.
    getDocumentElement2(node)
  );
  return isShadowRoot2(result) ? result.host : result;
}
function getNearestOverflowAncestor2(node) {
  const parentNode = getParentNode2(node);
  if (isLastTraversableNode(parentNode)) {
    return node.ownerDocument ? node.ownerDocument.body : node.body;
  }
  if (isHTMLElement2(parentNode) && isOverflowElement2(parentNode)) {
    return parentNode;
  }
  return getNearestOverflowAncestor2(parentNode);
}
function getOverflowAncestors2(node, list, traverseIframes) {
  var _node$ownerDocument2;
  if (list === void 0) {
    list = [];
  }
  if (traverseIframes === void 0) {
    traverseIframes = true;
  }
  const scrollableAncestor = getNearestOverflowAncestor2(node);
  const isBody = scrollableAncestor === ((_node$ownerDocument2 = node.ownerDocument) == null ? void 0 : _node$ownerDocument2.body);
  const win = getWindow2(scrollableAncestor);
  if (isBody) {
    const frameElement = getFrameElement(win);
    return list.concat(win, win.visualViewport || [], isOverflowElement2(scrollableAncestor) ? scrollableAncestor : [], frameElement && traverseIframes ? getOverflowAncestors2(frameElement) : []);
  }
  return list.concat(scrollableAncestor, getOverflowAncestors2(scrollableAncestor, [], traverseIframes));
}
function getFrameElement(win) {
  return win.parent && Object.getPrototypeOf(win.parent) ? win.frameElement : null;
}

// node_modules/@floating-ui/dom/dist/floating-ui.dom.mjs
function getCssDimensions(element) {
  const css2 = getComputedStyle3(element);
  let width = parseFloat(css2.width) || 0;
  let height = parseFloat(css2.height) || 0;
  const hasOffset = isHTMLElement2(element);
  const offsetWidth = hasOffset ? element.offsetWidth : width;
  const offsetHeight = hasOffset ? element.offsetHeight : height;
  const shouldFallback = round2(width) !== offsetWidth || round2(height) !== offsetHeight;
  if (shouldFallback) {
    width = offsetWidth;
    height = offsetHeight;
  }
  return {
    width,
    height,
    $: shouldFallback
  };
}
function unwrapElement(element) {
  return !isElement(element) ? element.contextElement : element;
}
function getScale(element) {
  const domElement = unwrapElement(element);
  if (!isHTMLElement2(domElement)) {
    return createCoords(1);
  }
  const rect = domElement.getBoundingClientRect();
  const {
    width,
    height,
    $: $2
  } = getCssDimensions(domElement);
  let x = ($2 ? round2(rect.width) : rect.width) / width;
  let y = ($2 ? round2(rect.height) : rect.height) / height;
  if (!x || !Number.isFinite(x)) {
    x = 1;
  }
  if (!y || !Number.isFinite(y)) {
    y = 1;
  }
  return {
    x,
    y
  };
}
var noOffsets = createCoords(0);
function getVisualOffsets(element) {
  const win = getWindow2(element);
  if (!isWebKit() || !win.visualViewport) {
    return noOffsets;
  }
  return {
    x: win.visualViewport.offsetLeft,
    y: win.visualViewport.offsetTop
  };
}
function shouldAddVisualOffsets(element, isFixed, floatingOffsetParent) {
  if (isFixed === void 0) {
    isFixed = false;
  }
  if (!floatingOffsetParent || isFixed && floatingOffsetParent !== getWindow2(element)) {
    return false;
  }
  return isFixed;
}
function getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {
  if (includeScale === void 0) {
    includeScale = false;
  }
  if (isFixedStrategy === void 0) {
    isFixedStrategy = false;
  }
  const clientRect = element.getBoundingClientRect();
  const domElement = unwrapElement(element);
  let scale = createCoords(1);
  if (includeScale) {
    if (offsetParent) {
      if (isElement(offsetParent)) {
        scale = getScale(offsetParent);
      }
    } else {
      scale = getScale(element);
    }
  }
  const visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets(domElement) : createCoords(0);
  let x = (clientRect.left + visualOffsets.x) / scale.x;
  let y = (clientRect.top + visualOffsets.y) / scale.y;
  let width = clientRect.width / scale.x;
  let height = clientRect.height / scale.y;
  if (domElement) {
    const win = getWindow2(domElement);
    const offsetWin = offsetParent && isElement(offsetParent) ? getWindow2(offsetParent) : offsetParent;
    let currentWin = win;
    let currentIFrame = getFrameElement(currentWin);
    while (currentIFrame && offsetParent && offsetWin !== currentWin) {
      const iframeScale = getScale(currentIFrame);
      const iframeRect = currentIFrame.getBoundingClientRect();
      const css2 = getComputedStyle3(currentIFrame);
      const left = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css2.paddingLeft)) * iframeScale.x;
      const top = iframeRect.top + (currentIFrame.clientTop + parseFloat(css2.paddingTop)) * iframeScale.y;
      x *= iframeScale.x;
      y *= iframeScale.y;
      width *= iframeScale.x;
      height *= iframeScale.y;
      x += left;
      y += top;
      currentWin = getWindow2(currentIFrame);
      currentIFrame = getFrameElement(currentWin);
    }
  }
  return rectToClientRect({
    width,
    height,
    x,
    y
  });
}
function getWindowScrollBarX(element, rect) {
  const leftScroll = getNodeScroll(element).scrollLeft;
  if (!rect) {
    return getBoundingClientRect(getDocumentElement2(element)).left + leftScroll;
  }
  return rect.left + leftScroll;
}
function getHTMLOffset(documentElement, scroll, ignoreScrollbarX) {
  if (ignoreScrollbarX === void 0) {
    ignoreScrollbarX = false;
  }
  const htmlRect = documentElement.getBoundingClientRect();
  const x = htmlRect.left + scroll.scrollLeft - (ignoreScrollbarX ? 0 : (
    // RTL <body> scrollbar.
    getWindowScrollBarX(documentElement, htmlRect)
  ));
  const y = htmlRect.top + scroll.scrollTop;
  return {
    x,
    y
  };
}
function convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {
  let {
    elements,
    rect,
    offsetParent,
    strategy
  } = _ref;
  const isFixed = strategy === "fixed";
  const documentElement = getDocumentElement2(offsetParent);
  const topLayer = elements ? isTopLayer(elements.floating) : false;
  if (offsetParent === documentElement || topLayer && isFixed) {
    return rect;
  }
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  let scale = createCoords(1);
  const offsets = createCoords(0);
  const isOffsetParentAnElement = isHTMLElement2(offsetParent);
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName2(offsetParent) !== "body" || isOverflowElement2(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isHTMLElement2(offsetParent)) {
      const offsetRect = getBoundingClientRect(offsetParent);
      scale = getScale(offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    }
  }
  const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll, true) : createCoords(0);
  return {
    width: rect.width * scale.x,
    height: rect.height * scale.y,
    x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x + htmlOffset.x,
    y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y + htmlOffset.y
  };
}
function getClientRects(element) {
  return Array.from(element.getClientRects());
}
function getDocumentRect(element) {
  const html = getDocumentElement2(element);
  const scroll = getNodeScroll(element);
  const body = element.ownerDocument.body;
  const width = max2(html.scrollWidth, html.clientWidth, body.scrollWidth, body.clientWidth);
  const height = max2(html.scrollHeight, html.clientHeight, body.scrollHeight, body.clientHeight);
  let x = -scroll.scrollLeft + getWindowScrollBarX(element);
  const y = -scroll.scrollTop;
  if (getComputedStyle3(body).direction === "rtl") {
    x += max2(html.clientWidth, body.clientWidth) - width;
  }
  return {
    width,
    height,
    x,
    y
  };
}
function getViewportRect(element, strategy) {
  const win = getWindow2(element);
  const html = getDocumentElement2(element);
  const visualViewport2 = win.visualViewport;
  let width = html.clientWidth;
  let height = html.clientHeight;
  let x = 0;
  let y = 0;
  if (visualViewport2) {
    width = visualViewport2.width;
    height = visualViewport2.height;
    const visualViewportBased = isWebKit();
    if (!visualViewportBased || visualViewportBased && strategy === "fixed") {
      x = visualViewport2.offsetLeft;
      y = visualViewport2.offsetTop;
    }
  }
  return {
    width,
    height,
    x,
    y
  };
}
function getInnerBoundingClientRect(element, strategy) {
  const clientRect = getBoundingClientRect(element, true, strategy === "fixed");
  const top = clientRect.top + element.clientTop;
  const left = clientRect.left + element.clientLeft;
  const scale = isHTMLElement2(element) ? getScale(element) : createCoords(1);
  const width = element.clientWidth * scale.x;
  const height = element.clientHeight * scale.y;
  const x = left * scale.x;
  const y = top * scale.y;
  return {
    width,
    height,
    x,
    y
  };
}
function getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {
  let rect;
  if (clippingAncestor === "viewport") {
    rect = getViewportRect(element, strategy);
  } else if (clippingAncestor === "document") {
    rect = getDocumentRect(getDocumentElement2(element));
  } else if (isElement(clippingAncestor)) {
    rect = getInnerBoundingClientRect(clippingAncestor, strategy);
  } else {
    const visualOffsets = getVisualOffsets(element);
    rect = {
      x: clippingAncestor.x - visualOffsets.x,
      y: clippingAncestor.y - visualOffsets.y,
      width: clippingAncestor.width,
      height: clippingAncestor.height
    };
  }
  return rectToClientRect(rect);
}
function hasFixedPositionAncestor(element, stopNode) {
  const parentNode = getParentNode2(element);
  if (parentNode === stopNode || !isElement(parentNode) || isLastTraversableNode(parentNode)) {
    return false;
  }
  return getComputedStyle3(parentNode).position === "fixed" || hasFixedPositionAncestor(parentNode, stopNode);
}
function getClippingElementAncestors(element, cache2) {
  const cachedResult = cache2.get(element);
  if (cachedResult) {
    return cachedResult;
  }
  let result = getOverflowAncestors2(element, [], false).filter((el) => isElement(el) && getNodeName2(el) !== "body");
  let currentContainingBlockComputedStyle = null;
  const elementIsFixed = getComputedStyle3(element).position === "fixed";
  let currentNode = elementIsFixed ? getParentNode2(element) : element;
  while (isElement(currentNode) && !isLastTraversableNode(currentNode)) {
    const computedStyle = getComputedStyle3(currentNode);
    const currentNodeIsContaining = isContainingBlock(currentNode);
    if (!currentNodeIsContaining && computedStyle.position === "fixed") {
      currentContainingBlockComputedStyle = null;
    }
    const shouldDropCurrentNode = elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === "static" && !!currentContainingBlockComputedStyle && ["absolute", "fixed"].includes(currentContainingBlockComputedStyle.position) || isOverflowElement2(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element, currentNode);
    if (shouldDropCurrentNode) {
      result = result.filter((ancestor) => ancestor !== currentNode);
    } else {
      currentContainingBlockComputedStyle = computedStyle;
    }
    currentNode = getParentNode2(currentNode);
  }
  cache2.set(element, result);
  return result;
}
function getClippingRect(_ref) {
  let {
    element,
    boundary,
    rootBoundary,
    strategy
  } = _ref;
  const elementClippingAncestors = boundary === "clippingAncestors" ? isTopLayer(element) ? [] : getClippingElementAncestors(element, this._c) : [].concat(boundary);
  const clippingAncestors = [...elementClippingAncestors, rootBoundary];
  const firstClippingAncestor = clippingAncestors[0];
  const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {
    const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);
    accRect.top = max2(rect.top, accRect.top);
    accRect.right = min2(rect.right, accRect.right);
    accRect.bottom = min2(rect.bottom, accRect.bottom);
    accRect.left = max2(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));
  return {
    width: clippingRect.right - clippingRect.left,
    height: clippingRect.bottom - clippingRect.top,
    x: clippingRect.left,
    y: clippingRect.top
  };
}
function getDimensions(element) {
  const {
    width,
    height
  } = getCssDimensions(element);
  return {
    width,
    height
  };
}
function getRectRelativeToOffsetParent(element, offsetParent, strategy) {
  const isOffsetParentAnElement = isHTMLElement2(offsetParent);
  const documentElement = getDocumentElement2(offsetParent);
  const isFixed = strategy === "fixed";
  const rect = getBoundingClientRect(element, true, isFixed, offsetParent);
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const offsets = createCoords(0);
  function setLeftRTLScrollbarOffset() {
    offsets.x = getWindowScrollBarX(documentElement);
  }
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName2(offsetParent) !== "body" || isOverflowElement2(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isOffsetParentAnElement) {
      const offsetRect = getBoundingClientRect(offsetParent, true, isFixed, offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    } else if (documentElement) {
      setLeftRTLScrollbarOffset();
    }
  }
  if (isFixed && !isOffsetParentAnElement && documentElement) {
    setLeftRTLScrollbarOffset();
  }
  const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll) : createCoords(0);
  const x = rect.left + scroll.scrollLeft - offsets.x - htmlOffset.x;
  const y = rect.top + scroll.scrollTop - offsets.y - htmlOffset.y;
  return {
    x,
    y,
    width: rect.width,
    height: rect.height
  };
}
function isStaticPositioned(element) {
  return getComputedStyle3(element).position === "static";
}
function getTrueOffsetParent(element, polyfill) {
  if (!isHTMLElement2(element) || getComputedStyle3(element).position === "fixed") {
    return null;
  }
  if (polyfill) {
    return polyfill(element);
  }
  let rawOffsetParent = element.offsetParent;
  if (getDocumentElement2(element) === rawOffsetParent) {
    rawOffsetParent = rawOffsetParent.ownerDocument.body;
  }
  return rawOffsetParent;
}
function getOffsetParent(element, polyfill) {
  const win = getWindow2(element);
  if (isTopLayer(element)) {
    return win;
  }
  if (!isHTMLElement2(element)) {
    let svgOffsetParent = getParentNode2(element);
    while (svgOffsetParent && !isLastTraversableNode(svgOffsetParent)) {
      if (isElement(svgOffsetParent) && !isStaticPositioned(svgOffsetParent)) {
        return svgOffsetParent;
      }
      svgOffsetParent = getParentNode2(svgOffsetParent);
    }
    return win;
  }
  let offsetParent = getTrueOffsetParent(element, polyfill);
  while (offsetParent && isTableElement(offsetParent) && isStaticPositioned(offsetParent)) {
    offsetParent = getTrueOffsetParent(offsetParent, polyfill);
  }
  if (offsetParent && isLastTraversableNode(offsetParent) && isStaticPositioned(offsetParent) && !isContainingBlock(offsetParent)) {
    return win;
  }
  return offsetParent || getContainingBlock(element) || win;
}
var getElementRects = async function(data) {
  const getOffsetParentFn = this.getOffsetParent || getOffsetParent;
  const getDimensionsFn = this.getDimensions;
  const floatingDimensions = await getDimensionsFn(data.floating);
  return {
    reference: getRectRelativeToOffsetParent(data.reference, await getOffsetParentFn(data.floating), data.strategy),
    floating: {
      x: 0,
      y: 0,
      width: floatingDimensions.width,
      height: floatingDimensions.height
    }
  };
};
function isRTL2(element) {
  return getComputedStyle3(element).direction === "rtl";
}
var platform = {
  convertOffsetParentRelativeRectToViewportRelativeRect,
  getDocumentElement: getDocumentElement2,
  getClippingRect,
  getOffsetParent,
  getElementRects,
  getClientRects,
  getDimensions,
  getScale,
  isElement,
  isRTL: isRTL2
};
function rectsAreEqual(a2, b2) {
  return a2.x === b2.x && a2.y === b2.y && a2.width === b2.width && a2.height === b2.height;
}
function observeMove(element, onMove) {
  let io = null;
  let timeoutId;
  const root = getDocumentElement2(element);
  function cleanup() {
    var _io;
    clearTimeout(timeoutId);
    (_io = io) == null || _io.disconnect();
    io = null;
  }
  function refresh(skip, threshold) {
    if (skip === void 0) {
      skip = false;
    }
    if (threshold === void 0) {
      threshold = 1;
    }
    cleanup();
    const elementRectForRootMargin = element.getBoundingClientRect();
    const {
      left,
      top,
      width,
      height
    } = elementRectForRootMargin;
    if (!skip) {
      onMove();
    }
    if (!width || !height) {
      return;
    }
    const insetTop = floor2(top);
    const insetRight = floor2(root.clientWidth - (left + width));
    const insetBottom = floor2(root.clientHeight - (top + height));
    const insetLeft = floor2(left);
    const rootMargin = -insetTop + "px " + -insetRight + "px " + -insetBottom + "px " + -insetLeft + "px";
    const options = {
      rootMargin,
      threshold: max2(0, min2(1, threshold)) || 1
    };
    let isFirstUpdate = true;
    function handleObserve(entries) {
      const ratio = entries[0].intersectionRatio;
      if (ratio !== threshold) {
        if (!isFirstUpdate) {
          return refresh();
        }
        if (!ratio) {
          timeoutId = setTimeout(() => {
            refresh(false, 1e-7);
          }, 1e3);
        } else {
          refresh(false, ratio);
        }
      }
      if (ratio === 1 && !rectsAreEqual(elementRectForRootMargin, element.getBoundingClientRect())) {
        refresh();
      }
      isFirstUpdate = false;
    }
    try {
      io = new IntersectionObserver(handleObserve, {
        ...options,
        // Handle <iframe>s
        root: root.ownerDocument
      });
    } catch (_e7) {
      io = new IntersectionObserver(handleObserve, options);
    }
    io.observe(element);
  }
  refresh(true);
  return cleanup;
}
function autoUpdate(reference, floating, update, options) {
  if (options === void 0) {
    options = {};
  }
  const {
    ancestorScroll = true,
    ancestorResize = true,
    elementResize = typeof ResizeObserver === "function",
    layoutShift = typeof IntersectionObserver === "function",
    animationFrame = false
  } = options;
  const referenceEl = unwrapElement(reference);
  const ancestors = ancestorScroll || ancestorResize ? [...referenceEl ? getOverflowAncestors2(referenceEl) : [], ...getOverflowAncestors2(floating)] : [];
  ancestors.forEach((ancestor) => {
    ancestorScroll && ancestor.addEventListener("scroll", update, {
      passive: true
    });
    ancestorResize && ancestor.addEventListener("resize", update);
  });
  const cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update) : null;
  let reobserveFrame = -1;
  let resizeObserver = null;
  if (elementResize) {
    resizeObserver = new ResizeObserver((_ref) => {
      let [firstEntry] = _ref;
      if (firstEntry && firstEntry.target === referenceEl && resizeObserver) {
        resizeObserver.unobserve(floating);
        cancelAnimationFrame(reobserveFrame);
        reobserveFrame = requestAnimationFrame(() => {
          var _resizeObserver;
          (_resizeObserver = resizeObserver) == null || _resizeObserver.observe(floating);
        });
      }
      update();
    });
    if (referenceEl && !animationFrame) {
      resizeObserver.observe(referenceEl);
    }
    resizeObserver.observe(floating);
  }
  let frameId;
  let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;
  if (animationFrame) {
    frameLoop();
  }
  function frameLoop() {
    const nextRefRect = getBoundingClientRect(reference);
    if (prevRefRect && !rectsAreEqual(prevRefRect, nextRefRect)) {
      update();
    }
    prevRefRect = nextRefRect;
    frameId = requestAnimationFrame(frameLoop);
  }
  update();
  return () => {
    var _resizeObserver2;
    ancestors.forEach((ancestor) => {
      ancestorScroll && ancestor.removeEventListener("scroll", update);
      ancestorResize && ancestor.removeEventListener("resize", update);
    });
    cleanupIo == null || cleanupIo();
    (_resizeObserver2 = resizeObserver) == null || _resizeObserver2.disconnect();
    resizeObserver = null;
    if (animationFrame) {
      cancelAnimationFrame(frameId);
    }
  };
}
var offset2 = offset;
var shift2 = shift;
var flip2 = flip;
var size2 = size;
var hide2 = hide;
var arrow2 = arrow;
var limitShift2 = limitShift;
var computePosition2 = (reference, floating, options) => {
  const cache2 = /* @__PURE__ */ new Map();
  const mergedOptions = {
    platform,
    ...options
  };
  const platformWithCache = {
    ...mergedOptions.platform,
    _c: cache2
  };
  return computePosition(reference, floating, {
    ...mergedOptions,
    platform: platformWithCache
  });
};

// node_modules/@zag-js/popper/dist/index.mjs
function createDOMRect(x = 0, y = 0, width = 0, height = 0) {
  if (typeof DOMRect === "function") {
    return new DOMRect(x, y, width, height);
  }
  const rect = {
    x,
    y,
    width,
    height,
    top: y,
    right: x + width,
    bottom: y + height,
    left: x
  };
  return { ...rect, toJSON: () => rect };
}
function getDOMRect(anchorRect) {
  if (!anchorRect) return createDOMRect();
  const { x, y, width, height } = anchorRect;
  return createDOMRect(x, y, width, height);
}
function getAnchorElement(anchorElement, getAnchorRect) {
  return {
    contextElement: isHTMLElement(anchorElement) ? anchorElement : void 0,
    getBoundingClientRect: () => {
      const anchor = anchorElement;
      const anchorRect = getAnchorRect == null ? void 0 : getAnchorRect(anchor);
      if (anchorRect || !anchor) {
        return getDOMRect(anchorRect);
      }
      return anchor.getBoundingClientRect();
    }
  };
}
var toVar = (value) => ({ variable: value, reference: `var(${value})` });
var cssVars = {
  arrowSize: toVar("--arrow-size"),
  arrowSizeHalf: toVar("--arrow-size-half"),
  arrowBg: toVar("--arrow-background"),
  transformOrigin: toVar("--transform-origin"),
  arrowOffset: toVar("--arrow-offset")
};
var getTransformOrigin = (arrow22) => ({
  top: "bottom center",
  "top-start": arrow22 ? `${arrow22.x}px bottom` : "left bottom",
  "top-end": arrow22 ? `${arrow22.x}px bottom` : "right bottom",
  bottom: "top center",
  "bottom-start": arrow22 ? `${arrow22.x}px top` : "top left",
  "bottom-end": arrow22 ? `${arrow22.x}px top` : "top right",
  left: "right center",
  "left-start": arrow22 ? `right ${arrow22.y}px` : "right top",
  "left-end": arrow22 ? `right ${arrow22.y}px` : "right bottom",
  right: "left center",
  "right-start": arrow22 ? `left ${arrow22.y}px` : "left top",
  "right-end": arrow22 ? `left ${arrow22.y}px` : "left bottom"
});
var transformOriginMiddleware = {
  name: "transformOrigin",
  fn({ placement, elements, middlewareData }) {
    const { arrow: arrow22 } = middlewareData;
    const transformOrigin = getTransformOrigin(arrow22)[placement];
    const { floating } = elements;
    floating.style.setProperty(cssVars.transformOrigin.variable, transformOrigin);
    return {
      data: { transformOrigin }
    };
  }
};
var rectMiddleware = {
  name: "rects",
  fn({ rects }) {
    return {
      data: rects
    };
  }
};
var shiftArrowMiddleware = (arrowEl) => {
  if (!arrowEl) return;
  return {
    name: "shiftArrow",
    fn({ placement, middlewareData }) {
      if (!middlewareData.arrow) return {};
      const { x, y } = middlewareData.arrow;
      const dir = placement.split("-")[0];
      Object.assign(arrowEl.style, {
        left: x != null ? `${x}px` : "",
        top: y != null ? `${y}px` : "",
        [dir]: `calc(100% + ${cssVars.arrowOffset.reference})`
      });
      return {};
    }
  };
};
function getPlacementDetails(placement) {
  const [side, align] = placement.split("-");
  return { side, align, hasAlign: align != null };
}
function getPlacementSide(placement) {
  return placement.split("-")[0];
}
var defaultOptions = {
  strategy: "absolute",
  placement: "bottom",
  listeners: true,
  gutter: 8,
  flip: true,
  slide: true,
  overlap: false,
  sameWidth: false,
  fitViewport: false,
  overflowPadding: 8,
  arrowPadding: 4
};
function roundByDpr(win, value) {
  const dpr = win.devicePixelRatio || 1;
  return Math.round(value * dpr) / dpr;
}
function getBoundaryMiddleware(opts) {
  return runIfFn(opts.boundary);
}
function getArrowMiddleware(arrowElement, opts) {
  if (!arrowElement) return;
  return arrow2({
    element: arrowElement,
    padding: opts.arrowPadding
  });
}
function getOffsetMiddleware(arrowElement, opts) {
  if (isNull(opts.offset ?? opts.gutter)) return;
  return offset2(({ placement }) => {
    var _a8, _b7;
    const arrowOffset = ((arrowElement == null ? void 0 : arrowElement.clientHeight) || 0) / 2;
    const gutter = ((_a8 = opts.offset) == null ? void 0 : _a8.mainAxis) ?? opts.gutter;
    const mainAxis = typeof gutter === "number" ? gutter + arrowOffset : gutter ?? arrowOffset;
    const { hasAlign } = getPlacementDetails(placement);
    const shift22 = !hasAlign ? opts.shift : void 0;
    const crossAxis = ((_b7 = opts.offset) == null ? void 0 : _b7.crossAxis) ?? shift22;
    return compact2({
      crossAxis,
      mainAxis,
      alignmentAxis: opts.shift
    });
  });
}
function getFlipMiddleware(opts) {
  if (!opts.flip) return;
  return flip2({
    boundary: getBoundaryMiddleware(opts),
    padding: opts.overflowPadding,
    fallbackPlacements: opts.flip === true ? void 0 : opts.flip
  });
}
function getShiftMiddleware(opts) {
  if (!opts.slide && !opts.overlap) return;
  return shift2({
    boundary: getBoundaryMiddleware(opts),
    mainAxis: opts.slide,
    crossAxis: opts.overlap,
    padding: opts.overflowPadding,
    limiter: limitShift2()
  });
}
function getSizeMiddleware(opts) {
  return size2({
    padding: opts.overflowPadding,
    apply({ elements, rects, availableHeight, availableWidth }) {
      const floating = elements.floating;
      const referenceWidth = Math.round(rects.reference.width);
      availableWidth = Math.floor(availableWidth);
      availableHeight = Math.floor(availableHeight);
      floating.style.setProperty("--reference-width", `${referenceWidth}px`);
      floating.style.setProperty("--available-width", `${availableWidth}px`);
      floating.style.setProperty("--available-height", `${availableHeight}px`);
    }
  });
}
function hideWhenDetachedMiddleware(opts) {
  var _a8;
  if (!opts.hideWhenDetached) return;
  return hide2({ strategy: "referenceHidden", boundary: ((_a8 = opts.boundary) == null ? void 0 : _a8.call(opts)) ?? "clippingAncestors" });
}
function getAutoUpdateOptions(opts) {
  if (!opts) return {};
  if (opts === true) {
    return { ancestorResize: true, ancestorScroll: true, elementResize: true, layoutShift: true };
  }
  return opts;
}
function getPlacementImpl(referenceOrVirtual, floating, opts = {}) {
  const reference = getAnchorElement(referenceOrVirtual, opts.getAnchorRect);
  if (!floating || !reference) return;
  const options = Object.assign({}, defaultOptions, opts);
  const arrowEl = floating.querySelector("[data-part=arrow]");
  const middleware = [
    getOffsetMiddleware(arrowEl, options),
    getFlipMiddleware(options),
    getShiftMiddleware(options),
    getArrowMiddleware(arrowEl, options),
    shiftArrowMiddleware(arrowEl),
    transformOriginMiddleware,
    getSizeMiddleware(options),
    hideWhenDetachedMiddleware(options),
    rectMiddleware
  ];
  const { placement, strategy, onComplete, onPositioned } = options;
  const updatePosition = async () => {
    var _a8;
    if (!reference || !floating) return;
    const pos = await computePosition2(reference, floating, {
      placement,
      middleware,
      strategy
    });
    onComplete == null ? void 0 : onComplete(pos);
    onPositioned == null ? void 0 : onPositioned({ placed: true });
    const win = getWindow(floating);
    const x = roundByDpr(win, pos.x);
    const y = roundByDpr(win, pos.y);
    floating.style.setProperty("--x", `${x}px`);
    floating.style.setProperty("--y", `${y}px`);
    if (options.hideWhenDetached) {
      const isHidden = (_a8 = pos.middlewareData.hide) == null ? void 0 : _a8.referenceHidden;
      if (isHidden) {
        floating.style.setProperty("visibility", "hidden");
        floating.style.setProperty("pointer-events", "none");
      } else {
        floating.style.removeProperty("visibility");
        floating.style.removeProperty("pointer-events");
      }
    }
    const contentEl = floating.firstElementChild;
    if (contentEl) {
      const styles = getComputedStyle2(contentEl);
      floating.style.setProperty("--z-index", styles.zIndex);
    }
  };
  const update = async () => {
    if (opts.updatePosition) {
      await opts.updatePosition({ updatePosition });
      onPositioned == null ? void 0 : onPositioned({ placed: true });
    } else {
      await updatePosition();
    }
  };
  const autoUpdateOptions = getAutoUpdateOptions(options.listeners);
  const cancelAutoUpdate = options.listeners ? autoUpdate(reference, floating, update, autoUpdateOptions) : noop;
  update();
  return () => {
    cancelAutoUpdate == null ? void 0 : cancelAutoUpdate();
    onPositioned == null ? void 0 : onPositioned({ placed: false });
  };
}
function getPlacement(referenceOrFn, floatingOrFn, opts = {}) {
  const { defer, ...options } = opts;
  const func = defer ? raf : (v) => v();
  const cleanups = [];
  cleanups.push(
    func(() => {
      const reference = typeof referenceOrFn === "function" ? referenceOrFn() : referenceOrFn;
      const floating = typeof floatingOrFn === "function" ? floatingOrFn() : floatingOrFn;
      cleanups.push(getPlacementImpl(reference, floating, options));
    })
  );
  return () => {
    cleanups.forEach((fn) => fn == null ? void 0 : fn());
  };
}
var ARROW_FLOATING_STYLE = {
  bottom: "rotate(45deg)",
  left: "rotate(135deg)",
  top: "rotate(225deg)",
  right: "rotate(315deg)"
};
function getPlacementStyles(options = {}) {
  const { placement, sameWidth, fitViewport, strategy = "absolute" } = options;
  return {
    arrow: {
      position: "absolute",
      width: cssVars.arrowSize.reference,
      height: cssVars.arrowSize.reference,
      [cssVars.arrowSizeHalf.variable]: `calc(${cssVars.arrowSize.reference} / 2)`,
      [cssVars.arrowOffset.variable]: `calc(${cssVars.arrowSizeHalf.reference} * -1)`
    },
    arrowTip: {
      // @ts-expect-error - Fix this
      transform: placement ? ARROW_FLOATING_STYLE[placement.split("-")[0]] : void 0,
      background: cssVars.arrowBg.reference,
      top: "0",
      left: "0",
      width: "100%",
      height: "100%",
      position: "absolute",
      zIndex: "inherit"
    },
    floating: {
      position: strategy,
      isolation: "isolate",
      minWidth: sameWidth ? void 0 : "max-content",
      width: sameWidth ? "var(--reference-width)" : void 0,
      maxWidth: fitViewport ? "var(--available-width)" : void 0,
      maxHeight: fitViewport ? "var(--available-height)" : void 0,
      pointerEvents: !placement ? "none" : void 0,
      top: "0px",
      left: "0px",
      // move off-screen if placement is not defined
      transform: placement ? "translate3d(var(--x), var(--y), 0)" : "translate3d(0, -100vh, 0)",
      zIndex: "var(--z-index)"
    }
  };
}

// node_modules/@zag-js/interact-outside/dist/index.mjs
function getWindowFrames(win) {
  const frames = {
    each(cb) {
      var _a8;
      for (let i = 0; i < ((_a8 = win.frames) == null ? void 0 : _a8.length); i += 1) {
        const frame = win.frames[i];
        if (frame) cb(frame);
      }
    },
    addEventListener(event, listener, options) {
      frames.each((frame) => {
        try {
          frame.document.addEventListener(event, listener, options);
        } catch {
        }
      });
      return () => {
        try {
          frames.removeEventListener(event, listener, options);
        } catch {
        }
      };
    },
    removeEventListener(event, listener, options) {
      frames.each((frame) => {
        try {
          frame.document.removeEventListener(event, listener, options);
        } catch {
        }
      });
    }
  };
  return frames;
}
function getParentWindow(win) {
  const parent = win.frameElement != null ? win.parent : null;
  return {
    addEventListener: (event, listener, options) => {
      try {
        parent == null ? void 0 : parent.addEventListener(event, listener, options);
      } catch {
      }
      return () => {
        try {
          parent == null ? void 0 : parent.removeEventListener(event, listener, options);
        } catch {
        }
      };
    },
    removeEventListener: (event, listener, options) => {
      try {
        parent == null ? void 0 : parent.removeEventListener(event, listener, options);
      } catch {
      }
    }
  };
}
var POINTER_OUTSIDE_EVENT = "pointerdown.outside";
var FOCUS_OUTSIDE_EVENT = "focus.outside";
function isComposedPathFocusable(composedPath) {
  for (const node of composedPath) {
    if (isHTMLElement(node) && isFocusable(node)) return true;
  }
  return false;
}
var isPointerEvent = (event) => "clientY" in event;
function isEventPointWithin(node, event) {
  if (!isPointerEvent(event) || !node) return false;
  const rect = node.getBoundingClientRect();
  if (rect.width === 0 || rect.height === 0) return false;
  return rect.top <= event.clientY && event.clientY <= rect.top + rect.height && rect.left <= event.clientX && event.clientX <= rect.left + rect.width;
}
function isPointInRect(rect, point) {
  return rect.y <= point.y && point.y <= rect.y + rect.height && rect.x <= point.x && point.x <= rect.x + rect.width;
}
function isEventWithinScrollbar(event, ancestor) {
  if (!ancestor || !isPointerEvent(event)) return false;
  const isScrollableY = ancestor.scrollHeight > ancestor.clientHeight;
  const onScrollbarY = isScrollableY && event.clientX > ancestor.offsetLeft + ancestor.clientWidth;
  const isScrollableX = ancestor.scrollWidth > ancestor.clientWidth;
  const onScrollbarX = isScrollableX && event.clientY > ancestor.offsetTop + ancestor.clientHeight;
  const rect = {
    x: ancestor.offsetLeft,
    y: ancestor.offsetTop,
    width: ancestor.clientWidth + (isScrollableY ? 16 : 0),
    height: ancestor.clientHeight + (isScrollableX ? 16 : 0)
  };
  const point = {
    x: event.clientX,
    y: event.clientY
  };
  if (!isPointInRect(rect, point)) return false;
  return onScrollbarY || onScrollbarX;
}
function trackInteractOutsideImpl(node, options) {
  const { exclude, onFocusOutside, onPointerDownOutside, onInteractOutside, defer } = options;
  if (!node) return;
  const doc = getDocument(node);
  const win = getWindow(node);
  const frames = getWindowFrames(win);
  const parentWin = getParentWindow(win);
  function isEventOutside(event, target) {
    if (!isHTMLElement(target)) return false;
    if (!target.isConnected) return false;
    if (contains(node, target)) return false;
    if (isEventPointWithin(node, event)) return false;
    const triggerEl = doc.querySelector(`[aria-controls="${node.id}"]`);
    if (triggerEl) {
      const triggerAncestor = getNearestOverflowAncestor(triggerEl);
      if (isEventWithinScrollbar(event, triggerAncestor)) return false;
    }
    const nodeAncestor = getNearestOverflowAncestor(node);
    if (isEventWithinScrollbar(event, nodeAncestor)) return false;
    return !(exclude == null ? void 0 : exclude(target));
  }
  const pointerdownCleanups = /* @__PURE__ */ new Set();
  const isInShadowRoot = isShadowRoot(node == null ? void 0 : node.getRootNode());
  function onPointerDown(event) {
    function handler(clickEvent) {
      var _a8;
      const func = defer && !isTouchDevice() ? raf : (v) => v();
      const evt = clickEvent ?? event;
      const composedPath = ((_a8 = evt == null ? void 0 : evt.composedPath) == null ? void 0 : _a8.call(evt)) ?? [evt == null ? void 0 : evt.target];
      func(() => {
        const target = isInShadowRoot ? composedPath[0] : getEventTarget(event);
        if (!node || !isEventOutside(event, target)) return;
        if (onPointerDownOutside || onInteractOutside) {
          const handler2 = callAll2(onPointerDownOutside, onInteractOutside);
          node.addEventListener(POINTER_OUTSIDE_EVENT, handler2, { once: true });
        }
        fireCustomEvent(node, POINTER_OUTSIDE_EVENT, {
          bubbles: false,
          cancelable: true,
          detail: {
            originalEvent: evt,
            contextmenu: isContextMenuEvent(evt),
            focusable: isComposedPathFocusable(composedPath),
            target
          }
        });
      });
    }
    if (event.pointerType === "touch") {
      pointerdownCleanups.forEach((fn) => fn());
      pointerdownCleanups.add(addDomEvent(doc, "click", handler, { once: true }));
      pointerdownCleanups.add(parentWin.addEventListener("click", handler, { once: true }));
      pointerdownCleanups.add(frames.addEventListener("click", handler, { once: true }));
    } else {
      handler();
    }
  }
  const cleanups = /* @__PURE__ */ new Set();
  const timer = setTimeout(() => {
    cleanups.add(addDomEvent(doc, "pointerdown", onPointerDown, true));
    cleanups.add(parentWin.addEventListener("pointerdown", onPointerDown, true));
    cleanups.add(frames.addEventListener("pointerdown", onPointerDown, true));
  }, 0);
  function onFocusin(event) {
    const func = defer ? raf : (v) => v();
    func(() => {
      const target = getEventTarget(event);
      if (!node || !isEventOutside(event, target)) return;
      if (onFocusOutside || onInteractOutside) {
        const handler = callAll2(onFocusOutside, onInteractOutside);
        node.addEventListener(FOCUS_OUTSIDE_EVENT, handler, { once: true });
      }
      fireCustomEvent(node, FOCUS_OUTSIDE_EVENT, {
        bubbles: false,
        cancelable: true,
        detail: {
          originalEvent: event,
          contextmenu: false,
          focusable: isFocusable(target),
          target
        }
      });
    });
  }
  if (!isTouchDevice()) {
    cleanups.add(addDomEvent(doc, "focusin", onFocusin, true));
    cleanups.add(parentWin.addEventListener("focusin", onFocusin, true));
    cleanups.add(frames.addEventListener("focusin", onFocusin, true));
  }
  return () => {
    clearTimeout(timer);
    pointerdownCleanups.forEach((fn) => fn());
    cleanups.forEach((fn) => fn());
  };
}
function trackInteractOutside(nodeOrFn, options) {
  const { defer } = options;
  const func = defer ? raf : (v) => v();
  const cleanups = [];
  cleanups.push(
    func(() => {
      const node = typeof nodeOrFn === "function" ? nodeOrFn() : nodeOrFn;
      cleanups.push(trackInteractOutsideImpl(node, options));
    })
  );
  return () => {
    cleanups.forEach((fn) => fn == null ? void 0 : fn());
  };
}
function fireCustomEvent(el, type, init) {
  const win = el.ownerDocument.defaultView || window;
  const event = new win.CustomEvent(type, init);
  return el.dispatchEvent(event);
}

// node_modules/@zag-js/dismissable/dist/index.mjs
function trackEscapeKeydown(node, fn) {
  const handleKeyDown = (event) => {
    if (event.key !== "Escape") return;
    if (event.isComposing) return;
    fn == null ? void 0 : fn(event);
  };
  return addDomEvent(getDocument(node), "keydown", handleKeyDown, { capture: true });
}
var layerStack = {
  layers: [],
  branches: [],
  count() {
    return this.layers.length;
  },
  pointerBlockingLayers() {
    return this.layers.filter((layer) => layer.pointerBlocking);
  },
  topMostPointerBlockingLayer() {
    return [...this.pointerBlockingLayers()].slice(-1)[0];
  },
  hasPointerBlockingLayer() {
    return this.pointerBlockingLayers().length > 0;
  },
  isBelowPointerBlockingLayer(node) {
    var _a8;
    const index = this.indexOf(node);
    const highestBlockingIndex = this.topMostPointerBlockingLayer() ? this.indexOf((_a8 = this.topMostPointerBlockingLayer()) == null ? void 0 : _a8.node) : -1;
    return index < highestBlockingIndex;
  },
  isTopMost(node) {
    const layer = this.layers[this.count() - 1];
    return (layer == null ? void 0 : layer.node) === node;
  },
  getNestedLayers(node) {
    return Array.from(this.layers).slice(this.indexOf(node) + 1);
  },
  isInNestedLayer(node, target) {
    return this.getNestedLayers(node).some((layer) => contains(layer.node, target));
  },
  isInBranch(target) {
    return Array.from(this.branches).some((branch) => contains(branch, target));
  },
  add(layer) {
    const num = this.layers.push(layer);
    layer.node.style.setProperty("--layer-index", `${num}`);
  },
  addBranch(node) {
    this.branches.push(node);
  },
  remove(node) {
    const index = this.indexOf(node);
    if (index < 0) return;
    if (index < this.count() - 1) {
      const _layers = this.getNestedLayers(node);
      _layers.forEach((layer) => layer.dismiss());
    }
    this.layers.splice(index, 1);
    node.style.removeProperty("--layer-index");
  },
  removeBranch(node) {
    const index = this.branches.indexOf(node);
    if (index >= 0) this.branches.splice(index, 1);
  },
  indexOf(node) {
    return this.layers.findIndex((layer) => layer.node === node);
  },
  dismiss(node) {
    var _a8;
    (_a8 = this.layers[this.indexOf(node)]) == null ? void 0 : _a8.dismiss();
  },
  clear() {
    this.remove(this.layers[0].node);
  }
};
var originalBodyPointerEvents;
function assignPointerEventToLayers() {
  layerStack.layers.forEach(({ node }) => {
    node.style.pointerEvents = layerStack.isBelowPointerBlockingLayer(node) ? "none" : "auto";
  });
}
function clearPointerEvent(node) {
  node.style.pointerEvents = "";
}
function disablePointerEventsOutside(node, persistentElements) {
  const doc = getDocument(node);
  const cleanups = [];
  if (layerStack.hasPointerBlockingLayer() && !doc.body.hasAttribute("data-inert")) {
    originalBodyPointerEvents = document.body.style.pointerEvents;
    queueMicrotask(() => {
      doc.body.style.pointerEvents = "none";
      doc.body.setAttribute("data-inert", "");
    });
  }
  if (persistentElements) {
    const persistedCleanup = waitForElements(persistentElements, (el) => {
      cleanups.push(setStyle(el, { pointerEvents: "auto" }));
    });
    cleanups.push(persistedCleanup);
  }
  return () => {
    if (layerStack.hasPointerBlockingLayer()) return;
    queueMicrotask(() => {
      doc.body.style.pointerEvents = originalBodyPointerEvents;
      doc.body.removeAttribute("data-inert");
      if (doc.body.style.length === 0) doc.body.removeAttribute("style");
    });
    cleanups.forEach((fn) => fn());
  };
}
function trackDismissableElementImpl(node, options) {
  const { warnOnMissingNode = true } = options;
  if (warnOnMissingNode && !node) {
    warn("[@zag-js/dismissable] node is `null` or `undefined`");
    return;
  }
  if (!node) {
    return;
  }
  const { onDismiss, pointerBlocking, exclude: excludeContainers, debug } = options;
  const layer = { dismiss: onDismiss, node, pointerBlocking };
  layerStack.add(layer);
  assignPointerEventToLayers();
  function onPointerDownOutside(event) {
    var _a8, _b7;
    const target = getEventTarget(event.detail.originalEvent);
    if (layerStack.isBelowPointerBlockingLayer(node) || layerStack.isInBranch(target)) return;
    (_a8 = options.onPointerDownOutside) == null ? void 0 : _a8.call(options, event);
    (_b7 = options.onInteractOutside) == null ? void 0 : _b7.call(options, event);
    if (event.defaultPrevented) return;
    if (debug) {
      console.log("onPointerDownOutside:", event.detail.originalEvent);
    }
    onDismiss == null ? void 0 : onDismiss();
  }
  function onFocusOutside(event) {
    var _a8, _b7;
    const target = getEventTarget(event.detail.originalEvent);
    if (layerStack.isInBranch(target)) return;
    (_a8 = options.onFocusOutside) == null ? void 0 : _a8.call(options, event);
    (_b7 = options.onInteractOutside) == null ? void 0 : _b7.call(options, event);
    if (event.defaultPrevented) return;
    if (debug) {
      console.log("onFocusOutside:", event.detail.originalEvent);
    }
    onDismiss == null ? void 0 : onDismiss();
  }
  function onEscapeKeyDown(event) {
    var _a8;
    if (!layerStack.isTopMost(node)) return;
    (_a8 = options.onEscapeKeyDown) == null ? void 0 : _a8.call(options, event);
    if (!event.defaultPrevented && onDismiss) {
      event.preventDefault();
      onDismiss();
    }
  }
  function exclude(target) {
    var _a8;
    if (!node) return false;
    const containers = typeof excludeContainers === "function" ? excludeContainers() : excludeContainers;
    const _containers = Array.isArray(containers) ? containers : [containers];
    const persistentElements = (_a8 = options.persistentElements) == null ? void 0 : _a8.map((fn) => fn()).filter(isHTMLElement);
    if (persistentElements) _containers.push(...persistentElements);
    return _containers.some((node2) => contains(node2, target)) || layerStack.isInNestedLayer(node, target);
  }
  const cleanups = [
    pointerBlocking ? disablePointerEventsOutside(node, options.persistentElements) : void 0,
    trackEscapeKeydown(node, onEscapeKeyDown),
    trackInteractOutside(node, { exclude, onFocusOutside, onPointerDownOutside, defer: options.defer })
  ];
  return () => {
    layerStack.remove(node);
    assignPointerEventToLayers();
    clearPointerEvent(node);
    cleanups.forEach((fn) => fn == null ? void 0 : fn());
  };
}
function trackDismissableElement(nodeOrFn, options) {
  const { defer } = options;
  const func = defer ? raf : (v) => v();
  const cleanups = [];
  cleanups.push(
    func(() => {
      const node = isFunction2(nodeOrFn) ? nodeOrFn() : nodeOrFn;
      cleanups.push(trackDismissableElementImpl(node, options));
    })
  );
  return () => {
    cleanups.forEach((fn) => fn == null ? void 0 : fn());
  };
}
function trackDismissableBranch(nodeOrFn, options = {}) {
  const { defer } = options;
  const func = defer ? raf : (v) => v();
  const cleanups = [];
  cleanups.push(
    func(() => {
      const node = isFunction2(nodeOrFn) ? nodeOrFn() : nodeOrFn;
      if (!node) {
        warn("[@zag-js/dismissable] branch node is `null` or `undefined`");
        return;
      }
      layerStack.addBranch(node);
      cleanups.push(() => {
        layerStack.removeBranch(node);
      });
    })
  );
  return () => {
    cleanups.forEach((fn) => fn == null ? void 0 : fn());
  };
}

// node_modules/@zag-js/color-picker/dist/index.mjs
var anatomy2 = createAnatomy("color-picker", [
  "root",
  "label",
  "control",
  "trigger",
  "positioner",
  "content",
  "area",
  "areaThumb",
  "valueText",
  "areaBackground",
  "channelSlider",
  "channelSliderLabel",
  "channelSliderTrack",
  "channelSliderThumb",
  "channelSliderValueText",
  "channelInput",
  "transparencyGrid",
  "swatchGroup",
  "swatchTrigger",
  "swatchIndicator",
  "swatch",
  "eyeDropperTrigger",
  "formatTrigger",
  "formatSelect"
]);
var parts2 = anatomy2.build();
var getRootId2 = (ctx) => {
  var _a8;
  return ((_a8 = ctx.ids) == null ? void 0 : _a8.root) ?? `color-picker:${ctx.id}`;
};
var getLabelId = (ctx) => {
  var _a8;
  return ((_a8 = ctx.ids) == null ? void 0 : _a8.label) ?? `color-picker:${ctx.id}:label`;
};
var getHiddenInputId = (ctx) => {
  var _a8;
  return ((_a8 = ctx.ids) == null ? void 0 : _a8.hiddenInput) ?? `color-picker:${ctx.id}:hidden-input`;
};
var getControlId = (ctx) => {
  var _a8;
  return ((_a8 = ctx.ids) == null ? void 0 : _a8.control) ?? `color-picker:${ctx.id}:control`;
};
var getTriggerId2 = (ctx) => {
  var _a8;
  return ((_a8 = ctx.ids) == null ? void 0 : _a8.trigger) ?? `color-picker:${ctx.id}:trigger`;
};
var getContentId2 = (ctx) => {
  var _a8;
  return ((_a8 = ctx.ids) == null ? void 0 : _a8.content) ?? `color-picker:${ctx.id}:content`;
};
var getPositionerId = (ctx) => {
  var _a8;
  return ((_a8 = ctx.ids) == null ? void 0 : _a8.positioner) ?? `color-picker:${ctx.id}:positioner`;
};
var getFormatSelectId = (ctx) => {
  var _a8;
  return ((_a8 = ctx.ids) == null ? void 0 : _a8.formatSelect) ?? `color-picker:${ctx.id}:format-select`;
};
var getAreaId = (ctx) => {
  var _a8;
  return ((_a8 = ctx.ids) == null ? void 0 : _a8.area) ?? `color-picker:${ctx.id}:area`;
};
var getAreaGradientId = (ctx) => {
  var _a8;
  return ((_a8 = ctx.ids) == null ? void 0 : _a8.areaGradient) ?? `color-picker:${ctx.id}:area-gradient`;
};
var getAreaThumbId = (ctx) => {
  var _a8;
  return ((_a8 = ctx.ids) == null ? void 0 : _a8.areaThumb) ?? `color-picker:${ctx.id}:area-thumb`;
};
var getChannelSliderTrackId = (ctx, channel) => {
  var _a8, _b7;
  return ((_b7 = (_a8 = ctx.ids) == null ? void 0 : _a8.channelSliderTrack) == null ? void 0 : _b7.call(_a8, channel)) ?? `color-picker:${ctx.id}:slider-track:${channel}`;
};
var getChannelSliderThumbId = (ctx, channel) => {
  var _a8, _b7;
  return ((_b7 = (_a8 = ctx.ids) == null ? void 0 : _a8.channelSliderThumb) == null ? void 0 : _b7.call(_a8, channel)) ?? `color-picker:${ctx.id}:slider-thumb:${channel}`;
};
var getContentEl2 = (ctx) => ctx.getById(getContentId2(ctx));
var getAreaThumbEl = (ctx) => ctx.getById(getAreaThumbId(ctx));
var getChannelSliderThumbEl = (ctx, channel) => ctx.getById(getChannelSliderThumbId(ctx, channel));
var getFormatSelectEl = (ctx) => ctx.getById(getFormatSelectId(ctx));
var getHiddenInputEl = (ctx) => ctx.getById(getHiddenInputId(ctx));
var getAreaEl = (ctx) => ctx.getById(getAreaId(ctx));
var getAreaValueFromPoint = (ctx, point) => {
  const areaEl = getAreaEl(ctx);
  if (!areaEl) return;
  const { percent } = getRelativePoint(point, areaEl);
  return percent;
};
var getControlEl = (ctx) => ctx.getById(getControlId(ctx));
var getTriggerEl = (ctx) => ctx.getById(getTriggerId2(ctx));
var getPositionerEl = (ctx) => ctx.getById(getPositionerId(ctx));
var getChannelSliderTrackEl = (ctx, channel) => ctx.getById(getChannelSliderTrackId(ctx, channel));
var getChannelSliderValueFromPoint = (ctx, point, channel) => {
  const trackEl = getChannelSliderTrackEl(ctx, channel);
  if (!trackEl) return;
  const { percent } = getRelativePoint(point, trackEl);
  return percent;
};
var getChannelInputEls = (ctx) => {
  return [
    ...queryAll(getContentEl2(ctx), "input[data-channel]"),
    ...queryAll(getControlEl(ctx), "input[data-channel]")
  ];
};
function getChannelDisplayColor(color, channel) {
  switch (channel) {
    case "hue":
      return parseColor(`hsl(${color.getChannelValue("hue")}, 100%, 50%)`);
    case "lightness":
    case "brightness":
    case "saturation":
    case "red":
    case "green":
    case "blue":
      return color.withChannelValue("alpha", 1);
    case "alpha": {
      return color;
    }
    default:
      throw new Error("Unknown color channel: " + channel);
  }
}
function getChannelValue(color, channel) {
  if (channel == null) return "";
  if (channel === "hex") {
    return color.toString("hex");
  }
  if (channel === "css") {
    return color.toString("css");
  }
  if (channel in color) {
    return color.getChannelValue(channel).toString();
  }
  const isHSL = color.getFormat() === "hsla";
  switch (channel) {
    case "hue":
      return isHSL ? color.toFormat("hsla").getChannelValue("hue").toString() : color.toFormat("hsba").getChannelValue("hue").toString();
    case "saturation":
      return isHSL ? color.toFormat("hsla").getChannelValue("saturation").toString() : color.toFormat("hsba").getChannelValue("saturation").toString();
    case "lightness":
      return color.toFormat("hsla").getChannelValue("lightness").toString();
    case "brightness":
      return color.toFormat("hsba").getChannelValue("brightness").toString();
    case "red":
    case "green":
    case "blue":
      return color.toFormat("rgba").getChannelValue(channel).toString();
    default:
      return color.getChannelValue(channel).toString();
  }
}
function getChannelRange(color, channel) {
  switch (channel) {
    case "hex":
      const minColor = parseColor("#000000");
      const maxColor = parseColor("#FFFFFF");
      return {
        minValue: minColor.toHexInt(),
        maxValue: maxColor.toHexInt(),
        pageSize: 10,
        step: 1
      };
    case "css":
      return void 0;
    case "hue":
    case "saturation":
    case "lightness":
      return color.toFormat("hsla").getChannelRange(channel);
    case "brightness":
      return color.toFormat("hsba").getChannelRange(channel);
    case "red":
    case "green":
    case "blue":
      return color.toFormat("rgba").getChannelRange(channel);
    default:
      return color.getChannelRange(channel);
  }
}
function getSliderBackgroundDirection(orientation, dir) {
  if (orientation === "vertical") {
    return "top";
  } else if (dir === "ltr") {
    return "right";
  } else {
    return "left";
  }
}
var getSliderBackground = (props210) => {
  const { channel, value, dir, orientation } = props210;
  const bgDirection = getSliderBackgroundDirection(orientation, dir);
  const { minValue, maxValue: maxValue2 } = value.getChannelRange(channel);
  switch (channel) {
    case "hue":
      return `linear-gradient(to ${bgDirection}, rgb(255, 0, 0) 0%, rgb(255, 255, 0) 17%, rgb(0, 255, 0) 33%, rgb(0, 255, 255) 50%, rgb(0, 0, 255) 67%, rgb(255, 0, 255) 83%, rgb(255, 0, 0) 100%)`;
    case "lightness": {
      let start = value.withChannelValue(channel, minValue).toString("css");
      let middle = value.withChannelValue(channel, (maxValue2 - minValue) / 2).toString("css");
      let end = value.withChannelValue(channel, maxValue2).toString("css");
      return `linear-gradient(to ${bgDirection}, ${start}, ${middle}, ${end})`;
    }
    case "saturation":
    case "brightness":
    case "red":
    case "green":
    case "blue":
    case "alpha": {
      let start = value.withChannelValue(channel, minValue).toString("css");
      let end = value.withChannelValue(channel, maxValue2).toString("css");
      return `linear-gradient(to ${bgDirection}, ${start}, ${end})`;
    }
    default:
      throw new Error("Unknown color channel: " + channel);
  }
};
function connect3(service, normalize4) {
  const { context, send, prop, computed, state: state2, scope } = service;
  const value = context.get("value");
  const format = context.get("format");
  const areaValue = computed("areaValue");
  const valueAsString = computed("valueAsString");
  const disabled = computed("disabled");
  const interactive = computed("interactive");
  const dragging = state2.hasTag("dragging");
  const open = state2.hasTag("open");
  const focused = state2.hasTag("focused");
  const getAreaChannels = (props210) => {
    const channels = areaValue.getChannels();
    return {
      xChannel: props210.xChannel ?? channels[1],
      yChannel: props210.yChannel ?? channels[2]
    };
  };
  const currentPlacement = context.get("currentPlacement");
  const popperStyles = getPlacementStyles({
    ...prop("positioning"),
    placement: currentPlacement
  });
  function getSwatchTriggerState(props210) {
    const color = normalizeColor(props210.value).toFormat(context.get("format"));
    return {
      value: color,
      valueAsString: color.toString("hex"),
      checked: color.isEqual(value),
      disabled: props210.disabled || !interactive
    };
  }
  return {
    dragging,
    open,
    valueAsString,
    value,
    setOpen(nextOpen) {
      const open2 = state2.hasTag("open");
      if (open2 === nextOpen) return;
      send({ type: nextOpen ? "OPEN" : "CLOSE" });
    },
    setValue(value2) {
      send({ type: "VALUE.SET", value: normalizeColor(value2), src: "set-color" });
    },
    getChannelValue(channel) {
      return getChannelValue(value, channel);
    },
    getChannelValueText(channel, locale) {
      return value.formatChannelValue(channel, locale);
    },
    setChannelValue(channel, channelValue) {
      const color = value.withChannelValue(channel, channelValue);
      send({ type: "VALUE.SET", value: color, src: "set-channel" });
    },
    format: context.get("format"),
    setFormat(format2) {
      const formatValue2 = value.toFormat(format2);
      send({ type: "VALUE.SET", value: formatValue2, src: "set-format" });
    },
    alpha: value.getChannelValue("alpha"),
    setAlpha(alphaValue) {
      const color = value.withChannelValue("alpha", alphaValue);
      send({ type: "VALUE.SET", value: color, src: "set-alpha" });
    },
    getRootProps() {
      return normalize4.element({
        ...parts2.root.attrs,
        dir: prop("dir"),
        id: getRootId2(scope),
        "data-disabled": dataAttr(disabled),
        "data-readonly": dataAttr(prop("readOnly")),
        "data-invalid": dataAttr(prop("invalid")),
        style: {
          "--value": value.toString("css")
        }
      });
    },
    getLabelProps() {
      return normalize4.element({
        ...parts2.label.attrs,
        dir: prop("dir"),
        id: getLabelId(scope),
        htmlFor: getHiddenInputId(scope),
        "data-disabled": dataAttr(disabled),
        "data-readonly": dataAttr(prop("readOnly")),
        "data-invalid": dataAttr(prop("invalid")),
        "data-focus": dataAttr(focused),
        onClick(event) {
          event.preventDefault();
          const inputEl = query(getControlEl(scope), "[data-channel=hex]");
          inputEl == null ? void 0 : inputEl.focus({ preventScroll: true });
        }
      });
    },
    getControlProps() {
      return normalize4.element({
        ...parts2.control.attrs,
        id: getControlId(scope),
        dir: prop("dir"),
        "data-disabled": dataAttr(disabled),
        "data-readonly": dataAttr(prop("readOnly")),
        "data-invalid": dataAttr(prop("invalid")),
        "data-state": open ? "open" : "closed",
        "data-focus": dataAttr(focused)
      });
    },
    getTriggerProps() {
      return normalize4.button({
        ...parts2.trigger.attrs,
        id: getTriggerId2(scope),
        dir: prop("dir"),
        disabled,
        "aria-label": `select color. current color is ${valueAsString}`,
        "aria-controls": getContentId2(scope),
        "aria-labelledby": getLabelId(scope),
        "data-disabled": dataAttr(disabled),
        "data-readonly": dataAttr(prop("readOnly")),
        "data-invalid": dataAttr(prop("invalid")),
        "data-placement": currentPlacement,
        "aria-expanded": dataAttr(open),
        "data-state": open ? "open" : "closed",
        "data-focus": dataAttr(focused),
        type: "button",
        onClick() {
          if (!interactive) return;
          send({ type: "TRIGGER.CLICK" });
        },
        onBlur() {
          if (!interactive) return;
          send({ type: "TRIGGER.BLUR" });
        },
        style: {
          position: "relative"
        }
      });
    },
    getPositionerProps() {
      return normalize4.element({
        ...parts2.positioner.attrs,
        id: getPositionerId(scope),
        dir: prop("dir"),
        style: popperStyles.floating
      });
    },
    getContentProps() {
      return normalize4.element({
        ...parts2.content.attrs,
        id: getContentId2(scope),
        dir: prop("dir"),
        tabIndex: -1,
        "data-placement": currentPlacement,
        "data-state": open ? "open" : "closed",
        hidden: !open
      });
    },
    getValueTextProps() {
      return normalize4.element({
        ...parts2.valueText.attrs,
        dir: prop("dir"),
        "data-disabled": dataAttr(disabled),
        "data-focus": dataAttr(focused)
      });
    },
    getAreaProps(props210 = {}) {
      const { xChannel, yChannel } = getAreaChannels(props210);
      const { areaStyles } = getColorAreaGradient(areaValue, {
        xChannel,
        yChannel,
        dir: prop("dir")
      });
      return normalize4.element({
        ...parts2.area.attrs,
        id: getAreaId(scope),
        role: "group",
        "data-invalid": dataAttr(prop("invalid")),
        "data-disabled": dataAttr(disabled),
        "data-readonly": dataAttr(prop("readOnly")),
        onPointerDown(event) {
          if (!interactive) return;
          if (!isLeftClick(event)) return;
          if (isModifierKey(event)) return;
          const point = getEventPoint(event);
          const channel = { xChannel, yChannel };
          send({ type: "AREA.POINTER_DOWN", point, channel, id: "area" });
          event.preventDefault();
        },
        style: {
          position: "relative",
          touchAction: "none",
          forcedColorAdjust: "none",
          ...areaStyles
        }
      });
    },
    getAreaBackgroundProps(props210 = {}) {
      const { xChannel, yChannel } = getAreaChannels(props210);
      const { areaGradientStyles } = getColorAreaGradient(areaValue, {
        xChannel,
        yChannel,
        dir: prop("dir")
      });
      return normalize4.element({
        ...parts2.areaBackground.attrs,
        id: getAreaGradientId(scope),
        "data-invalid": dataAttr(prop("invalid")),
        "data-disabled": dataAttr(disabled),
        "data-readonly": dataAttr(prop("readOnly")),
        style: {
          position: "relative",
          touchAction: "none",
          forcedColorAdjust: "none",
          ...areaGradientStyles
        }
      });
    },
    getAreaThumbProps(props210 = {}) {
      const { xChannel, yChannel } = getAreaChannels(props210);
      const channel = { xChannel, yChannel };
      const xPercent = areaValue.getChannelValuePercent(xChannel);
      const yPercent = 1 - areaValue.getChannelValuePercent(yChannel);
      const xValue = areaValue.getChannelValue(xChannel);
      const yValue = areaValue.getChannelValue(yChannel);
      const color = areaValue.withChannelValue("alpha", 1).toString("css");
      return normalize4.element({
        ...parts2.areaThumb.attrs,
        id: getAreaThumbId(scope),
        dir: prop("dir"),
        tabIndex: disabled ? void 0 : 0,
        "data-disabled": dataAttr(disabled),
        "data-invalid": dataAttr(prop("invalid")),
        "data-readonly": dataAttr(prop("readOnly")),
        role: "slider",
        "aria-valuemin": 0,
        "aria-valuemax": 100,
        "aria-valuenow": xValue,
        "aria-label": `${xChannel} and ${yChannel}`,
        "aria-roledescription": "2d slider",
        "aria-valuetext": `${xChannel} ${xValue}, ${yChannel} ${yValue}`,
        style: {
          position: "absolute",
          left: `${xPercent * 100}%`,
          top: `${yPercent * 100}%`,
          transform: "translate(-50%, -50%)",
          touchAction: "none",
          forcedColorAdjust: "none",
          "--color": color,
          background: color
        },
        onFocus() {
          if (!interactive) return;
          send({ type: "AREA.FOCUS", id: "area", channel });
        },
        onKeyDown(event) {
          if (event.defaultPrevented) return;
          if (!interactive) return;
          const step = getEventStep(event);
          const keyMap2 = {
            ArrowUp() {
              send({ type: "AREA.ARROW_UP", channel, step });
            },
            ArrowDown() {
              send({ type: "AREA.ARROW_DOWN", channel, step });
            },
            ArrowLeft() {
              send({ type: "AREA.ARROW_LEFT", channel, step });
            },
            ArrowRight() {
              send({ type: "AREA.ARROW_RIGHT", channel, step });
            },
            PageUp() {
              send({ type: "AREA.PAGE_UP", channel, step });
            },
            PageDown() {
              send({ type: "AREA.PAGE_DOWN", channel, step });
            },
            Escape(event2) {
              event2.stopPropagation();
            }
          };
          const exec = keyMap2[getEventKey(event, {
            dir: prop("dir")
          })];
          if (exec) {
            exec(event);
            event.preventDefault();
          }
        }
      });
    },
    getTransparencyGridProps(props210 = {}) {
      const { size: size3 = "12px" } = props210;
      return normalize4.element({
        ...parts2.transparencyGrid.attrs,
        style: {
          "--size": size3,
          width: "100%",
          height: "100%",
          position: "absolute",
          backgroundColor: "#fff",
          backgroundImage: "conic-gradient(#eeeeee 0 25%, transparent 0 50%, #eeeeee 0 75%, transparent 0)",
          backgroundSize: "var(--size) var(--size)",
          inset: "0px",
          zIndex: "auto",
          pointerEvents: "none"
        }
      });
    },
    getChannelSliderProps(props210) {
      const { orientation = "horizontal", channel, format: format2 } = props210;
      return normalize4.element({
        ...parts2.channelSlider.attrs,
        "data-channel": channel,
        "data-orientation": orientation,
        role: "presentation",
        onPointerDown(event) {
          if (!interactive) return;
          if (!isLeftClick(event)) return;
          if (isModifierKey(event)) return;
          const point = getEventPoint(event);
          send({ type: "CHANNEL_SLIDER.POINTER_DOWN", channel, format: format2, point, id: channel, orientation });
          event.preventDefault();
        },
        style: {
          position: "relative",
          touchAction: "none"
        }
      });
    },
    getChannelSliderTrackProps(props210) {
      const { orientation = "horizontal", channel, format: format2 } = props210;
      const normalizedValue = format2 ? value.toFormat(format2) : areaValue;
      return normalize4.element({
        ...parts2.channelSliderTrack.attrs,
        id: getChannelSliderTrackId(scope, channel),
        role: "group",
        "data-channel": channel,
        "data-orientation": orientation,
        style: {
          position: "relative",
          forcedColorAdjust: "none",
          backgroundImage: getSliderBackground({
            orientation,
            channel,
            dir: prop("dir"),
            value: normalizedValue
          })
        }
      });
    },
    getChannelSliderLabelProps(props210) {
      const { channel } = props210;
      return normalize4.element({
        ...parts2.channelSliderLabel.attrs,
        "data-channel": channel,
        onClick(event) {
          var _a8;
          if (!interactive) return;
          event.preventDefault();
          const thumbId = getChannelSliderThumbId(scope, channel);
          (_a8 = scope.getById(thumbId)) == null ? void 0 : _a8.focus({ preventScroll: true });
        },
        style: {
          userSelect: "none",
          WebkitUserSelect: "none"
        }
      });
    },
    getChannelSliderValueTextProps(props210) {
      return normalize4.element({
        ...parts2.channelSliderValueText.attrs,
        "data-channel": props210.channel
      });
    },
    getChannelSliderThumbProps(props210) {
      const { orientation = "horizontal", channel, format: format2 } = props210;
      const normalizedValue = format2 ? value.toFormat(format2) : areaValue;
      const channelRange = normalizedValue.getChannelRange(channel);
      const channelValue = normalizedValue.getChannelValue(channel);
      const offset4 = (channelValue - channelRange.minValue) / (channelRange.maxValue - channelRange.minValue);
      const placementStyles = orientation === "horizontal" ? { left: `${offset4 * 100}%`, top: "50%" } : { top: `${offset4 * 100}%`, left: "50%" };
      return normalize4.element({
        ...parts2.channelSliderThumb.attrs,
        id: getChannelSliderThumbId(scope, channel),
        role: "slider",
        "aria-label": channel,
        tabIndex: disabled ? void 0 : 0,
        "data-channel": channel,
        "data-disabled": dataAttr(disabled),
        "data-orientation": orientation,
        "aria-disabled": dataAttr(disabled),
        "aria-orientation": orientation,
        "aria-valuemax": channelRange.maxValue,
        "aria-valuemin": channelRange.minValue,
        "aria-valuenow": channelValue,
        "aria-valuetext": `${channel} ${channelValue}`,
        style: {
          forcedColorAdjust: "none",
          position: "absolute",
          background: getChannelDisplayColor(areaValue, channel).toString("css"),
          ...placementStyles
        },
        onFocus() {
          if (!interactive) return;
          send({ type: "CHANNEL_SLIDER.FOCUS", channel });
        },
        onKeyDown(event) {
          if (event.defaultPrevented) return;
          if (!interactive) return;
          const step = getEventStep(event) * channelRange.step;
          const keyMap2 = {
            ArrowUp() {
              send({ type: "CHANNEL_SLIDER.ARROW_UP", channel, step });
            },
            ArrowDown() {
              send({ type: "CHANNEL_SLIDER.ARROW_DOWN", channel, step });
            },
            ArrowLeft() {
              send({ type: "CHANNEL_SLIDER.ARROW_LEFT", channel, step });
            },
            ArrowRight() {
              send({ type: "CHANNEL_SLIDER.ARROW_RIGHT", channel, step });
            },
            PageUp() {
              send({ type: "CHANNEL_SLIDER.PAGE_UP", channel });
            },
            PageDown() {
              send({ type: "CHANNEL_SLIDER.PAGE_DOWN", channel });
            },
            Home() {
              send({ type: "CHANNEL_SLIDER.HOME", channel });
            },
            End() {
              send({ type: "CHANNEL_SLIDER.END", channel });
            },
            Escape(event2) {
              event2.stopPropagation();
            }
          };
          const exec = keyMap2[getEventKey(event, {
            dir: prop("dir")
          })];
          if (exec) {
            exec(event);
            event.preventDefault();
          }
        }
      });
    },
    getChannelInputProps(props210) {
      const { channel } = props210;
      const isTextField = channel === "hex" || channel === "css";
      const channelRange = getChannelRange(value, channel);
      return normalize4.input({
        ...parts2.channelInput.attrs,
        dir: prop("dir"),
        type: isTextField ? "text" : "number",
        "data-channel": channel,
        "aria-label": channel,
        spellCheck: false,
        autoComplete: "off",
        disabled,
        "data-disabled": dataAttr(disabled),
        "data-invalid": dataAttr(prop("invalid")),
        "data-readonly": dataAttr(prop("readOnly")),
        readOnly: prop("readOnly"),
        defaultValue: getChannelValue(value, channel),
        min: channelRange == null ? void 0 : channelRange.minValue,
        max: channelRange == null ? void 0 : channelRange.maxValue,
        step: channelRange == null ? void 0 : channelRange.step,
        onBeforeInput(event) {
          if (isTextField || !interactive) return;
          const value2 = event.currentTarget.value;
          if (value2.match(/[^0-9.]/g)) {
            event.preventDefault();
          }
        },
        onFocus(event) {
          if (!interactive) return;
          send({ type: "CHANNEL_INPUT.FOCUS", channel });
          event.currentTarget.select();
        },
        onBlur(event) {
          if (!interactive) return;
          const value2 = isTextField ? event.currentTarget.value : event.currentTarget.valueAsNumber;
          send({ type: "CHANNEL_INPUT.BLUR", channel, value: value2, isTextField });
        },
        onKeyDown(event) {
          if (event.defaultPrevented) return;
          if (!interactive) return;
          if (event.key === "Enter") {
            const value2 = isTextField ? event.currentTarget.value : event.currentTarget.valueAsNumber;
            send({ type: "CHANNEL_INPUT.CHANGE", channel, value: value2, isTextField });
            event.preventDefault();
          }
        },
        style: {
          appearance: "none",
          WebkitAppearance: "none",
          MozAppearance: "textfield"
        }
      });
    },
    getHiddenInputProps() {
      return normalize4.input({
        type: "text",
        disabled,
        name: prop("name"),
        tabIndex: -1,
        readOnly: prop("readOnly"),
        required: prop("required"),
        id: getHiddenInputId(scope),
        style: visuallyHiddenStyle,
        defaultValue: valueAsString
      });
    },
    getEyeDropperTriggerProps() {
      return normalize4.button({
        ...parts2.eyeDropperTrigger.attrs,
        type: "button",
        dir: prop("dir"),
        disabled,
        "data-disabled": dataAttr(disabled),
        "data-invalid": dataAttr(prop("invalid")),
        "data-readonly": dataAttr(prop("readOnly")),
        "aria-label": "Pick a color from the screen",
        onClick() {
          if (!interactive) return;
          send({ type: "EYEDROPPER.CLICK" });
        }
      });
    },
    getSwatchGroupProps() {
      return normalize4.element({
        ...parts2.swatchGroup.attrs,
        role: "group"
      });
    },
    getSwatchTriggerState,
    getSwatchTriggerProps(props210) {
      const swatchState = getSwatchTriggerState(props210);
      return normalize4.button({
        ...parts2.swatchTrigger.attrs,
        disabled: swatchState.disabled,
        dir: prop("dir"),
        type: "button",
        "aria-label": `select ${swatchState.valueAsString} as the color`,
        "data-state": swatchState.checked ? "checked" : "unchecked",
        "data-value": swatchState.valueAsString,
        "data-disabled": dataAttr(swatchState.disabled),
        onClick() {
          if (swatchState.disabled) return;
          send({ type: "SWATCH_TRIGGER.CLICK", value: swatchState.value });
        },
        style: {
          "--color": swatchState.valueAsString,
          position: "relative"
        }
      });
    },
    getSwatchIndicatorProps(props210) {
      const swatchState = getSwatchTriggerState(props210);
      return normalize4.element({
        ...parts2.swatchIndicator.attrs,
        dir: prop("dir"),
        hidden: !swatchState.checked
      });
    },
    getSwatchProps(props210) {
      const { respectAlpha = true } = props210;
      const swatchState = getSwatchTriggerState(props210);
      const color = swatchState.value.toString(respectAlpha ? "css" : "hex");
      return normalize4.element({
        ...parts2.swatch.attrs,
        dir: prop("dir"),
        "data-state": swatchState.checked ? "checked" : "unchecked",
        "data-value": swatchState.valueAsString,
        style: {
          "--color": color,
          position: "relative",
          background: color
        }
      });
    },
    getFormatTriggerProps() {
      return normalize4.button({
        ...parts2.formatTrigger.attrs,
        dir: prop("dir"),
        type: "button",
        "aria-label": `change color format to ${getNextFormat(format)}`,
        onClick(event) {
          if (event.currentTarget.disabled) return;
          const nextFormat = getNextFormat(format);
          send({ type: "FORMAT.SET", format: nextFormat, src: "format-trigger" });
        }
      });
    },
    getFormatSelectProps() {
      return normalize4.select({
        ...parts2.formatSelect.attrs,
        "aria-label": "change color format",
        dir: prop("dir"),
        defaultValue: prop("format"),
        disabled,
        onChange(event) {
          const format2 = assertFormat(event.currentTarget.value);
          send({ type: "FORMAT.SET", format: format2, src: "format-select" });
        }
      });
    }
  };
}
var formats = ["hsba", "hsla", "rgba"];
var formatRegex = new RegExp(`^(${formats.join("|")})$`);
function getNextFormat(format) {
  const index = formats.indexOf(format);
  return formats[index + 1] ?? formats[0];
}
function assertFormat(format) {
  if (formatRegex.test(format)) return format;
  throw new Error(`Unsupported color format: ${format}`);
}
var parse = (colorString) => {
  return parseColor(colorString);
};
var { and } = createGuards();
var machine3 = createMachine({
  props({ props: props210 }) {
    return {
      dir: "ltr",
      defaultValue: parse("#000000"),
      defaultFormat: "rgba",
      openAutoFocus: true,
      ...props210,
      positioning: {
        placement: "bottom",
        ...props210.positioning
      }
    };
  },
  initialState({ prop }) {
    const open = prop("open") || prop("defaultOpen");
    return open ? "open" : "idle";
  },
  context({ prop, bindable, getContext }) {
    return {
      value: bindable(() => ({
        defaultValue: prop("defaultValue"),
        value: prop("value"),
        isEqual(a2, b2) {
          return a2.toString("css") === (b2 == null ? void 0 : b2.toString("css"));
        },
        hash(a2) {
          return a2.toString("css");
        },
        onChange(value) {
          var _a8;
          const ctx = getContext();
          const valueAsString = value.toString(ctx.get("format"));
          (_a8 = prop("onValueChange")) == null ? void 0 : _a8({ value, valueAsString });
        }
      })),
      format: bindable(() => ({
        defaultValue: prop("defaultFormat"),
        value: prop("format"),
        onChange(format) {
          var _a8;
          (_a8 = prop("onFormatChange")) == null ? void 0 : _a8({ format });
        }
      })),
      activeId: bindable(() => ({ defaultValue: null })),
      activeChannel: bindable(() => ({ defaultValue: null })),
      activeOrientation: bindable(() => ({ defaultValue: null })),
      fieldsetDisabled: bindable(() => ({ defaultValue: false })),
      restoreFocus: bindable(() => ({ defaultValue: true })),
      currentPlacement: bindable(() => ({
        defaultValue: void 0
      }))
    };
  },
  computed: {
    rtl: ({ prop }) => prop("dir") === "rtl",
    disabled: ({ prop, context }) => !!prop("disabled") || context.get("fieldsetDisabled"),
    interactive: ({ prop }) => !(prop("disabled") || prop("readOnly")),
    valueAsString: ({ context }) => context.get("value").toString(context.get("format")),
    areaValue: ({ context }) => {
      const format = context.get("format").startsWith("hsl") ? "hsla" : "hsba";
      return context.get("value").toFormat(format);
    }
  },
  effects: ["trackFormControl"],
  watch({ prop, context, action, track }) {
    track([() => context.hash("value")], () => {
      action(["syncInputElements", "dispatchChangeEvent"]);
    });
    track([() => context.get("format")], () => {
      action(["syncFormatSelectElement"]);
    });
    track([() => prop("open")], () => {
      action(["toggleVisibility"]);
    });
  },
  on: {
    "VALUE.SET": {
      actions: ["setValue"]
    },
    "FORMAT.SET": {
      actions: ["setFormat"]
    },
    "CHANNEL_INPUT.CHANGE": {
      actions: ["setChannelColorFromInput"]
    },
    "EYEDROPPER.CLICK": {
      actions: ["openEyeDropper"]
    },
    "SWATCH_TRIGGER.CLICK": {
      actions: ["setValue"]
    }
  },
  states: {
    idle: {
      tags: ["closed"],
      on: {
        "CONTROLLED.OPEN": {
          target: "open",
          actions: ["setInitialFocus"]
        },
        OPEN: [
          {
            guard: "isOpenControlled",
            actions: ["invokeOnOpen"]
          },
          {
            target: "open",
            actions: ["invokeOnOpen", "setInitialFocus"]
          }
        ],
        "TRIGGER.CLICK": [
          {
            guard: "isOpenControlled",
            actions: ["invokeOnOpen"]
          },
          {
            target: "open",
            actions: ["invokeOnOpen", "setInitialFocus"]
          }
        ],
        "CHANNEL_INPUT.FOCUS": {
          target: "focused",
          actions: ["setActiveChannel"]
        }
      }
    },
    focused: {
      tags: ["closed", "focused"],
      on: {
        "CONTROLLED.OPEN": {
          target: "open",
          actions: ["setInitialFocus"]
        },
        OPEN: [
          {
            guard: "isOpenControlled",
            actions: ["invokeOnOpen"]
          },
          {
            target: "open",
            actions: ["invokeOnOpen", "setInitialFocus"]
          }
        ],
        "TRIGGER.CLICK": [
          {
            guard: "isOpenControlled",
            actions: ["invokeOnOpen"]
          },
          {
            target: "open",
            actions: ["invokeOnOpen", "setInitialFocus"]
          }
        ],
        "CHANNEL_INPUT.FOCUS": {
          actions: ["setActiveChannel"]
        },
        "CHANNEL_INPUT.BLUR": {
          target: "idle",
          actions: ["setChannelColorFromInput"]
        },
        "TRIGGER.BLUR": {
          target: "idle"
        }
      }
    },
    open: {
      tags: ["open"],
      effects: ["trackPositioning", "trackDismissableElement"],
      on: {
        "CONTROLLED.CLOSE": [
          {
            guard: "shouldRestoreFocus",
            target: "focused",
            actions: ["setReturnFocus"]
          },
          {
            target: "idle"
          }
        ],
        "TRIGGER.CLICK": [
          {
            guard: "isOpenControlled",
            actions: ["invokeOnClose"]
          },
          {
            target: "idle",
            actions: ["invokeOnClose"]
          }
        ],
        "AREA.POINTER_DOWN": {
          target: "open:dragging",
          actions: ["setActiveChannel", "setAreaColorFromPoint", "focusAreaThumb"]
        },
        "AREA.FOCUS": {
          actions: ["setActiveChannel"]
        },
        "CHANNEL_SLIDER.POINTER_DOWN": {
          target: "open:dragging",
          actions: ["setActiveChannel", "setChannelColorFromPoint", "focusChannelThumb"]
        },
        "CHANNEL_SLIDER.FOCUS": {
          actions: ["setActiveChannel"]
        },
        "AREA.ARROW_LEFT": {
          actions: ["decrementAreaXChannel"]
        },
        "AREA.ARROW_RIGHT": {
          actions: ["incrementAreaXChannel"]
        },
        "AREA.ARROW_UP": {
          actions: ["incrementAreaYChannel"]
        },
        "AREA.ARROW_DOWN": {
          actions: ["decrementAreaYChannel"]
        },
        "AREA.PAGE_UP": {
          actions: ["incrementAreaXChannel"]
        },
        "AREA.PAGE_DOWN": {
          actions: ["decrementAreaXChannel"]
        },
        "CHANNEL_SLIDER.ARROW_LEFT": {
          actions: ["decrementChannel"]
        },
        "CHANNEL_SLIDER.ARROW_RIGHT": {
          actions: ["incrementChannel"]
        },
        "CHANNEL_SLIDER.ARROW_UP": {
          actions: ["incrementChannel"]
        },
        "CHANNEL_SLIDER.ARROW_DOWN": {
          actions: ["decrementChannel"]
        },
        "CHANNEL_SLIDER.PAGE_UP": {
          actions: ["incrementChannel"]
        },
        "CHANNEL_SLIDER.PAGE_DOWN": {
          actions: ["decrementChannel"]
        },
        "CHANNEL_SLIDER.HOME": {
          actions: ["setChannelToMin"]
        },
        "CHANNEL_SLIDER.END": {
          actions: ["setChannelToMax"]
        },
        "CHANNEL_INPUT.BLUR": {
          actions: ["setChannelColorFromInput"]
        },
        INTERACT_OUTSIDE: [
          {
            guard: "isOpenControlled",
            actions: ["invokeOnClose"]
          },
          {
            guard: "shouldRestoreFocus",
            target: "focused",
            actions: ["invokeOnClose", "setReturnFocus"]
          },
          {
            target: "idle",
            actions: ["invokeOnClose"]
          }
        ],
        CLOSE: [
          {
            guard: "isOpenControlled",
            actions: ["invokeOnClose"]
          },
          {
            target: "idle",
            actions: ["invokeOnClose"]
          }
        ],
        "SWATCH_TRIGGER.CLICK": [
          {
            guard: and("isOpenControlled", "closeOnSelect"),
            actions: ["setValue", "invokeOnClose"]
          },
          {
            guard: "closeOnSelect",
            target: "focused",
            actions: ["setValue", "invokeOnClose", "setReturnFocus"]
          },
          {
            actions: ["setValue"]
          }
        ]
      }
    },
    "open:dragging": {
      tags: ["open"],
      exit: ["clearActiveChannel"],
      effects: ["trackPointerMove", "disableTextSelection", "trackPositioning", "trackDismissableElement"],
      on: {
        "CONTROLLED.CLOSE": [
          {
            guard: "shouldRestoreFocus",
            target: "focused",
            actions: ["setReturnFocus"]
          },
          {
            target: "idle"
          }
        ],
        "AREA.POINTER_MOVE": {
          actions: ["setAreaColorFromPoint", "focusAreaThumb"]
        },
        "AREA.POINTER_UP": {
          target: "open",
          actions: ["invokeOnChangeEnd"]
        },
        "CHANNEL_SLIDER.POINTER_MOVE": {
          actions: ["setChannelColorFromPoint", "focusChannelThumb"]
        },
        "CHANNEL_SLIDER.POINTER_UP": {
          target: "open",
          actions: ["invokeOnChangeEnd"]
        },
        INTERACT_OUTSIDE: [
          {
            guard: "isOpenControlled",
            actions: ["invokeOnClose"]
          },
          {
            guard: "shouldRestoreFocus",
            target: "focused",
            actions: ["invokeOnClose", "setReturnFocus"]
          },
          {
            target: "idle",
            actions: ["invokeOnClose"]
          }
        ],
        CLOSE: [
          {
            guard: "isOpenControlled",
            actions: ["invokeOnClose"]
          },
          {
            target: "idle",
            actions: ["invokeOnClose"]
          }
        ]
      }
    }
  },
  implementations: {
    guards: {
      closeOnSelect: ({ prop }) => !!prop("closeOnSelect"),
      isOpenControlled: ({ prop }) => prop("open") != null,
      shouldRestoreFocus: ({ context }) => !!context.get("restoreFocus")
    },
    effects: {
      trackPositioning({ context, prop, scope }) {
        var _a8;
        if (!context.get("currentPlacement")) {
          context.set("currentPlacement", (_a8 = prop("positioning")) == null ? void 0 : _a8.placement);
        }
        const anchorEl = getTriggerEl(scope);
        const getPositionerEl22 = () => getPositionerEl(scope);
        return getPlacement(anchorEl, getPositionerEl22, {
          ...prop("positioning"),
          defer: true,
          onComplete(data) {
            context.set("currentPlacement", data.placement);
          }
        });
      },
      trackDismissableElement({ context, scope, prop, send }) {
        const getContentEl22 = () => getContentEl2(scope);
        return trackDismissableElement(getContentEl22, {
          exclude: getTriggerEl(scope),
          defer: true,
          onInteractOutside(event) {
            var _a8;
            (_a8 = prop("onInteractOutside")) == null ? void 0 : _a8(event);
            if (event.defaultPrevented) return;
            context.set("restoreFocus", !(event.detail.focusable || event.detail.contextmenu));
          },
          onPointerDownOutside: prop("onPointerDownOutside"),
          onFocusOutside: prop("onFocusOutside"),
          onDismiss() {
            send({ type: "INTERACT_OUTSIDE" });
          }
        });
      },
      trackFormControl({ context, scope, send }) {
        const inputEl = getHiddenInputEl(scope);
        return trackFormControl(inputEl, {
          onFieldsetDisabledChange(disabled) {
            context.set("fieldsetDisabled", disabled);
          },
          onFormReset() {
            send({ type: "VALUE.SET", value: context.initial("value"), src: "form.reset" });
          }
        });
      },
      trackPointerMove({ context, scope, event, send }) {
        return trackPointerMove(scope.getDoc(), {
          onPointerMove({ point }) {
            const type = context.get("activeId") === "area" ? "AREA.POINTER_MOVE" : "CHANNEL_SLIDER.POINTER_MOVE";
            send({ type, point, format: event.format });
          },
          onPointerUp() {
            const type = context.get("activeId") === "area" ? "AREA.POINTER_UP" : "CHANNEL_SLIDER.POINTER_UP";
            send({ type });
          }
        });
      },
      disableTextSelection({ scope }) {
        return disableTextSelection({
          doc: scope.getDoc(),
          target: getContentEl2(scope)
        });
      }
    },
    actions: {
      openEyeDropper({ scope, context }) {
        const win = scope.getWin();
        const isSupported = "EyeDropper" in win;
        if (!isSupported) return;
        const picker = new win.EyeDropper();
        picker.open().then(({ sRGBHex }) => {
          const format = context.get("value").getFormat();
          const color = parseColor(sRGBHex).toFormat(format);
          context.set("value", color);
        }).catch(() => void 0);
      },
      setActiveChannel({ context, event }) {
        context.set("activeId", event.id);
        if (event.channel) context.set("activeChannel", event.channel);
        if (event.orientation) context.set("activeOrientation", event.orientation);
      },
      clearActiveChannel({ context }) {
        context.set("activeChannel", null);
        context.set("activeId", null);
        context.set("activeOrientation", null);
      },
      setAreaColorFromPoint({ context, event, computed, scope }) {
        const v = event.format ? context.get("value").toFormat(event.format) : computed("areaValue");
        const { xChannel, yChannel } = event.channel || context.get("activeChannel");
        const percent = getAreaValueFromPoint(scope, event.point);
        if (!percent) return;
        const xValue = v.getChannelPercentValue(xChannel, percent.x);
        const yValue = v.getChannelPercentValue(yChannel, 1 - percent.y);
        const color = v.withChannelValue(xChannel, xValue).withChannelValue(yChannel, yValue);
        context.set("value", color);
      },
      setChannelColorFromPoint({ context, event, computed, scope }) {
        const channel = event.channel || context.get("activeId");
        const normalizedValue = event.format ? context.get("value").toFormat(event.format) : computed("areaValue");
        const percent = getChannelSliderValueFromPoint(scope, event.point, channel);
        if (!percent) return;
        const orientation = context.get("activeOrientation") || "horizontal";
        const channelPercent = orientation === "horizontal" ? percent.x : percent.y;
        const value = normalizedValue.getChannelPercentValue(channel, channelPercent);
        const color = normalizedValue.withChannelValue(channel, value);
        context.set("value", color);
      },
      setValue({ context, event }) {
        context.set("value", event.value);
      },
      setFormat({ context, event }) {
        context.set("format", event.format);
      },
      dispatchChangeEvent({ scope, computed }) {
        dispatchInputValueEvent(getHiddenInputEl(scope), { value: computed("valueAsString") });
      },
      syncInputElements({ context, scope }) {
        syncChannelInputs(scope, context.get("value"));
      },
      invokeOnChangeEnd({ context, prop, computed }) {
        var _a8;
        (_a8 = prop("onValueChangeEnd")) == null ? void 0 : _a8({
          value: context.get("value"),
          valueAsString: computed("valueAsString")
        });
      },
      setChannelColorFromInput({ context, event, scope, prop }) {
        var _a8;
        const { channel, isTextField, value } = event;
        const currentAlpha = context.get("value").getChannelValue("alpha");
        let color;
        if (channel === "alpha") {
          let valueAsNumber = parseFloat(value);
          valueAsNumber = Number.isNaN(valueAsNumber) ? currentAlpha : valueAsNumber;
          color = context.get("value").withChannelValue("alpha", valueAsNumber);
        } else if (isTextField) {
          color = tryCatch(
            () => parse(value).withChannelValue("alpha", currentAlpha),
            () => context.get("value")
          );
        } else {
          const current = context.get("value").toFormat(context.get("format"));
          const valueAsNumber = Number.isNaN(value) ? current.getChannelValue(channel) : value;
          color = current.withChannelValue(channel, valueAsNumber);
        }
        syncChannelInputs(scope, context.get("value"), color);
        context.set("value", color);
        (_a8 = prop("onValueChangeEnd")) == null ? void 0 : _a8({
          value: color,
          valueAsString: color.toString(context.get("format"))
        });
      },
      incrementChannel({ context, event }) {
        const color = context.get("value").incrementChannel(event.channel, event.step);
        context.set("value", color);
      },
      decrementChannel({ context, event }) {
        const color = context.get("value").decrementChannel(event.channel, event.step);
        context.set("value", color);
      },
      incrementAreaXChannel({ context, event, computed }) {
        const { xChannel } = event.channel;
        const color = computed("areaValue").incrementChannel(xChannel, event.step);
        context.set("value", color);
      },
      decrementAreaXChannel({ context, event, computed }) {
        const { xChannel } = event.channel;
        const color = computed("areaValue").decrementChannel(xChannel, event.step);
        context.set("value", color);
      },
      incrementAreaYChannel({ context, event, computed }) {
        const { yChannel } = event.channel;
        const color = computed("areaValue").incrementChannel(yChannel, event.step);
        context.set("value", color);
      },
      decrementAreaYChannel({ context, event, computed }) {
        const { yChannel } = event.channel;
        const color = computed("areaValue").decrementChannel(yChannel, event.step);
        context.set("value", color);
      },
      setChannelToMax({ context, event }) {
        const value = context.get("value");
        const range2 = value.getChannelRange(event.channel);
        const color = value.withChannelValue(event.channel, range2.maxValue);
        context.set("value", color);
      },
      setChannelToMin({ context, event }) {
        const value = context.get("value");
        const range2 = value.getChannelRange(event.channel);
        const color = value.withChannelValue(event.channel, range2.minValue);
        context.set("value", color);
      },
      focusAreaThumb({ scope }) {
        raf(() => {
          var _a8;
          (_a8 = getAreaThumbEl(scope)) == null ? void 0 : _a8.focus({ preventScroll: true });
        });
      },
      focusChannelThumb({ event, scope }) {
        raf(() => {
          var _a8;
          (_a8 = getChannelSliderThumbEl(scope, event.channel)) == null ? void 0 : _a8.focus({ preventScroll: true });
        });
      },
      setInitialFocus({ prop, scope }) {
        if (!prop("openAutoFocus")) return;
        raf(() => {
          const element = getInitialFocus({
            root: getContentEl2(scope),
            getInitialEl: prop("initialFocusEl")
          });
          element == null ? void 0 : element.focus({ preventScroll: true });
        });
      },
      setReturnFocus({ scope }) {
        raf(() => {
          var _a8;
          (_a8 = getTriggerEl(scope)) == null ? void 0 : _a8.focus({ preventScroll: true });
        });
      },
      syncFormatSelectElement({ context, scope }) {
        syncFormatSelect(scope, context.get("format"));
      },
      invokeOnOpen({ prop }) {
        var _a8;
        (_a8 = prop("onOpenChange")) == null ? void 0 : _a8({ open: true });
      },
      invokeOnClose({ prop }) {
        var _a8;
        (_a8 = prop("onOpenChange")) == null ? void 0 : _a8({ open: false });
      },
      toggleVisibility({ prop, event, send }) {
        send({ type: prop("open") ? "CONTROLLED.OPEN" : "CONTROLLED.CLOSE", previousEvent: event });
      }
    }
  }
});
function syncChannelInputs(scope, currentValue, nextValue) {
  const channelInputEls = getChannelInputEls(scope);
  raf(() => {
    channelInputEls.forEach((inputEl) => {
      const channel = inputEl.dataset.channel;
      setElementValue(inputEl, getChannelValue(nextValue || currentValue, channel));
    });
  });
}
function syncFormatSelect(scope, format) {
  const selectEl = getFormatSelectEl(scope);
  if (!selectEl) return;
  raf(() => setElementValue(selectEl, format));
}
var props3 = createProps()([
  "closeOnSelect",
  "dir",
  "disabled",
  "format",
  "defaultFormat",
  "getRootNode",
  "id",
  "ids",
  "initialFocusEl",
  "name",
  "positioning",
  "onFocusOutside",
  "onFormatChange",
  "onInteractOutside",
  "onOpenChange",
  "onPointerDownOutside",
  "onValueChange",
  "onValueChangeEnd",
  "defaultOpen",
  "open",
  "positioning",
  "required",
  "readOnly",
  "value",
  "defaultValue",
  "invalid",
  "openAutoFocus"
]);
var splitProps4 = createSplitProps(props3);
var areaProps = createProps()(["xChannel", "yChannel"]);
var splitAreaProps = createSplitProps(areaProps);
var channelProps = createProps()(["channel", "orientation"]);
var splitChannelProps = createSplitProps(channelProps);
var swatchTriggerProps = createProps()(["value", "disabled"]);
var splitSwatchTriggerProps = createSplitProps(swatchTriggerProps);
var swatchProps = createProps()(["value", "respectAlpha"]);
var splitSwatchProps = createSplitProps(swatchProps);
var transparencyGridProps = createProps()(["size"]);
var splitTransparencyGridProps = createSplitProps(transparencyGridProps);

// node_modules/@internationalized/date/dist/utils.mjs
function $2b4dce13dd5a17fa$export$842a2cf37af977e1(amount, numerator) {
  return amount - numerator * Math.floor(amount / numerator);
}

// node_modules/@internationalized/date/dist/GregorianCalendar.mjs
var $3b62074eb05584b2$var$EPOCH = 1721426;
function $3b62074eb05584b2$export$f297eb839006d339(era, year, month, day) {
  year = $3b62074eb05584b2$export$c36e0ecb2d4fa69d(era, year);
  let y1 = year - 1;
  let monthOffset = -2;
  if (month <= 2) monthOffset = 0;
  else if ($3b62074eb05584b2$export$553d7fa8e3805fc0(year)) monthOffset = -1;
  return $3b62074eb05584b2$var$EPOCH - 1 + 365 * y1 + Math.floor(y1 / 4) - Math.floor(y1 / 100) + Math.floor(y1 / 400) + Math.floor((367 * month - 362) / 12 + monthOffset + day);
}
function $3b62074eb05584b2$export$553d7fa8e3805fc0(year) {
  return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
}
function $3b62074eb05584b2$export$c36e0ecb2d4fa69d(era, year) {
  return era === "BC" ? 1 - year : year;
}
function $3b62074eb05584b2$export$4475b7e617eb123c(year) {
  let era = "AD";
  if (year <= 0) {
    era = "BC";
    year = 1 - year;
  }
  return [
    era,
    year
  ];
}
var $3b62074eb05584b2$var$daysInMonth = {
  standard: [
    31,
    28,
    31,
    30,
    31,
    30,
    31,
    31,
    30,
    31,
    30,
    31
  ],
  leapyear: [
    31,
    29,
    31,
    30,
    31,
    30,
    31,
    31,
    30,
    31,
    30,
    31
  ]
};
var $3b62074eb05584b2$export$80ee6245ec4f29ec = class {
  fromJulianDay(jd) {
    let jd0 = jd;
    let depoch = jd0 - $3b62074eb05584b2$var$EPOCH;
    let quadricent = Math.floor(depoch / 146097);
    let dqc = (0, $2b4dce13dd5a17fa$export$842a2cf37af977e1)(depoch, 146097);
    let cent = Math.floor(dqc / 36524);
    let dcent = (0, $2b4dce13dd5a17fa$export$842a2cf37af977e1)(dqc, 36524);
    let quad = Math.floor(dcent / 1461);
    let dquad = (0, $2b4dce13dd5a17fa$export$842a2cf37af977e1)(dcent, 1461);
    let yindex = Math.floor(dquad / 365);
    let extendedYear = quadricent * 400 + cent * 100 + quad * 4 + yindex + (cent !== 4 && yindex !== 4 ? 1 : 0);
    let [era, year] = $3b62074eb05584b2$export$4475b7e617eb123c(extendedYear);
    let yearDay = jd0 - $3b62074eb05584b2$export$f297eb839006d339(era, year, 1, 1);
    let leapAdj = 2;
    if (jd0 < $3b62074eb05584b2$export$f297eb839006d339(era, year, 3, 1)) leapAdj = 0;
    else if ($3b62074eb05584b2$export$553d7fa8e3805fc0(year)) leapAdj = 1;
    let month = Math.floor(((yearDay + leapAdj) * 12 + 373) / 367);
    let day = jd0 - $3b62074eb05584b2$export$f297eb839006d339(era, year, month, 1) + 1;
    return new (0, $35ea8db9cb2ccb90$export$99faa760c7908e4f)(era, year, month, day);
  }
  toJulianDay(date) {
    return $3b62074eb05584b2$export$f297eb839006d339(date.era, date.year, date.month, date.day);
  }
  getDaysInMonth(date) {
    return $3b62074eb05584b2$var$daysInMonth[$3b62074eb05584b2$export$553d7fa8e3805fc0(date.year) ? "leapyear" : "standard"][date.month - 1];
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  getMonthsInYear(date) {
    return 12;
  }
  getDaysInYear(date) {
    return $3b62074eb05584b2$export$553d7fa8e3805fc0(date.year) ? 366 : 365;
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  getYearsInEra(date) {
    return 9999;
  }
  getEras() {
    return [
      "BC",
      "AD"
    ];
  }
  isInverseEra(date) {
    return date.era === "BC";
  }
  balanceDate(date) {
    if (date.year <= 0) {
      date.era = date.era === "BC" ? "AD" : "BC";
      date.year = 1 - date.year;
    }
  }
  constructor() {
    this.identifier = "gregory";
  }
};

// node_modules/@internationalized/date/dist/weekStartData.mjs
var $2fe286d2fb449abb$export$7a5acbd77d414bd9 = {
  "001": 1,
  AD: 1,
  AE: 6,
  AF: 6,
  AI: 1,
  AL: 1,
  AM: 1,
  AN: 1,
  AR: 1,
  AT: 1,
  AU: 1,
  AX: 1,
  AZ: 1,
  BA: 1,
  BE: 1,
  BG: 1,
  BH: 6,
  BM: 1,
  BN: 1,
  BY: 1,
  CH: 1,
  CL: 1,
  CM: 1,
  CN: 1,
  CR: 1,
  CY: 1,
  CZ: 1,
  DE: 1,
  DJ: 6,
  DK: 1,
  DZ: 6,
  EC: 1,
  EE: 1,
  EG: 6,
  ES: 1,
  FI: 1,
  FJ: 1,
  FO: 1,
  FR: 1,
  GB: 1,
  GE: 1,
  GF: 1,
  GP: 1,
  GR: 1,
  HR: 1,
  HU: 1,
  IE: 1,
  IQ: 6,
  IR: 6,
  IS: 1,
  IT: 1,
  JO: 6,
  KG: 1,
  KW: 6,
  KZ: 1,
  LB: 1,
  LI: 1,
  LK: 1,
  LT: 1,
  LU: 1,
  LV: 1,
  LY: 6,
  MC: 1,
  MD: 1,
  ME: 1,
  MK: 1,
  MN: 1,
  MQ: 1,
  MV: 5,
  MY: 1,
  NL: 1,
  NO: 1,
  NZ: 1,
  OM: 6,
  PL: 1,
  QA: 6,
  RE: 1,
  RO: 1,
  RS: 1,
  RU: 1,
  SD: 6,
  SE: 1,
  SI: 1,
  SK: 1,
  SM: 1,
  SY: 6,
  TJ: 1,
  TM: 1,
  TR: 1,
  UA: 1,
  UY: 1,
  UZ: 1,
  VA: 1,
  VN: 1,
  XK: 1
};

// node_modules/@internationalized/date/dist/queries.mjs
function $14e0f24ef4ac5c92$export$ea39ec197993aef0(a2, b2) {
  b2 = (0, $11d87f3f76e88657$export$b4a036af3fc0b032)(b2, a2.calendar);
  return a2.era === b2.era && a2.year === b2.year && a2.month === b2.month && a2.day === b2.day;
}
function $14e0f24ef4ac5c92$export$91b62ebf2ba703ee(a2, b2) {
  return $14e0f24ef4ac5c92$export$dbc69fd56b53d5e(a2.calendar, b2.calendar) && $14e0f24ef4ac5c92$export$ea39ec197993aef0(a2, b2);
}
function $14e0f24ef4ac5c92$export$dbc69fd56b53d5e(a2, b2) {
  var _a_isEqual, _b_isEqual;
  var _a_isEqual1, _ref;
  return (_ref = (_a_isEqual1 = (_a_isEqual = a2.isEqual) === null || _a_isEqual === void 0 ? void 0 : _a_isEqual.call(a2, b2)) !== null && _a_isEqual1 !== void 0 ? _a_isEqual1 : (_b_isEqual = b2.isEqual) === null || _b_isEqual === void 0 ? void 0 : _b_isEqual.call(b2, a2)) !== null && _ref !== void 0 ? _ref : a2.identifier === b2.identifier;
}
function $14e0f24ef4ac5c92$export$629b0a497aa65267(date, timeZone) {
  return $14e0f24ef4ac5c92$export$ea39ec197993aef0(date, $14e0f24ef4ac5c92$export$d0bdf45af03a6ea3(timeZone));
}
var $14e0f24ef4ac5c92$var$DAY_MAP = {
  sun: 0,
  mon: 1,
  tue: 2,
  wed: 3,
  thu: 4,
  fri: 5,
  sat: 6
};
function $14e0f24ef4ac5c92$export$2061056d06d7cdf7(date, locale, firstDayOfWeek) {
  let julian = date.calendar.toJulianDay(date);
  let weekStart = firstDayOfWeek ? $14e0f24ef4ac5c92$var$DAY_MAP[firstDayOfWeek] : $14e0f24ef4ac5c92$var$getWeekStart(locale);
  let dayOfWeek = Math.ceil(julian + 1 - weekStart) % 7;
  if (dayOfWeek < 0) dayOfWeek += 7;
  return dayOfWeek;
}
function $14e0f24ef4ac5c92$export$461939dd4422153(timeZone) {
  return (0, $11d87f3f76e88657$export$1b96692a1ba042ac)(Date.now(), timeZone);
}
function $14e0f24ef4ac5c92$export$d0bdf45af03a6ea3(timeZone) {
  return (0, $11d87f3f76e88657$export$93522d1a439f3617)($14e0f24ef4ac5c92$export$461939dd4422153(timeZone));
}
function $14e0f24ef4ac5c92$export$68781ddf31c0090f(a2, b2) {
  return a2.calendar.toJulianDay(a2) - b2.calendar.toJulianDay(b2);
}
function $14e0f24ef4ac5c92$export$c19a80a9721b80f6(a2, b2) {
  return $14e0f24ef4ac5c92$var$timeToMs(a2) - $14e0f24ef4ac5c92$var$timeToMs(b2);
}
function $14e0f24ef4ac5c92$var$timeToMs(a2) {
  return a2.hour * 36e5 + a2.minute * 6e4 + a2.second * 1e3 + a2.millisecond;
}
var $14e0f24ef4ac5c92$var$localTimeZone = null;
function $14e0f24ef4ac5c92$export$aa8b41735afcabd2() {
  if ($14e0f24ef4ac5c92$var$localTimeZone == null) $14e0f24ef4ac5c92$var$localTimeZone = new Intl.DateTimeFormat().resolvedOptions().timeZone;
  return $14e0f24ef4ac5c92$var$localTimeZone;
}
function $14e0f24ef4ac5c92$export$a5a3b454ada2268e(date) {
  return date.subtract({
    days: date.day - 1
  });
}
function $14e0f24ef4ac5c92$export$a2258d9c4118825c(date) {
  return date.add({
    days: date.calendar.getDaysInMonth(date) - date.day
  });
}
function $14e0f24ef4ac5c92$export$f91e89d3d0406102(date) {
  return $14e0f24ef4ac5c92$export$a5a3b454ada2268e(date.subtract({
    months: date.month - 1
  }));
}
function $14e0f24ef4ac5c92$export$8b7aa55c66d5569e(date) {
  return $14e0f24ef4ac5c92$export$a2258d9c4118825c(date.add({
    months: date.calendar.getMonthsInYear(date) - date.month
  }));
}
function $14e0f24ef4ac5c92$export$42c81a444fbfb5d4(date, locale, firstDayOfWeek) {
  let dayOfWeek = $14e0f24ef4ac5c92$export$2061056d06d7cdf7(date, locale, firstDayOfWeek);
  return date.subtract({
    days: dayOfWeek
  });
}
function $14e0f24ef4ac5c92$export$ef8b6d9133084f4e(date, locale, firstDayOfWeek) {
  return $14e0f24ef4ac5c92$export$42c81a444fbfb5d4(date, locale, firstDayOfWeek).add({
    days: 6
  });
}
var $14e0f24ef4ac5c92$var$cachedRegions = /* @__PURE__ */ new Map();
function $14e0f24ef4ac5c92$var$getRegion(locale) {
  if (Intl.Locale) {
    let region = $14e0f24ef4ac5c92$var$cachedRegions.get(locale);
    if (!region) {
      region = new Intl.Locale(locale).maximize().region;
      if (region) $14e0f24ef4ac5c92$var$cachedRegions.set(locale, region);
    }
    return region;
  }
  let part = locale.split("-")[1];
  return part === "u" ? void 0 : part;
}
function $14e0f24ef4ac5c92$var$getWeekStart(locale) {
  let region = $14e0f24ef4ac5c92$var$getRegion(locale);
  return region ? (0, $2fe286d2fb449abb$export$7a5acbd77d414bd9)[region] || 0 : 0;
}
function $14e0f24ef4ac5c92$export$ccc1b2479e7dd654(date, locale, firstDayOfWeek) {
  let days = date.calendar.getDaysInMonth(date);
  return Math.ceil(($14e0f24ef4ac5c92$export$2061056d06d7cdf7($14e0f24ef4ac5c92$export$a5a3b454ada2268e(date), locale, firstDayOfWeek) + days) / 7);
}
function $14e0f24ef4ac5c92$export$5c333a116e949cdd(a2, b2) {
  if (a2 && b2) return a2.compare(b2) <= 0 ? a2 : b2;
  return a2 || b2;
}
function $14e0f24ef4ac5c92$export$a75f2bff57811055(a2, b2) {
  if (a2 && b2) return a2.compare(b2) >= 0 ? a2 : b2;
  return a2 || b2;
}
var $14e0f24ef4ac5c92$var$WEEKEND_DATA = {
  AF: [
    4,
    5
  ],
  AE: [
    5,
    6
  ],
  BH: [
    5,
    6
  ],
  DZ: [
    5,
    6
  ],
  EG: [
    5,
    6
  ],
  IL: [
    5,
    6
  ],
  IQ: [
    5,
    6
  ],
  IR: [
    5,
    5
  ],
  JO: [
    5,
    6
  ],
  KW: [
    5,
    6
  ],
  LY: [
    5,
    6
  ],
  OM: [
    5,
    6
  ],
  QA: [
    5,
    6
  ],
  SA: [
    5,
    6
  ],
  SD: [
    5,
    6
  ],
  SY: [
    5,
    6
  ],
  YE: [
    5,
    6
  ]
};
function $14e0f24ef4ac5c92$export$618d60ea299da42(date, locale) {
  let julian = date.calendar.toJulianDay(date);
  let dayOfWeek = Math.ceil(julian + 1) % 7;
  if (dayOfWeek < 0) dayOfWeek += 7;
  let region = $14e0f24ef4ac5c92$var$getRegion(locale);
  let [start, end] = $14e0f24ef4ac5c92$var$WEEKEND_DATA[region] || [
    6,
    0
  ];
  return dayOfWeek === start || dayOfWeek === end;
}

// node_modules/@internationalized/date/dist/conversion.mjs
function $11d87f3f76e88657$export$bd4fb2bc8bb06fb(date) {
  date = $11d87f3f76e88657$export$b4a036af3fc0b032(date, new (0, $3b62074eb05584b2$export$80ee6245ec4f29ec)());
  let year = (0, $3b62074eb05584b2$export$c36e0ecb2d4fa69d)(date.era, date.year);
  return $11d87f3f76e88657$var$epochFromParts(year, date.month, date.day, date.hour, date.minute, date.second, date.millisecond);
}
function $11d87f3f76e88657$var$epochFromParts(year, month, day, hour, minute, second, millisecond) {
  let date = /* @__PURE__ */ new Date();
  date.setUTCHours(hour, minute, second, millisecond);
  date.setUTCFullYear(year, month - 1, day);
  return date.getTime();
}
function $11d87f3f76e88657$export$59c99f3515d3493f(ms, timeZone) {
  if (timeZone === "UTC") return 0;
  if (ms > 0 && timeZone === (0, $14e0f24ef4ac5c92$export$aa8b41735afcabd2)()) return new Date(ms).getTimezoneOffset() * -6e4;
  let { year, month, day, hour, minute, second } = $11d87f3f76e88657$var$getTimeZoneParts(ms, timeZone);
  let utc = $11d87f3f76e88657$var$epochFromParts(year, month, day, hour, minute, second, 0);
  return utc - Math.floor(ms / 1e3) * 1e3;
}
var $11d87f3f76e88657$var$formattersByTimeZone = /* @__PURE__ */ new Map();
function $11d87f3f76e88657$var$getTimeZoneParts(ms, timeZone) {
  let formatter = $11d87f3f76e88657$var$formattersByTimeZone.get(timeZone);
  if (!formatter) {
    formatter = new Intl.DateTimeFormat("en-US", {
      timeZone,
      hour12: false,
      era: "short",
      year: "numeric",
      month: "numeric",
      day: "numeric",
      hour: "numeric",
      minute: "numeric",
      second: "numeric"
    });
    $11d87f3f76e88657$var$formattersByTimeZone.set(timeZone, formatter);
  }
  let parts46 = formatter.formatToParts(new Date(ms));
  let namedParts = {};
  for (let part of parts46) if (part.type !== "literal") namedParts[part.type] = part.value;
  return {
    // Firefox returns B instead of BC... https://bugzilla.mozilla.org/show_bug.cgi?id=1752253
    year: namedParts.era === "BC" || namedParts.era === "B" ? -namedParts.year + 1 : +namedParts.year,
    month: +namedParts.month,
    day: +namedParts.day,
    hour: namedParts.hour === "24" ? 0 : +namedParts.hour,
    minute: +namedParts.minute,
    second: +namedParts.second
  };
}
var $11d87f3f76e88657$var$DAYMILLIS = 864e5;
function $11d87f3f76e88657$var$getValidWallTimes(date, timeZone, earlier, later) {
  let found = earlier === later ? [
    earlier
  ] : [
    earlier,
    later
  ];
  return found.filter((absolute) => $11d87f3f76e88657$var$isValidWallTime(date, timeZone, absolute));
}
function $11d87f3f76e88657$var$isValidWallTime(date, timeZone, absolute) {
  let parts46 = $11d87f3f76e88657$var$getTimeZoneParts(absolute, timeZone);
  return date.year === parts46.year && date.month === parts46.month && date.day === parts46.day && date.hour === parts46.hour && date.minute === parts46.minute && date.second === parts46.second;
}
function $11d87f3f76e88657$export$5107c82f94518f5c(date, timeZone, disambiguation = "compatible") {
  let dateTime = $11d87f3f76e88657$export$b21e0b124e224484(date);
  if (timeZone === "UTC") return $11d87f3f76e88657$export$bd4fb2bc8bb06fb(dateTime);
  if (timeZone === (0, $14e0f24ef4ac5c92$export$aa8b41735afcabd2)() && disambiguation === "compatible") {
    dateTime = $11d87f3f76e88657$export$b4a036af3fc0b032(dateTime, new (0, $3b62074eb05584b2$export$80ee6245ec4f29ec)());
    let date2 = /* @__PURE__ */ new Date();
    let year = (0, $3b62074eb05584b2$export$c36e0ecb2d4fa69d)(dateTime.era, dateTime.year);
    date2.setFullYear(year, dateTime.month - 1, dateTime.day);
    date2.setHours(dateTime.hour, dateTime.minute, dateTime.second, dateTime.millisecond);
    return date2.getTime();
  }
  let ms = $11d87f3f76e88657$export$bd4fb2bc8bb06fb(dateTime);
  let offsetBefore = $11d87f3f76e88657$export$59c99f3515d3493f(ms - $11d87f3f76e88657$var$DAYMILLIS, timeZone);
  let offsetAfter = $11d87f3f76e88657$export$59c99f3515d3493f(ms + $11d87f3f76e88657$var$DAYMILLIS, timeZone);
  let valid = $11d87f3f76e88657$var$getValidWallTimes(dateTime, timeZone, ms - offsetBefore, ms - offsetAfter);
  if (valid.length === 1) return valid[0];
  if (valid.length > 1) switch (disambiguation) {
    // 'compatible' means 'earlier' for "fall back" transitions
    case "compatible":
    case "earlier":
      return valid[0];
    case "later":
      return valid[valid.length - 1];
    case "reject":
      throw new RangeError("Multiple possible absolute times found");
  }
  switch (disambiguation) {
    case "earlier":
      return Math.min(ms - offsetBefore, ms - offsetAfter);
    // 'compatible' means 'later' for "spring forward" transitions
    case "compatible":
    case "later":
      return Math.max(ms - offsetBefore, ms - offsetAfter);
    case "reject":
      throw new RangeError("No such absolute time found");
  }
}
function $11d87f3f76e88657$export$e67a095c620b86fe(dateTime, timeZone, disambiguation = "compatible") {
  return new Date($11d87f3f76e88657$export$5107c82f94518f5c(dateTime, timeZone, disambiguation));
}
function $11d87f3f76e88657$export$1b96692a1ba042ac(ms, timeZone) {
  let offset4 = $11d87f3f76e88657$export$59c99f3515d3493f(ms, timeZone);
  let date = new Date(ms + offset4);
  let year = date.getUTCFullYear();
  let month = date.getUTCMonth() + 1;
  let day = date.getUTCDate();
  let hour = date.getUTCHours();
  let minute = date.getUTCMinutes();
  let second = date.getUTCSeconds();
  let millisecond = date.getUTCMilliseconds();
  return new (0, $35ea8db9cb2ccb90$export$d3b7288e7994edea)(year < 1 ? "BC" : "AD", year < 1 ? -year + 1 : year, month, day, timeZone, offset4, hour, minute, second, millisecond);
}
function $11d87f3f76e88657$export$93522d1a439f3617(dateTime) {
  return new (0, $35ea8db9cb2ccb90$export$99faa760c7908e4f)(dateTime.calendar, dateTime.era, dateTime.year, dateTime.month, dateTime.day);
}
function $11d87f3f76e88657$export$b21e0b124e224484(date, time) {
  let hour = 0, minute = 0, second = 0, millisecond = 0;
  if ("timeZone" in date) ({ hour, minute, second, millisecond } = date);
  else if ("hour" in date && !time) return date;
  if (time) ({ hour, minute, second, millisecond } = time);
  return new (0, $35ea8db9cb2ccb90$export$ca871e8dbb80966f)(date.calendar, date.era, date.year, date.month, date.day, hour, minute, second, millisecond);
}
function $11d87f3f76e88657$export$b4a036af3fc0b032(date, calendar) {
  if ((0, $14e0f24ef4ac5c92$export$dbc69fd56b53d5e)(date.calendar, calendar)) return date;
  let calendarDate = calendar.fromJulianDay(date.calendar.toJulianDay(date));
  let copy = date.copy();
  copy.calendar = calendar;
  copy.era = calendarDate.era;
  copy.year = calendarDate.year;
  copy.month = calendarDate.month;
  copy.day = calendarDate.day;
  (0, $735220c2d4774dd3$export$c4e2ecac49351ef2)(copy);
  return copy;
}
function $11d87f3f76e88657$export$84c95a83c799e074(date, timeZone, disambiguation) {
  if (date instanceof (0, $35ea8db9cb2ccb90$export$d3b7288e7994edea)) {
    if (date.timeZone === timeZone) return date;
    return $11d87f3f76e88657$export$538b00033cc11c75(date, timeZone);
  }
  let ms = $11d87f3f76e88657$export$5107c82f94518f5c(date, timeZone, disambiguation);
  return $11d87f3f76e88657$export$1b96692a1ba042ac(ms, timeZone);
}
function $11d87f3f76e88657$export$83aac07b4c37b25(date) {
  let ms = $11d87f3f76e88657$export$bd4fb2bc8bb06fb(date) - date.offset;
  return new Date(ms);
}
function $11d87f3f76e88657$export$538b00033cc11c75(date, timeZone) {
  let ms = $11d87f3f76e88657$export$bd4fb2bc8bb06fb(date) - date.offset;
  return $11d87f3f76e88657$export$b4a036af3fc0b032($11d87f3f76e88657$export$1b96692a1ba042ac(ms, timeZone), date.calendar);
}

// node_modules/@internationalized/date/dist/manipulation.mjs
var $735220c2d4774dd3$var$ONE_HOUR = 36e5;
function $735220c2d4774dd3$export$e16d8520af44a096(date, duration) {
  let mutableDate = date.copy();
  let days = "hour" in mutableDate ? $735220c2d4774dd3$var$addTimeFields(mutableDate, duration) : 0;
  $735220c2d4774dd3$var$addYears(mutableDate, duration.years || 0);
  if (mutableDate.calendar.balanceYearMonth) mutableDate.calendar.balanceYearMonth(mutableDate, date);
  mutableDate.month += duration.months || 0;
  $735220c2d4774dd3$var$balanceYearMonth(mutableDate);
  $735220c2d4774dd3$var$constrainMonthDay(mutableDate);
  mutableDate.day += (duration.weeks || 0) * 7;
  mutableDate.day += duration.days || 0;
  mutableDate.day += days;
  $735220c2d4774dd3$var$balanceDay(mutableDate);
  if (mutableDate.calendar.balanceDate) mutableDate.calendar.balanceDate(mutableDate);
  if (mutableDate.year < 1) {
    mutableDate.year = 1;
    mutableDate.month = 1;
    mutableDate.day = 1;
  }
  let maxYear = mutableDate.calendar.getYearsInEra(mutableDate);
  if (mutableDate.year > maxYear) {
    var _mutableDate_calendar_isInverseEra, _mutableDate_calendar;
    let isInverseEra = (_mutableDate_calendar_isInverseEra = (_mutableDate_calendar = mutableDate.calendar).isInverseEra) === null || _mutableDate_calendar_isInverseEra === void 0 ? void 0 : _mutableDate_calendar_isInverseEra.call(_mutableDate_calendar, mutableDate);
    mutableDate.year = maxYear;
    mutableDate.month = isInverseEra ? 1 : mutableDate.calendar.getMonthsInYear(mutableDate);
    mutableDate.day = isInverseEra ? 1 : mutableDate.calendar.getDaysInMonth(mutableDate);
  }
  if (mutableDate.month < 1) {
    mutableDate.month = 1;
    mutableDate.day = 1;
  }
  let maxMonth = mutableDate.calendar.getMonthsInYear(mutableDate);
  if (mutableDate.month > maxMonth) {
    mutableDate.month = maxMonth;
    mutableDate.day = mutableDate.calendar.getDaysInMonth(mutableDate);
  }
  mutableDate.day = Math.max(1, Math.min(mutableDate.calendar.getDaysInMonth(mutableDate), mutableDate.day));
  return mutableDate;
}
function $735220c2d4774dd3$var$addYears(date, years) {
  var _date_calendar_isInverseEra, _date_calendar;
  if ((_date_calendar_isInverseEra = (_date_calendar = date.calendar).isInverseEra) === null || _date_calendar_isInverseEra === void 0 ? void 0 : _date_calendar_isInverseEra.call(_date_calendar, date)) years = -years;
  date.year += years;
}
function $735220c2d4774dd3$var$balanceYearMonth(date) {
  while (date.month < 1) {
    $735220c2d4774dd3$var$addYears(date, -1);
    date.month += date.calendar.getMonthsInYear(date);
  }
  let monthsInYear = 0;
  while (date.month > (monthsInYear = date.calendar.getMonthsInYear(date))) {
    date.month -= monthsInYear;
    $735220c2d4774dd3$var$addYears(date, 1);
  }
}
function $735220c2d4774dd3$var$balanceDay(date) {
  while (date.day < 1) {
    date.month--;
    $735220c2d4774dd3$var$balanceYearMonth(date);
    date.day += date.calendar.getDaysInMonth(date);
  }
  while (date.day > date.calendar.getDaysInMonth(date)) {
    date.day -= date.calendar.getDaysInMonth(date);
    date.month++;
    $735220c2d4774dd3$var$balanceYearMonth(date);
  }
}
function $735220c2d4774dd3$var$constrainMonthDay(date) {
  date.month = Math.max(1, Math.min(date.calendar.getMonthsInYear(date), date.month));
  date.day = Math.max(1, Math.min(date.calendar.getDaysInMonth(date), date.day));
}
function $735220c2d4774dd3$export$c4e2ecac49351ef2(date) {
  if (date.calendar.constrainDate) date.calendar.constrainDate(date);
  date.year = Math.max(1, Math.min(date.calendar.getYearsInEra(date), date.year));
  $735220c2d4774dd3$var$constrainMonthDay(date);
}
function $735220c2d4774dd3$export$3e2544e88a25bff8(duration) {
  let inverseDuration = {};
  for (let key in duration) if (typeof duration[key] === "number") inverseDuration[key] = -duration[key];
  return inverseDuration;
}
function $735220c2d4774dd3$export$4e2d2ead65e5f7e3(date, duration) {
  return $735220c2d4774dd3$export$e16d8520af44a096(date, $735220c2d4774dd3$export$3e2544e88a25bff8(duration));
}
function $735220c2d4774dd3$export$adaa4cf7ef1b65be(date, fields) {
  let mutableDate = date.copy();
  if (fields.era != null) mutableDate.era = fields.era;
  if (fields.year != null) mutableDate.year = fields.year;
  if (fields.month != null) mutableDate.month = fields.month;
  if (fields.day != null) mutableDate.day = fields.day;
  $735220c2d4774dd3$export$c4e2ecac49351ef2(mutableDate);
  return mutableDate;
}
function $735220c2d4774dd3$export$e5d5e1c1822b6e56(value, fields) {
  let mutableValue = value.copy();
  if (fields.hour != null) mutableValue.hour = fields.hour;
  if (fields.minute != null) mutableValue.minute = fields.minute;
  if (fields.second != null) mutableValue.second = fields.second;
  if (fields.millisecond != null) mutableValue.millisecond = fields.millisecond;
  $735220c2d4774dd3$export$7555de1e070510cb(mutableValue);
  return mutableValue;
}
function $735220c2d4774dd3$var$balanceTime(time) {
  time.second += Math.floor(time.millisecond / 1e3);
  time.millisecond = $735220c2d4774dd3$var$nonNegativeMod(time.millisecond, 1e3);
  time.minute += Math.floor(time.second / 60);
  time.second = $735220c2d4774dd3$var$nonNegativeMod(time.second, 60);
  time.hour += Math.floor(time.minute / 60);
  time.minute = $735220c2d4774dd3$var$nonNegativeMod(time.minute, 60);
  let days = Math.floor(time.hour / 24);
  time.hour = $735220c2d4774dd3$var$nonNegativeMod(time.hour, 24);
  return days;
}
function $735220c2d4774dd3$export$7555de1e070510cb(time) {
  time.millisecond = Math.max(0, Math.min(time.millisecond, 1e3));
  time.second = Math.max(0, Math.min(time.second, 59));
  time.minute = Math.max(0, Math.min(time.minute, 59));
  time.hour = Math.max(0, Math.min(time.hour, 23));
}
function $735220c2d4774dd3$var$nonNegativeMod(a2, b2) {
  let result = a2 % b2;
  if (result < 0) result += b2;
  return result;
}
function $735220c2d4774dd3$var$addTimeFields(time, duration) {
  time.hour += duration.hours || 0;
  time.minute += duration.minutes || 0;
  time.second += duration.seconds || 0;
  time.millisecond += duration.milliseconds || 0;
  return $735220c2d4774dd3$var$balanceTime(time);
}
function $735220c2d4774dd3$export$7ed87b6bc2506470(time, duration) {
  let res = time.copy();
  $735220c2d4774dd3$var$addTimeFields(res, duration);
  return res;
}
function $735220c2d4774dd3$export$fe34d3a381cd7501(time, duration) {
  return $735220c2d4774dd3$export$7ed87b6bc2506470(time, $735220c2d4774dd3$export$3e2544e88a25bff8(duration));
}
function $735220c2d4774dd3$export$d52ced6badfb9a4c(value, field, amount, options) {
  let mutable = value.copy();
  switch (field) {
    case "era": {
      let eras = value.calendar.getEras();
      let eraIndex = eras.indexOf(value.era);
      if (eraIndex < 0) throw new Error("Invalid era: " + value.era);
      eraIndex = $735220c2d4774dd3$var$cycleValue(eraIndex, amount, 0, eras.length - 1, options === null || options === void 0 ? void 0 : options.round);
      mutable.era = eras[eraIndex];
      $735220c2d4774dd3$export$c4e2ecac49351ef2(mutable);
      break;
    }
    case "year":
      var _mutable_calendar_isInverseEra, _mutable_calendar;
      if ((_mutable_calendar_isInverseEra = (_mutable_calendar = mutable.calendar).isInverseEra) === null || _mutable_calendar_isInverseEra === void 0 ? void 0 : _mutable_calendar_isInverseEra.call(_mutable_calendar, mutable)) amount = -amount;
      mutable.year = $735220c2d4774dd3$var$cycleValue(value.year, amount, -Infinity, 9999, options === null || options === void 0 ? void 0 : options.round);
      if (mutable.year === -Infinity) mutable.year = 1;
      if (mutable.calendar.balanceYearMonth) mutable.calendar.balanceYearMonth(mutable, value);
      break;
    case "month":
      mutable.month = $735220c2d4774dd3$var$cycleValue(value.month, amount, 1, value.calendar.getMonthsInYear(value), options === null || options === void 0 ? void 0 : options.round);
      break;
    case "day":
      mutable.day = $735220c2d4774dd3$var$cycleValue(value.day, amount, 1, value.calendar.getDaysInMonth(value), options === null || options === void 0 ? void 0 : options.round);
      break;
    default:
      throw new Error("Unsupported field " + field);
  }
  if (value.calendar.balanceDate) value.calendar.balanceDate(mutable);
  $735220c2d4774dd3$export$c4e2ecac49351ef2(mutable);
  return mutable;
}
function $735220c2d4774dd3$export$dd02b3e0007dfe28(value, field, amount, options) {
  let mutable = value.copy();
  switch (field) {
    case "hour": {
      let hours = value.hour;
      let min4 = 0;
      let max4 = 23;
      if ((options === null || options === void 0 ? void 0 : options.hourCycle) === 12) {
        let isPM = hours >= 12;
        min4 = isPM ? 12 : 0;
        max4 = isPM ? 23 : 11;
      }
      mutable.hour = $735220c2d4774dd3$var$cycleValue(hours, amount, min4, max4, options === null || options === void 0 ? void 0 : options.round);
      break;
    }
    case "minute":
      mutable.minute = $735220c2d4774dd3$var$cycleValue(value.minute, amount, 0, 59, options === null || options === void 0 ? void 0 : options.round);
      break;
    case "second":
      mutable.second = $735220c2d4774dd3$var$cycleValue(value.second, amount, 0, 59, options === null || options === void 0 ? void 0 : options.round);
      break;
    case "millisecond":
      mutable.millisecond = $735220c2d4774dd3$var$cycleValue(value.millisecond, amount, 0, 999, options === null || options === void 0 ? void 0 : options.round);
      break;
    default:
      throw new Error("Unsupported field " + field);
  }
  return mutable;
}
function $735220c2d4774dd3$var$cycleValue(value, amount, min4, max4, round3 = false) {
  if (round3) {
    value += Math.sign(amount);
    if (value < min4) value = max4;
    let div = Math.abs(amount);
    if (amount > 0) value = Math.ceil(value / div) * div;
    else value = Math.floor(value / div) * div;
    if (value > max4) value = min4;
  } else {
    value += amount;
    if (value < min4) value = max4 - (min4 - value - 1);
    else if (value > max4) value = min4 + (value - max4 - 1);
  }
  return value;
}
function $735220c2d4774dd3$export$96b1d28349274637(dateTime, duration) {
  let ms;
  if (duration.years != null && duration.years !== 0 || duration.months != null && duration.months !== 0 || duration.weeks != null && duration.weeks !== 0 || duration.days != null && duration.days !== 0) {
    let res2 = $735220c2d4774dd3$export$e16d8520af44a096((0, $11d87f3f76e88657$export$b21e0b124e224484)(dateTime), {
      years: duration.years,
      months: duration.months,
      weeks: duration.weeks,
      days: duration.days
    });
    ms = (0, $11d87f3f76e88657$export$5107c82f94518f5c)(res2, dateTime.timeZone);
  } else
    ms = (0, $11d87f3f76e88657$export$bd4fb2bc8bb06fb)(dateTime) - dateTime.offset;
  ms += duration.milliseconds || 0;
  ms += (duration.seconds || 0) * 1e3;
  ms += (duration.minutes || 0) * 6e4;
  ms += (duration.hours || 0) * 36e5;
  let res = (0, $11d87f3f76e88657$export$1b96692a1ba042ac)(ms, dateTime.timeZone);
  return (0, $11d87f3f76e88657$export$b4a036af3fc0b032)(res, dateTime.calendar);
}
function $735220c2d4774dd3$export$6814caac34ca03c7(dateTime, duration) {
  return $735220c2d4774dd3$export$96b1d28349274637(dateTime, $735220c2d4774dd3$export$3e2544e88a25bff8(duration));
}
function $735220c2d4774dd3$export$9a297d111fc86b79(dateTime, field, amount, options) {
  switch (field) {
    case "hour": {
      let min4 = 0;
      let max4 = 23;
      if ((options === null || options === void 0 ? void 0 : options.hourCycle) === 12) {
        let isPM = dateTime.hour >= 12;
        min4 = isPM ? 12 : 0;
        max4 = isPM ? 23 : 11;
      }
      let plainDateTime = (0, $11d87f3f76e88657$export$b21e0b124e224484)(dateTime);
      let minDate = (0, $11d87f3f76e88657$export$b4a036af3fc0b032)($735220c2d4774dd3$export$e5d5e1c1822b6e56(plainDateTime, {
        hour: min4
      }), new (0, $3b62074eb05584b2$export$80ee6245ec4f29ec)());
      let minAbsolute = [
        (0, $11d87f3f76e88657$export$5107c82f94518f5c)(minDate, dateTime.timeZone, "earlier"),
        (0, $11d87f3f76e88657$export$5107c82f94518f5c)(minDate, dateTime.timeZone, "later")
      ].filter((ms2) => (0, $11d87f3f76e88657$export$1b96692a1ba042ac)(ms2, dateTime.timeZone).day === minDate.day)[0];
      let maxDate = (0, $11d87f3f76e88657$export$b4a036af3fc0b032)($735220c2d4774dd3$export$e5d5e1c1822b6e56(plainDateTime, {
        hour: max4
      }), new (0, $3b62074eb05584b2$export$80ee6245ec4f29ec)());
      let maxAbsolute = [
        (0, $11d87f3f76e88657$export$5107c82f94518f5c)(maxDate, dateTime.timeZone, "earlier"),
        (0, $11d87f3f76e88657$export$5107c82f94518f5c)(maxDate, dateTime.timeZone, "later")
      ].filter((ms2) => (0, $11d87f3f76e88657$export$1b96692a1ba042ac)(ms2, dateTime.timeZone).day === maxDate.day).pop();
      let ms = (0, $11d87f3f76e88657$export$bd4fb2bc8bb06fb)(dateTime) - dateTime.offset;
      let hours = Math.floor(ms / $735220c2d4774dd3$var$ONE_HOUR);
      let remainder = ms % $735220c2d4774dd3$var$ONE_HOUR;
      ms = $735220c2d4774dd3$var$cycleValue(hours, amount, Math.floor(minAbsolute / $735220c2d4774dd3$var$ONE_HOUR), Math.floor(maxAbsolute / $735220c2d4774dd3$var$ONE_HOUR), options === null || options === void 0 ? void 0 : options.round) * $735220c2d4774dd3$var$ONE_HOUR + remainder;
      return (0, $11d87f3f76e88657$export$b4a036af3fc0b032)((0, $11d87f3f76e88657$export$1b96692a1ba042ac)(ms, dateTime.timeZone), dateTime.calendar);
    }
    case "minute":
    case "second":
    case "millisecond":
      return $735220c2d4774dd3$export$dd02b3e0007dfe28(dateTime, field, amount, options);
    case "era":
    case "year":
    case "month":
    case "day": {
      let res = $735220c2d4774dd3$export$d52ced6badfb9a4c((0, $11d87f3f76e88657$export$b21e0b124e224484)(dateTime), field, amount, options);
      let ms = (0, $11d87f3f76e88657$export$5107c82f94518f5c)(res, dateTime.timeZone);
      return (0, $11d87f3f76e88657$export$b4a036af3fc0b032)((0, $11d87f3f76e88657$export$1b96692a1ba042ac)(ms, dateTime.timeZone), dateTime.calendar);
    }
    default:
      throw new Error("Unsupported field " + field);
  }
}
function $735220c2d4774dd3$export$31b5430eb18be4f8(dateTime, fields, disambiguation) {
  let plainDateTime = (0, $11d87f3f76e88657$export$b21e0b124e224484)(dateTime);
  let res = $735220c2d4774dd3$export$e5d5e1c1822b6e56($735220c2d4774dd3$export$adaa4cf7ef1b65be(plainDateTime, fields), fields);
  if (res.compare(plainDateTime) === 0) return dateTime;
  let ms = (0, $11d87f3f76e88657$export$5107c82f94518f5c)(res, dateTime.timeZone, disambiguation);
  return (0, $11d87f3f76e88657$export$b4a036af3fc0b032)((0, $11d87f3f76e88657$export$1b96692a1ba042ac)(ms, dateTime.timeZone), dateTime.calendar);
}

// node_modules/@internationalized/date/dist/string.mjs
var $fae977aafc393c5c$var$requiredDurationTimeGroups = [
  "hours",
  "minutes",
  "seconds"
];
var $fae977aafc393c5c$var$requiredDurationGroups = [
  "years",
  "months",
  "weeks",
  "days",
  ...$fae977aafc393c5c$var$requiredDurationTimeGroups
];
function $fae977aafc393c5c$export$f59dee82248f5ad4(time) {
  return `${String(time.hour).padStart(2, "0")}:${String(time.minute).padStart(2, "0")}:${String(time.second).padStart(2, "0")}${time.millisecond ? String(time.millisecond / 1e3).slice(1) : ""}`;
}
function $fae977aafc393c5c$export$60dfd74aa96791bd(date) {
  let gregorianDate = (0, $11d87f3f76e88657$export$b4a036af3fc0b032)(date, new (0, $3b62074eb05584b2$export$80ee6245ec4f29ec)());
  let year;
  if (gregorianDate.era === "BC") year = gregorianDate.year === 1 ? "0000" : "-" + String(Math.abs(1 - gregorianDate.year)).padStart(6, "00");
  else year = String(gregorianDate.year).padStart(4, "0");
  return `${year}-${String(gregorianDate.month).padStart(2, "0")}-${String(gregorianDate.day).padStart(2, "0")}`;
}
function $fae977aafc393c5c$export$4223de14708adc63(date) {
  return `${$fae977aafc393c5c$export$60dfd74aa96791bd(date)}T${$fae977aafc393c5c$export$f59dee82248f5ad4(date)}`;
}
function $fae977aafc393c5c$var$offsetToString(offset4) {
  let sign3 = Math.sign(offset4) < 0 ? "-" : "+";
  offset4 = Math.abs(offset4);
  let offsetHours = Math.floor(offset4 / 36e5);
  let offsetMinutes = offset4 % 36e5 / 6e4;
  return `${sign3}${String(offsetHours).padStart(2, "0")}:${String(offsetMinutes).padStart(2, "0")}`;
}
function $fae977aafc393c5c$export$bf79f1ebf4b18792(date) {
  return `${$fae977aafc393c5c$export$4223de14708adc63(date)}${$fae977aafc393c5c$var$offsetToString(date.offset)}[${date.timeZone}]`;
}

// node_modules/@swc/helpers/esm/_check_private_redeclaration.js
function _check_private_redeclaration(obj, privateCollection) {
  if (privateCollection.has(obj)) {
    throw new TypeError("Cannot initialize the same private elements twice on an object");
  }
}

// node_modules/@swc/helpers/esm/_class_private_field_init.js
function _class_private_field_init(obj, privateMap, value) {
  _check_private_redeclaration(obj, privateMap);
  privateMap.set(obj, value);
}

// node_modules/@internationalized/date/dist/CalendarDate.mjs
function $35ea8db9cb2ccb90$var$shiftArgs(args) {
  let calendar = typeof args[0] === "object" ? args.shift() : new (0, $3b62074eb05584b2$export$80ee6245ec4f29ec)();
  let era;
  if (typeof args[0] === "string") era = args.shift();
  else {
    let eras = calendar.getEras();
    era = eras[eras.length - 1];
  }
  let year = args.shift();
  let month = args.shift();
  let day = args.shift();
  return [
    calendar,
    era,
    year,
    month,
    day
  ];
}
var $35ea8db9cb2ccb90$var$_type = /* @__PURE__ */ new WeakMap();
var $35ea8db9cb2ccb90$export$99faa760c7908e4f = class _$35ea8db9cb2ccb90$export$99faa760c7908e4f {
  /** Returns a copy of this date. */
  copy() {
    if (this.era) return new _$35ea8db9cb2ccb90$export$99faa760c7908e4f(this.calendar, this.era, this.year, this.month, this.day);
    else return new _$35ea8db9cb2ccb90$export$99faa760c7908e4f(this.calendar, this.year, this.month, this.day);
  }
  /** Returns a new `CalendarDate` with the given duration added to it. */
  add(duration) {
    return (0, $735220c2d4774dd3$export$e16d8520af44a096)(this, duration);
  }
  /** Returns a new `CalendarDate` with the given duration subtracted from it. */
  subtract(duration) {
    return (0, $735220c2d4774dd3$export$4e2d2ead65e5f7e3)(this, duration);
  }
  /** Returns a new `CalendarDate` with the given fields set to the provided values. Other fields will be constrained accordingly. */
  set(fields) {
    return (0, $735220c2d4774dd3$export$adaa4cf7ef1b65be)(this, fields);
  }
  /**
  * Returns a new `CalendarDate` with the given field adjusted by a specified amount.
  * When the resulting value reaches the limits of the field, it wraps around.
  */
  cycle(field, amount, options) {
    return (0, $735220c2d4774dd3$export$d52ced6badfb9a4c)(this, field, amount, options);
  }
  /** Converts the date to a native JavaScript Date object, with the time set to midnight in the given time zone. */
  toDate(timeZone) {
    return (0, $11d87f3f76e88657$export$e67a095c620b86fe)(this, timeZone);
  }
  /** Converts the date to an ISO 8601 formatted string. */
  toString() {
    return (0, $fae977aafc393c5c$export$60dfd74aa96791bd)(this);
  }
  /** Compares this date with another. A negative result indicates that this date is before the given one, and a positive date indicates that it is after. */
  compare(b2) {
    return (0, $14e0f24ef4ac5c92$export$68781ddf31c0090f)(this, b2);
  }
  constructor(...args) {
    (0, _class_private_field_init)(this, $35ea8db9cb2ccb90$var$_type, {
      writable: true,
      value: void 0
    });
    let [calendar, era, year, month, day] = $35ea8db9cb2ccb90$var$shiftArgs(args);
    this.calendar = calendar;
    this.era = era;
    this.year = year;
    this.month = month;
    this.day = day;
    (0, $735220c2d4774dd3$export$c4e2ecac49351ef2)(this);
  }
};
var $35ea8db9cb2ccb90$var$_type1 = /* @__PURE__ */ new WeakMap();
var $35ea8db9cb2ccb90$export$680ea196effce5f = class _$35ea8db9cb2ccb90$export$680ea196effce5f {
  /** Returns a copy of this time. */
  copy() {
    return new _$35ea8db9cb2ccb90$export$680ea196effce5f(this.hour, this.minute, this.second, this.millisecond);
  }
  /** Returns a new `Time` with the given duration added to it. */
  add(duration) {
    return (0, $735220c2d4774dd3$export$7ed87b6bc2506470)(this, duration);
  }
  /** Returns a new `Time` with the given duration subtracted from it. */
  subtract(duration) {
    return (0, $735220c2d4774dd3$export$fe34d3a381cd7501)(this, duration);
  }
  /** Returns a new `Time` with the given fields set to the provided values. Other fields will be constrained accordingly. */
  set(fields) {
    return (0, $735220c2d4774dd3$export$e5d5e1c1822b6e56)(this, fields);
  }
  /**
  * Returns a new `Time` with the given field adjusted by a specified amount.
  * When the resulting value reaches the limits of the field, it wraps around.
  */
  cycle(field, amount, options) {
    return (0, $735220c2d4774dd3$export$dd02b3e0007dfe28)(this, field, amount, options);
  }
  /** Converts the time to an ISO 8601 formatted string. */
  toString() {
    return (0, $fae977aafc393c5c$export$f59dee82248f5ad4)(this);
  }
  /** Compares this time with another. A negative result indicates that this time is before the given one, and a positive time indicates that it is after. */
  compare(b2) {
    return (0, $14e0f24ef4ac5c92$export$c19a80a9721b80f6)(this, b2);
  }
  constructor(hour = 0, minute = 0, second = 0, millisecond = 0) {
    (0, _class_private_field_init)(this, $35ea8db9cb2ccb90$var$_type1, {
      writable: true,
      value: void 0
    });
    this.hour = hour;
    this.minute = minute;
    this.second = second;
    this.millisecond = millisecond;
    (0, $735220c2d4774dd3$export$7555de1e070510cb)(this);
  }
};
var $35ea8db9cb2ccb90$var$_type2 = /* @__PURE__ */ new WeakMap();
var $35ea8db9cb2ccb90$export$ca871e8dbb80966f = class _$35ea8db9cb2ccb90$export$ca871e8dbb80966f {
  /** Returns a copy of this date. */
  copy() {
    if (this.era) return new _$35ea8db9cb2ccb90$export$ca871e8dbb80966f(this.calendar, this.era, this.year, this.month, this.day, this.hour, this.minute, this.second, this.millisecond);
    else return new _$35ea8db9cb2ccb90$export$ca871e8dbb80966f(this.calendar, this.year, this.month, this.day, this.hour, this.minute, this.second, this.millisecond);
  }
  /** Returns a new `CalendarDateTime` with the given duration added to it. */
  add(duration) {
    return (0, $735220c2d4774dd3$export$e16d8520af44a096)(this, duration);
  }
  /** Returns a new `CalendarDateTime` with the given duration subtracted from it. */
  subtract(duration) {
    return (0, $735220c2d4774dd3$export$4e2d2ead65e5f7e3)(this, duration);
  }
  /** Returns a new `CalendarDateTime` with the given fields set to the provided values. Other fields will be constrained accordingly. */
  set(fields) {
    return (0, $735220c2d4774dd3$export$adaa4cf7ef1b65be)((0, $735220c2d4774dd3$export$e5d5e1c1822b6e56)(this, fields), fields);
  }
  /**
  * Returns a new `CalendarDateTime` with the given field adjusted by a specified amount.
  * When the resulting value reaches the limits of the field, it wraps around.
  */
  cycle(field, amount, options) {
    switch (field) {
      case "era":
      case "year":
      case "month":
      case "day":
        return (0, $735220c2d4774dd3$export$d52ced6badfb9a4c)(this, field, amount, options);
      default:
        return (0, $735220c2d4774dd3$export$dd02b3e0007dfe28)(this, field, amount, options);
    }
  }
  /** Converts the date to a native JavaScript Date object in the given time zone. */
  toDate(timeZone, disambiguation) {
    return (0, $11d87f3f76e88657$export$e67a095c620b86fe)(this, timeZone, disambiguation);
  }
  /** Converts the date to an ISO 8601 formatted string. */
  toString() {
    return (0, $fae977aafc393c5c$export$4223de14708adc63)(this);
  }
  /** Compares this date with another. A negative result indicates that this date is before the given one, and a positive date indicates that it is after. */
  compare(b2) {
    let res = (0, $14e0f24ef4ac5c92$export$68781ddf31c0090f)(this, b2);
    if (res === 0) return (0, $14e0f24ef4ac5c92$export$c19a80a9721b80f6)(this, (0, $11d87f3f76e88657$export$b21e0b124e224484)(b2));
    return res;
  }
  constructor(...args) {
    (0, _class_private_field_init)(this, $35ea8db9cb2ccb90$var$_type2, {
      writable: true,
      value: void 0
    });
    let [calendar, era, year, month, day] = $35ea8db9cb2ccb90$var$shiftArgs(args);
    this.calendar = calendar;
    this.era = era;
    this.year = year;
    this.month = month;
    this.day = day;
    this.hour = args.shift() || 0;
    this.minute = args.shift() || 0;
    this.second = args.shift() || 0;
    this.millisecond = args.shift() || 0;
    (0, $735220c2d4774dd3$export$c4e2ecac49351ef2)(this);
  }
};
var $35ea8db9cb2ccb90$var$_type3 = /* @__PURE__ */ new WeakMap();
var $35ea8db9cb2ccb90$export$d3b7288e7994edea = class _$35ea8db9cb2ccb90$export$d3b7288e7994edea {
  /** Returns a copy of this date. */
  copy() {
    if (this.era) return new _$35ea8db9cb2ccb90$export$d3b7288e7994edea(this.calendar, this.era, this.year, this.month, this.day, this.timeZone, this.offset, this.hour, this.minute, this.second, this.millisecond);
    else return new _$35ea8db9cb2ccb90$export$d3b7288e7994edea(this.calendar, this.year, this.month, this.day, this.timeZone, this.offset, this.hour, this.minute, this.second, this.millisecond);
  }
  /** Returns a new `ZonedDateTime` with the given duration added to it. */
  add(duration) {
    return (0, $735220c2d4774dd3$export$96b1d28349274637)(this, duration);
  }
  /** Returns a new `ZonedDateTime` with the given duration subtracted from it. */
  subtract(duration) {
    return (0, $735220c2d4774dd3$export$6814caac34ca03c7)(this, duration);
  }
  /** Returns a new `ZonedDateTime` with the given fields set to the provided values. Other fields will be constrained accordingly. */
  set(fields, disambiguation) {
    return (0, $735220c2d4774dd3$export$31b5430eb18be4f8)(this, fields, disambiguation);
  }
  /**
  * Returns a new `ZonedDateTime` with the given field adjusted by a specified amount.
  * When the resulting value reaches the limits of the field, it wraps around.
  */
  cycle(field, amount, options) {
    return (0, $735220c2d4774dd3$export$9a297d111fc86b79)(this, field, amount, options);
  }
  /** Converts the date to a native JavaScript Date object. */
  toDate() {
    return (0, $11d87f3f76e88657$export$83aac07b4c37b25)(this);
  }
  /** Converts the date to an ISO 8601 formatted string, including the UTC offset and time zone identifier. */
  toString() {
    return (0, $fae977aafc393c5c$export$bf79f1ebf4b18792)(this);
  }
  /** Converts the date to an ISO 8601 formatted string in UTC. */
  toAbsoluteString() {
    return this.toDate().toISOString();
  }
  /** Compares this date with another. A negative result indicates that this date is before the given one, and a positive date indicates that it is after. */
  compare(b2) {
    return this.toDate().getTime() - (0, $11d87f3f76e88657$export$84c95a83c799e074)(b2, this.timeZone).toDate().getTime();
  }
  constructor(...args) {
    (0, _class_private_field_init)(this, $35ea8db9cb2ccb90$var$_type3, {
      writable: true,
      value: void 0
    });
    let [calendar, era, year, month, day] = $35ea8db9cb2ccb90$var$shiftArgs(args);
    let timeZone = args.shift();
    let offset4 = args.shift();
    this.calendar = calendar;
    this.era = era;
    this.year = year;
    this.month = month;
    this.day = day;
    this.timeZone = timeZone;
    this.offset = offset4;
    this.hour = args.shift() || 0;
    this.minute = args.shift() || 0;
    this.second = args.shift() || 0;
    this.millisecond = args.shift() || 0;
    (0, $735220c2d4774dd3$export$c4e2ecac49351ef2)(this);
  }
};

// node_modules/@internationalized/date/dist/HebrewCalendar.mjs
var $7c5f6fbf42389787$var$HOUR_PARTS = 1080;
var $7c5f6fbf42389787$var$DAY_PARTS = 24 * $7c5f6fbf42389787$var$HOUR_PARTS;
var $7c5f6fbf42389787$var$MONTH_DAYS = 29;
var $7c5f6fbf42389787$var$MONTH_FRACT = 12 * $7c5f6fbf42389787$var$HOUR_PARTS + 793;
var $7c5f6fbf42389787$var$MONTH_PARTS = $7c5f6fbf42389787$var$MONTH_DAYS * $7c5f6fbf42389787$var$DAY_PARTS + $7c5f6fbf42389787$var$MONTH_FRACT;

// node_modules/@internationalized/date/dist/DateFormatter.mjs
var $fb18d541ea1ad717$var$formatterCache = /* @__PURE__ */ new Map();
var $fb18d541ea1ad717$export$ad991b66133851cf = class {
  /** Formats a date as a string according to the locale and format options passed to the constructor. */
  format(value) {
    return this.formatter.format(value);
  }
  /** Formats a date to an array of parts such as separators, numbers, punctuation, and more. */
  formatToParts(value) {
    return this.formatter.formatToParts(value);
  }
  /** Formats a date range as a string. */
  formatRange(start, end) {
    if (typeof this.formatter.formatRange === "function")
      return this.formatter.formatRange(start, end);
    if (end < start) throw new RangeError("End date must be >= start date");
    return `${this.formatter.format(start)}  ${this.formatter.format(end)}`;
  }
  /** Formats a date range as an array of parts. */
  formatRangeToParts(start, end) {
    if (typeof this.formatter.formatRangeToParts === "function")
      return this.formatter.formatRangeToParts(start, end);
    if (end < start) throw new RangeError("End date must be >= start date");
    let startParts = this.formatter.formatToParts(start);
    let endParts = this.formatter.formatToParts(end);
    return [
      ...startParts.map((p) => ({
        ...p,
        source: "startRange"
      })),
      {
        type: "literal",
        value: "  ",
        source: "shared"
      },
      ...endParts.map((p) => ({
        ...p,
        source: "endRange"
      }))
    ];
  }
  /** Returns the resolved formatting options based on the values passed to the constructor. */
  resolvedOptions() {
    let resolvedOptions = this.formatter.resolvedOptions();
    if ($fb18d541ea1ad717$var$hasBuggyResolvedHourCycle()) {
      if (!this.resolvedHourCycle) this.resolvedHourCycle = $fb18d541ea1ad717$var$getResolvedHourCycle(resolvedOptions.locale, this.options);
      resolvedOptions.hourCycle = this.resolvedHourCycle;
      resolvedOptions.hour12 = this.resolvedHourCycle === "h11" || this.resolvedHourCycle === "h12";
    }
    if (resolvedOptions.calendar === "ethiopic-amete-alem") resolvedOptions.calendar = "ethioaa";
    return resolvedOptions;
  }
  constructor(locale, options = {}) {
    this.formatter = $fb18d541ea1ad717$var$getCachedDateFormatter(locale, options);
    this.options = options;
  }
};
var $fb18d541ea1ad717$var$hour12Preferences = {
  true: {
    // Only Japanese uses the h11 style for 12 hour time. All others use h12.
    ja: "h11"
  },
  false: {}
};
function $fb18d541ea1ad717$var$getCachedDateFormatter(locale, options = {}) {
  if (typeof options.hour12 === "boolean" && $fb18d541ea1ad717$var$hasBuggyHour12Behavior()) {
    options = {
      ...options
    };
    let pref = $fb18d541ea1ad717$var$hour12Preferences[String(options.hour12)][locale.split("-")[0]];
    let defaultHourCycle = options.hour12 ? "h12" : "h23";
    options.hourCycle = pref !== null && pref !== void 0 ? pref : defaultHourCycle;
    delete options.hour12;
  }
  let cacheKey = locale + (options ? Object.entries(options).sort((a2, b2) => a2[0] < b2[0] ? -1 : 1).join() : "");
  if ($fb18d541ea1ad717$var$formatterCache.has(cacheKey)) return $fb18d541ea1ad717$var$formatterCache.get(cacheKey);
  let numberFormatter = new Intl.DateTimeFormat(locale, options);
  $fb18d541ea1ad717$var$formatterCache.set(cacheKey, numberFormatter);
  return numberFormatter;
}
var $fb18d541ea1ad717$var$_hasBuggyHour12Behavior = null;
function $fb18d541ea1ad717$var$hasBuggyHour12Behavior() {
  if ($fb18d541ea1ad717$var$_hasBuggyHour12Behavior == null) $fb18d541ea1ad717$var$_hasBuggyHour12Behavior = new Intl.DateTimeFormat("en-US", {
    hour: "numeric",
    hour12: false
  }).format(new Date(2020, 2, 3, 0)) === "24";
  return $fb18d541ea1ad717$var$_hasBuggyHour12Behavior;
}
var $fb18d541ea1ad717$var$_hasBuggyResolvedHourCycle = null;
function $fb18d541ea1ad717$var$hasBuggyResolvedHourCycle() {
  if ($fb18d541ea1ad717$var$_hasBuggyResolvedHourCycle == null) $fb18d541ea1ad717$var$_hasBuggyResolvedHourCycle = new Intl.DateTimeFormat("fr", {
    hour: "numeric",
    hour12: false
  }).resolvedOptions().hourCycle === "h12";
  return $fb18d541ea1ad717$var$_hasBuggyResolvedHourCycle;
}
function $fb18d541ea1ad717$var$getResolvedHourCycle(locale, options) {
  if (!options.timeStyle && !options.hour) return void 0;
  locale = locale.replace(/(-u-)?-nu-[a-zA-Z0-9]+/, "");
  locale += (locale.includes("-u-") ? "" : "-u") + "-nu-latn";
  let formatter = $fb18d541ea1ad717$var$getCachedDateFormatter(locale, {
    ...options,
    timeZone: void 0
    // use local timezone
  });
  let min4 = parseInt(formatter.formatToParts(new Date(2020, 2, 3, 0)).find((p) => p.type === "hour").value, 10);
  let max4 = parseInt(formatter.formatToParts(new Date(2020, 2, 3, 23)).find((p) => p.type === "hour").value, 10);
  if (min4 === 0 && max4 === 23) return "h23";
  if (min4 === 24 && max4 === 23) return "h24";
  if (min4 === 0 && max4 === 11) return "h11";
  if (min4 === 12 && max4 === 11) return "h12";
  throw new Error("Unexpected hour cycle result");
}

// node_modules/@zag-js/date-utils/dist/index.mjs
function alignCenter(date, duration, locale, min4, max4) {
  const halfDuration = {};
  for (let prop in duration) {
    const key = prop;
    const value = duration[key];
    if (value == null) continue;
    halfDuration[key] = Math.floor(value / 2);
    if (halfDuration[key] > 0 && value % 2 === 0) {
      halfDuration[key]--;
    }
  }
  const aligned = alignStart(date, duration, locale).subtract(halfDuration);
  return constrainStart(date, aligned, duration, locale, min4, max4);
}
function alignStart(date, duration, locale, min4, max4) {
  let aligned = date;
  if (duration.years) {
    aligned = $14e0f24ef4ac5c92$export$f91e89d3d0406102(date);
  } else if (duration.months) {
    aligned = $14e0f24ef4ac5c92$export$a5a3b454ada2268e(date);
  } else if (duration.weeks) {
    aligned = $14e0f24ef4ac5c92$export$42c81a444fbfb5d4(date, locale);
  }
  return constrainStart(date, aligned, duration, locale, min4, max4);
}
function alignEnd(date, duration, locale, min4, max4) {
  let d = { ...duration };
  if (d.days) {
    d.days--;
  } else if (d.weeks) {
    d.weeks--;
  } else if (d.months) {
    d.months--;
  } else if (d.years) {
    d.years--;
  }
  let aligned = alignStart(date, duration, locale).subtract(d);
  return constrainStart(date, aligned, duration, locale, min4, max4);
}
function constrainStart(date, aligned, duration, locale, min4, max4) {
  if (min4 && date.compare(min4) >= 0) {
    aligned = $14e0f24ef4ac5c92$export$a75f2bff57811055(aligned, alignStart($11d87f3f76e88657$export$93522d1a439f3617(min4), duration, locale));
  }
  if (max4 && date.compare(max4) <= 0) {
    aligned = $14e0f24ef4ac5c92$export$5c333a116e949cdd(aligned, alignEnd($11d87f3f76e88657$export$93522d1a439f3617(max4), duration, locale));
  }
  return aligned;
}
function constrainValue(date, minValue, maxValue2) {
  if (minValue) {
    date = $14e0f24ef4ac5c92$export$a75f2bff57811055(date, $11d87f3f76e88657$export$93522d1a439f3617(minValue));
  }
  if (maxValue2) {
    date = $14e0f24ef4ac5c92$export$5c333a116e949cdd(date, $11d87f3f76e88657$export$93522d1a439f3617(maxValue2));
  }
  return date;
}
function alignDate(date, alignment, duration, locale, min4, max4) {
  switch (alignment) {
    case "start":
      return alignStart(date, duration, locale, min4, max4);
    case "end":
      return alignEnd(date, duration, locale, min4, max4);
    case "center":
    default:
      return alignCenter(date, duration, locale, min4, max4);
  }
}
function isDateEqual(dateA, dateB) {
  return dateB != null && $14e0f24ef4ac5c92$export$ea39ec197993aef0(dateA, dateB);
}
function isDateUnavailable(date, isUnavailable, locale, minValue, maxValue2) {
  if (!date) return false;
  if (isUnavailable == null ? void 0 : isUnavailable(date, locale)) return true;
  return isDateOutsideRange(date, minValue, maxValue2);
}
function isDateOutsideRange(date, startDate, endDate) {
  return startDate != null && date.compare(startDate) < 0 || endDate != null && date.compare(endDate) > 0;
}
function isPreviousRangeInvalid(startDate, minValue, maxValue2) {
  const prevDate = startDate.subtract({ days: 1 });
  return $14e0f24ef4ac5c92$export$ea39ec197993aef0(prevDate, startDate) || isDateOutsideRange(prevDate, minValue, maxValue2);
}
function isNextRangeInvalid(endDate, minValue, maxValue2) {
  const nextDate = endDate.add({ days: 1 });
  return $14e0f24ef4ac5c92$export$ea39ec197993aef0(nextDate, endDate) || isDateOutsideRange(nextDate, minValue, maxValue2);
}
function getUnitDuration(duration) {
  let clone2 = { ...duration };
  for (let key in clone2) clone2[key] = 1;
  return clone2;
}
function getEndDate(startDate, duration) {
  let clone2 = { ...duration };
  if (clone2.days) clone2.days--;
  else clone2.days = -1;
  return startDate.add(clone2);
}
function getEraFormat(date) {
  return (date == null ? void 0 : date.calendar.identifier) === "gregory" && date.era === "BC" ? "short" : void 0;
}
function getDayFormatter(locale, timeZone) {
  const date = $11d87f3f76e88657$export$b21e0b124e224484($14e0f24ef4ac5c92$export$d0bdf45af03a6ea3(timeZone));
  return new $fb18d541ea1ad717$export$ad991b66133851cf(locale, {
    weekday: "long",
    month: "long",
    year: "numeric",
    day: "numeric",
    era: getEraFormat(date),
    timeZone
  });
}
function getMonthFormatter(locale, timeZone) {
  const date = $11d87f3f76e88657$export$93522d1a439f3617($14e0f24ef4ac5c92$export$d0bdf45af03a6ea3(timeZone));
  return new $fb18d541ea1ad717$export$ad991b66133851cf(locale, {
    month: "long",
    year: "numeric",
    era: getEraFormat(date),
    calendar: date == null ? void 0 : date.calendar.identifier,
    timeZone
  });
}
function formatRange(startDate, endDate, formatter, toString, timeZone) {
  let parts46 = formatter.formatRangeToParts(startDate.toDate(timeZone), endDate.toDate(timeZone));
  let separatorIndex = -1;
  for (let i = 0; i < parts46.length; i++) {
    let part = parts46[i];
    if (part.source === "shared" && part.type === "literal") {
      separatorIndex = i;
    } else if (part.source === "endRange") {
      break;
    }
  }
  let start = "";
  let end = "";
  for (let i = 0; i < parts46.length; i++) {
    if (i < separatorIndex) {
      start += parts46[i].value;
    } else if (i > separatorIndex) {
      end += parts46[i].value;
    }
  }
  return toString(start, end);
}
function formatSelectedDate(startDate, endDate, locale, timeZone) {
  let start = startDate;
  let end = endDate ?? startDate;
  let formatter = getDayFormatter(locale, timeZone);
  if ($14e0f24ef4ac5c92$export$ea39ec197993aef0(start, end)) {
    return formatter.format(start.toDate(timeZone));
  }
  return formatRange(start, end, formatter, (start2, end2) => `${start2}  ${end2}`, timeZone);
}
var daysOfTheWeek = ["sun", "mon", "tue", "wed", "thu", "fri", "sat"];
function normalizeFirstDayOfWeek(firstDayOfWeek) {
  return firstDayOfWeek != null ? daysOfTheWeek[firstDayOfWeek] : void 0;
}
function getStartOfWeek(date, locale, firstDayOfWeek) {
  const firstDay = normalizeFirstDayOfWeek(firstDayOfWeek);
  return $14e0f24ef4ac5c92$export$42c81a444fbfb5d4(date, locale, firstDay);
}
function getDaysInWeek(weekIndex, from, locale, firstDayOfWeek) {
  const weekDate = from.add({ weeks: weekIndex });
  const dates = [];
  let date = getStartOfWeek(weekDate, locale, firstDayOfWeek);
  while (dates.length < 7) {
    dates.push(date);
    let nextDate = date.add({ days: 1 });
    if ($14e0f24ef4ac5c92$export$ea39ec197993aef0(date, nextDate)) break;
    date = nextDate;
  }
  return dates;
}
function getMonthDays(from, locale, numOfWeeks, firstDayOfWeek) {
  const firstDay = normalizeFirstDayOfWeek(firstDayOfWeek);
  const monthWeeks = numOfWeeks ?? $14e0f24ef4ac5c92$export$ccc1b2479e7dd654(from, locale, firstDay);
  const weeks = [...new Array(monthWeeks).keys()];
  return weeks.map((week) => getDaysInWeek(week, from, locale, firstDayOfWeek));
}
function getWeekdayFormats(locale, timeZone) {
  const longFormat = new $fb18d541ea1ad717$export$ad991b66133851cf(locale, { weekday: "long", timeZone });
  const shortFormat = new $fb18d541ea1ad717$export$ad991b66133851cf(locale, { weekday: "short", timeZone });
  const narrowFormat = new $fb18d541ea1ad717$export$ad991b66133851cf(locale, { weekday: "narrow", timeZone });
  return (value) => {
    const date = value instanceof Date ? value : value.toDate(timeZone);
    return {
      value,
      short: shortFormat.format(date),
      long: longFormat.format(date),
      narrow: narrowFormat.format(date)
    };
  };
}
function getWeekDays(date, startOfWeekProp, timeZone, locale) {
  const firstDayOfWeek = getStartOfWeek(date, locale, startOfWeekProp);
  const weeks = [...new Array(7).keys()];
  const format = getWeekdayFormats(locale, timeZone);
  return weeks.map((index) => format(firstDayOfWeek.add({ days: index })));
}
function getMonthNames(locale, format = "long") {
  const date = new Date(2021, 0, 1);
  const monthNames = [];
  for (let i = 0; i < 12; i++) {
    monthNames.push(date.toLocaleString(locale, { month: format }));
    date.setMonth(date.getMonth() + 1);
  }
  return monthNames;
}
function getYearsRange(range2) {
  const years = [];
  for (let year = range2.from; year <= range2.to; year += 1) years.push(year);
  return years;
}
var FUTURE_YEAR_COERCION = 10;
function normalizeYear(year) {
  if (!year) return;
  if (year.length === 3) return year.padEnd(4, "0");
  if (year.length === 2) {
    const currentYear = (/* @__PURE__ */ new Date()).getFullYear();
    const currentCentury = Math.floor(currentYear / 100) * 100;
    const twoDigitYear = parseInt(year.slice(-2), 10);
    const fullYear = currentCentury + twoDigitYear;
    return fullYear > currentYear + FUTURE_YEAR_COERCION ? (fullYear - 100).toString() : fullYear.toString();
  }
  return year;
}
function getDecadeRange(year) {
  const computedYear = year - year % 10 - 1;
  const years = [];
  for (let i = 0; i < 12; i += 1) {
    const value = computedYear + i;
    years.push(value);
  }
  return years;
}
function getTodayDate(timeZone) {
  return $14e0f24ef4ac5c92$export$d0bdf45af03a6ea3(timeZone ?? $14e0f24ef4ac5c92$export$aa8b41735afcabd2());
}
function getAdjustedDateFn(visibleDuration, locale, minValue, maxValue2) {
  return function getDate(options) {
    const { startDate, focusedDate } = options;
    const endDate = getEndDate(startDate, visibleDuration);
    if (isDateOutsideRange(focusedDate, minValue, maxValue2)) {
      return {
        startDate,
        focusedDate: constrainValue(focusedDate, minValue, maxValue2),
        endDate
      };
    }
    if (focusedDate.compare(startDate) < 0) {
      return {
        startDate: alignEnd(focusedDate, visibleDuration, locale, minValue, maxValue2),
        focusedDate: constrainValue(focusedDate, minValue, maxValue2),
        endDate
      };
    }
    if (focusedDate.compare(endDate) > 0) {
      return {
        startDate: alignStart(focusedDate, visibleDuration, locale, minValue, maxValue2),
        endDate,
        focusedDate: constrainValue(focusedDate, minValue, maxValue2)
      };
    }
    return {
      startDate,
      endDate,
      focusedDate: constrainValue(focusedDate, minValue, maxValue2)
    };
  };
}
function getNextPage(focusedDate, startDate, visibleDuration, locale, minValue, maxValue2) {
  const adjust2 = getAdjustedDateFn(visibleDuration, locale, minValue, maxValue2);
  const start = startDate.add(visibleDuration);
  return adjust2({
    focusedDate: focusedDate.add(visibleDuration),
    startDate: alignStart(
      constrainStart(focusedDate, start, visibleDuration, locale, minValue, maxValue2),
      visibleDuration,
      locale
    )
  });
}
function getPreviousPage(focusedDate, startDate, visibleDuration, locale, minValue, maxValue2) {
  const adjust2 = getAdjustedDateFn(visibleDuration, locale, minValue, maxValue2);
  let start = startDate.subtract(visibleDuration);
  return adjust2({
    focusedDate: focusedDate.subtract(visibleDuration),
    startDate: alignStart(
      constrainStart(focusedDate, start, visibleDuration, locale, minValue, maxValue2),
      visibleDuration,
      locale
    )
  });
}
function getNextSection(focusedDate, startDate, larger, visibleDuration, locale, minValue, maxValue2) {
  const adjust2 = getAdjustedDateFn(visibleDuration, locale, minValue, maxValue2);
  if (!larger && !visibleDuration.days) {
    return adjust2({
      focusedDate: focusedDate.add(getUnitDuration(visibleDuration)),
      startDate
    });
  }
  if (visibleDuration.days) {
    return getNextPage(focusedDate, startDate, visibleDuration, locale, minValue, maxValue2);
  }
  if (visibleDuration.weeks) {
    return adjust2({
      focusedDate: focusedDate.add({ months: 1 }),
      startDate
    });
  }
  if (visibleDuration.months || visibleDuration.years) {
    return adjust2({
      focusedDate: focusedDate.add({ years: 1 }),
      startDate
    });
  }
}
function getPreviousSection(focusedDate, startDate, larger, visibleDuration, locale, minValue, maxValue2) {
  const adjust2 = getAdjustedDateFn(visibleDuration, locale, minValue, maxValue2);
  if (!larger && !visibleDuration.days) {
    return adjust2({
      focusedDate: focusedDate.subtract(getUnitDuration(visibleDuration)),
      startDate
    });
  }
  if (visibleDuration.days) {
    return getPreviousPage(focusedDate, startDate, visibleDuration, locale, minValue, maxValue2);
  }
  if (visibleDuration.weeks) {
    return adjust2({
      focusedDate: focusedDate.subtract({ months: 1 }),
      startDate
    });
  }
  if (visibleDuration.months || visibleDuration.years) {
    return adjust2({
      focusedDate: focusedDate.subtract({ years: 1 }),
      startDate
    });
  }
}
var isValidYear = (year) => year != null && year.length === 4;
var isValidMonth = (month) => month != null && parseFloat(month) <= 12;
var isValidDay = (day) => day != null && parseFloat(day) <= 31;
function parseDateString(date, locale, timeZone) {
  const regex = createRegex(locale, timeZone);
  let { year, month, day } = extract(regex, date) ?? {};
  const hasMatch = year != null || month != null || day != null;
  if (hasMatch) {
    const curr = /* @__PURE__ */ new Date();
    year || (year = curr.getFullYear().toString());
    month || (month = (curr.getMonth() + 1).toString());
    day || (day = curr.getDate().toString());
  }
  if (!isValidYear(year)) {
    year = normalizeYear(year);
  }
  if (isValidYear(year) && isValidMonth(month) && isValidDay(day)) {
    return new $35ea8db9cb2ccb90$export$99faa760c7908e4f(+year, +month, +day);
  }
  const time = Date.parse(date);
  if (!isNaN(time)) {
    const date2 = new Date(time);
    return new $35ea8db9cb2ccb90$export$99faa760c7908e4f(date2.getFullYear(), date2.getMonth() + 1, date2.getDate());
  }
}
function createRegex(locale, timeZone) {
  const formatter = new $fb18d541ea1ad717$export$ad991b66133851cf(locale, { day: "numeric", month: "numeric", year: "numeric", timeZone });
  const parts46 = formatter.formatToParts(new Date(2e3, 11, 25));
  return parts46.map(({ type, value }) => type === "literal" ? `${value}?` : `((?!=<${type}>)\\d+)?`).join("");
}
function extract(pattern, str) {
  var _a8;
  const matches = str.match(pattern);
  return (_a8 = pattern.toString().match(/<(.+?)>/g)) == null ? void 0 : _a8.map((group2) => {
    var _a9;
    const groupMatches = group2.match(/<(.+)>/);
    if (!groupMatches || groupMatches.length <= 0) {
      return null;
    }
    return (_a9 = group2.match(/<(.+)>/)) == null ? void 0 : _a9[1];
  }).reduce((acc, curr, index) => {
    if (!curr) return acc;
    if (matches && matches.length > index) {
      acc[curr] = matches[index + 1];
    } else {
      acc[curr] = null;
    }
    return acc;
  }, {});
}
function getDateRangePreset(preset, locale, timeZone) {
  const today3 = $14e0f24ef4ac5c92$export$461939dd4422153(timeZone);
  switch (preset) {
    case "thisWeek":
      return [$14e0f24ef4ac5c92$export$42c81a444fbfb5d4(today3, locale), $14e0f24ef4ac5c92$export$ef8b6d9133084f4e(today3, locale)];
    case "thisMonth":
      return [$14e0f24ef4ac5c92$export$a5a3b454ada2268e(today3), today3];
    case "thisQuarter":
      return [$14e0f24ef4ac5c92$export$a5a3b454ada2268e(today3).add({ months: -today3.month % 3 }), today3];
    case "thisYear":
      return [$14e0f24ef4ac5c92$export$f91e89d3d0406102(today3), today3];
    case "last3Days":
      return [today3.add({ days: -2 }), today3];
    case "last7Days":
      return [today3.add({ days: -6 }), today3];
    case "last14Days":
      return [today3.add({ days: -13 }), today3];
    case "last30Days":
      return [today3.add({ days: -29 }), today3];
    case "last90Days":
      return [today3.add({ days: -89 }), today3];
    case "lastMonth":
      return [$14e0f24ef4ac5c92$export$a5a3b454ada2268e(today3.add({ months: -1 })), $14e0f24ef4ac5c92$export$a2258d9c4118825c(today3.add({ months: -1 }))];
    case "lastQuarter":
      return [
        $14e0f24ef4ac5c92$export$a5a3b454ada2268e(today3.add({ months: -today3.month % 3 - 3 })),
        $14e0f24ef4ac5c92$export$a2258d9c4118825c(today3.add({ months: -today3.month % 3 - 1 }))
      ];
    case "lastWeek":
      return [$14e0f24ef4ac5c92$export$42c81a444fbfb5d4(today3, locale).add({ weeks: -1 }), $14e0f24ef4ac5c92$export$ef8b6d9133084f4e(today3, locale).add({ weeks: -1 })];
    case "lastYear":
      return [$14e0f24ef4ac5c92$export$f91e89d3d0406102(today3.add({ years: -1 })), $14e0f24ef4ac5c92$export$8b7aa55c66d5569e(today3.add({ years: -1 }))];
    default:
      throw new Error(`Invalid date range preset: ${preset}`);
  }
}

// node_modules/@zag-js/live-region/dist/index.mjs
var ID = "__live-region__";
function createLiveRegion(opts = {}) {
  const { level = "polite", document: doc = document, root, delay: _delay = 0 } = opts;
  const win = doc.defaultView ?? window;
  const parent = root ?? doc.body;
  function announce(message, delay2) {
    const oldRegion = doc.getElementById(ID);
    oldRegion == null ? void 0 : oldRegion.remove();
    delay2 = delay2 ?? _delay;
    const region = doc.createElement("span");
    region.id = ID;
    region.dataset.liveAnnouncer = "true";
    const role = level !== "assertive" ? "status" : "alert";
    region.setAttribute("aria-live", level);
    region.setAttribute("role", role);
    Object.assign(region.style, {
      border: "0",
      clip: "rect(0 0 0 0)",
      height: "1px",
      margin: "-1px",
      overflow: "hidden",
      padding: "0",
      position: "absolute",
      width: "1px",
      whiteSpace: "nowrap",
      wordWrap: "normal"
    });
    parent.appendChild(region);
    win.setTimeout(() => {
      region.textContent = message;
    }, delay2);
  }
  function destroy() {
    const oldRegion = doc.getElementById(ID);
    oldRegion == null ? void 0 : oldRegion.remove();
  }
  return {
    announce,
    destroy,
    toJSON() {
      return ID;
    }
  };
}

// node_modules/@zag-js/date-picker/dist/index.mjs
var anatomy3 = createAnatomy("date-picker").parts(
  "clearTrigger",
  "content",
  "control",
  "input",
  "label",
  "monthSelect",
  "nextTrigger",
  "positioner",
  "presetTrigger",
  "prevTrigger",
  "rangeText",
  "root",
  "table",
  "tableBody",
  "tableCell",
  "tableCellTrigger",
  "tableHead",
  "tableHeader",
  "tableRow",
  "trigger",
  "view",
  "viewControl",
  "viewTrigger",
  "yearSelect"
);
var parts3 = anatomy3.build();
var getLabelId2 = (ctx, index) => {
  var _a8, _b7;
  return ((_b7 = (_a8 = ctx.ids) == null ? void 0 : _a8.label) == null ? void 0 : _b7.call(_a8, index)) ?? `datepicker:${ctx.id}:label:${index}`;
};
var getRootId3 = (ctx) => {
  var _a8;
  return ((_a8 = ctx.ids) == null ? void 0 : _a8.root) ?? `datepicker:${ctx.id}`;
};
var getTableId = (ctx, id) => {
  var _a8, _b7;
  return ((_b7 = (_a8 = ctx.ids) == null ? void 0 : _a8.table) == null ? void 0 : _b7.call(_a8, id)) ?? `datepicker:${ctx.id}:table:${id}`;
};
var getContentId3 = (ctx) => {
  var _a8;
  return ((_a8 = ctx.ids) == null ? void 0 : _a8.content) ?? `datepicker:${ctx.id}:content`;
};
var getCellTriggerId = (ctx, id) => {
  var _a8, _b7;
  return ((_b7 = (_a8 = ctx.ids) == null ? void 0 : _a8.cellTrigger) == null ? void 0 : _b7.call(_a8, id)) ?? `datepicker:${ctx.id}:cell-trigger:${id}`;
};
var getPrevTriggerId = (ctx, view) => {
  var _a8, _b7;
  return ((_b7 = (_a8 = ctx.ids) == null ? void 0 : _a8.prevTrigger) == null ? void 0 : _b7.call(_a8, view)) ?? `datepicker:${ctx.id}:prev:${view}`;
};
var getNextTriggerId = (ctx, view) => {
  var _a8, _b7;
  return ((_b7 = (_a8 = ctx.ids) == null ? void 0 : _a8.nextTrigger) == null ? void 0 : _b7.call(_a8, view)) ?? `datepicker:${ctx.id}:next:${view}`;
};
var getViewTriggerId = (ctx, view) => {
  var _a8, _b7;
  return ((_b7 = (_a8 = ctx.ids) == null ? void 0 : _a8.viewTrigger) == null ? void 0 : _b7.call(_a8, view)) ?? `datepicker:${ctx.id}:view:${view}`;
};
var getClearTriggerId = (ctx) => {
  var _a8;
  return ((_a8 = ctx.ids) == null ? void 0 : _a8.clearTrigger) ?? `datepicker:${ctx.id}:clear`;
};
var getControlId2 = (ctx) => {
  var _a8;
  return ((_a8 = ctx.ids) == null ? void 0 : _a8.control) ?? `datepicker:${ctx.id}:control`;
};
var getInputId = (ctx, index) => {
  var _a8, _b7;
  return ((_b7 = (_a8 = ctx.ids) == null ? void 0 : _a8.input) == null ? void 0 : _b7.call(_a8, index)) ?? `datepicker:${ctx.id}:input:${index}`;
};
var getTriggerId3 = (ctx) => {
  var _a8;
  return ((_a8 = ctx.ids) == null ? void 0 : _a8.trigger) ?? `datepicker:${ctx.id}:trigger`;
};
var getPositionerId2 = (ctx) => {
  var _a8;
  return ((_a8 = ctx.ids) == null ? void 0 : _a8.positioner) ?? `datepicker:${ctx.id}:positioner`;
};
var getMonthSelectId = (ctx) => {
  var _a8;
  return ((_a8 = ctx.ids) == null ? void 0 : _a8.monthSelect) ?? `datepicker:${ctx.id}:month-select`;
};
var getYearSelectId = (ctx) => {
  var _a8;
  return ((_a8 = ctx.ids) == null ? void 0 : _a8.yearSelect) ?? `datepicker:${ctx.id}:year-select`;
};
var getFocusedCell = (ctx, view) => query(getContentEl3(ctx), `[data-part=table-cell-trigger][data-view=${view}][data-focus]:not([data-outside-range])`);
var getTriggerEl2 = (ctx) => ctx.getById(getTriggerId3(ctx));
var getContentEl3 = (ctx) => ctx.getById(getContentId3(ctx));
var getInputEls = (ctx) => queryAll(getControlEl2(ctx), `[data-part=input]`);
var getYearSelectEl = (ctx) => ctx.getById(getYearSelectId(ctx));
var getMonthSelectEl = (ctx) => ctx.getById(getMonthSelectId(ctx));
var getClearTriggerEl = (ctx) => ctx.getById(getClearTriggerId(ctx));
var getPositionerEl2 = (ctx) => ctx.getById(getPositionerId2(ctx));
var getControlEl2 = (ctx) => ctx.getById(getControlId2(ctx));
function adjustStartAndEndDate(value) {
  const [startDate, endDate] = value;
  if (!startDate || !endDate) return value;
  return startDate.compare(endDate) <= 0 ? value : [endDate, startDate];
}
function isDateWithinRange(date, value) {
  const [startDate, endDate] = value;
  if (!startDate || !endDate) return false;
  return startDate.compare(date) <= 0 && endDate.compare(date) >= 0;
}
function sortDates(values) {
  return values.slice().sort((a2, b2) => a2.compare(b2));
}
function getRoleDescription(view) {
  return match(view, {
    year: "calendar decade",
    month: "calendar year",
    day: "calendar month"
  });
}
var PLACEHOLDERS = {
  day: "dd",
  month: "mm",
  year: "yyyy"
};
function getInputPlaceholder(locale) {
  return new $fb18d541ea1ad717$export$ad991b66133851cf(locale).formatToParts(/* @__PURE__ */ new Date()).map((item) => PLACEHOLDERS[item.type] ?? item.value).join("");
}
var isValidCharacter = (char, separator) => {
  if (!char) return true;
  return /\d/.test(char) || char === separator || char.length !== 1;
};
var isValidDate = (value) => {
  return !Number.isNaN(value.day) && !Number.isNaN(value.month) && !Number.isNaN(value.year);
};
var ensureValidCharacters = (value, separator) => {
  return value.split("").filter((char) => isValidCharacter(char, separator)).join("");
};
function getLocaleSeparator(locale) {
  const dateFormatter = new Intl.DateTimeFormat(locale);
  const parts210 = dateFormatter.formatToParts(/* @__PURE__ */ new Date());
  const literalPart = parts210.find((part) => part.type === "literal");
  return literalPart ? literalPart.value : "/";
}
var defaultTranslations = {
  dayCell(state2) {
    if (state2.unavailable) return `Not available. ${state2.formattedDate}`;
    if (state2.selected) return `Selected date. ${state2.formattedDate}`;
    return `Choose ${state2.formattedDate}`;
  },
  trigger(open) {
    return open ? "Close calendar" : "Open calendar";
  },
  viewTrigger(view) {
    return match(view, {
      year: "Switch to month view",
      month: "Switch to day view",
      day: "Switch to year view"
    });
  },
  presetTrigger(value) {
    return Array.isArray(value) ? `select ${value[0].toString()} to ${value[1].toString()}` : `select ${value}`;
  },
  prevTrigger(view) {
    return match(view, {
      year: "Switch to previous decade",
      month: "Switch to previous year",
      day: "Switch to previous month"
    });
  },
  nextTrigger(view) {
    return match(view, {
      year: "Switch to next decade",
      month: "Switch to next year",
      day: "Switch to next month"
    });
  },
  // TODO: Revisit this
  placeholder() {
    return { day: "dd", month: "mm", year: "yyyy" };
  },
  content: "calendar",
  monthSelect: "Select month",
  yearSelect: "Select year",
  clearTrigger: "Clear selected dates"
};
function viewToNumber(view, fallback4) {
  if (!view) return fallback4 || 0;
  return view === "day" ? 0 : view === "month" ? 1 : 2;
}
function viewNumberToView(viewNumber) {
  return viewNumber === 0 ? "day" : viewNumber === 1 ? "month" : "year";
}
function clampView(view, minView, maxView) {
  return viewNumberToView(
    clampValue(viewToNumber(view, 0), viewToNumber(minView, 0), viewToNumber(maxView, 2))
  );
}
function isAboveMinView(view, minView) {
  return viewToNumber(view, 0) > viewToNumber(minView, 0);
}
function isBelowMinView(view, minView) {
  return viewToNumber(view, 0) < viewToNumber(minView, 0);
}
function getNextView(view, minView, maxView) {
  const nextViewNumber = viewToNumber(view, 0) + 1;
  return clampView(viewNumberToView(nextViewNumber), minView, maxView);
}
function getPreviousView(view, minView, maxView) {
  const prevViewNumber = viewToNumber(view, 0) - 1;
  return clampView(viewNumberToView(prevViewNumber), minView, maxView);
}
var views = ["day", "month", "year"];
function eachView(cb) {
  views.forEach((view) => cb(view));
}
function connect4(service, normalize4) {
  const { state: state2, context, prop, send, computed, scope } = service;
  const startValue = context.get("startValue");
  const endValue = computed("endValue");
  const selectedValue = context.get("value");
  const focusedValue = context.get("focusedValue");
  const hoveredValue = context.get("hoveredValue");
  const hoveredRangeValue = hoveredValue ? adjustStartAndEndDate([selectedValue[0], hoveredValue]) : [];
  const disabled = prop("disabled");
  const readOnly = prop("readOnly");
  const interactive = computed("isInteractive");
  const min4 = prop("min");
  const max4 = prop("max");
  const locale = prop("locale");
  const timeZone = prop("timeZone");
  const startOfWeek = prop("startOfWeek");
  const focused = state2.matches("focused");
  const open = state2.matches("open");
  const isRangePicker = prop("selectionMode") === "range";
  const isDateUnavailableFn = prop("isDateUnavailable");
  const currentPlacement = context.get("currentPlacement");
  const popperStyles = getPlacementStyles({
    ...prop("positioning"),
    placement: currentPlacement
  });
  const separator = getLocaleSeparator(locale);
  const translations = { ...defaultTranslations, ...prop("translations") };
  function getMonthWeeks(from = startValue) {
    const numOfWeeks = prop("fixedWeeks") ? 6 : void 0;
    return getMonthDays(from, locale, numOfWeeks, startOfWeek);
  }
  function getMonths(props210 = {}) {
    const { format } = props210;
    return getMonthNames(locale, format).map((label, index) => ({ label, value: index + 1 }));
  }
  function getYears() {
    const range2 = getYearsRange({ from: (min4 == null ? void 0 : min4.year) ?? 1900, to: (max4 == null ? void 0 : max4.year) ?? 2100 });
    return range2.map((year) => ({ label: year.toString(), value: year }));
  }
  function getDecadeYears(year) {
    const range2 = getDecadeRange(focusedValue.year);
    return range2.map((year2) => ({ label: year2.toString(), value: year2 }));
  }
  function isUnavailable(date) {
    return isDateUnavailable(date, isDateUnavailableFn, locale, min4, max4);
  }
  function focusMonth(month) {
    const date = startValue ?? getTodayDate(timeZone);
    send({ type: "FOCUS.SET", value: date.set({ month }) });
  }
  function focusYear(year) {
    const date = startValue ?? getTodayDate(timeZone);
    send({ type: "FOCUS.SET", value: date.set({ year }) });
  }
  function getYearTableCellState(props210) {
    const { value, disabled: disabled2 } = props210;
    const cellState = {
      focused: focusedValue.year === props210.value,
      selectable: isValueWithinRange(value, (min4 == null ? void 0 : min4.year) ?? 0, (max4 == null ? void 0 : max4.year) ?? 9999),
      selected: !!selectedValue.find((date) => date.year === value),
      valueText: value.toString(),
      get disabled() {
        return disabled2 || !cellState.selectable;
      }
    };
    return cellState;
  }
  function getMonthTableCellState(props210) {
    const { value, disabled: disabled2 } = props210;
    const normalized = focusedValue.set({ month: value });
    const formatter = getMonthFormatter(locale, timeZone);
    const cellState = {
      focused: focusedValue.month === props210.value,
      selectable: !isDateOutsideRange(normalized, min4, max4),
      selected: !!selectedValue.find((date) => date.month === value && date.year === focusedValue.year),
      valueText: formatter.format(normalized.toDate(timeZone)),
      get disabled() {
        return disabled2 || !cellState.selectable;
      }
    };
    return cellState;
  }
  function getDayTableCellState(props210) {
    const { value, disabled: disabled2, visibleRange = computed("visibleRange") } = props210;
    const formatter = getDayFormatter(locale, timeZone);
    const unitDuration = getUnitDuration(computed("visibleDuration"));
    const outsideDaySelectable = prop("outsideDaySelectable");
    const end = visibleRange.start.add(unitDuration).subtract({ days: 1 });
    const isOutsideRange = isDateOutsideRange(value, visibleRange.start, end);
    const cellState = {
      invalid: isDateOutsideRange(value, min4, max4),
      disabled: disabled2 || !outsideDaySelectable && isOutsideRange || isDateOutsideRange(value, min4, max4),
      selected: selectedValue.some((date) => isDateEqual(value, date)),
      unavailable: isDateUnavailable(value, isDateUnavailableFn, locale, min4, max4) && !disabled2,
      outsideRange: isOutsideRange,
      inRange: isRangePicker && (isDateWithinRange(value, selectedValue) || isDateWithinRange(value, hoveredRangeValue)),
      firstInRange: isRangePicker && isDateEqual(value, selectedValue[0]),
      lastInRange: isRangePicker && isDateEqual(value, selectedValue[1]),
      today: $14e0f24ef4ac5c92$export$629b0a497aa65267(value, timeZone),
      weekend: $14e0f24ef4ac5c92$export$618d60ea299da42(value, locale),
      formattedDate: formatter.format(value.toDate(timeZone)),
      get focused() {
        return isDateEqual(value, focusedValue) && (!cellState.outsideRange || outsideDaySelectable);
      },
      get ariaLabel() {
        return translations.dayCell(cellState);
      },
      get selectable() {
        return !cellState.disabled && !cellState.unavailable;
      }
    };
    return cellState;
  }
  function getTableId2(props210) {
    const { view = "day", id } = props210;
    return [view, id].filter(Boolean).join(" ");
  }
  return {
    focused,
    open,
    view: context.get("view"),
    getRangePresetValue(preset) {
      return getDateRangePreset(preset, locale, timeZone);
    },
    getDaysInWeek(week, from = startValue) {
      return getDaysInWeek(week, from, locale, startOfWeek);
    },
    getOffset(duration) {
      const from = startValue.add(duration);
      const end = endValue.add(duration);
      const formatter = getMonthFormatter(locale, timeZone);
      return {
        visibleRange: { start: from, end },
        weeks: getMonthWeeks(from),
        visibleRangeText: {
          start: formatter.format(from.toDate(timeZone)),
          end: formatter.format(end.toDate(timeZone))
        }
      };
    },
    getMonthWeeks,
    isUnavailable,
    weeks: getMonthWeeks(),
    weekDays: getWeekDays(getTodayDate(timeZone), startOfWeek, timeZone, locale),
    visibleRangeText: computed("visibleRangeText"),
    value: selectedValue,
    valueAsDate: selectedValue.map((date) => date.toDate(timeZone)),
    valueAsString: computed("valueAsString"),
    focusedValue,
    focusedValueAsDate: focusedValue == null ? void 0 : focusedValue.toDate(timeZone),
    focusedValueAsString: prop("format")(focusedValue, { locale, timeZone }),
    visibleRange: computed("visibleRange"),
    selectToday() {
      const value = constrainValue(getTodayDate(timeZone), min4, max4);
      send({ type: "VALUE.SET", value });
    },
    setValue(values) {
      const computedValue = values.map((date) => constrainValue(date, min4, max4));
      send({ type: "VALUE.SET", value: computedValue });
    },
    clearValue() {
      send({ type: "VALUE.CLEAR" });
    },
    setFocusedValue(value) {
      send({ type: "FOCUS.SET", value });
    },
    setOpen(nextOpen) {
      const open2 = state2.matches("open");
      if (open2 === nextOpen) return;
      send({ type: nextOpen ? "OPEN" : "CLOSE" });
    },
    focusMonth,
    focusYear,
    getYears,
    getMonths,
    getYearsGrid(props210 = {}) {
      const { columns = 1 } = props210;
      return chunk(getDecadeYears(), columns);
    },
    getDecade() {
      const years = getDecadeRange(focusedValue.year);
      return { start: years.at(0), end: years.at(-1) };
    },
    getMonthsGrid(props210 = {}) {
      const { columns = 1, format } = props210;
      return chunk(getMonths({ format }), columns);
    },
    format(value, opts = { month: "long", year: "numeric" }) {
      return new $fb18d541ea1ad717$export$ad991b66133851cf(locale, opts).format(value.toDate(timeZone));
    },
    setView(view) {
      send({ type: "VIEW.SET", view });
    },
    goToNext() {
      send({ type: "GOTO.NEXT", view: context.get("view") });
    },
    goToPrev() {
      send({ type: "GOTO.PREV", view: context.get("view") });
    },
    getRootProps() {
      return normalize4.element({
        ...parts3.root.attrs,
        dir: prop("dir"),
        id: getRootId3(scope),
        "data-state": open ? "open" : "closed",
        "data-disabled": dataAttr(disabled),
        "data-readonly": dataAttr(readOnly)
      });
    },
    getLabelProps(props210 = {}) {
      const { index = 0 } = props210;
      return normalize4.label({
        ...parts3.label.attrs,
        id: getLabelId2(scope, index),
        dir: prop("dir"),
        htmlFor: getInputId(scope, index),
        "data-state": open ? "open" : "closed",
        "data-index": index,
        "data-disabled": dataAttr(disabled),
        "data-readonly": dataAttr(readOnly)
      });
    },
    getControlProps() {
      return normalize4.element({
        ...parts3.control.attrs,
        dir: prop("dir"),
        id: getControlId2(scope),
        "data-disabled": dataAttr(disabled)
      });
    },
    getRangeTextProps() {
      return normalize4.element({
        ...parts3.rangeText.attrs,
        dir: prop("dir")
      });
    },
    getContentProps() {
      return normalize4.element({
        ...parts3.content.attrs,
        hidden: !open,
        dir: prop("dir"),
        "data-state": open ? "open" : "closed",
        "data-placement": currentPlacement,
        id: getContentId3(scope),
        tabIndex: -1,
        role: "application",
        "aria-roledescription": "datepicker",
        "aria-label": translations.content
      });
    },
    getTableProps(props210 = {}) {
      const { view = "day", columns = view === "day" ? 7 : 4 } = props210;
      const uid = getTableId2(props210);
      return normalize4.element({
        ...parts3.table.attrs,
        role: "grid",
        "data-columns": columns,
        "aria-roledescription": getRoleDescription(view),
        id: getTableId(scope, uid),
        "aria-readonly": ariaAttr(readOnly),
        "aria-disabled": ariaAttr(disabled),
        "aria-multiselectable": ariaAttr(prop("selectionMode") !== "single"),
        "data-view": view,
        dir: prop("dir"),
        tabIndex: -1,
        onKeyDown(event) {
          if (event.defaultPrevented) return;
          const keyMap2 = {
            Enter() {
              if (isUnavailable(focusedValue)) return;
              send({ type: "TABLE.ENTER", view, columns, focus: true });
            },
            ArrowLeft() {
              send({ type: "TABLE.ARROW_LEFT", view, columns, focus: true });
            },
            ArrowRight() {
              send({ type: "TABLE.ARROW_RIGHT", view, columns, focus: true });
            },
            ArrowUp() {
              send({ type: "TABLE.ARROW_UP", view, columns, focus: true });
            },
            ArrowDown() {
              send({ type: "TABLE.ARROW_DOWN", view, columns, focus: true });
            },
            PageUp(event2) {
              send({ type: "TABLE.PAGE_UP", larger: event2.shiftKey, view, columns, focus: true });
            },
            PageDown(event2) {
              send({ type: "TABLE.PAGE_DOWN", larger: event2.shiftKey, view, columns, focus: true });
            },
            Home() {
              send({ type: "TABLE.HOME", view, columns, focus: true });
            },
            End() {
              send({ type: "TABLE.END", view, columns, focus: true });
            }
          };
          const exec = keyMap2[getEventKey(event, {
            dir: prop("dir")
          })];
          if (exec) {
            exec(event);
            event.preventDefault();
            event.stopPropagation();
          }
        },
        onPointerLeave() {
          send({ type: "TABLE.POINTER_LEAVE" });
        },
        onPointerDown() {
          send({ type: "TABLE.POINTER_DOWN", view });
        },
        onPointerUp() {
          send({ type: "TABLE.POINTER_UP", view });
        }
      });
    },
    getTableHeadProps(props210 = {}) {
      const { view = "day" } = props210;
      return normalize4.element({
        ...parts3.tableHead.attrs,
        "aria-hidden": true,
        dir: prop("dir"),
        "data-view": view,
        "data-disabled": dataAttr(disabled)
      });
    },
    getTableHeaderProps(props210 = {}) {
      const { view = "day" } = props210;
      return normalize4.element({
        ...parts3.tableHeader.attrs,
        dir: prop("dir"),
        "data-view": view,
        "data-disabled": dataAttr(disabled)
      });
    },
    getTableBodyProps(props210 = {}) {
      const { view = "day" } = props210;
      return normalize4.element({
        ...parts3.tableBody.attrs,
        "data-view": view,
        "data-disabled": dataAttr(disabled)
      });
    },
    getTableRowProps(props210 = {}) {
      const { view = "day" } = props210;
      return normalize4.element({
        ...parts3.tableRow.attrs,
        "aria-disabled": ariaAttr(disabled),
        "data-disabled": dataAttr(disabled),
        "data-view": view
      });
    },
    getDayTableCellState,
    getDayTableCellProps(props210) {
      const { value } = props210;
      const cellState = getDayTableCellState(props210);
      return normalize4.element({
        ...parts3.tableCell.attrs,
        role: "gridcell",
        "aria-disabled": ariaAttr(!cellState.selectable),
        "aria-selected": cellState.selected || cellState.inRange,
        "aria-invalid": ariaAttr(cellState.invalid),
        "aria-current": cellState.today ? "date" : void 0,
        "data-value": value.toString()
      });
    },
    getDayTableCellTriggerProps(props210) {
      const { value } = props210;
      const cellState = getDayTableCellState(props210);
      return normalize4.element({
        ...parts3.tableCellTrigger.attrs,
        id: getCellTriggerId(scope, value.toString()),
        role: "button",
        dir: prop("dir"),
        tabIndex: cellState.focused ? 0 : -1,
        "aria-label": cellState.ariaLabel,
        "aria-disabled": ariaAttr(!cellState.selectable),
        "aria-invalid": ariaAttr(cellState.invalid),
        "data-disabled": dataAttr(!cellState.selectable),
        "data-selected": dataAttr(cellState.selected),
        "data-value": value.toString(),
        "data-view": "day",
        "data-today": dataAttr(cellState.today),
        "data-focus": dataAttr(cellState.focused),
        "data-unavailable": dataAttr(cellState.unavailable),
        "data-range-start": dataAttr(cellState.firstInRange),
        "data-range-end": dataAttr(cellState.lastInRange),
        "data-in-range": dataAttr(cellState.inRange),
        "data-outside-range": dataAttr(cellState.outsideRange),
        "data-weekend": dataAttr(cellState.weekend),
        onClick(event) {
          if (event.defaultPrevented) return;
          if (!cellState.selectable) return;
          send({ type: "CELL.CLICK", cell: "day", value });
        },
        onPointerMove(event) {
          if (event.pointerType === "touch" || !cellState.selectable) return;
          const focus = event.currentTarget.ownerDocument.activeElement !== event.currentTarget;
          if (hoveredValue && $14e0f24ef4ac5c92$export$91b62ebf2ba703ee(value, hoveredValue)) return;
          send({ type: "CELL.POINTER_MOVE", cell: "day", value, focus });
        }
      });
    },
    getMonthTableCellState,
    getMonthTableCellProps(props210) {
      const { value, columns } = props210;
      const cellState = getMonthTableCellState(props210);
      return normalize4.element({
        ...parts3.tableCell.attrs,
        dir: prop("dir"),
        colSpan: columns,
        role: "gridcell",
        "aria-selected": ariaAttr(cellState.selected),
        "data-selected": dataAttr(cellState.selected),
        "aria-disabled": ariaAttr(!cellState.selectable),
        "data-value": value
      });
    },
    getMonthTableCellTriggerProps(props210) {
      const { value } = props210;
      const cellState = getMonthTableCellState(props210);
      return normalize4.element({
        ...parts3.tableCellTrigger.attrs,
        dir: prop("dir"),
        role: "button",
        id: getCellTriggerId(scope, value.toString()),
        "data-selected": dataAttr(cellState.selected),
        "aria-disabled": ariaAttr(!cellState.selectable),
        "data-disabled": dataAttr(!cellState.selectable),
        "data-focus": dataAttr(cellState.focused),
        "aria-label": cellState.valueText,
        "data-view": "month",
        "data-value": value,
        tabIndex: cellState.focused ? 0 : -1,
        onClick(event) {
          if (event.defaultPrevented) return;
          if (!cellState.selectable) return;
          send({ type: "CELL.CLICK", cell: "month", value });
        }
      });
    },
    getYearTableCellState,
    getYearTableCellProps(props210) {
      const { value, columns } = props210;
      const cellState = getYearTableCellState(props210);
      return normalize4.element({
        ...parts3.tableCell.attrs,
        dir: prop("dir"),
        colSpan: columns,
        role: "gridcell",
        "aria-selected": ariaAttr(cellState.selected),
        "data-selected": dataAttr(cellState.selected),
        "aria-disabled": ariaAttr(!cellState.selectable),
        "data-value": value
      });
    },
    getYearTableCellTriggerProps(props210) {
      const { value } = props210;
      const cellState = getYearTableCellState(props210);
      return normalize4.element({
        ...parts3.tableCellTrigger.attrs,
        dir: prop("dir"),
        role: "button",
        id: getCellTriggerId(scope, value.toString()),
        "data-selected": dataAttr(cellState.selected),
        "data-focus": dataAttr(cellState.focused),
        "aria-disabled": ariaAttr(!cellState.selectable),
        "data-disabled": dataAttr(!cellState.selectable),
        "aria-label": cellState.valueText,
        "data-value": value,
        "data-view": "year",
        tabIndex: cellState.focused ? 0 : -1,
        onClick(event) {
          if (event.defaultPrevented) return;
          if (!cellState.selectable) return;
          send({ type: "CELL.CLICK", cell: "year", value });
        }
      });
    },
    getNextTriggerProps(props210 = {}) {
      const { view = "day" } = props210;
      const isDisabled = disabled || !computed("isNextVisibleRangeValid");
      return normalize4.button({
        ...parts3.nextTrigger.attrs,
        dir: prop("dir"),
        id: getNextTriggerId(scope, view),
        type: "button",
        "aria-label": translations.nextTrigger(view),
        disabled: isDisabled,
        "data-disabled": dataAttr(isDisabled),
        onClick(event) {
          if (event.defaultPrevented) return;
          send({ type: "GOTO.NEXT", view });
        }
      });
    },
    getPrevTriggerProps(props210 = {}) {
      const { view = "day" } = props210;
      const isDisabled = disabled || !computed("isPrevVisibleRangeValid");
      return normalize4.button({
        ...parts3.prevTrigger.attrs,
        dir: prop("dir"),
        id: getPrevTriggerId(scope, view),
        type: "button",
        "aria-label": translations.prevTrigger(view),
        disabled: isDisabled,
        "data-disabled": dataAttr(isDisabled),
        onClick(event) {
          if (event.defaultPrevented) return;
          send({ type: "GOTO.PREV", view });
        }
      });
    },
    getClearTriggerProps() {
      return normalize4.button({
        ...parts3.clearTrigger.attrs,
        id: getClearTriggerId(scope),
        dir: prop("dir"),
        type: "button",
        "aria-label": translations.clearTrigger,
        hidden: !selectedValue.length,
        onClick(event) {
          if (event.defaultPrevented) return;
          send({ type: "VALUE.CLEAR" });
        }
      });
    },
    getTriggerProps() {
      return normalize4.button({
        ...parts3.trigger.attrs,
        id: getTriggerId3(scope),
        dir: prop("dir"),
        type: "button",
        "data-placement": currentPlacement,
        "aria-label": translations.trigger(open),
        "aria-controls": getContentId3(scope),
        "data-state": open ? "open" : "closed",
        "aria-haspopup": "grid",
        disabled,
        onClick(event) {
          if (event.defaultPrevented) return;
          if (!interactive) return;
          send({ type: "TRIGGER.CLICK" });
        }
      });
    },
    getViewProps(props210 = {}) {
      const { view = "day" } = props210;
      return normalize4.element({
        ...parts3.view.attrs,
        "data-view": view,
        hidden: context.get("view") !== view
      });
    },
    getViewTriggerProps(props210 = {}) {
      const { view = "day" } = props210;
      return normalize4.button({
        ...parts3.viewTrigger.attrs,
        "data-view": view,
        dir: prop("dir"),
        id: getViewTriggerId(scope, view),
        type: "button",
        disabled,
        "aria-label": translations.viewTrigger(view),
        onClick(event) {
          if (event.defaultPrevented) return;
          if (!interactive) return;
          send({ type: "VIEW.TOGGLE", src: "viewTrigger" });
        }
      });
    },
    getViewControlProps(props210 = {}) {
      const { view = "day" } = props210;
      return normalize4.element({
        ...parts3.viewControl.attrs,
        "data-view": view,
        dir: prop("dir")
      });
    },
    getInputProps(props210 = {}) {
      const { index = 0, fixOnBlur = true } = props210;
      return normalize4.input({
        ...parts3.input.attrs,
        id: getInputId(scope, index),
        autoComplete: "off",
        autoCorrect: "off",
        spellCheck: "false",
        dir: prop("dir"),
        name: prop("name"),
        "data-index": index,
        "data-state": open ? "open" : "closed",
        readOnly,
        disabled,
        placeholder: prop("placeholder") || getInputPlaceholder(locale),
        defaultValue: computed("valueAsString")[index],
        onBeforeInput(event) {
          const { data } = getNativeEvent(event);
          if (!isValidCharacter(data, separator)) {
            event.preventDefault();
          }
        },
        onFocus() {
          send({ type: "INPUT.FOCUS", index });
        },
        onBlur(event) {
          const value = event.currentTarget.value.trim();
          send({ type: "INPUT.BLUR", value, index, fixOnBlur });
        },
        onKeyDown(event) {
          if (event.defaultPrevented) return;
          if (!interactive) return;
          const keyMap2 = {
            Enter(event2) {
              if (isComposingEvent(event2)) return;
              if (isUnavailable(focusedValue)) return;
              if (event2.currentTarget.value.trim() === "") return;
              send({ type: "INPUT.ENTER", value: event2.currentTarget.value, index });
            }
          };
          const exec = keyMap2[event.key];
          if (exec) {
            exec(event);
            event.preventDefault();
          }
        },
        onInput(event) {
          const value = event.currentTarget.value;
          send({ type: "INPUT.CHANGE", value: ensureValidCharacters(value, separator), index });
        }
      });
    },
    getMonthSelectProps() {
      return normalize4.select({
        ...parts3.monthSelect.attrs,
        id: getMonthSelectId(scope),
        "aria-label": translations.monthSelect,
        disabled,
        dir: prop("dir"),
        defaultValue: startValue.month,
        onChange(event) {
          focusMonth(Number(event.currentTarget.value));
        }
      });
    },
    getYearSelectProps() {
      return normalize4.select({
        ...parts3.yearSelect.attrs,
        id: getYearSelectId(scope),
        disabled,
        "aria-label": translations.yearSelect,
        dir: prop("dir"),
        defaultValue: startValue.year,
        onChange(event) {
          focusYear(Number(event.currentTarget.value));
        }
      });
    },
    getPositionerProps() {
      return normalize4.element({
        id: getPositionerId2(scope),
        ...parts3.positioner.attrs,
        dir: prop("dir"),
        style: popperStyles.floating
      });
    },
    getPresetTriggerProps(props210) {
      const value = Array.isArray(props210.value) ? props210.value : getDateRangePreset(props210.value, locale, timeZone);
      const valueAsString = value.map((item) => item.toDate(timeZone).toDateString());
      return normalize4.button({
        ...parts3.presetTrigger.attrs,
        "aria-label": translations.presetTrigger(valueAsString),
        type: "button",
        onClick(event) {
          if (event.defaultPrevented) return;
          send({ type: "PRESET.CLICK", value });
        }
      });
    }
  };
}
var { and: and2 } = createGuards();
function isDateArrayEqual(a2, b2) {
  if ((a2 == null ? void 0 : a2.length) !== (b2 == null ? void 0 : b2.length)) return false;
  const len = Math.max(a2.length, b2.length);
  for (let i = 0; i < len; i++) {
    if (!isDateEqual(a2[i], b2[i])) return false;
  }
  return true;
}
var machine4 = createMachine({
  props({ props: props210 }) {
    const locale = props210.locale || "en-US";
    const timeZone = props210.timeZone || "UTC";
    const selectionMode = props210.selectionMode || "single";
    const numOfMonths = props210.numOfMonths || 1;
    const defaultValue = props210.defaultValue ? sortDates(props210.defaultValue).map((date) => constrainValue(date, props210.min, props210.max)) : void 0;
    const value = props210.value ? sortDates(props210.value).map((date) => constrainValue(date, props210.min, props210.max)) : void 0;
    let focusedValue = props210.focusedValue || (value == null ? void 0 : value[0]) || (defaultValue == null ? void 0 : defaultValue[0]) || getTodayDate(timeZone);
    focusedValue = constrainValue(focusedValue, props210.min, props210.max);
    const minView = "day";
    const maxView = "year";
    const defaultView = clampView(props210.view || minView, minView, maxView);
    return {
      locale,
      numOfMonths,
      timeZone,
      selectionMode,
      defaultView,
      minView,
      maxView,
      outsideDaySelectable: false,
      closeOnSelect: true,
      format(date, { locale: locale2, timeZone: timeZone2 }) {
        const formatter = new $fb18d541ea1ad717$export$ad991b66133851cf(locale2, { timeZone: timeZone2, day: "2-digit", month: "2-digit", year: "numeric" });
        return formatter.format(date.toDate(timeZone2));
      },
      parse(value2, { locale: locale2, timeZone: timeZone2 }) {
        return parseDateString(value2, locale2, timeZone2);
      },
      ...props210,
      focusedValue,
      value,
      defaultValue: defaultValue ?? [],
      positioning: {
        placement: "bottom",
        ...props210.positioning
      }
    };
  },
  initialState({ prop }) {
    const open = prop("open") || prop("defaultOpen");
    return open ? "open" : "idle";
  },
  refs() {
    return {
      announcer: void 0
    };
  },
  context({ prop, bindable, getContext, getComputed }) {
    return {
      focusedValue: bindable(() => ({
        defaultValue: prop("focusedValue"),
        isEqual: isDateEqual,
        hash: (v) => v.toString(),
        sync: true,
        onChange(focusedValue) {
          var _a8;
          const context = getContext();
          const computed = getComputed();
          (_a8 = prop("onFocusChange")) == null ? void 0 : _a8({
            value: context.get("value"),
            valueAsString: computed("valueAsString"),
            view: context.get("view"),
            focusedValue
          });
        }
      })),
      value: bindable(() => ({
        defaultValue: prop("defaultValue"),
        value: prop("value"),
        isEqual: isDateArrayEqual,
        hash: (v) => v.map((date) => date.toString()).join(","),
        onChange(value) {
          var _a8;
          const context = getContext();
          const valueAsString = value.map(
            (date) => prop("format")(date, { locale: prop("locale"), timeZone: prop("timeZone") })
          );
          (_a8 = prop("onValueChange")) == null ? void 0 : _a8({ value, valueAsString, view: context.get("view") });
        }
      })),
      inputValue: bindable(() => ({
        defaultValue: ""
      })),
      activeIndex: bindable(() => ({
        defaultValue: 0,
        sync: true
      })),
      hoveredValue: bindable(() => ({
        defaultValue: null,
        isEqual: (a2, b2) => b2 !== null && a2 !== null && isDateEqual(a2, b2)
      })),
      view: bindable(() => ({
        defaultValue: prop("defaultView"),
        value: prop("view"),
        onChange(value) {
          var _a8;
          (_a8 = prop("onViewChange")) == null ? void 0 : _a8({ view: value });
        }
      })),
      startValue: bindable(() => {
        return {
          defaultValue: alignDate(prop("focusedValue"), "start", { months: prop("numOfMonths") }, prop("locale")),
          isEqual: isDateEqual
        };
      }),
      currentPlacement: bindable(() => ({
        defaultValue: void 0
      })),
      restoreFocus: bindable(() => ({
        defaultValue: false
      }))
    };
  },
  computed: {
    isInteractive: ({ prop }) => !prop("disabled") && !prop("readOnly"),
    visibleDuration: ({ prop }) => ({ months: prop("numOfMonths") }),
    endValue: ({ context, computed }) => getEndDate(context.get("startValue"), computed("visibleDuration")),
    visibleRange: ({ context, computed }) => ({ start: context.get("startValue"), end: computed("endValue") }),
    visibleRangeText({ context, prop, computed }) {
      const timeZone = prop("timeZone");
      const formatter = new $fb18d541ea1ad717$export$ad991b66133851cf(prop("locale"), { month: "long", year: "numeric", timeZone });
      const start = formatter.format(context.get("startValue").toDate(timeZone));
      const end = formatter.format(computed("endValue").toDate(timeZone));
      const formatted = prop("selectionMode") === "range" ? `${start} - ${end}` : start;
      return { start, end, formatted };
    },
    isPrevVisibleRangeValid: ({ context, prop }) => !isPreviousRangeInvalid(context.get("startValue"), prop("min"), prop("max")),
    isNextVisibleRangeValid: ({ prop, computed }) => !isNextRangeInvalid(computed("endValue"), prop("min"), prop("max")),
    valueAsString({ context, prop }) {
      const value = context.get("value");
      return value.map((date) => prop("format")(date, { locale: prop("locale"), timeZone: prop("timeZone") }));
    }
  },
  effects: ["setupLiveRegion"],
  watch({ track, prop, context, action, computed }) {
    track([() => prop("locale")], () => {
      action(["setStartValue"]);
    });
    track([() => context.hash("focusedValue")], () => {
      action([
        "setStartValue",
        "syncMonthSelectElement",
        "syncYearSelectElement",
        "focusActiveCellIfNeeded",
        "setHoveredValueIfKeyboard"
      ]);
    });
    track([() => context.get("inputValue")], () => {
      action(["syncInputValue"]);
    });
    track([() => context.hash("value")], () => {
      action(["syncInputElement"]);
    });
    track([() => computed("valueAsString").toString()], () => {
      action(["announceValueText"]);
    });
    track([() => context.get("view")], () => {
      action(["focusActiveCell"]);
    });
    track([() => prop("open")], () => {
      action(["toggleVisibility"]);
    });
  },
  on: {
    "VALUE.SET": {
      actions: ["setDateValue", "setFocusedDate"]
    },
    "VIEW.SET": {
      actions: ["setView"]
    },
    "FOCUS.SET": {
      actions: ["setFocusedDate"]
    },
    "VALUE.CLEAR": {
      actions: ["clearDateValue", "clearFocusedDate", "focusFirstInputElement"]
    },
    "INPUT.CHANGE": [
      {
        guard: "isInputValueEmpty",
        actions: ["setInputValue", "clearDateValue", "clearFocusedDate"]
      },
      {
        actions: ["setInputValue", "focusParsedDate"]
      }
    ],
    "INPUT.ENTER": {
      actions: ["focusParsedDate", "selectFocusedDate"]
    },
    "INPUT.FOCUS": {
      actions: ["setActiveIndex"]
    },
    "INPUT.BLUR": [
      {
        guard: "shouldFixOnBlur",
        actions: ["setActiveIndexToStart", "selectParsedDate"]
      },
      {
        actions: ["setActiveIndexToStart"]
      }
    ],
    "PRESET.CLICK": [
      {
        guard: "isOpenControlled",
        actions: ["setDateValue", "setFocusedDate", "invokeOnClose"]
      },
      {
        target: "focused",
        actions: ["setDateValue", "setFocusedDate", "focusInputElement"]
      }
    ],
    "GOTO.NEXT": [
      {
        guard: "isYearView",
        actions: ["focusNextDecade", "announceVisibleRange"]
      },
      {
        guard: "isMonthView",
        actions: ["focusNextYear", "announceVisibleRange"]
      },
      {
        actions: ["focusNextPage"]
      }
    ],
    "GOTO.PREV": [
      {
        guard: "isYearView",
        actions: ["focusPreviousDecade", "announceVisibleRange"]
      },
      {
        guard: "isMonthView",
        actions: ["focusPreviousYear", "announceVisibleRange"]
      },
      {
        actions: ["focusPreviousPage"]
      }
    ]
  },
  states: {
    idle: {
      tags: ["closed"],
      on: {
        "CONTROLLED.OPEN": {
          target: "open",
          actions: ["focusFirstSelectedDate", "focusActiveCell"]
        },
        "TRIGGER.CLICK": [
          {
            guard: "isOpenControlled",
            actions: ["invokeOnOpen"]
          },
          {
            target: "open",
            actions: ["focusFirstSelectedDate", "focusActiveCell", "invokeOnOpen"]
          }
        ],
        OPEN: [
          {
            guard: "isOpenControlled",
            actions: ["invokeOnOpen"]
          },
          {
            target: "open",
            actions: ["focusFirstSelectedDate", "focusActiveCell", "invokeOnOpen"]
          }
        ]
      }
    },
    focused: {
      tags: ["closed"],
      on: {
        "CONTROLLED.OPEN": {
          target: "open",
          actions: ["focusFirstSelectedDate", "focusActiveCell"]
        },
        "TRIGGER.CLICK": [
          {
            guard: "isOpenControlled",
            actions: ["invokeOnOpen"]
          },
          {
            target: "open",
            actions: ["focusFirstSelectedDate", "focusActiveCell", "invokeOnOpen"]
          }
        ],
        OPEN: [
          {
            guard: "isOpenControlled",
            actions: ["invokeOnOpen"]
          },
          {
            target: "open",
            actions: ["focusFirstSelectedDate", "focusActiveCell", "invokeOnOpen"]
          }
        ]
      }
    },
    open: {
      tags: ["open"],
      effects: ["trackDismissableElement", "trackPositioning"],
      exit: ["clearHoveredDate", "resetView"],
      on: {
        "CONTROLLED.CLOSE": [
          {
            guard: and2("shouldRestoreFocus", "isInteractOutsideEvent"),
            target: "focused",
            actions: ["focusTriggerElement"]
          },
          {
            guard: "shouldRestoreFocus",
            target: "focused",
            actions: ["focusInputElement"]
          },
          {
            target: "idle"
          }
        ],
        "CELL.CLICK": [
          {
            guard: "isAboveMinView",
            actions: ["setFocusedValueForView", "setPreviousView"]
          },
          {
            guard: and2("isRangePicker", "hasSelectedRange"),
            actions: ["setActiveIndexToStart", "resetSelection", "setActiveIndexToEnd"]
          },
          // === Grouped transitions (based on `closeOnSelect` and `isOpenControlled`) ===
          {
            guard: and2("isRangePicker", "isSelectingEndDate", "closeOnSelect", "isOpenControlled"),
            actions: ["setFocusedDate", "setSelectedDate", "setActiveIndexToStart", "invokeOnClose", "setRestoreFocus"]
          },
          {
            guard: and2("isRangePicker", "isSelectingEndDate", "closeOnSelect"),
            target: "focused",
            actions: [
              "setFocusedDate",
              "setSelectedDate",
              "setActiveIndexToStart",
              "invokeOnClose",
              "focusInputElement"
            ]
          },
          {
            guard: and2("isRangePicker", "isSelectingEndDate"),
            actions: ["setFocusedDate", "setSelectedDate", "setActiveIndexToStart", "clearHoveredDate"]
          },
          // ===
          {
            guard: "isRangePicker",
            actions: ["setFocusedDate", "setSelectedDate", "setActiveIndexToEnd"]
          },
          {
            guard: "isMultiPicker",
            actions: ["setFocusedDate", "toggleSelectedDate"]
          },
          // === Grouped transitions (based on `closeOnSelect` and `isOpenControlled`) ===
          {
            guard: and2("closeOnSelect", "isOpenControlled"),
            actions: ["setFocusedDate", "setSelectedDate", "invokeOnClose"]
          },
          {
            guard: "closeOnSelect",
            target: "focused",
            actions: ["setFocusedDate", "setSelectedDate", "invokeOnClose", "focusInputElement"]
          },
          {
            actions: ["setFocusedDate", "setSelectedDate"]
          }
          // ===
        ],
        "CELL.POINTER_MOVE": {
          guard: and2("isRangePicker", "isSelectingEndDate"),
          actions: ["setHoveredDate", "setFocusedDate"]
        },
        "TABLE.POINTER_LEAVE": {
          guard: "isRangePicker",
          actions: ["clearHoveredDate"]
        },
        "TABLE.POINTER_DOWN": {
          actions: ["disableTextSelection"]
        },
        "TABLE.POINTER_UP": {
          actions: ["enableTextSelection"]
        },
        "TABLE.ESCAPE": [
          {
            guard: "isOpenControlled",
            actions: ["focusFirstSelectedDate", "invokeOnClose"]
          },
          {
            target: "focused",
            actions: ["focusFirstSelectedDate", "invokeOnClose", "focusTriggerElement"]
          }
        ],
        "TABLE.ENTER": [
          {
            guard: "isAboveMinView",
            actions: ["setPreviousView"]
          },
          {
            guard: and2("isRangePicker", "hasSelectedRange"),
            actions: ["setActiveIndexToStart", "clearDateValue", "setSelectedDate", "setActiveIndexToEnd"]
          },
          // === Grouped transitions (based on `closeOnSelect` and `isOpenControlled`) ===
          {
            guard: and2("isRangePicker", "isSelectingEndDate", "closeOnSelect", "isOpenControlled"),
            actions: ["setSelectedDate", "setActiveIndexToStart", "invokeOnClose"]
          },
          {
            guard: and2("isRangePicker", "isSelectingEndDate", "closeOnSelect"),
            target: "focused",
            actions: ["setSelectedDate", "setActiveIndexToStart", "invokeOnClose", "focusInputElement"]
          },
          {
            guard: and2("isRangePicker", "isSelectingEndDate"),
            actions: ["setSelectedDate", "setActiveIndexToStart"]
          },
          // ===
          {
            guard: "isRangePicker",
            actions: ["setSelectedDate", "setActiveIndexToEnd", "focusNextDay"]
          },
          {
            guard: "isMultiPicker",
            actions: ["toggleSelectedDate"]
          },
          // === Grouped transitions (based on `closeOnSelect` and `isOpenControlled`) ===
          {
            guard: and2("closeOnSelect", "isOpenControlled"),
            actions: ["selectFocusedDate", "invokeOnClose"]
          },
          {
            guard: "closeOnSelect",
            target: "focused",
            actions: ["selectFocusedDate", "invokeOnClose", "focusInputElement"]
          },
          {
            actions: ["selectFocusedDate"]
          }
          // ===
        ],
        "TABLE.ARROW_RIGHT": [
          {
            guard: "isMonthView",
            actions: ["focusNextMonth"]
          },
          {
            guard: "isYearView",
            actions: ["focusNextYear"]
          },
          {
            actions: ["focusNextDay", "setHoveredDate"]
          }
        ],
        "TABLE.ARROW_LEFT": [
          {
            guard: "isMonthView",
            actions: ["focusPreviousMonth"]
          },
          {
            guard: "isYearView",
            actions: ["focusPreviousYear"]
          },
          {
            actions: ["focusPreviousDay"]
          }
        ],
        "TABLE.ARROW_UP": [
          {
            guard: "isMonthView",
            actions: ["focusPreviousMonthColumn"]
          },
          {
            guard: "isYearView",
            actions: ["focusPreviousYearColumn"]
          },
          {
            actions: ["focusPreviousWeek"]
          }
        ],
        "TABLE.ARROW_DOWN": [
          {
            guard: "isMonthView",
            actions: ["focusNextMonthColumn"]
          },
          {
            guard: "isYearView",
            actions: ["focusNextYearColumn"]
          },
          {
            actions: ["focusNextWeek"]
          }
        ],
        "TABLE.PAGE_UP": {
          actions: ["focusPreviousSection"]
        },
        "TABLE.PAGE_DOWN": {
          actions: ["focusNextSection"]
        },
        "TABLE.HOME": [
          {
            guard: "isMonthView",
            actions: ["focusFirstMonth"]
          },
          {
            guard: "isYearView",
            actions: ["focusFirstYear"]
          },
          {
            actions: ["focusSectionStart"]
          }
        ],
        "TABLE.END": [
          {
            guard: "isMonthView",
            actions: ["focusLastMonth"]
          },
          {
            guard: "isYearView",
            actions: ["focusLastYear"]
          },
          {
            actions: ["focusSectionEnd"]
          }
        ],
        "TRIGGER.CLICK": [
          {
            guard: "isOpenControlled",
            actions: ["invokeOnClose"]
          },
          {
            target: "focused",
            actions: ["invokeOnClose"]
          }
        ],
        "VIEW.TOGGLE": {
          actions: ["setNextView"]
        },
        INTERACT_OUTSIDE: [
          {
            guard: "isOpenControlled",
            actions: ["setActiveIndexToStart", "invokeOnClose"]
          },
          {
            guard: "shouldRestoreFocus",
            target: "focused",
            actions: ["setActiveIndexToStart", "invokeOnClose", "focusTriggerElement"]
          },
          {
            target: "idle",
            actions: ["setActiveIndexToStart", "invokeOnClose"]
          }
        ],
        CLOSE: [
          {
            guard: "isOpenControlled",
            actions: ["setActiveIndexToStart", "invokeOnClose"]
          },
          {
            target: "idle",
            actions: ["setActiveIndexToStart", "invokeOnClose"]
          }
        ]
      }
    }
  },
  implementations: {
    guards: {
      isAboveMinView: ({ context, prop }) => isAboveMinView(context.get("view"), prop("minView")),
      isDayView: ({ context, event }) => (event.view || context.get("view")) === "day",
      isMonthView: ({ context, event }) => (event.view || context.get("view")) === "month",
      isYearView: ({ context, event }) => (event.view || context.get("view")) === "year",
      isRangePicker: ({ prop }) => prop("selectionMode") === "range",
      hasSelectedRange: ({ context }) => context.get("value").length === 2,
      isMultiPicker: ({ prop }) => prop("selectionMode") === "multiple",
      shouldRestoreFocus: ({ context }) => !!context.get("restoreFocus"),
      isSelectingEndDate: ({ context }) => context.get("activeIndex") === 1,
      closeOnSelect: ({ prop }) => !!prop("closeOnSelect"),
      isOpenControlled: ({ prop }) => prop("open") != void 0,
      isInteractOutsideEvent: ({ event }) => {
        var _a8;
        return ((_a8 = event.previousEvent) == null ? void 0 : _a8.type) === "INTERACT_OUTSIDE";
      },
      isInputValueEmpty: ({ event }) => event.value.trim() === "",
      shouldFixOnBlur: ({ event }) => !!event.fixOnBlur
    },
    effects: {
      trackPositioning({ context, prop, scope }) {
        if (!context.get("currentPlacement")) {
          context.set("currentPlacement", prop("positioning").placement);
        }
        const anchorEl = getControlEl2(scope);
        const getPositionerEl22 = () => getPositionerEl2(scope);
        return getPlacement(anchorEl, getPositionerEl22, {
          ...prop("positioning"),
          defer: true,
          onComplete(data) {
            context.set("currentPlacement", data.placement);
          }
        });
      },
      setupLiveRegion({ scope, refs }) {
        const doc = scope.getDoc();
        refs.set("announcer", createLiveRegion({ level: "assertive", document: doc }));
        return () => {
          var _a8, _b7;
          return (_b7 = (_a8 = refs.get("announcer")) == null ? void 0 : _a8.destroy) == null ? void 0 : _b7.call(_a8);
        };
      },
      trackDismissableElement({ scope, send, context }) {
        const getContentEl22 = () => getContentEl3(scope);
        return trackDismissableElement(getContentEl22, {
          defer: true,
          exclude: [...getInputEls(scope), getTriggerEl2(scope), getClearTriggerEl(scope)],
          onInteractOutside(event) {
            context.set("restoreFocus", !event.detail.focusable);
          },
          onDismiss() {
            send({ type: "INTERACT_OUTSIDE" });
          },
          onEscapeKeyDown(event) {
            event.preventDefault();
            send({ type: "TABLE.ESCAPE", src: "dismissable" });
          }
        });
      }
    },
    actions: {
      setNextView({ context, prop }) {
        const nextView = getNextView(context.get("view"), prop("minView"), prop("maxView"));
        context.set("view", nextView);
      },
      setPreviousView({ context, prop }) {
        const prevView = getPreviousView(context.get("view"), prop("minView"), prop("maxView"));
        context.set("view", prevView);
      },
      setView({ context, event }) {
        context.set("view", event.view);
      },
      setRestoreFocus({ context }) {
        context.set("restoreFocus", true);
      },
      announceValueText({ context, prop, refs }) {
        var _a8;
        const announceText = context.get("value").map((date) => formatSelectedDate(date, null, prop("locale"), prop("timeZone")));
        (_a8 = refs.get("announcer")) == null ? void 0 : _a8.announce(announceText.join(","), 3e3);
      },
      announceVisibleRange({ computed, refs }) {
        var _a8;
        const { formatted } = computed("visibleRangeText");
        (_a8 = refs.get("announcer")) == null ? void 0 : _a8.announce(formatted);
      },
      disableTextSelection({ scope }) {
        disableTextSelection({ target: getContentEl3(scope), doc: scope.getDoc() });
      },
      enableTextSelection({ scope }) {
        restoreTextSelection({ doc: scope.getDoc(), target: getContentEl3(scope) });
      },
      focusFirstSelectedDate(params) {
        const { context } = params;
        if (!context.get("value").length) return;
        setFocusedValue(params, context.get("value")[0]);
      },
      syncInputElement({ scope, computed }) {
        raf(() => {
          const inputEls = getInputEls(scope);
          inputEls.forEach((inputEl, index) => {
            setElementValue(inputEl, computed("valueAsString")[index] || "");
          });
        });
      },
      setFocusedDate(params) {
        const { event } = params;
        const value = Array.isArray(event.value) ? event.value[0] : event.value;
        setFocusedValue(params, value);
      },
      setFocusedValueForView(params) {
        const { context, event } = params;
        setFocusedValue(params, context.get("focusedValue").set({ [context.get("view")]: event.value }));
      },
      focusNextMonth(params) {
        const { context } = params;
        setFocusedValue(params, context.get("focusedValue").add({ months: 1 }));
      },
      focusPreviousMonth(params) {
        const { context } = params;
        setFocusedValue(params, context.get("focusedValue").subtract({ months: 1 }));
      },
      setDateValue({ context, event, prop }) {
        if (!Array.isArray(event.value)) return;
        const value = event.value.map((date) => constrainValue(date, prop("min"), prop("max")));
        context.set("value", value);
      },
      clearDateValue({ context }) {
        context.set("value", []);
      },
      setSelectedDate(params) {
        const { context, event } = params;
        const values = Array.from(context.get("value"));
        values[context.get("activeIndex")] = normalizeValue(params, event.value ?? context.get("focusedValue"));
        context.set("value", adjustStartAndEndDate(values));
      },
      resetSelection(params) {
        const { context, event } = params;
        context.set("value", [event.value ?? context.get("focusedValue")]);
      },
      toggleSelectedDate(params) {
        const { context, event } = params;
        const currentValue = normalizeValue(params, event.value ?? context.get("focusedValue"));
        const index = context.get("value").findIndex((date) => isDateEqual(date, currentValue));
        if (index === -1) {
          const values = [...context.get("value"), currentValue];
          context.set("value", sortDates(values));
        } else {
          const values = Array.from(context.get("value"));
          values.splice(index, 1);
          context.set("value", sortDates(values));
        }
      },
      setHoveredDate({ context, event }) {
        context.set("hoveredValue", event.value);
      },
      clearHoveredDate({ context }) {
        context.set("hoveredValue", null);
      },
      selectFocusedDate({ context, computed }) {
        const values = Array.from(context.get("value"));
        const activeIndex = context.get("activeIndex");
        values[activeIndex] = context.get("focusedValue").copy();
        context.set("value", adjustStartAndEndDate(values));
        const valueAsString = computed("valueAsString");
        context.set("inputValue", valueAsString[activeIndex]);
      },
      focusPreviousDay(params) {
        const { context } = params;
        const nextValue = context.get("focusedValue").subtract({ days: 1 });
        setFocusedValue(params, nextValue);
      },
      focusNextDay(params) {
        const { context } = params;
        const nextValue = context.get("focusedValue").add({ days: 1 });
        setFocusedValue(params, nextValue);
      },
      focusPreviousWeek(params) {
        const { context } = params;
        const nextValue = context.get("focusedValue").subtract({ weeks: 1 });
        setFocusedValue(params, nextValue);
      },
      focusNextWeek(params) {
        const { context } = params;
        const nextValue = context.get("focusedValue").add({ weeks: 1 });
        setFocusedValue(params, nextValue);
      },
      focusNextPage(params) {
        const { context, computed, prop } = params;
        const nextPage = getNextPage(
          context.get("focusedValue"),
          context.get("startValue"),
          computed("visibleDuration"),
          prop("locale"),
          prop("min"),
          prop("max")
        );
        setAdjustedValue(params, nextPage);
      },
      focusPreviousPage(params) {
        const { context, computed, prop } = params;
        const previousPage = getPreviousPage(
          context.get("focusedValue"),
          context.get("startValue"),
          computed("visibleDuration"),
          prop("locale"),
          prop("min"),
          prop("max")
        );
        setAdjustedValue(params, previousPage);
      },
      focusSectionStart(params) {
        const { context } = params;
        setFocusedValue(params, context.get("startValue").copy());
      },
      focusSectionEnd(params) {
        const { computed } = params;
        setFocusedValue(params, computed("endValue").copy());
      },
      focusNextSection(params) {
        const { context, event, computed, prop } = params;
        const nextSection = getNextSection(
          context.get("focusedValue"),
          context.get("startValue"),
          event.larger,
          computed("visibleDuration"),
          prop("locale"),
          prop("min"),
          prop("max")
        );
        if (!nextSection) return;
        setAdjustedValue(params, nextSection);
      },
      focusPreviousSection(params) {
        const { context, event, computed, prop } = params;
        const previousSection = getPreviousSection(
          context.get("focusedValue"),
          context.get("startValue"),
          event.larger,
          computed("visibleDuration"),
          prop("locale"),
          prop("min"),
          prop("max")
        );
        if (!previousSection) return;
        setAdjustedValue(params, previousSection);
      },
      focusNextYear(params) {
        const { context } = params;
        const nextValue = context.get("focusedValue").add({ years: 1 });
        setFocusedValue(params, nextValue);
      },
      focusPreviousYear(params) {
        const { context } = params;
        const nextValue = context.get("focusedValue").subtract({ years: 1 });
        setFocusedValue(params, nextValue);
      },
      focusNextDecade(params) {
        const { context } = params;
        const nextValue = context.get("focusedValue").add({ years: 10 });
        setFocusedValue(params, nextValue);
      },
      focusPreviousDecade(params) {
        const { context } = params;
        const nextValue = context.get("focusedValue").subtract({ years: 10 });
        setFocusedValue(params, nextValue);
      },
      clearFocusedDate(params) {
        const { prop } = params;
        setFocusedValue(params, getTodayDate(prop("timeZone")));
      },
      focusPreviousMonthColumn(params) {
        const { context, event } = params;
        const nextValue = context.get("focusedValue").subtract({ months: event.columns });
        setFocusedValue(params, nextValue);
      },
      focusNextMonthColumn(params) {
        const { context, event } = params;
        const nextValue = context.get("focusedValue").add({ months: event.columns });
        setFocusedValue(params, nextValue);
      },
      focusPreviousYearColumn(params) {
        const { context, event } = params;
        const nextValue = context.get("focusedValue").subtract({ years: event.columns });
        setFocusedValue(params, nextValue);
      },
      focusNextYearColumn(params) {
        const { context, event } = params;
        const nextValue = context.get("focusedValue").add({ years: event.columns });
        setFocusedValue(params, nextValue);
      },
      focusFirstMonth(params) {
        const { context } = params;
        const nextValue = context.get("focusedValue").set({ month: 0 });
        setFocusedValue(params, nextValue);
      },
      focusLastMonth(params) {
        const { context } = params;
        const nextValue = context.get("focusedValue").set({ month: 12 });
        setFocusedValue(params, nextValue);
      },
      focusFirstYear(params) {
        const { context } = params;
        const range2 = getDecadeRange(context.get("focusedValue").year);
        const nextValue = context.get("focusedValue").set({ year: range2[0] });
        setFocusedValue(params, nextValue);
      },
      focusLastYear(params) {
        const { context } = params;
        const range2 = getDecadeRange(context.get("focusedValue").year);
        const nextValue = context.get("focusedValue").set({ year: range2[range2.length - 1] });
        setFocusedValue(params, nextValue);
      },
      setActiveIndex({ context, event }) {
        context.set("activeIndex", event.index);
      },
      setActiveIndexToEnd({ context }) {
        context.set("activeIndex", 1);
      },
      setActiveIndexToStart({ context }) {
        context.set("activeIndex", 0);
      },
      focusActiveCell({ scope, context }) {
        raf(() => {
          var _a8;
          const view = context.get("view");
          (_a8 = getFocusedCell(scope, view)) == null ? void 0 : _a8.focus({ preventScroll: true });
        });
      },
      focusActiveCellIfNeeded({ scope, context, event }) {
        if (!event.focus) return;
        raf(() => {
          var _a8;
          const view = context.get("view");
          (_a8 = getFocusedCell(scope, view)) == null ? void 0 : _a8.focus({ preventScroll: true });
        });
      },
      setHoveredValueIfKeyboard({ context, event, prop }) {
        if (!event.type.startsWith("TABLE.ARROW") || prop("selectionMode") !== "range" || context.get("activeIndex") === 0)
          return;
        context.set("hoveredValue", context.get("focusedValue").copy());
      },
      focusTriggerElement({ scope }) {
        raf(() => {
          var _a8;
          (_a8 = getTriggerEl2(scope)) == null ? void 0 : _a8.focus({ preventScroll: true });
        });
      },
      focusFirstInputElement({ scope }) {
        raf(() => {
          const [inputEl] = getInputEls(scope);
          inputEl == null ? void 0 : inputEl.focus({ preventScroll: true });
        });
      },
      focusInputElement({ scope }) {
        raf(() => {
          const inputEls = getInputEls(scope);
          const lastIndexWithValue = inputEls.findLastIndex((inputEl2) => inputEl2.value !== "");
          const indexToFocus = Math.max(lastIndexWithValue, 0);
          const inputEl = inputEls[indexToFocus];
          inputEl == null ? void 0 : inputEl.focus({ preventScroll: true });
          inputEl == null ? void 0 : inputEl.setSelectionRange(inputEl.value.length, inputEl.value.length);
        });
      },
      syncMonthSelectElement({ scope, context }) {
        const monthSelectEl = getMonthSelectEl(scope);
        setElementValue(monthSelectEl, context.get("startValue").month.toString());
      },
      syncYearSelectElement({ scope, context }) {
        const yearSelectEl = getYearSelectEl(scope);
        setElementValue(yearSelectEl, context.get("startValue").year.toString());
      },
      setInputValue({ context, event }) {
        if (context.get("activeIndex") !== event.index) return;
        context.set("inputValue", event.value);
      },
      syncInputValue({ scope, context, event }) {
        queueMicrotask(() => {
          const inputEls = getInputEls(scope);
          const idx = event.index ?? context.get("activeIndex");
          setElementValue(inputEls[idx], context.get("inputValue"));
        });
      },
      focusParsedDate(params) {
        const { event, prop } = params;
        if (event.index == null) return;
        const parse22 = prop("parse");
        const date = parse22(event.value, { locale: prop("locale"), timeZone: prop("timeZone") });
        if (!date || !isValidDate(date)) return;
        setFocusedValue(params, date);
      },
      selectParsedDate({ context, event, computed, prop }) {
        if (event.index == null) return;
        const parse22 = prop("parse");
        let date = parse22(event.value, { locale: prop("locale"), timeZone: prop("timeZone") });
        if (!date || !isValidDate(date)) {
          if (event.value) {
            date = context.get("focusedValue").copy();
          }
        }
        if (!date) return;
        const values = Array.from(context.get("value"));
        values[event.index] = date;
        context.set("value", values);
        context.set("inputValue", computed("valueAsString")[event.index]);
      },
      resetView({ context }) {
        context.set("view", context.initial("view"));
      },
      setStartValue({ context, computed, prop }) {
        const focusedValue = context.get("focusedValue");
        const outside = isDateOutsideRange(focusedValue, context.get("startValue"), computed("endValue"));
        if (!outside) return;
        const startValue = alignDate(focusedValue, "start", { months: prop("numOfMonths") }, prop("locale"));
        context.set("startValue", startValue);
      },
      invokeOnOpen({ prop }) {
        var _a8;
        (_a8 = prop("onOpenChange")) == null ? void 0 : _a8({ open: true });
      },
      invokeOnClose({ prop }) {
        var _a8;
        (_a8 = prop("onOpenChange")) == null ? void 0 : _a8({ open: false });
      },
      toggleVisibility({ event, send, prop }) {
        send({ type: prop("open") ? "CONTROLLED.OPEN" : "CONTROLLED.CLOSE", previousEvent: event });
      }
    }
  }
});
var normalizeValue = (ctx, value) => {
  const { context, prop } = ctx;
  const view = context.get("view");
  let dateValue = typeof value === "number" ? context.get("focusedValue").set({ [view]: value }) : value;
  eachView((view2) => {
    if (isBelowMinView(view2, prop("minView"))) {
      dateValue = dateValue.set({ [view2]: view2 === "day" ? 1 : 0 });
    }
  });
  return dateValue;
};
function setFocusedValue(ctx, mixedValue) {
  const { context, prop, computed } = ctx;
  if (!mixedValue) return;
  const value = normalizeValue(ctx, mixedValue);
  if (isDateEqual(context.get("focusedValue"), value)) return;
  const adjustFn = getAdjustedDateFn(computed("visibleDuration"), prop("locale"), prop("min"), prop("max"));
  const adjustedValue = adjustFn({
    focusedDate: value,
    startDate: context.get("startValue")
  });
  context.set("startValue", adjustedValue.startDate);
  context.set("focusedValue", adjustedValue.focusedDate);
}
function setAdjustedValue(ctx, value) {
  const { context } = ctx;
  context.set("startValue", value.startDate);
  const focusedValue = context.get("focusedValue");
  if (isDateEqual(focusedValue, value.focusedDate)) return;
  context.set("focusedValue", value.focusedDate);
}
var props4 = createProps()([
  "closeOnSelect",
  "dir",
  "disabled",
  "fixedWeeks",
  "focusedValue",
  "format",
  "parse",
  "placeholder",
  "getRootNode",
  "id",
  "ids",
  "isDateUnavailable",
  "locale",
  "max",
  "min",
  "name",
  "numOfMonths",
  "onFocusChange",
  "onOpenChange",
  "onValueChange",
  "onViewChange",
  "open",
  "defaultOpen",
  "positioning",
  "readOnly",
  "selectionMode",
  "startOfWeek",
  "timeZone",
  "translations",
  "value",
  "defaultView",
  "defaultValue",
  "view",
  "defaultFocusedValue",
  "outsideDaySelectable",
  "minView",
  "maxView"
]);
var splitProps5 = createSplitProps(props4);
var inputProps = createProps()(["index", "fixOnBlur"]);
var splitInputProps = createSplitProps(inputProps);
var presetTriggerProps = createProps()(["value"]);
var splitPresetTriggerProps = createSplitProps(presetTriggerProps);
var tableProps = createProps()(["columns", "id", "view"]);
var splitTableProps = createSplitProps(tableProps);
var tableCellProps = createProps()(["disabled", "value", "columns"]);
var splitTableCellProps = createSplitProps(tableCellProps);
var viewProps = createProps()(["view"]);
var splitViewProps = createSplitProps(viewProps);

// node_modules/@ark-ui/react/dist/utils/render-strategy.js
var [RenderStrategyPropsProvider, useRenderStrategyPropsContext] = createContext3({
  name: "RenderStrategyContext",
  hookName: "useRenderStrategyContext",
  providerName: "<RenderStrategyPropsProvider />"
});
var splitRenderStrategyProps = (props43) => createSplitProps2()(props43, ["lazyMount", "unmountOnExit"]);

// node_modules/@ark-ui/react/dist/components/accordion/use-accordion-item-props-context.js
var [AccordionItemPropsProvider, useAccordionItemPropsContext] = createContext3({
  name: "AccordionItemPropsContext",
  hookName: "useAccordionItemPropsContext",
  providerName: "<AccordionItemPropsProvider />"
});

// node_modules/@ark-ui/react/dist/components/accordion/accordion-item.js
var AccordionItem = (0, import_react32.forwardRef)((props43, ref) => {
  const [itemProps14, localProps] = createSplitProps2()(props43, ["value", "disabled"]);
  const accordion = useAccordionContext();
  const renderStrategy = useRenderStrategyPropsContext();
  const mergedProps = mergeProps2(accordion.getItemProps(itemProps14), localProps);
  const item = accordion.getItemState(itemProps14);
  const itemContentProps = accordion.getItemContentProps(itemProps14);
  return (0, import_jsx_runtime14.jsx)(AccordionItemPropsProvider, { value: itemProps14, children: (0, import_jsx_runtime14.jsx)(AccordionItemProvider, { value: item, children: (0, import_jsx_runtime14.jsx)(
    CollapsibleRoot,
    {
      ref,
      open: item.expanded,
      ids: { content: itemContentProps.id },
      ...renderStrategy,
      ...mergedProps
    }
  ) }) });
});
AccordionItem.displayName = "AccordionItem";

// node_modules/@ark-ui/react/dist/components/accordion/accordion-item-content.js
var import_jsx_runtime16 = __toESM(require_jsx_runtime(), 1);
var import_react36 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/collapsible/collapsible-content.js
var import_jsx_runtime15 = __toESM(require_jsx_runtime(), 1);
var import_react34 = __toESM(require_react(), 1);
var CollapsibleContent = (0, import_react34.forwardRef)((props43, ref) => {
  const collapsible = useCollapsibleContext();
  if (collapsible.isUnmounted) {
    return null;
  }
  const mergedProps = mergeProps2(collapsible.getContentProps(), props43);
  return (0, import_jsx_runtime15.jsx)(ark.div, { ...mergedProps, ref });
});
CollapsibleContent.displayName = "CollapsibleContent";

// node_modules/@ark-ui/react/dist/components/accordion/accordion-item-content.js
var splitVisibilityProps = createSplitProps2();
var AccordionItemContent = (0, import_react36.forwardRef)((props43, ref) => {
  const accordion = useAccordionContext();
  const itemProps14 = useAccordionItemPropsContext();
  const contentProps2 = accordion.getItemContentProps(itemProps14);
  const [, itemContentProps] = splitVisibilityProps(contentProps2, ["hidden", "data-state"]);
  const mergedProps = mergeProps2(itemContentProps, props43);
  return (0, import_jsx_runtime16.jsx)(CollapsibleContent, { ref, ...mergedProps });
});
AccordionItemContent.displayName = "AccordionItemContent";

// node_modules/@ark-ui/react/dist/components/accordion/accordion-item-context.js
var AccordionItemContext = (props43) => props43.children(useAccordionItemContext());

// node_modules/@ark-ui/react/dist/components/accordion/accordion-item-indicator.js
var import_jsx_runtime17 = __toESM(require_jsx_runtime(), 1);
var import_react38 = __toESM(require_react(), 1);
var AccordionItemIndicator = (0, import_react38.forwardRef)((props43, ref) => {
  const accordion = useAccordionContext();
  const itemProps14 = useAccordionItemPropsContext();
  const mergedProps = mergeProps2(accordion.getItemIndicatorProps(itemProps14), props43);
  return (0, import_jsx_runtime17.jsx)(ark.div, { ...mergedProps, ref });
});
AccordionItemIndicator.displayName = "AccordionItemIndicator";

// node_modules/@ark-ui/react/dist/components/accordion/accordion-item-trigger.js
var import_jsx_runtime18 = __toESM(require_jsx_runtime(), 1);
var import_react40 = __toESM(require_react(), 1);
var AccordionItemTrigger = (0, import_react40.forwardRef)((props43, ref) => {
  const accordion = useAccordionContext();
  const itemProps14 = useAccordionItemPropsContext();
  const collapsible = useCollapsibleContext();
  const triggerProps2 = accordion.getItemTriggerProps(itemProps14);
  const mergedProps = mergeProps2(
    {
      ...triggerProps2,
      "aria-controls": collapsible.isUnmounted ? void 0 : triggerProps2["aria-controls"]
    },
    props43
  );
  return (0, import_jsx_runtime18.jsx)(ark.button, { ...mergedProps, ref });
});
AccordionItemTrigger.displayName = "AccordionItemTrigger";

// node_modules/@ark-ui/react/dist/components/accordion/accordion-root.js
var import_jsx_runtime19 = __toESM(require_jsx_runtime(), 1);
var import_react44 = __toESM(require_react(), 1);

// node_modules/@zag-js/accordion/dist/index.mjs
var anatomy4 = createAnatomy("accordion").parts("root", "item", "itemTrigger", "itemContent", "itemIndicator");
var parts4 = anatomy4.build();
var getRootId4 = (ctx) => {
  var _a8;
  return ((_a8 = ctx.ids) == null ? void 0 : _a8.root) ?? `accordion:${ctx.id}`;
};
var getItemId = (ctx, value) => {
  var _a8, _b7;
  return ((_b7 = (_a8 = ctx.ids) == null ? void 0 : _a8.item) == null ? void 0 : _b7.call(_a8, value)) ?? `accordion:${ctx.id}:item:${value}`;
};
var getItemContentId = (ctx, value) => {
  var _a8, _b7;
  return ((_b7 = (_a8 = ctx.ids) == null ? void 0 : _a8.itemContent) == null ? void 0 : _b7.call(_a8, value)) ?? `accordion:${ctx.id}:content:${value}`;
};
var getItemTriggerId = (ctx, value) => {
  var _a8, _b7;
  return ((_b7 = (_a8 = ctx.ids) == null ? void 0 : _a8.itemTrigger) == null ? void 0 : _b7.call(_a8, value)) ?? `accordion:${ctx.id}:trigger:${value}`;
};
var getRootEl = (ctx) => ctx.getById(getRootId4(ctx));
var getTriggerEls = (ctx) => {
  const ownerId = CSS.escape(getRootId4(ctx));
  const selector = `[aria-controls][data-ownedby='${ownerId}']:not([disabled])`;
  return queryAll(getRootEl(ctx), selector);
};
var getFirstTriggerEl = (ctx) => first(getTriggerEls(ctx));
var getLastTriggerEl = (ctx) => last(getTriggerEls(ctx));
var getNextTriggerEl = (ctx, id) => nextById(getTriggerEls(ctx), getItemTriggerId(ctx, id));
var getPrevTriggerEl = (ctx, id) => prevById(getTriggerEls(ctx), getItemTriggerId(ctx, id));
function connect5(service, normalize4) {
  const { send, context, prop, scope, computed } = service;
  const focusedValue = context.get("focusedValue");
  const value = context.get("value");
  const multiple = prop("multiple");
  function setValue(value2) {
    let nextValue = value2;
    if (!multiple && nextValue.length > 1) {
      nextValue = [nextValue[0]];
    }
    send({ type: "VALUE.SET", value: nextValue });
  }
  function getItemState(props210) {
    return {
      expanded: value.includes(props210.value),
      focused: focusedValue === props210.value,
      disabled: Boolean(props210.disabled ?? prop("disabled"))
    };
  }
  return {
    focusedValue,
    value,
    setValue,
    getItemState,
    getRootProps() {
      return normalize4.element({
        ...parts4.root.attrs,
        dir: prop("dir"),
        id: getRootId4(scope),
        "data-orientation": prop("orientation")
      });
    },
    getItemProps(props210) {
      const itemState = getItemState(props210);
      return normalize4.element({
        ...parts4.item.attrs,
        dir: prop("dir"),
        id: getItemId(scope, props210.value),
        "data-state": itemState.expanded ? "open" : "closed",
        "data-focus": dataAttr(itemState.focused),
        "data-disabled": dataAttr(itemState.disabled),
        "data-orientation": prop("orientation")
      });
    },
    getItemContentProps(props210) {
      const itemState = getItemState(props210);
      return normalize4.element({
        ...parts4.itemContent.attrs,
        dir: prop("dir"),
        role: "region",
        id: getItemContentId(scope, props210.value),
        "aria-labelledby": getItemTriggerId(scope, props210.value),
        hidden: !itemState.expanded,
        "data-state": itemState.expanded ? "open" : "closed",
        "data-disabled": dataAttr(itemState.disabled),
        "data-focus": dataAttr(itemState.focused),
        "data-orientation": prop("orientation")
      });
    },
    getItemIndicatorProps(props210) {
      const itemState = getItemState(props210);
      return normalize4.element({
        ...parts4.itemIndicator.attrs,
        dir: prop("dir"),
        "aria-hidden": true,
        "data-state": itemState.expanded ? "open" : "closed",
        "data-disabled": dataAttr(itemState.disabled),
        "data-focus": dataAttr(itemState.focused),
        "data-orientation": prop("orientation")
      });
    },
    getItemTriggerProps(props210) {
      const { value: value2 } = props210;
      const itemState = getItemState(props210);
      return normalize4.button({
        ...parts4.itemTrigger.attrs,
        type: "button",
        dir: prop("dir"),
        id: getItemTriggerId(scope, value2),
        "aria-controls": getItemContentId(scope, value2),
        "aria-expanded": itemState.expanded,
        disabled: itemState.disabled,
        "data-orientation": prop("orientation"),
        "aria-disabled": itemState.disabled,
        "data-state": itemState.expanded ? "open" : "closed",
        "data-ownedby": getRootId4(scope),
        onFocus() {
          if (itemState.disabled) return;
          send({ type: "TRIGGER.FOCUS", value: value2 });
        },
        onBlur() {
          if (itemState.disabled) return;
          send({ type: "TRIGGER.BLUR" });
        },
        onClick(event) {
          if (itemState.disabled) return;
          if (isSafari()) {
            event.currentTarget.focus();
          }
          send({ type: "TRIGGER.CLICK", value: value2 });
        },
        onKeyDown(event) {
          if (event.defaultPrevented) return;
          if (itemState.disabled) return;
          const keyMap2 = {
            ArrowDown() {
              if (computed("isHorizontal")) return;
              send({ type: "GOTO.NEXT", value: value2 });
            },
            ArrowUp() {
              if (computed("isHorizontal")) return;
              send({ type: "GOTO.PREV", value: value2 });
            },
            ArrowRight() {
              if (!computed("isHorizontal")) return;
              send({ type: "GOTO.NEXT", value: value2 });
            },
            ArrowLeft() {
              if (!computed("isHorizontal")) return;
              send({ type: "GOTO.PREV", value: value2 });
            },
            Home() {
              send({ type: "GOTO.FIRST", value: value2 });
            },
            End() {
              send({ type: "GOTO.LAST", value: value2 });
            }
          };
          const key = getEventKey(event, {
            dir: prop("dir"),
            orientation: prop("orientation")
          });
          const exec = keyMap2[key];
          if (exec) {
            exec(event);
            event.preventDefault();
          }
        }
      });
    }
  };
}
var { and: and3, not } = createGuards();
var machine5 = createMachine({
  props({ props: props210 }) {
    return {
      collapsible: false,
      multiple: false,
      orientation: "vertical",
      defaultValue: [],
      ...props210
    };
  },
  initialState() {
    return "idle";
  },
  context({ prop, bindable }) {
    return {
      focusedValue: bindable(() => ({
        defaultValue: null,
        sync: true,
        onChange(value) {
          var _a8;
          (_a8 = prop("onFocusChange")) == null ? void 0 : _a8({ value });
        }
      })),
      value: bindable(() => ({
        defaultValue: prop("defaultValue"),
        value: prop("value"),
        onChange(value) {
          var _a8;
          (_a8 = prop("onValueChange")) == null ? void 0 : _a8({ value });
        }
      }))
    };
  },
  computed: {
    isHorizontal: ({ prop }) => prop("orientation") === "horizontal"
  },
  on: {
    "VALUE.SET": {
      actions: ["setValue"]
    }
  },
  states: {
    idle: {
      on: {
        "TRIGGER.FOCUS": {
          target: "focused",
          actions: ["setFocusedValue"]
        }
      }
    },
    focused: {
      on: {
        "GOTO.NEXT": {
          actions: ["focusNextTrigger"]
        },
        "GOTO.PREV": {
          actions: ["focusPrevTrigger"]
        },
        "TRIGGER.CLICK": [
          {
            guard: and3("isExpanded", "canToggle"),
            actions: ["collapse"]
          },
          {
            guard: not("isExpanded"),
            actions: ["expand"]
          }
        ],
        "GOTO.FIRST": {
          actions: ["focusFirstTrigger"]
        },
        "GOTO.LAST": {
          actions: ["focusLastTrigger"]
        },
        "TRIGGER.BLUR": {
          target: "idle",
          actions: ["clearFocusedValue"]
        }
      }
    }
  },
  implementations: {
    guards: {
      canToggle: ({ prop }) => !!prop("collapsible") || !!prop("multiple"),
      isExpanded: ({ context, event }) => context.get("value").includes(event.value)
    },
    actions: {
      collapse({ context, prop, event }) {
        const next2 = prop("multiple") ? remove(context.get("value"), event.value) : [];
        context.set("value", next2);
      },
      expand({ context, prop, event }) {
        const next2 = prop("multiple") ? add(context.get("value"), event.value) : [event.value];
        context.set("value", next2);
      },
      focusFirstTrigger({ scope }) {
        var _a8;
        (_a8 = getFirstTriggerEl(scope)) == null ? void 0 : _a8.focus();
      },
      focusLastTrigger({ scope }) {
        var _a8;
        (_a8 = getLastTriggerEl(scope)) == null ? void 0 : _a8.focus();
      },
      focusNextTrigger({ context, scope }) {
        const focusedValue = context.get("focusedValue");
        if (!focusedValue) return;
        const triggerEl = getNextTriggerEl(scope, focusedValue);
        triggerEl == null ? void 0 : triggerEl.focus();
      },
      focusPrevTrigger({ context, scope }) {
        const focusedValue = context.get("focusedValue");
        if (!focusedValue) return;
        const triggerEl = getPrevTriggerEl(scope, focusedValue);
        triggerEl == null ? void 0 : triggerEl.focus();
      },
      setFocusedValue({ context, event }) {
        context.set("focusedValue", event.value);
      },
      clearFocusedValue({ context }) {
        context.set("focusedValue", null);
      },
      setValue({ context, event }) {
        context.set("value", event.value);
      },
      coarseValue({ context, prop }) {
        if (!prop("multiple") && context.get("value").length > 1) {
          warn(`The value of accordion should be a single value when multiple is false.`);
          context.set("value", [context.get("value")[0]]);
        }
      }
    }
  }
});
var props5 = createProps()([
  "collapsible",
  "dir",
  "disabled",
  "getRootNode",
  "id",
  "ids",
  "multiple",
  "onFocusChange",
  "onValueChange",
  "orientation",
  "value",
  "defaultValue"
]);
var splitProps6 = createSplitProps(props5);
var itemProps = createProps()(["value", "disabled"]);
var splitItemProps = createSplitProps(itemProps);

// node_modules/@ark-ui/react/dist/components/accordion/use-accordion.js
var import_react42 = __toESM(require_react(), 1);
var useAccordion = (props43) => {
  const id = (0, import_react42.useId)();
  const { getRootNode } = useEnvironmentContext();
  const { dir } = useLocaleContext();
  const machineProps = {
    id,
    dir,
    getRootNode,
    ...props43
  };
  const service = useMachine(machine5, machineProps);
  return connect5(service, normalizeProps);
};

// node_modules/@ark-ui/react/dist/components/accordion/accordion-root.js
var AccordionRoot = (0, import_react44.forwardRef)((props43, ref) => {
  const [renderStrategyProps, accordionProps] = splitRenderStrategyProps(props43);
  const [useAccordionProps, localProps] = createSplitProps2()(accordionProps, [
    "collapsible",
    "defaultValue",
    "disabled",
    "id",
    "ids",
    "multiple",
    "onFocusChange",
    "onValueChange",
    "orientation",
    "value"
  ]);
  const accordion = useAccordion(useAccordionProps);
  const mergedProps = mergeProps2(accordion.getRootProps(), localProps);
  return (0, import_jsx_runtime19.jsx)(AccordionProvider, { value: accordion, children: (0, import_jsx_runtime19.jsx)(RenderStrategyPropsProvider, { value: renderStrategyProps, children: (0, import_jsx_runtime19.jsx)(ark.div, { ...mergedProps, ref }) }) });
});
AccordionRoot.displayName = "AccordionRoot";

// node_modules/@ark-ui/react/dist/components/accordion/accordion-root-provider.js
var import_jsx_runtime20 = __toESM(require_jsx_runtime(), 1);
var import_react46 = __toESM(require_react(), 1);
var AccordionRootProvider = (0, import_react46.forwardRef)((props43, ref) => {
  const [renderStrategyProps, accordionProps] = splitRenderStrategyProps(props43);
  const [{ value: accordion }, localProps] = createSplitProps2()(accordionProps, ["value"]);
  const mergedProps = mergeProps2(accordion.getRootProps(), localProps);
  return (0, import_jsx_runtime20.jsx)(AccordionProvider, { value: accordion, children: (0, import_jsx_runtime20.jsx)(RenderStrategyPropsProvider, { value: renderStrategyProps, children: (0, import_jsx_runtime20.jsx)(ark.div, { ...mergedProps, ref }) }) });
});
AccordionRootProvider.displayName = "AccordionRootProvider";

// node_modules/@ark-ui/react/dist/components/accordion/accordion.js
var accordion_exports = {};
__export(accordion_exports, {
  Context: () => AccordionContext,
  Item: () => AccordionItem,
  ItemContent: () => AccordionItemContent,
  ItemContext: () => AccordionItemContext,
  ItemIndicator: () => AccordionItemIndicator,
  ItemTrigger: () => AccordionItemTrigger,
  Root: () => AccordionRoot,
  RootProvider: () => AccordionRootProvider
});

// node_modules/@ark-ui/react/dist/components/angle-slider/use-angle-slider-context.js
var [AngleSliderProvider, useAngleSliderContext] = createContext3({
  name: "AngleSliderContext",
  hookName: "useAngleSliderContext",
  providerName: "<AngleSliderProvider />"
});

// node_modules/@ark-ui/react/dist/components/angle-slider/angle-slider-control.js
var import_jsx_runtime21 = __toESM(require_jsx_runtime(), 1);
var import_react48 = __toESM(require_react(), 1);
var AngleSliderControl = (0, import_react48.forwardRef)((props43, ref) => {
  const angleSlider = useAngleSliderContext();
  const mergedProps = mergeProps2(angleSlider.getControlProps(), props43);
  return (0, import_jsx_runtime21.jsx)(ark.div, { ...mergedProps, ref });
});
AngleSliderControl.displayName = "AngleSliderControl";

// node_modules/@ark-ui/react/dist/components/angle-slider/angle-slider-hidden-input.js
var import_jsx_runtime22 = __toESM(require_jsx_runtime(), 1);
var import_react50 = __toESM(require_react(), 1);
var AngleSliderHiddenInput = (0, import_react50.forwardRef)((props43, ref) => {
  const angleSlider = useAngleSliderContext();
  const mergedProps = mergeProps2(angleSlider.getHiddenInputProps(), props43);
  return (0, import_jsx_runtime22.jsx)(ark.input, { ...mergedProps, ref });
});
AngleSliderHiddenInput.displayName = "AngleSliderHiddenInput";

// node_modules/@ark-ui/react/dist/components/angle-slider/angle-slider-label.js
var import_jsx_runtime23 = __toESM(require_jsx_runtime(), 1);
var import_react52 = __toESM(require_react(), 1);
var AngleSliderLabel = (0, import_react52.forwardRef)((props43, ref) => {
  const angleSlider = useAngleSliderContext();
  const mergedProps = mergeProps2(angleSlider.getLabelProps(), props43);
  return (0, import_jsx_runtime23.jsx)(ark.label, { ...mergedProps, ref });
});
AngleSliderLabel.displayName = "AngleSliderLabel";

// node_modules/@ark-ui/react/dist/components/angle-slider/angle-slider-marker.js
var import_jsx_runtime24 = __toESM(require_jsx_runtime(), 1);
var import_react54 = __toESM(require_react(), 1);
var AngleSliderMarker = (0, import_react54.forwardRef)((props43, ref) => {
  const [itemProps14, localProps] = createSplitProps2()(props43, ["value"]);
  const angleSlider = useAngleSliderContext();
  const mergedProps = mergeProps2(angleSlider.getMarkerProps(itemProps14), localProps);
  return (0, import_jsx_runtime24.jsx)(ark.div, { ...mergedProps, ref });
});
AngleSliderMarker.displayName = "AngleSliderMarker";

// node_modules/@ark-ui/react/dist/components/angle-slider/angle-slider-marker-group.js
var import_jsx_runtime25 = __toESM(require_jsx_runtime(), 1);
var import_react56 = __toESM(require_react(), 1);
var AngleSliderMarkerGroup = (0, import_react56.forwardRef)((props43, ref) => {
  const angleSlider = useAngleSliderContext();
  const mergedProps = mergeProps2(angleSlider.getMarkerGroupProps(), props43);
  return (0, import_jsx_runtime25.jsx)(ark.div, { ...mergedProps, ref });
});
AngleSliderMarkerGroup.displayName = "AngleSliderMarkerGroup";

// node_modules/@ark-ui/react/dist/components/angle-slider/angle-slider-root.js
var import_jsx_runtime26 = __toESM(require_jsx_runtime(), 1);
var import_react60 = __toESM(require_react(), 1);

// node_modules/@zag-js/rect-utils/dist/index.mjs
var __defProp2 = Object.defineProperty;
var __defNormalProp2 = (obj, key, value) => key in obj ? __defProp2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField2 = (obj, key, value) => __defNormalProp2(obj, typeof key !== "symbol" ? key + "" : key, value);
var AffineTransform = class _AffineTransform {
  constructor([m00, m01, m02, m10, m11, m12] = [0, 0, 0, 0, 0, 0]) {
    __publicField2(this, "m00");
    __publicField2(this, "m01");
    __publicField2(this, "m02");
    __publicField2(this, "m10");
    __publicField2(this, "m11");
    __publicField2(this, "m12");
    __publicField2(this, "rotate", (...args) => {
      return this.prepend(_AffineTransform.rotate(...args));
    });
    __publicField2(this, "scale", (...args) => {
      return this.prepend(_AffineTransform.scale(...args));
    });
    __publicField2(this, "translate", (...args) => {
      return this.prepend(_AffineTransform.translate(...args));
    });
    this.m00 = m00;
    this.m01 = m01;
    this.m02 = m02;
    this.m10 = m10;
    this.m11 = m11;
    this.m12 = m12;
  }
  applyTo(point) {
    const { x, y } = point;
    const { m00, m01, m02, m10, m11, m12 } = this;
    return {
      x: m00 * x + m01 * y + m02,
      y: m10 * x + m11 * y + m12
    };
  }
  prepend(other) {
    return new _AffineTransform([
      this.m00 * other.m00 + this.m01 * other.m10,
      // m00
      this.m00 * other.m01 + this.m01 * other.m11,
      // m01
      this.m00 * other.m02 + this.m01 * other.m12 + this.m02,
      // m02
      this.m10 * other.m00 + this.m11 * other.m10,
      // m10
      this.m10 * other.m01 + this.m11 * other.m11,
      // m11
      this.m10 * other.m02 + this.m11 * other.m12 + this.m12
      // m12
    ]);
  }
  append(other) {
    return new _AffineTransform([
      other.m00 * this.m00 + other.m01 * this.m10,
      // m00
      other.m00 * this.m01 + other.m01 * this.m11,
      // m01
      other.m00 * this.m02 + other.m01 * this.m12 + other.m02,
      // m02
      other.m10 * this.m00 + other.m11 * this.m10,
      // m10
      other.m10 * this.m01 + other.m11 * this.m11,
      // m11
      other.m10 * this.m02 + other.m11 * this.m12 + other.m12
      // m12
    ]);
  }
  get determinant() {
    return this.m00 * this.m11 - this.m01 * this.m10;
  }
  get isInvertible() {
    const det = this.determinant;
    return isFinite(det) && isFinite(this.m02) && isFinite(this.m12) && det !== 0;
  }
  invert() {
    const det = this.determinant;
    return new _AffineTransform([
      this.m11 / det,
      // m00
      -this.m01 / det,
      // m01
      (this.m01 * this.m12 - this.m11 * this.m02) / det,
      // m02
      -this.m10 / det,
      // m10
      this.m00 / det,
      // m11
      (this.m10 * this.m02 - this.m00 * this.m12) / det
      // m12
    ]);
  }
  get array() {
    return [this.m00, this.m01, this.m02, this.m10, this.m11, this.m12, 0, 0, 1];
  }
  get float32Array() {
    return new Float32Array(this.array);
  }
  // Static
  static get identity() {
    return new _AffineTransform([1, 0, 0, 0, 1, 0]);
  }
  static rotate(theta, origin) {
    const rotation = new _AffineTransform([Math.cos(theta), -Math.sin(theta), 0, Math.sin(theta), Math.cos(theta), 0]);
    if (origin && (origin.x !== 0 || origin.y !== 0)) {
      return _AffineTransform.multiply(
        _AffineTransform.translate(origin.x, origin.y),
        rotation,
        _AffineTransform.translate(-origin.x, -origin.y)
      );
    }
    return rotation;
  }
  static scale(sx, sy = sx, origin = { x: 0, y: 0 }) {
    const scale = new _AffineTransform([sx, 0, 0, 0, sy, 0]);
    if (origin.x !== 0 || origin.y !== 0) {
      return _AffineTransform.multiply(
        _AffineTransform.translate(origin.x, origin.y),
        scale,
        _AffineTransform.translate(-origin.x, -origin.y)
      );
    }
    return scale;
  }
  static translate(tx, ty) {
    return new _AffineTransform([1, 0, tx, 0, 1, ty]);
  }
  static multiply(...[first2, ...rest]) {
    if (!first2) return _AffineTransform.identity;
    return rest.reduce((result, item) => result.prepend(item), first2);
  }
  get a() {
    return this.m00;
  }
  get b() {
    return this.m10;
  }
  get c() {
    return this.m01;
  }
  get d() {
    return this.m11;
  }
  get tx() {
    return this.m02;
  }
  get ty() {
    return this.m12;
  }
  get scaleComponents() {
    return { x: this.a, y: this.d };
  }
  get translationComponents() {
    return { x: this.tx, y: this.ty };
  }
  get skewComponents() {
    return { x: this.c, y: this.b };
  }
  toString() {
    return `matrix(${this.a}, ${this.b}, ${this.c}, ${this.d}, ${this.tx}, ${this.ty})`;
  }
};
function getPointAngle(rect, point, reference = rect.center) {
  const x = point.x - reference.x;
  const y = point.y - reference.y;
  const deg2 = Math.atan2(x, y) * (180 / Math.PI) + 180;
  return 360 - deg2;
}
var clamp3 = (value, min32, max22) => Math.min(Math.max(value, min32), max22);
var clampPoint = (position, size3, boundaryRect) => {
  const x = clamp3(position.x, boundaryRect.x, boundaryRect.x + boundaryRect.width - size3.width);
  const y = clamp3(position.y, boundaryRect.y, boundaryRect.y + boundaryRect.height - size3.height);
  return { x, y };
};
var defaultMinSize = {
  width: 0,
  height: 0
};
var defaultMaxSize = {
  width: Infinity,
  height: Infinity
};
var clampSize = (size3, minSize = defaultMinSize, maxSize = defaultMaxSize) => {
  return {
    width: Math.min(Math.max(size3.width, minSize.width), maxSize.width),
    height: Math.min(Math.max(size3.height, minSize.height), maxSize.height)
  };
};
var createPoint = (x, y) => ({ x, y });
var subtractPoints = (a2, b2) => {
  if (!b2) return a2;
  return createPoint(a2.x - b2.x, a2.y - b2.y);
};
var addPoints = (a2, b2) => createPoint(a2.x + b2.x, a2.y + b2.y);
function createRect(r) {
  const { x, y, width, height } = r;
  const midX = x + width / 2;
  const midY = y + height / 2;
  return {
    x,
    y,
    width,
    height,
    minX: x,
    minY: y,
    maxX: x + width,
    maxY: y + height,
    midX,
    midY,
    center: createPoint(midX, midY)
  };
}
function getRectCorners(v) {
  const top = createPoint(v.minX, v.minY);
  const right = createPoint(v.maxX, v.minY);
  const bottom = createPoint(v.maxX, v.maxY);
  const left = createPoint(v.minX, v.maxY);
  return { top, right, bottom, left };
}
var constrainRect = (rect, boundary) => {
  const left = Math.max(boundary.x, Math.min(rect.x, boundary.x + boundary.width - rect.width));
  const top = Math.max(boundary.y, Math.min(rect.y, boundary.y + boundary.height - rect.height));
  return {
    x: left,
    y: top,
    width: Math.min(rect.width, boundary.width),
    height: Math.min(rect.height, boundary.height)
  };
};
var isSizeEqual = (a2, b2) => {
  return a2.width === (b2 == null ? void 0 : b2.width) && a2.height === (b2 == null ? void 0 : b2.height);
};
var isPointEqual = (a2, b2) => {
  return a2.x === (b2 == null ? void 0 : b2.x) && a2.y === (b2 == null ? void 0 : b2.y);
};
var styleCache2 = /* @__PURE__ */ new WeakMap();
function getCacheComputedStyle(el) {
  if (!styleCache2.has(el)) {
    const win = el.ownerDocument.defaultView || window;
    styleCache2.set(el, win.getComputedStyle(el));
  }
  return styleCache2.get(el);
}
function getElementRect(el, opts = {}) {
  return createRect(getClientRect(el, opts));
}
function getClientRect(el, opts = {}) {
  const { excludeScrollbar = false, excludeBorders = false } = opts;
  const { x, y, width, height } = el.getBoundingClientRect();
  const r = { x, y, width, height };
  const style = getCacheComputedStyle(el);
  const { borderLeftWidth, borderTopWidth, borderRightWidth, borderBottomWidth } = style;
  const borderXWidth = sum(borderLeftWidth, borderRightWidth);
  const borderYWidth = sum(borderTopWidth, borderBottomWidth);
  if (excludeBorders) {
    r.width -= borderXWidth;
    r.height -= borderYWidth;
    r.x += px(borderLeftWidth);
    r.y += px(borderTopWidth);
  }
  if (excludeScrollbar) {
    const scrollbarWidth = el.offsetWidth - el.clientWidth - borderXWidth;
    const scrollbarHeight = el.offsetHeight - el.clientHeight - borderYWidth;
    r.width -= scrollbarWidth;
    r.height -= scrollbarHeight;
  }
  return r;
}
var px = (v) => parseFloat(v.replace("px", ""));
var sum = (...vals) => vals.reduce((sum2, v) => sum2 + (v ? px(v) : 0), 0);
var { min: min3, max: max3 } = Math;
function getWindowRect(win, opts = {}) {
  return createRect(getViewportRect2(win, opts));
}
function getViewportRect2(win, opts) {
  const { excludeScrollbar = false } = opts;
  const { innerWidth, innerHeight, document: doc, visualViewport: visualViewport2 } = win;
  const width = (visualViewport2 == null ? void 0 : visualViewport2.width) || innerWidth;
  const height = (visualViewport2 == null ? void 0 : visualViewport2.height) || innerHeight;
  const rect = { x: 0, y: 0, width, height };
  if (excludeScrollbar) {
    const scrollbarWidth = innerWidth - doc.documentElement.clientWidth;
    const scrollbarHeight = innerHeight - doc.documentElement.clientHeight;
    rect.width -= scrollbarWidth;
    rect.height -= scrollbarHeight;
  }
  return rect;
}
function getElementPolygon(rectValue, placement) {
  const rect = createRect(rectValue);
  const { top, right, left, bottom } = getRectCorners(rect);
  const [base] = placement.split("-");
  return {
    top: [left, top, right, bottom],
    right: [top, right, bottom, left],
    bottom: [top, left, bottom, right],
    left: [right, top, left, bottom]
  }[base];
}
function isPointInPolygon(polygon, point) {
  const { x, y } = point;
  let c = false;
  for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
    const xi = polygon[i].x;
    const yi = polygon[i].y;
    const xj = polygon[j].x;
    const yj = polygon[j].y;
    if (yi > y !== yj > y && x < (xj - xi) * (y - yi) / (yj - yi) + xi) {
      c = !c;
    }
  }
  return c;
}
var compassDirectionMap = {
  n: { x: 0.5, y: 0 },
  ne: { x: 1, y: 0 },
  e: { x: 1, y: 0.5 },
  se: { x: 1, y: 1 },
  s: { x: 0.5, y: 1 },
  sw: { x: 0, y: 1 },
  w: { x: 0, y: 0.5 },
  nw: { x: 0, y: 0 }
};
var oppositeDirectionMap = {
  n: "s",
  ne: "sw",
  e: "w",
  se: "nw",
  s: "n",
  sw: "ne",
  w: "e",
  nw: "se"
};
var { sign: sign2, abs: abs2, min: min22 } = Math;
function getRectExtentPoint(rect, direction) {
  const { minX, minY, maxX, maxY, midX, midY } = rect;
  const x = direction.includes("w") ? minX : direction.includes("e") ? maxX : midX;
  const y = direction.includes("n") ? minY : direction.includes("s") ? maxY : midY;
  return { x, y };
}
function getOppositeDirection(direction) {
  return oppositeDirectionMap[direction];
}
function resizeRect(rect, offset4, direction, opts) {
  const { scalingOriginMode, lockAspectRatio } = opts;
  const extent = getRectExtentPoint(rect, direction);
  const oppositeDirection = getOppositeDirection(direction);
  const oppositeExtent = getRectExtentPoint(rect, oppositeDirection);
  if (scalingOriginMode === "center") {
    offset4 = { x: offset4.x * 2, y: offset4.y * 2 };
  }
  const newExtent = {
    x: extent.x + offset4.x,
    y: extent.y + offset4.y
  };
  const multiplier = {
    x: compassDirectionMap[direction].x * 2 - 1,
    y: compassDirectionMap[direction].y * 2 - 1
  };
  const newSize = {
    width: newExtent.x - oppositeExtent.x,
    height: newExtent.y - oppositeExtent.y
  };
  const scaleX = multiplier.x * newSize.width / rect.width;
  const scaleY = multiplier.y * newSize.height / rect.height;
  const largestMagnitude = abs2(scaleX) > abs2(scaleY) ? scaleX : scaleY;
  const scale = lockAspectRatio ? { x: largestMagnitude, y: largestMagnitude } : {
    x: extent.x === oppositeExtent.x ? 1 : scaleX,
    y: extent.y === oppositeExtent.y ? 1 : scaleY
  };
  if (extent.y === oppositeExtent.y) {
    scale.y = abs2(scale.y);
  } else if (sign2(scale.y) !== sign2(scaleY)) {
    scale.y *= -1;
  }
  if (extent.x === oppositeExtent.x) {
    scale.x = abs2(scale.x);
  } else if (sign2(scale.x) !== sign2(scaleX)) {
    scale.x *= -1;
  }
  switch (scalingOriginMode) {
    case "extent":
      return transformRect(rect, AffineTransform.scale(scale.x, scale.y, oppositeExtent), false);
    case "center":
      return transformRect(
        rect,
        AffineTransform.scale(scale.x, scale.y, {
          x: rect.midX,
          y: rect.midY
        }),
        false
      );
  }
}
function createRectFromPoints(initialPoint, finalPoint, normalized = true) {
  if (normalized) {
    return {
      x: min22(finalPoint.x, initialPoint.x),
      y: min22(finalPoint.y, initialPoint.y),
      width: abs2(finalPoint.x - initialPoint.x),
      height: abs2(finalPoint.y - initialPoint.y)
    };
  }
  return {
    x: initialPoint.x,
    y: initialPoint.y,
    width: finalPoint.x - initialPoint.x,
    height: finalPoint.y - initialPoint.y
  };
}
function transformRect(rect, transform2, normalized = true) {
  const p1 = transform2.applyTo({ x: rect.minX, y: rect.minY });
  const p2 = transform2.applyTo({ x: rect.maxX, y: rect.maxY });
  return createRectFromPoints(p1, p2, normalized);
}

// node_modules/@zag-js/angle-slider/dist/index.mjs
var anatomy5 = createAnatomy("angle-slider").parts(
  "root",
  "label",
  "thumb",
  "valueText",
  "control",
  "track",
  "markerGroup",
  "marker"
);
var parts5 = anatomy5.build();
var getRootId5 = (ctx) => {
  var _a8;
  return ((_a8 = ctx.ids) == null ? void 0 : _a8.root) ?? `angle-slider:${ctx.id}`;
};
var getThumbId = (ctx) => {
  var _a8;
  return ((_a8 = ctx.ids) == null ? void 0 : _a8.thumb) ?? `angle-slider:${ctx.id}:thumb`;
};
var getHiddenInputId2 = (ctx) => {
  var _a8;
  return ((_a8 = ctx.ids) == null ? void 0 : _a8.hiddenInput) ?? `angle-slider:${ctx.id}:input`;
};
var getControlId3 = (ctx) => {
  var _a8;
  return ((_a8 = ctx.ids) == null ? void 0 : _a8.control) ?? `angle-slider:${ctx.id}:control`;
};
var getValueTextId = (ctx) => {
  var _a8;
  return ((_a8 = ctx.ids) == null ? void 0 : _a8.valueText) ?? `angle-slider:${ctx.id}:value-text`;
};
var getHiddenInputEl2 = (ctx) => ctx.getById(getHiddenInputId2(ctx));
var getControlEl3 = (ctx) => ctx.getById(getControlId3(ctx));
var getThumbEl = (ctx) => ctx.getById(getThumbId(ctx));
function connect6(service, normalize4) {
  const { state: state2, send, context, prop, computed, scope } = service;
  const dragging = state2.matches("dragging");
  const value = context.get("value");
  const valueAsDegree = computed("valueAsDegree");
  const disabled = prop("disabled");
  const invalid = prop("invalid");
  const readOnly = prop("readOnly");
  const interactive = computed("interactive");
  return {
    value,
    valueAsDegree,
    dragging,
    setValue(value2) {
      send({ type: "VALUE.SET", value: value2 });
    },
    getRootProps() {
      return normalize4.element({
        ...parts5.root.attrs,
        id: getRootId5(scope),
        "data-disabled": dataAttr(disabled),
        "data-invalid": dataAttr(invalid),
        "data-readonly": dataAttr(readOnly),
        style: {
          "--value": value,
          "--angle": valueAsDegree
        }
      });
    },
    getLabelProps() {
      return normalize4.label({
        ...parts5.label.attrs,
        htmlFor: getHiddenInputId2(scope),
        "data-disabled": dataAttr(disabled),
        "data-invalid": dataAttr(invalid),
        "data-readonly": dataAttr(readOnly),
        onClick(event) {
          var _a8;
          if (!interactive) return;
          event.preventDefault();
          (_a8 = getThumbEl(scope)) == null ? void 0 : _a8.focus();
        }
      });
    },
    getHiddenInputProps() {
      return normalize4.element({
        type: "hidden",
        value,
        name: prop("name"),
        id: getHiddenInputId2(scope)
      });
    },
    getControlProps() {
      return normalize4.element({
        ...parts5.control.attrs,
        role: "presentation",
        id: getControlId3(scope),
        "data-disabled": dataAttr(disabled),
        "data-invalid": dataAttr(invalid),
        "data-readonly": dataAttr(readOnly),
        onPointerDown(event) {
          if (!interactive) return;
          const point = getEventPoint(event);
          send({ type: "CONTROL.POINTER_DOWN", point });
        }
      });
    },
    getThumbProps() {
      return normalize4.element({
        ...parts5.thumb.attrs,
        id: getThumbId(scope),
        role: "slider",
        "aria-valuemax": 360,
        "aria-valuemin": 0,
        "aria-valuenow": value,
        tabIndex: readOnly || interactive ? 0 : void 0,
        "data-disabled": dataAttr(disabled),
        "data-invalid": dataAttr(invalid),
        "data-readonly": dataAttr(readOnly),
        onFocus() {
          send({ type: "THUMB.FOCUS" });
        },
        onBlur() {
          send({ type: "THUMB.BLUR" });
        },
        onKeyDown(event) {
          if (!interactive) return;
          const step = getEventStep(event) * prop("step");
          switch (event.key) {
            case "ArrowLeft":
            case "ArrowUp":
              event.preventDefault();
              send({ type: "THUMB.ARROW_DEC", step });
              break;
            case "ArrowRight":
            case "ArrowDown":
              event.preventDefault();
              send({ type: "THUMB.ARROW_INC", step });
              break;
            case "Home":
              event.preventDefault();
              send({ type: "THUMB.HOME" });
              break;
            case "End":
              event.preventDefault();
              send({ type: "THUMB.END" });
              break;
          }
        },
        style: {
          rotate: `var(--angle)`
        }
      });
    },
    getValueTextProps() {
      return normalize4.element({
        ...parts5.valueText.attrs,
        id: getValueTextId(scope)
      });
    },
    getMarkerGroupProps() {
      return normalize4.element({
        ...parts5.markerGroup.attrs
      });
    },
    getMarkerProps(props210) {
      let markerState;
      if (props210.value < value) {
        markerState = "under-value";
      } else if (props210.value > value) {
        markerState = "over-value";
      } else {
        markerState = "at-value";
      }
      return normalize4.element({
        ...parts5.marker.attrs,
        "data-value": props210.value,
        "data-state": markerState,
        "data-disabled": dataAttr(disabled),
        style: {
          "--marker-value": props210.value,
          rotate: `calc(var(--marker-value) * 1deg)`
        }
      });
    }
  };
}
var MIN_VALUE = 0;
var MAX_VALUE = 359;
var machine6 = createMachine({
  props({ props: props210 }) {
    return {
      step: 1,
      defaultValue: 0,
      ...props210
    };
  },
  context({ prop, bindable }) {
    return {
      value: bindable(() => ({
        defaultValue: prop("defaultValue"),
        value: prop("value"),
        onChange(value) {
          var _a8;
          (_a8 = prop("onValueChange")) == null ? void 0 : _a8({ value, valueAsDegree: `${value}deg` });
        }
      }))
    };
  },
  computed: {
    interactive: ({ prop }) => !(prop("disabled") || prop("readOnly")),
    valueAsDegree: ({ context }) => `${context.get("value")}deg`
  },
  watch({ track, context, action }) {
    track([() => context.get("value")], () => {
      action(["syncInputElement"]);
    });
  },
  initialState() {
    return "idle";
  },
  on: {
    "VALUE.SET": {
      actions: ["setValue"]
    }
  },
  states: {
    idle: {
      on: {
        "CONTROL.POINTER_DOWN": {
          target: "dragging",
          actions: ["setPointerValue", "focusThumb"]
        },
        "THUMB.FOCUS": {
          target: "focused"
        }
      }
    },
    focused: {
      on: {
        "CONTROL.POINTER_DOWN": {
          target: "dragging",
          actions: ["setPointerValue", "focusThumb"]
        },
        "THUMB.ARROW_DEC": {
          actions: ["decrementValue", "invokeOnChangeEnd"]
        },
        "THUMB.ARROW_INC": {
          actions: ["incrementValue", "invokeOnChangeEnd"]
        },
        "THUMB.HOME": {
          actions: ["setValueToMin", "invokeOnChangeEnd"]
        },
        "THUMB.END": {
          actions: ["setValueToMax", "invokeOnChangeEnd"]
        },
        "THUMB.BLUR": {
          target: "idle"
        }
      }
    },
    dragging: {
      entry: ["focusThumb"],
      effects: ["trackPointerMove"],
      on: {
        "DOC.POINTER_UP": {
          target: "focused",
          actions: ["invokeOnChangeEnd"]
        },
        "DOC.POINTER_MOVE": {
          actions: ["setPointerValue"]
        }
      }
    }
  },
  implementations: {
    effects: {
      trackPointerMove({ scope, send }) {
        return trackPointerMove(scope.getDoc(), {
          onPointerMove(info) {
            send({ type: "DOC.POINTER_MOVE", point: info.point });
          },
          onPointerUp() {
            send({ type: "DOC.POINTER_UP" });
          }
        });
      }
    },
    actions: {
      syncInputElement({ scope, context }) {
        const inputEl = getHiddenInputEl2(scope);
        setElementValue(inputEl, context.get("value").toString());
      },
      invokeOnChangeEnd({ context, prop, computed }) {
        var _a8;
        (_a8 = prop("onValueChangeEnd")) == null ? void 0 : _a8({
          value: context.get("value"),
          valueAsDegree: computed("valueAsDegree")
        });
      },
      setPointerValue({ scope, event, context, prop }) {
        const controlEl = getControlEl3(scope);
        if (!controlEl) return;
        const deg2 = getAngle(controlEl, event.point);
        context.set("value", constrainAngle(deg2, prop("step")));
      },
      setValueToMin({ context }) {
        context.set("value", MIN_VALUE);
      },
      setValueToMax({ context }) {
        context.set("value", MAX_VALUE);
      },
      setValue({ context, event }) {
        context.set("value", clampAngle(event.value));
      },
      decrementValue({ context, event, prop }) {
        const value = snapValueToStep(
          context.get("value") - event.step,
          MIN_VALUE,
          MAX_VALUE,
          event.step ?? prop("step")
        );
        context.set("value", value);
      },
      incrementValue({ context, event, prop }) {
        const value = snapValueToStep(
          context.get("value") + event.step,
          MIN_VALUE,
          MAX_VALUE,
          event.step ?? prop("step")
        );
        context.set("value", value);
      },
      focusThumb({ scope }) {
        raf(() => {
          var _a8;
          (_a8 = getThumbEl(scope)) == null ? void 0 : _a8.focus({ preventScroll: true });
        });
      }
    }
  }
});
function getAngle(controlEl, point) {
  const rect = createRect(controlEl.getBoundingClientRect());
  return getPointAngle(rect, point);
}
function clampAngle(degree) {
  return Math.min(Math.max(degree, MIN_VALUE), MAX_VALUE);
}
function constrainAngle(degree, step) {
  const clampedDegree = clampAngle(degree);
  const upperStep = Math.ceil(clampedDegree / step);
  const nearestStep = Math.round(clampedDegree / step);
  return upperStep >= clampedDegree / step ? upperStep * step === MAX_VALUE ? MIN_VALUE : upperStep * step : nearestStep * step;
}
var props6 = createProps()([
  "dir",
  "disabled",
  "getRootNode",
  "id",
  "ids",
  "invalid",
  "name",
  "onValueChange",
  "onValueChangeEnd",
  "readOnly",
  "step",
  "value",
  "defaultValue"
]);
var splitProps7 = createSplitProps(props6);

// node_modules/@ark-ui/react/dist/components/angle-slider/use-angle-slider.js
var import_react58 = __toESM(require_react(), 1);
var useAngleSlider = (props43) => {
  const id = (0, import_react58.useId)();
  const { getRootNode } = useEnvironmentContext();
  const { dir } = useLocaleContext();
  const machineProps = {
    id,
    dir,
    getRootNode,
    ...props43
  };
  const service = useMachine(machine6, machineProps);
  return connect6(service, normalizeProps);
};

// node_modules/@ark-ui/react/dist/components/angle-slider/angle-slider-root.js
var AngleSliderRoot = (0, import_react60.forwardRef)((props43, ref) => {
  const [useAngleSliderProps, localProps] = createSplitProps2()(props43, [
    "id",
    "ids",
    "name",
    "invalid",
    "readOnly",
    "disabled",
    "onValueChangeEnd",
    "onValueChange",
    "defaultValue",
    "value",
    "step"
  ]);
  const angleSlider = useAngleSlider(useAngleSliderProps);
  const mergedProps = mergeProps2(angleSlider.getRootProps(), localProps);
  return (0, import_jsx_runtime26.jsx)(AngleSliderProvider, { value: angleSlider, children: (0, import_jsx_runtime26.jsx)(ark.div, { ...mergedProps, ref }) });
});
AngleSliderRoot.displayName = "AngleSliderRoot";

// node_modules/@ark-ui/react/dist/components/angle-slider/angle-slider-root-provider.js
var import_jsx_runtime27 = __toESM(require_jsx_runtime(), 1);
var import_react62 = __toESM(require_react(), 1);
var AngleSliderRootProvider = (0, import_react62.forwardRef)((props43, ref) => {
  const [{ value: angleSlider }, localProps] = createSplitProps2()(props43, ["value"]);
  const mergedProps = mergeProps2(angleSlider.getRootProps(), localProps);
  return (0, import_jsx_runtime27.jsx)(AngleSliderProvider, { value: angleSlider, children: (0, import_jsx_runtime27.jsx)(ark.div, { ...mergedProps, ref }) });
});
AngleSliderRootProvider.displayName = "AngleSliderRootProvider";

// node_modules/@ark-ui/react/dist/components/angle-slider/angle-slider-thumb.js
var import_jsx_runtime28 = __toESM(require_jsx_runtime(), 1);
var import_react64 = __toESM(require_react(), 1);
var AngleSliderThumb = (0, import_react64.forwardRef)((props43, ref) => {
  const angleSlider = useAngleSliderContext();
  const mergedProps = mergeProps2(angleSlider.getThumbProps(), props43);
  return (0, import_jsx_runtime28.jsx)(ark.div, { ...mergedProps, ref });
});
AngleSliderThumb.displayName = "AngleSliderThumb";

// node_modules/@ark-ui/react/dist/components/angle-slider/angle-slider-value-text.js
var import_jsx_runtime29 = __toESM(require_jsx_runtime(), 1);
var import_react65 = __toESM(require_react(), 1);
var AngleSliderValueText = (0, import_react65.forwardRef)((props43, ref) => {
  const angleSlider = useAngleSliderContext();
  return (0, import_jsx_runtime29.jsx)(ark.div, { ...props43, ref, children: props43.children || angleSlider.valueAsDegree });
});
AngleSliderValueText.displayName = "AngleSliderValueText";

// node_modules/@ark-ui/react/dist/components/avatar/use-avatar-context.js
var [AvatarProvider, useAvatarContext] = createContext3({
  name: "AvatarContext",
  hookName: "useAvatarContext",
  providerName: "<AvatarProvider />"
});

// node_modules/@ark-ui/react/dist/components/avatar/avatar-context.js
var AvatarContext = (props43) => props43.children(useAvatarContext());

// node_modules/@ark-ui/react/dist/components/avatar/avatar-fallback.js
var import_jsx_runtime30 = __toESM(require_jsx_runtime(), 1);
var import_react67 = __toESM(require_react(), 1);
var AvatarFallback = (0, import_react67.forwardRef)((props43, ref) => {
  const avatar = useAvatarContext();
  const mergedProps = mergeProps2(avatar.getFallbackProps(), props43);
  return (0, import_jsx_runtime30.jsx)(ark.span, { ...mergedProps, ref });
});
AvatarFallback.displayName = "AvatarFallback";

// node_modules/@ark-ui/react/dist/components/avatar/avatar-image.js
var import_jsx_runtime31 = __toESM(require_jsx_runtime(), 1);
var import_react69 = __toESM(require_react(), 1);
var AvatarImage = (0, import_react69.forwardRef)((props43, ref) => {
  const avatar = useAvatarContext();
  const mergedProps = mergeProps2(avatar.getImageProps(), props43);
  return (0, import_jsx_runtime31.jsx)(ark.img, { ...mergedProps, ref });
});
AvatarImage.displayName = "AvatarImage";

// node_modules/@ark-ui/react/dist/components/avatar/avatar-root.js
var import_jsx_runtime32 = __toESM(require_jsx_runtime(), 1);
var import_react73 = __toESM(require_react(), 1);

// node_modules/@zag-js/avatar/dist/index.mjs
var anatomy6 = createAnatomy("avatar").parts("root", "image", "fallback");
var parts6 = anatomy6.build();
var getRootId6 = (ctx) => {
  var _a8;
  return ((_a8 = ctx.ids) == null ? void 0 : _a8.root) ?? `avatar:${ctx.id}`;
};
var getImageId = (ctx) => {
  var _a8;
  return ((_a8 = ctx.ids) == null ? void 0 : _a8.image) ?? `avatar:${ctx.id}:image`;
};
var getFallbackId = (ctx) => {
  var _a8;
  return ((_a8 = ctx.ids) == null ? void 0 : _a8.fallback) ?? `avatar:${ctx.id}:fallback`;
};
var getRootEl2 = (ctx) => ctx.getById(getRootId6(ctx));
var getImageEl = (ctx) => ctx.getById(getImageId(ctx));
function connect7(service, normalize4) {
  const { state: state2, send, prop, scope } = service;
  const loaded = state2.matches("loaded");
  return {
    loaded,
    setSrc(src) {
      const img = getImageEl(scope);
      img == null ? void 0 : img.setAttribute("src", src);
    },
    setLoaded() {
      send({ type: "img.loaded", src: "api" });
    },
    setError() {
      send({ type: "img.error", src: "api" });
    },
    getRootProps() {
      return normalize4.element({
        ...parts6.root.attrs,
        dir: prop("dir"),
        id: getRootId6(scope)
      });
    },
    getImageProps() {
      return normalize4.img({
        ...parts6.image.attrs,
        hidden: !loaded,
        dir: prop("dir"),
        id: getImageId(scope),
        "data-state": loaded ? "visible" : "hidden",
        onLoad() {
          send({ type: "img.loaded", src: "element" });
        },
        onError() {
          send({ type: "img.error", src: "element" });
        }
      });
    },
    getFallbackProps() {
      return normalize4.element({
        ...parts6.fallback.attrs,
        dir: prop("dir"),
        id: getFallbackId(scope),
        hidden: loaded,
        "data-state": loaded ? "hidden" : "visible"
      });
    }
  };
}
var machine7 = createMachine({
  initialState() {
    return "loading";
  },
  effects: ["trackImageRemoval", "trackSrcChange"],
  on: {
    "src.change": {
      target: "loading"
    },
    "img.unmount": {
      target: "error"
    }
  },
  states: {
    loading: {
      entry: ["checkImageStatus"],
      on: {
        "img.loaded": {
          target: "loaded",
          actions: ["invokeOnLoad"]
        },
        "img.error": {
          target: "error",
          actions: ["invokeOnError"]
        }
      }
    },
    error: {
      on: {
        "img.loaded": {
          target: "loaded",
          actions: ["invokeOnLoad"]
        }
      }
    },
    loaded: {
      on: {
        "img.error": {
          target: "error",
          actions: ["invokeOnError"]
        }
      }
    }
  },
  implementations: {
    actions: {
      invokeOnLoad({ prop }) {
        var _a8;
        (_a8 = prop("onStatusChange")) == null ? void 0 : _a8({ status: "loaded" });
      },
      invokeOnError({ prop }) {
        var _a8;
        (_a8 = prop("onStatusChange")) == null ? void 0 : _a8({ status: "error" });
      },
      checkImageStatus({ send, scope }) {
        const imageEl = getImageEl(scope);
        if (!(imageEl == null ? void 0 : imageEl.complete)) return;
        const type = hasLoaded(imageEl) ? "img.loaded" : "img.error";
        send({ type, src: "ssr" });
      }
    },
    effects: {
      trackImageRemoval({ send, scope }) {
        const rootEl = getRootEl2(scope);
        return observeChildren(rootEl, {
          callback(records) {
            const removedNodes = Array.from(records[0].removedNodes);
            const removed = removedNodes.find(
              (node) => node.nodeType === Node.ELEMENT_NODE && node.matches("[data-scope=avatar][data-part=image]")
            );
            if (removed) {
              send({ type: "img.unmount" });
            }
          }
        });
      },
      trackSrcChange({ send, scope }) {
        const imageEl = getImageEl(scope);
        return observeAttributes(imageEl, {
          attributes: ["src", "srcset"],
          callback() {
            send({ type: "src.change" });
          }
        });
      }
    }
  }
});
function hasLoaded(image) {
  return image.complete && image.naturalWidth !== 0 && image.naturalHeight !== 0;
}
var props7 = createProps()(["dir", "id", "ids", "onStatusChange", "getRootNode"]);
var splitProps8 = createSplitProps(props7);

// node_modules/@ark-ui/react/dist/components/avatar/use-avatar.js
var import_react71 = __toESM(require_react(), 1);
var useAvatar = (props43) => {
  const id = (0, import_react71.useId)();
  const { getRootNode } = useEnvironmentContext();
  const { dir } = useLocaleContext();
  const context = {
    id,
    dir,
    getRootNode,
    ...props43
  };
  const service = useMachine(machine7, context);
  return connect7(service, normalizeProps);
};

// node_modules/@ark-ui/react/dist/components/avatar/avatar-root.js
var AvatarRoot = (0, import_react73.forwardRef)((props43, ref) => {
  const [useAvatarProps, localProps] = createSplitProps2()(props43, ["id", "ids", "onStatusChange"]);
  const avatar = useAvatar(useAvatarProps);
  const mergedProps = mergeProps2(avatar.getRootProps(), localProps);
  return (0, import_jsx_runtime32.jsx)(AvatarProvider, { value: avatar, children: (0, import_jsx_runtime32.jsx)(ark.div, { ...mergedProps, ref }) });
});
AvatarRoot.displayName = "AvatarRoot";

// node_modules/@ark-ui/react/dist/components/avatar/avatar-root-provider.js
var import_jsx_runtime33 = __toESM(require_jsx_runtime(), 1);
var import_react75 = __toESM(require_react(), 1);
var AvatarRootProvider = (0, import_react75.forwardRef)((props43, ref) => {
  const [{ value: avatar }, localProps] = createSplitProps2()(props43, ["value"]);
  const mergedProps = mergeProps2(avatar.getRootProps(), localProps);
  return (0, import_jsx_runtime33.jsx)(AvatarProvider, { value: avatar, children: (0, import_jsx_runtime33.jsx)(ark.div, { ...mergedProps, ref }) });
});
AvatarRootProvider.displayName = "AvatarRootProvider";

// node_modules/@ark-ui/react/dist/components/avatar/avatar.js
var avatar_exports = {};
__export(avatar_exports, {
  Context: () => AvatarContext,
  Fallback: () => AvatarFallback,
  Image: () => AvatarImage,
  Root: () => AvatarRoot,
  RootProvider: () => AvatarRootProvider
});

// node_modules/@ark-ui/react/dist/components/carousel/carousel-autoplay-trigger.js
var import_jsx_runtime34 = __toESM(require_jsx_runtime(), 1);
var import_react77 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/carousel/use-carousel-context.js
var [CarouselProvider, useCarouselContext] = createContext3({
  name: "CarouselContext",
  hookName: "useCarouselContext",
  providerName: "<CarouselProvider />"
});

// node_modules/@ark-ui/react/dist/components/carousel/carousel-autoplay-trigger.js
var CarouselAutoplayTrigger = (0, import_react77.forwardRef)((props43, ref) => {
  const carousel = useCarouselContext();
  const mergedProps = mergeProps2(carousel.getAutoplayTriggerProps(), props43);
  return (0, import_jsx_runtime34.jsx)(ark.button, { ...mergedProps, ref });
});
CarouselAutoplayTrigger.displayName = "CarouselAutoplayTrigger";

// node_modules/@ark-ui/react/dist/components/carousel/carousel-control.js
var import_jsx_runtime35 = __toESM(require_jsx_runtime(), 1);
var import_react79 = __toESM(require_react(), 1);
var CarouselControl = (0, import_react79.forwardRef)((props43, ref) => {
  const carousel = useCarouselContext();
  const mergedProps = mergeProps2(carousel.getControlProps(), props43);
  return (0, import_jsx_runtime35.jsx)(ark.div, { ...mergedProps, ...props43, ref });
});
CarouselControl.displayName = "CarouselControl";

// node_modules/@ark-ui/react/dist/components/carousel/carousel-indicator.js
var import_jsx_runtime36 = __toESM(require_jsx_runtime(), 1);
var import_react81 = __toESM(require_react(), 1);
var CarouselIndicator = (0, import_react81.forwardRef)((props43, ref) => {
  const [indicatorProps3, localProps] = createSplitProps2()(props43, ["readOnly", "index"]);
  const carousel = useCarouselContext();
  const mergedProps = mergeProps2(carousel.getIndicatorProps(indicatorProps3), localProps);
  return (0, import_jsx_runtime36.jsx)(ark.button, { ...mergedProps, ref });
});
CarouselIndicator.displayName = "CarouselIndicator";

// node_modules/@ark-ui/react/dist/components/carousel/carousel-indicator-group.js
var import_jsx_runtime37 = __toESM(require_jsx_runtime(), 1);
var import_react83 = __toESM(require_react(), 1);
var CarouselIndicatorGroup = (0, import_react83.forwardRef)((props43, ref) => {
  const carousel = useCarouselContext();
  const mergedProps = mergeProps2(carousel.getIndicatorGroupProps(), props43);
  return (0, import_jsx_runtime37.jsx)(ark.div, { ...mergedProps, ref });
});
CarouselIndicatorGroup.displayName = "CarouselIndicatorGroup";

// node_modules/@ark-ui/react/dist/components/carousel/carousel-item.js
var import_jsx_runtime38 = __toESM(require_jsx_runtime(), 1);
var import_react85 = __toESM(require_react(), 1);
var CarouselItem = (0, import_react85.forwardRef)((props43, ref) => {
  const [itemProps14, localProps] = createSplitProps2()(props43, ["index", "snapAlign"]);
  const carousel = useCarouselContext();
  const mergedProps = mergeProps2(carousel.getItemProps(itemProps14), localProps);
  return (0, import_jsx_runtime38.jsx)(ark.div, { ...mergedProps, ref });
});
CarouselItem.displayName = "CarouselItem";

// node_modules/@ark-ui/react/dist/components/carousel/carousel-item-group.js
var import_jsx_runtime39 = __toESM(require_jsx_runtime(), 1);
var import_react87 = __toESM(require_react(), 1);
var CarouselItemGroup = (0, import_react87.forwardRef)((props43, ref) => {
  const carousel = useCarouselContext();
  const mergedProps = mergeProps2(carousel.getItemGroupProps(), props43);
  return (0, import_jsx_runtime39.jsx)(ark.div, { ...mergedProps, ref });
});
CarouselItemGroup.displayName = "CarouselItemGroup";

// node_modules/@ark-ui/react/dist/components/carousel/carousel-next-trigger.js
var import_jsx_runtime40 = __toESM(require_jsx_runtime(), 1);
var import_react89 = __toESM(require_react(), 1);
var CarouselNextTrigger = (0, import_react89.forwardRef)((props43, ref) => {
  const carousel = useCarouselContext();
  const mergedProps = mergeProps2(carousel.getNextTriggerProps(), props43);
  return (0, import_jsx_runtime40.jsx)(ark.button, { ...mergedProps, ref });
});
CarouselNextTrigger.displayName = "CarouselNextTrigger";

// node_modules/@ark-ui/react/dist/components/carousel/carousel-prev-trigger.js
var import_jsx_runtime41 = __toESM(require_jsx_runtime(), 1);
var import_react91 = __toESM(require_react(), 1);
var CarouselPrevTrigger = (0, import_react91.forwardRef)((props43, ref) => {
  const carousel = useCarouselContext();
  const mergedProps = mergeProps2(carousel.getPrevTriggerProps(), props43);
  return (0, import_jsx_runtime41.jsx)(ark.button, { ...mergedProps, ref });
});
CarouselPrevTrigger.displayName = "CarouselPrevTrigger";

// node_modules/@ark-ui/react/dist/components/carousel/carousel-root.js
var import_jsx_runtime42 = __toESM(require_jsx_runtime(), 1);
var import_react95 = __toESM(require_react(), 1);

// node_modules/@zag-js/scroll-snap/dist/index.mjs
function getScrollPadding(element) {
  const style = getComputedStyle2(element);
  const rect = element.getBoundingClientRect();
  let xBeforeRaw = style.getPropertyValue("scroll-padding-left").replace("auto", "0px");
  let yBeforeRaw = style.getPropertyValue("scroll-padding-top").replace("auto", "0px");
  let xAfterRaw = style.getPropertyValue("scroll-padding-right").replace("auto", "0px");
  let yAfterRaw = style.getPropertyValue("scroll-padding-bottom").replace("auto", "0px");
  function convert(raw, size3) {
    let n = parseFloat(raw);
    if (/%/.test(raw)) {
      n /= 100;
      n *= size3;
    }
    return Number.isNaN(n) ? 0 : n;
  }
  let xBefore = convert(xBeforeRaw, rect.width);
  let yBefore = convert(yBeforeRaw, rect.height);
  let xAfter = convert(xAfterRaw, rect.width);
  let yAfter = convert(yAfterRaw, rect.height);
  return {
    x: { before: xBefore, after: xAfter },
    y: { before: yBefore, after: yAfter }
  };
}
function isRectIntersecting(a2, b2, axis = "both") {
  return axis === "x" && a2.right >= b2.left && a2.left <= b2.right || axis === "y" && a2.bottom >= b2.top && a2.top <= b2.bottom || axis === "both" && a2.right >= b2.left && a2.left <= b2.right && a2.bottom >= b2.top && a2.top <= b2.bottom;
}
function getDescendants(parent) {
  let children = [];
  for (const child of parent.children) {
    children = children.concat(child, getDescendants(child));
  }
  return children;
}
function getSnapPositions(parent, subtree = false) {
  const parentRect = parent.getBoundingClientRect();
  const positions = {
    x: { start: [], center: [], end: [] },
    y: { start: [], center: [], end: [] }
  };
  const children = subtree ? getDescendants(parent) : parent.children;
  for (const axis of ["x", "y"]) {
    const orthogonalAxis = axis === "x" ? "y" : "x";
    const axisStart = axis === "x" ? "left" : "top";
    const axisSize = axis === "x" ? "width" : "height";
    const axisScroll = axis === "x" ? "scrollLeft" : "scrollTop";
    for (const child of children) {
      const childRect = child.getBoundingClientRect();
      if (!isRectIntersecting(parentRect, childRect, orthogonalAxis)) {
        continue;
      }
      const childStyle = getComputedStyle2(child);
      let [childAlignY, childAlignX] = childStyle.getPropertyValue("scroll-snap-align").split(" ");
      if (typeof childAlignX === "undefined") {
        childAlignX = childAlignY;
      }
      const childAlign = axis === "x" ? childAlignX : childAlignY;
      const childOffsetStart = childRect[axisStart] - parentRect[axisStart] + parent[axisScroll];
      switch (childAlign) {
        case "none":
          break;
        case "start":
          positions[axis].start.push({ node: child, position: childOffsetStart });
          break;
        case "center":
          positions[axis].center.push({ node: child, position: childOffsetStart + childRect[axisSize] / 2 });
          break;
        case "end":
          positions[axis].end.push({ node: child, position: childOffsetStart + childRect[axisSize] });
          break;
      }
    }
  }
  return positions;
}
function getScrollSnapPositions(element) {
  const rect = element.getBoundingClientRect();
  const scrollPadding = getScrollPadding(element);
  const snapPositions = getSnapPositions(element);
  const maxScroll = {
    x: element.scrollWidth - element.offsetWidth,
    y: element.scrollHeight - element.offsetHeight
  };
  return {
    x: uniq3(
      [
        ...snapPositions.x.start.map((v) => v.position - scrollPadding.x.before),
        ...snapPositions.x.center.map((v) => v.position - rect.width / 2),
        ...snapPositions.x.end.map((v) => v.position - rect.width + scrollPadding.x.after)
      ].map(clamp4(0, maxScroll.x))
    ),
    y: uniq3(
      [
        ...snapPositions.y.start.map((v) => v.position - scrollPadding.y.before),
        ...snapPositions.y.center.map((v) => v.position - rect.height / 2),
        ...snapPositions.y.end.map((v) => v.position - rect.height + scrollPadding.y.after)
      ].map(clamp4(0, maxScroll.y))
    )
  };
}
function findSnapPoint(parent, axis, predicate) {
  const snapPositions = getSnapPositions(parent);
  const items = [...snapPositions[axis].start, ...snapPositions[axis].center, ...snapPositions[axis].end];
  for (const item of items) {
    if (predicate(item.node)) {
      return item.position;
    }
  }
}
var uniq3 = (arr) => [...new Set(arr)];
var clamp4 = (min4, max4) => (value) => Math.max(min4, Math.min(max4, value));

// node_modules/@zag-js/carousel/dist/index.mjs
var anatomy7 = createAnatomy("carousel").parts(
  "root",
  "itemGroup",
  "item",
  "control",
  "nextTrigger",
  "prevTrigger",
  "indicatorGroup",
  "indicator",
  "autoplayTrigger"
);
var parts7 = anatomy7.build();
var getRootId7 = (ctx) => {
  var _a8;
  return ((_a8 = ctx.ids) == null ? void 0 : _a8.root) ?? `carousel:${ctx.id}`;
};
var getItemId2 = (ctx, index) => {
  var _a8, _b7;
  return ((_b7 = (_a8 = ctx.ids) == null ? void 0 : _a8.item) == null ? void 0 : _b7.call(_a8, index)) ?? `carousel:${ctx.id}:item:${index}`;
};
var getItemGroupId = (ctx) => {
  var _a8;
  return ((_a8 = ctx.ids) == null ? void 0 : _a8.itemGroup) ?? `carousel:${ctx.id}:item-group`;
};
var getNextTriggerId2 = (ctx) => {
  var _a8;
  return ((_a8 = ctx.ids) == null ? void 0 : _a8.nextTrigger) ?? `carousel:${ctx.id}:next-trigger`;
};
var getPrevTriggerId2 = (ctx) => {
  var _a8;
  return ((_a8 = ctx.ids) == null ? void 0 : _a8.prevTrigger) ?? `carousel:${ctx.id}:prev-trigger`;
};
var getIndicatorGroupId = (ctx) => {
  var _a8;
  return ((_a8 = ctx.ids) == null ? void 0 : _a8.indicatorGroup) ?? `carousel:${ctx.id}:indicator-group`;
};
var getIndicatorId = (ctx, index) => {
  var _a8, _b7;
  return ((_b7 = (_a8 = ctx.ids) == null ? void 0 : _a8.indicator) == null ? void 0 : _b7.call(_a8, index)) ?? `carousel:${ctx.id}:indicator:${index}`;
};
var getItemGroupEl = (ctx) => ctx.getById(getItemGroupId(ctx));
var getItemEls = (ctx) => queryAll(getItemGroupEl(ctx), `[data-part=item]`);
var getIndicatorEl = (ctx, page) => ctx.getById(getIndicatorId(ctx, page));
var syncTabIndex = (ctx) => {
  const el = getItemGroupEl(ctx);
  if (!el) return;
  const tabbables = getTabbables(el);
  el.setAttribute("tabindex", tabbables.length > 0 ? "-1" : "0");
};
function connect8(service, normalize4) {
  const { state: state2, context, computed, send, scope, prop } = service;
  const isPlaying = state2.matches("autoplay");
  const isDragging = state2.matches("dragging");
  const canScrollNext = computed("canScrollNext");
  const canScrollPrev = computed("canScrollPrev");
  const horizontal = computed("isHorizontal");
  const pageSnapPoints = Array.from(context.get("pageSnapPoints"));
  const page = context.get("page");
  const slidesPerPage = prop("slidesPerPage");
  const padding = prop("padding");
  const translations = prop("translations");
  return {
    isPlaying,
    isDragging,
    page,
    pageSnapPoints,
    canScrollNext,
    canScrollPrev,
    getProgress() {
      return page / pageSnapPoints.length;
    },
    scrollToIndex(index, instant) {
      send({ type: "INDEX.SET", index, instant });
    },
    scrollTo(index, instant) {
      send({ type: "PAGE.SET", index, instant });
    },
    scrollNext(instant) {
      send({ type: "PAGE.NEXT", instant });
    },
    scrollPrev(instant) {
      send({ type: "PAGE.PREV", instant });
    },
    play() {
      send({ type: "AUTOPLAY.START" });
    },
    pause() {
      send({ type: "AUTOPLAY.PAUSE" });
    },
    isInView(index) {
      return Array.from(context.get("slidesInView")).includes(index);
    },
    refresh() {
      send({ type: "SNAP.REFRESH" });
    },
    getRootProps() {
      return normalize4.element({
        ...parts7.root.attrs,
        id: getRootId7(scope),
        role: "region",
        "aria-roledescription": "carousel",
        "data-orientation": prop("orientation"),
        dir: prop("dir"),
        style: {
          "--slides-per-page": slidesPerPage,
          "--slide-spacing": prop("spacing"),
          "--slide-item-size": "calc(100% / var(--slides-per-page) - var(--slide-spacing) * (var(--slides-per-page) - 1) / var(--slides-per-page))"
        }
      });
    },
    getItemGroupProps() {
      return normalize4.element({
        ...parts7.itemGroup.attrs,
        id: getItemGroupId(scope),
        "data-orientation": prop("orientation"),
        "data-dragging": dataAttr(isDragging),
        dir: prop("dir"),
        "aria-live": isPlaying ? "off" : "polite",
        onFocus(event) {
          if (!isSelfTarget(event)) return;
          send({ type: "VIEWPORT.FOCUS" });
        },
        onBlur(event) {
          if (contains(event.currentTarget, event.relatedTarget)) return;
          send({ type: "VIEWPORT.BLUR" });
        },
        onMouseDown(event) {
          if (!prop("allowMouseDrag")) return;
          if (event.button !== 0) return;
          if (event.defaultPrevented) return;
          const target = getEventTarget(event);
          if (isFocusable(target) && target !== event.currentTarget) return;
          event.preventDefault();
          send({ type: "DRAGGING.START" });
        },
        onWheel: throttle((event) => {
          const axis = prop("orientation") === "horizontal" ? "deltaX" : "deltaY";
          const isScrollingLeft = event[axis] < 0;
          if (isScrollingLeft && !computed("canScrollPrev")) return;
          const isScrollingRight = event[axis] > 0;
          if (isScrollingRight && !computed("canScrollNext")) return;
          send({ type: "USER.SCROLL" });
        }, 150),
        onTouchStart() {
          send({ type: "USER.SCROLL" });
        },
        style: {
          display: "grid",
          gap: "var(--slide-spacing)",
          scrollSnapType: [horizontal ? "x" : "y", prop("snapType")].join(" "),
          gridAutoFlow: horizontal ? "column" : "row",
          scrollbarWidth: "none",
          overscrollBehavior: "contain",
          [horizontal ? "gridAutoColumns" : "gridAutoRows"]: "var(--slide-item-size)",
          [horizontal ? "scrollPaddingInline" : "scrollPaddingBlock"]: padding,
          [horizontal ? "paddingInline" : "paddingBlock"]: padding,
          [horizontal ? "overflowX" : "overflowY"]: "auto"
        }
      });
    },
    getItemProps(props210) {
      const isInView = context.get("slidesInView").includes(props210.index);
      return normalize4.element({
        ...parts7.item.attrs,
        id: getItemId2(scope, props210.index),
        dir: prop("dir"),
        role: "group",
        "data-index": props210.index,
        "data-inview": dataAttr(isInView),
        "aria-roledescription": "slide",
        "data-orientation": prop("orientation"),
        "aria-label": translations.item(props210.index, prop("slideCount")),
        "aria-hidden": ariaAttr(!isInView),
        style: {
          scrollSnapAlign: (() => {
            const snapAlign = props210.snapAlign ?? "start";
            const slidesPerMove = prop("slidesPerMove");
            const perMove = slidesPerMove === "auto" ? Math.floor(prop("slidesPerPage")) : slidesPerMove;
            const shouldSnap = (props210.index + perMove) % perMove === 0;
            return shouldSnap ? snapAlign : void 0;
          })()
        }
      });
    },
    getControlProps() {
      return normalize4.element({
        ...parts7.control.attrs,
        "data-orientation": prop("orientation")
      });
    },
    getPrevTriggerProps() {
      return normalize4.button({
        ...parts7.prevTrigger.attrs,
        id: getPrevTriggerId2(scope),
        type: "button",
        disabled: !canScrollPrev,
        dir: prop("dir"),
        "aria-label": translations.prevTrigger,
        "data-orientation": prop("orientation"),
        "aria-controls": getItemGroupId(scope),
        onClick(event) {
          if (event.defaultPrevented) return;
          send({ type: "PAGE.PREV", src: "trigger" });
        }
      });
    },
    getNextTriggerProps() {
      return normalize4.button({
        ...parts7.nextTrigger.attrs,
        dir: prop("dir"),
        id: getNextTriggerId2(scope),
        type: "button",
        "aria-label": translations.nextTrigger,
        "data-orientation": prop("orientation"),
        "aria-controls": getItemGroupId(scope),
        disabled: !canScrollNext,
        onClick(event) {
          if (event.defaultPrevented) return;
          send({ type: "PAGE.NEXT", src: "trigger" });
        }
      });
    },
    getIndicatorGroupProps() {
      return normalize4.element({
        ...parts7.indicatorGroup.attrs,
        dir: prop("dir"),
        id: getIndicatorGroupId(scope),
        "data-orientation": prop("orientation"),
        onKeyDown(event) {
          if (event.defaultPrevented) return;
          const src = "indicator";
          const keyMap2 = {
            ArrowDown(event2) {
              if (horizontal) return;
              send({ type: "PAGE.NEXT", src });
              event2.preventDefault();
            },
            ArrowUp(event2) {
              if (horizontal) return;
              send({ type: "PAGE.PREV", src });
              event2.preventDefault();
            },
            ArrowRight(event2) {
              if (!horizontal) return;
              send({ type: "PAGE.NEXT", src });
              event2.preventDefault();
            },
            ArrowLeft(event2) {
              if (!horizontal) return;
              send({ type: "PAGE.PREV", src });
              event2.preventDefault();
            },
            Home(event2) {
              send({ type: "PAGE.SET", index: 0, src });
              event2.preventDefault();
            },
            End(event2) {
              send({ type: "PAGE.SET", index: pageSnapPoints.length - 1, src });
              event2.preventDefault();
            }
          };
          const key = getEventKey(event, {
            dir: prop("dir"),
            orientation: prop("orientation")
          });
          const exec = keyMap2[key];
          exec == null ? void 0 : exec(event);
        }
      });
    },
    getIndicatorProps(props210) {
      return normalize4.button({
        ...parts7.indicator.attrs,
        dir: prop("dir"),
        id: getIndicatorId(scope, props210.index),
        type: "button",
        "data-orientation": prop("orientation"),
        "data-index": props210.index,
        "data-readonly": dataAttr(props210.readOnly),
        "data-current": dataAttr(props210.index === page),
        "aria-label": translations.indicator(props210.index),
        onClick(event) {
          if (event.defaultPrevented) return;
          if (props210.readOnly) return;
          send({ type: "PAGE.SET", index: props210.index, src: "indicator" });
        }
      });
    },
    getAutoplayTriggerProps() {
      return normalize4.button({
        ...parts7.autoplayTrigger.attrs,
        type: "button",
        "data-orientation": prop("orientation"),
        "data-pressed": dataAttr(isPlaying),
        "aria-label": isPlaying ? translations.autoplayStop : translations.autoplayStart,
        onClick(event) {
          if (event.defaultPrevented) return;
          send({ type: isPlaying ? "AUTOPLAY.PAUSE" : "AUTOPLAY.START" });
        }
      });
    }
  };
}
var machine8 = createMachine({
  props({ props: props210 }) {
    ensureProps(props210, ["slideCount"], "carousel");
    return {
      dir: "ltr",
      defaultPage: 0,
      orientation: "horizontal",
      snapType: "mandatory",
      loop: !!props210.autoplay,
      slidesPerPage: 1,
      slidesPerMove: "auto",
      spacing: "0px",
      autoplay: false,
      allowMouseDrag: false,
      inViewThreshold: 0.6,
      ...props210,
      translations: {
        nextTrigger: "Next slide",
        prevTrigger: "Previous slide",
        indicator: (index) => `Go to slide ${index + 1}`,
        item: (index, count) => `${index + 1} of ${count}`,
        autoplayStart: "Start slide rotation",
        autoplayStop: "Stop slide rotation",
        ...props210.translations
      }
    };
  },
  refs() {
    return {
      timeoutRef: void 0
    };
  },
  initialState({ prop }) {
    return prop("autoplay") ? "autoplay" : "idle";
  },
  context({ prop, bindable, getContext }) {
    return {
      page: bindable(() => ({
        defaultValue: prop("defaultPage"),
        value: prop("page"),
        onChange(page) {
          var _a8;
          const ctx = getContext();
          const pageSnapPoints = ctx.get("pageSnapPoints");
          (_a8 = prop("onPageChange")) == null ? void 0 : _a8({ page, pageSnapPoint: pageSnapPoints[page] });
        }
      })),
      pageSnapPoints: bindable(() => {
        return {
          defaultValue: getPageSnapPoints(prop("slideCount"), prop("slidesPerMove"), prop("slidesPerPage"))
        };
      }),
      slidesInView: bindable(() => ({
        defaultValue: []
      }))
    };
  },
  computed: {
    isRtl: ({ prop }) => prop("dir") === "rtl",
    isHorizontal: ({ prop }) => prop("orientation") === "horizontal",
    canScrollNext: ({ prop, context }) => prop("loop") || context.get("page") < context.get("pageSnapPoints").length - 1,
    canScrollPrev: ({ prop, context }) => prop("loop") || context.get("page") > 0,
    autoplayInterval: ({ prop }) => {
      const autoplay = prop("autoplay");
      return isObject2(autoplay) ? autoplay.delay : 4e3;
    }
  },
  watch({ track, action, context, prop }) {
    track([() => prop("slidesPerPage"), () => prop("slidesPerMove")], () => {
      action(["setSnapPoints"]);
    });
    track([() => context.get("page")], () => {
      action(["scrollToPage", "focusIndicatorEl"]);
    });
    track([() => prop("orientation")], () => {
      action(["setSnapPoints", "scrollToPage"]);
    });
  },
  on: {
    "PAGE.NEXT": {
      target: "idle",
      actions: ["clearScrollEndTimer", "setNextPage"]
    },
    "PAGE.PREV": {
      target: "idle",
      actions: ["clearScrollEndTimer", "setPrevPage"]
    },
    "PAGE.SET": {
      target: "idle",
      actions: ["clearScrollEndTimer", "setPage"]
    },
    "INDEX.SET": {
      target: "idle",
      actions: ["clearScrollEndTimer", "setMatchingPage"]
    },
    "SNAP.REFRESH": {
      actions: ["setSnapPoints", "clampPage"]
    },
    "PAGE.SCROLL": {
      actions: ["scrollToPage"]
    }
  },
  effects: ["trackSlideMutation", "trackSlideIntersections", "trackSlideResize"],
  entry: ["setSnapPoints", "setPage"],
  exit: ["clearScrollEndTimer"],
  states: {
    idle: {
      on: {
        "DRAGGING.START": {
          target: "dragging",
          actions: ["invokeDragStart"]
        },
        "AUTOPLAY.START": {
          target: "autoplay",
          actions: ["invokeAutoplayStart"]
        },
        "USER.SCROLL": {
          target: "userScroll"
        },
        "VIEWPORT.FOCUS": {
          target: "focus"
        }
      }
    },
    focus: {
      effects: ["trackKeyboardScroll"],
      on: {
        "VIEWPORT.BLUR": {
          target: "idle"
        },
        "PAGE.NEXT": {
          actions: ["clearScrollEndTimer", "setNextPage"]
        },
        "PAGE.PREV": {
          actions: ["clearScrollEndTimer", "setPrevPage"]
        },
        "PAGE.SET": {
          actions: ["clearScrollEndTimer", "setPage"]
        },
        "INDEX.SET": {
          actions: ["clearScrollEndTimer", "setMatchingPage"]
        },
        "USER.SCROLL": {
          target: "userScroll"
        }
      }
    },
    dragging: {
      effects: ["trackPointerMove"],
      entry: ["disableScrollSnap"],
      on: {
        DRAGGING: {
          actions: ["scrollSlides", "invokeDragging"]
        },
        "DRAGGING.END": {
          target: "idle",
          actions: ["endDragging", "invokeDraggingEnd"]
        }
      }
    },
    userScroll: {
      effects: ["trackScroll"],
      on: {
        "SCROLL.END": [
          {
            guard: "isFocused",
            target: "focus",
            actions: ["setClosestPage"]
          },
          {
            target: "idle",
            actions: ["setClosestPage"]
          }
        ]
      }
    },
    autoplay: {
      effects: ["trackDocumentVisibility", "trackScroll", "autoUpdateSlide"],
      exit: ["invokeAutoplayEnd"],
      on: {
        "AUTOPLAY.TICK": {
          actions: ["setNextPage", "invokeAutoplay"]
        },
        "DRAGGING.START": {
          target: "dragging",
          actions: ["invokeDragStart"]
        },
        "AUTOPLAY.PAUSE": {
          target: "idle"
        }
      }
    }
  },
  implementations: {
    guards: {
      isFocused: ({ scope }) => scope.isActiveElement(getItemGroupEl(scope))
    },
    effects: {
      autoUpdateSlide({ computed, send }) {
        const id = setInterval(() => {
          send({ type: "AUTOPLAY.TICK", src: "autoplay.interval" });
        }, computed("autoplayInterval"));
        return () => clearInterval(id);
      },
      trackSlideMutation({ scope, send }) {
        const el = getItemGroupEl(scope);
        if (!el) return;
        const win = scope.getWin();
        const observer = new win.MutationObserver(() => {
          send({ type: "SNAP.REFRESH", src: "slide.mutation" });
          syncTabIndex(scope);
        });
        syncTabIndex(scope);
        observer.observe(el, { childList: true, subtree: true });
        return () => observer.disconnect();
      },
      trackSlideResize({ scope, send }) {
        const el = getItemGroupEl(scope);
        if (!el) return;
        const win = scope.getWin();
        const exec = () => {
          send({ type: "SNAP.REFRESH", src: "slide.resize" });
        };
        raf(() => {
          exec();
          raf(() => {
            send({ type: "PAGE.SCROLL", instant: true });
          });
        });
        const observer = new win.ResizeObserver(exec);
        getItemEls(scope).forEach((slide) => observer.observe(slide));
        return () => observer.disconnect();
      },
      trackSlideIntersections({ scope, prop, context }) {
        const el = getItemGroupEl(scope);
        const win = scope.getWin();
        const observer = new win.IntersectionObserver(
          (entries) => {
            const slidesInView = entries.reduce((acc, entry) => {
              const target = entry.target;
              const index = Number(target.dataset.index ?? "-1");
              if (index == null || Number.isNaN(index) || index === -1) return acc;
              return entry.isIntersecting ? add(acc, index) : remove(acc, index);
            }, context.get("slidesInView"));
            context.set("slidesInView", uniq2(slidesInView));
          },
          {
            root: el,
            threshold: prop("inViewThreshold")
          }
        );
        getItemEls(scope).forEach((slide) => observer.observe(slide));
        return () => observer.disconnect();
      },
      trackScroll({ send, refs, scope }) {
        const el = getItemGroupEl(scope);
        if (!el) return;
        const onScroll = () => {
          clearTimeout(refs.get("timeoutRef"));
          refs.set("timeoutRef", void 0);
          refs.set(
            "timeoutRef",
            setTimeout(() => {
              send({ type: "SCROLL.END" });
            }, 150)
          );
        };
        return addDomEvent(el, "scroll", onScroll, { passive: true });
      },
      trackDocumentVisibility({ scope, send }) {
        const doc = scope.getDoc();
        const onVisibilityChange = () => {
          if (doc.visibilityState === "visible") return;
          send({ type: "AUTOPLAY.PAUSE", src: "doc.hidden" });
        };
        return addDomEvent(doc, "visibilitychange", onVisibilityChange);
      },
      trackPointerMove({ scope, send }) {
        const doc = scope.getDoc();
        return trackPointerMove(doc, {
          onPointerMove({ event }) {
            send({ type: "DRAGGING", left: -event.movementX, top: -event.movementY });
          },
          onPointerUp() {
            send({ type: "DRAGGING.END" });
          }
        });
      },
      trackKeyboardScroll({ scope, send, context }) {
        const win = scope.getWin();
        const onKeyDown = (event) => {
          switch (event.key) {
            case "ArrowRight":
              event.preventDefault();
              send({ type: "PAGE.NEXT" });
              break;
            case "ArrowLeft":
              event.preventDefault();
              send({ type: "PAGE.PREV" });
              break;
            case "Home":
              event.preventDefault();
              send({ type: "PAGE.SET", index: 0 });
              break;
            case "End":
              event.preventDefault();
              send({ type: "PAGE.SET", index: context.get("pageSnapPoints").length - 1 });
          }
        };
        return addDomEvent(win, "keydown", onKeyDown, { capture: true });
      }
    },
    actions: {
      clearScrollEndTimer({ refs }) {
        if (refs.get("timeoutRef") == null) return;
        clearTimeout(refs.get("timeoutRef"));
        refs.set("timeoutRef", void 0);
      },
      scrollToPage({ context, event, scope, computed, flush: flush2 }) {
        const behavior = event.instant ? "instant" : "smooth";
        const index = clampValue(event.index ?? context.get("page"), 0, context.get("pageSnapPoints").length - 1);
        const el = getItemGroupEl(scope);
        if (!el) return;
        const axis = computed("isHorizontal") ? "left" : "top";
        flush2(() => {
          el.scrollTo({ [axis]: context.get("pageSnapPoints")[index], behavior });
        });
      },
      setClosestPage({ context, scope, computed }) {
        const el = getItemGroupEl(scope);
        if (!el) return;
        const scrollPosition = computed("isHorizontal") ? el.scrollLeft : el.scrollTop;
        const page = context.get("pageSnapPoints").findIndex((point) => Math.abs(point - scrollPosition) < 1);
        if (page === -1) return;
        context.set("page", page);
      },
      setNextPage({ context, prop, state: state2 }) {
        const loop = state2.matches("autoplay") || prop("loop");
        const page = nextIndex(context.get("pageSnapPoints"), context.get("page"), { loop });
        context.set("page", page);
      },
      setPrevPage({ context, prop, state: state2 }) {
        const loop = state2.matches("autoplay") || prop("loop");
        const page = prevIndex(context.get("pageSnapPoints"), context.get("page"), { loop });
        context.set("page", page);
      },
      setMatchingPage({ context, event, computed, scope }) {
        const el = getItemGroupEl(scope);
        if (!el) return;
        const snapPoint = findSnapPoint(
          el,
          computed("isHorizontal") ? "x" : "y",
          (node) => node.dataset.index === event.index.toString()
        );
        if (snapPoint == null) return;
        const page = context.get("pageSnapPoints").findIndex((point) => Math.abs(point - snapPoint) < 1);
        context.set("page", page);
      },
      setPage({ context, event }) {
        const page = event.index ?? context.get("page");
        context.set("page", page);
      },
      clampPage({ context }) {
        const index = clampValue(context.get("page"), 0, context.get("pageSnapPoints").length - 1);
        context.set("page", index);
      },
      setSnapPoints({ context, computed, scope }) {
        const el = getItemGroupEl(scope);
        if (!el) return;
        const scrollSnapPoints = getScrollSnapPositions(el);
        context.set("pageSnapPoints", computed("isHorizontal") ? scrollSnapPoints.x : scrollSnapPoints.y);
      },
      disableScrollSnap({ scope }) {
        const el = getItemGroupEl(scope);
        if (!el) return;
        const styles = getComputedStyle(el);
        el.dataset.scrollSnapType = styles.getPropertyValue("scroll-snap-type");
        el.style.setProperty("scroll-snap-type", "none");
      },
      scrollSlides({ scope, event }) {
        const el = getItemGroupEl(scope);
        el == null ? void 0 : el.scrollBy({ left: event.left, top: event.top, behavior: "instant" });
      },
      endDragging({ scope, context, computed }) {
        const el = getItemGroupEl(scope);
        if (!el) return;
        const startX = el.scrollLeft;
        const startY = el.scrollTop;
        const snapPositions = getScrollSnapPositions(el);
        const closestX = snapPositions.x.reduce((closest, curr) => {
          return Math.abs(curr - startX) < Math.abs(closest - startX) ? curr : closest;
        }, snapPositions.x[0]);
        const closestY = snapPositions.y.reduce((closest, curr) => {
          return Math.abs(curr - startY) < Math.abs(closest - startY) ? curr : closest;
        }, snapPositions.y[0]);
        raf(() => {
          el.scrollTo({ left: closestX, top: closestY, behavior: "smooth" });
          const closest = computed("isHorizontal") ? closestX : closestY;
          context.set("page", context.get("pageSnapPoints").indexOf(closest));
          const scrollSnapType = el.dataset.scrollSnapType;
          if (scrollSnapType) {
            el.style.setProperty("scroll-snap-type", scrollSnapType);
            delete el.dataset.scrollSnapType;
          }
        });
      },
      focusIndicatorEl({ context, event, scope }) {
        if (event.src !== "indicator") return;
        const el = getIndicatorEl(scope, context.get("page"));
        if (!el) return;
        raf(() => el.focus({ preventScroll: true }));
      },
      invokeDragStart({ context, prop }) {
        var _a8;
        (_a8 = prop("onDragStatusChange")) == null ? void 0 : _a8({ type: "dragging.start", isDragging: true, page: context.get("page") });
      },
      invokeDragging({ context, prop }) {
        var _a8;
        (_a8 = prop("onDragStatusChange")) == null ? void 0 : _a8({ type: "dragging", isDragging: true, page: context.get("page") });
      },
      invokeDraggingEnd({ context, prop }) {
        var _a8;
        (_a8 = prop("onDragStatusChange")) == null ? void 0 : _a8({ type: "dragging.end", isDragging: false, page: context.get("page") });
      },
      invokeAutoplay({ context, prop }) {
        var _a8;
        (_a8 = prop("onAutoplayStatusChange")) == null ? void 0 : _a8({ type: "autoplay", isPlaying: true, page: context.get("page") });
      },
      invokeAutoplayStart({ context, prop }) {
        var _a8;
        (_a8 = prop("onAutoplayStatusChange")) == null ? void 0 : _a8({ type: "autoplay.start", isPlaying: true, page: context.get("page") });
      },
      invokeAutoplayEnd({ context, prop }) {
        var _a8;
        (_a8 = prop("onAutoplayStatusChange")) == null ? void 0 : _a8({ type: "autoplay.stop", isPlaying: false, page: context.get("page") });
      }
    }
  }
});
function getPageSnapPoints(totalSlides, slidesPerMove, slidesPerPage) {
  if (totalSlides == null || slidesPerPage <= 0) {
    return [];
  }
  const snapPoints = [];
  const perMove = slidesPerMove === "auto" ? Math.floor(slidesPerPage) : slidesPerMove;
  if (perMove <= 0) {
    return [];
  }
  for (let i = 0; i < totalSlides - 1; i += perMove) {
    snapPoints.push(i);
  }
  return snapPoints;
}
var props8 = createProps()([
  "dir",
  "getRootNode",
  "id",
  "ids",
  "loop",
  "page",
  "defaultPage",
  "onPageChange",
  "orientation",
  "slideCount",
  "slidesPerPage",
  "slidesPerMove",
  "spacing",
  "padding",
  "autoplay",
  "allowMouseDrag",
  "inViewThreshold",
  "translations",
  "snapType",
  "onDragStatusChange",
  "onAutoplayStatusChange"
]);
var splitProps9 = createSplitProps(props8);
var indicatorProps = createProps()(["index", "readOnly"]);
var splitIndicatorProps = createSplitProps(indicatorProps);
var itemProps2 = createProps()(["index", "snapAlign"]);
var splitItemProps2 = createSplitProps(itemProps2);

// node_modules/@ark-ui/react/dist/components/carousel/use-carousel.js
var import_react93 = __toESM(require_react(), 1);
var useCarousel = (props43) => {
  const id = (0, import_react93.useId)();
  const { getRootNode } = useEnvironmentContext();
  const { dir } = useLocaleContext();
  const machineProps = {
    id,
    dir,
    getRootNode,
    ...props43
  };
  const service = useMachine(machine8, machineProps);
  return connect8(service, normalizeProps);
};

// node_modules/@ark-ui/react/dist/components/carousel/carousel-root.js
var CarouselRoot = (0, import_react95.forwardRef)((props43, ref) => {
  const [useCarouselProps, localProps] = createSplitProps2()(props43, [
    "allowMouseDrag",
    "autoplay",
    "defaultPage",
    "id",
    "ids",
    "inViewThreshold",
    "loop",
    "onAutoplayStatusChange",
    "onDragStatusChange",
    "onPageChange",
    "orientation",
    "padding",
    "page",
    "slideCount",
    "slidesPerMove",
    "slidesPerPage",
    "snapType",
    "spacing",
    "translations"
  ]);
  const carousel = useCarousel(useCarouselProps);
  const mergedProps = mergeProps2(carousel.getRootProps(), localProps);
  return (0, import_jsx_runtime42.jsx)(CarouselProvider, { value: carousel, children: (0, import_jsx_runtime42.jsx)(ark.div, { ...mergedProps, ref }) });
});
CarouselRoot.displayName = "CarouselRoot";

// node_modules/@ark-ui/react/dist/components/carousel/carousel-root-provider.js
var import_jsx_runtime43 = __toESM(require_jsx_runtime(), 1);
var import_react97 = __toESM(require_react(), 1);
var CarouselRootProvider = (0, import_react97.forwardRef)((props43, ref) => {
  const [{ value: carousel }, localProps] = createSplitProps2()(props43, ["value"]);
  const mergedProps = mergeProps2(carousel.getRootProps(), localProps);
  return (0, import_jsx_runtime43.jsx)(CarouselProvider, { value: carousel, children: (0, import_jsx_runtime43.jsx)(ark.div, { ...mergedProps, ref }) });
});
CarouselRootProvider.displayName = "CarouselRootProvider";

// node_modules/@ark-ui/react/dist/components/checkbox/use-checkbox-context.js
var [CheckboxProvider, useCheckboxContext] = createContext3({
  name: "CheckboxContext",
  hookName: "useCheckboxContext",
  providerName: "<CheckboxProvider />"
});

// node_modules/@ark-ui/react/dist/components/checkbox/checkbox-context.js
var CheckboxContext = (props43) => props43.children(useCheckboxContext());

// node_modules/@ark-ui/react/dist/components/checkbox/checkbox-control.js
var import_jsx_runtime44 = __toESM(require_jsx_runtime(), 1);
var import_react99 = __toESM(require_react(), 1);
var CheckboxControl = (0, import_react99.forwardRef)((props43, ref) => {
  const checkbox = useCheckboxContext();
  const mergedProps = mergeProps2(checkbox.getControlProps(), props43);
  return (0, import_jsx_runtime44.jsx)(ark.div, { ...mergedProps, ref });
});
CheckboxControl.displayName = "CheckboxControl";

// node_modules/@ark-ui/react/dist/components/checkbox/checkbox-group.js
var import_jsx_runtime45 = __toESM(require_jsx_runtime(), 1);
var import_react101 = __toESM(require_react(), 1);

// node_modules/@zag-js/focus-visible/dist/index.mjs
function isValidKey(e) {
  return !(e.metaKey || !isMac() && e.altKey || e.ctrlKey || e.key === "Control" || e.key === "Shift" || e.key === "Meta");
}
var nonTextInputTypes = /* @__PURE__ */ new Set(["checkbox", "radio", "range", "color", "file", "image", "button", "submit", "reset"]);
function isKeyboardFocusEvent(isTextInput, modality, e) {
  const target = e ? getEventTarget(e) : null;
  const win = getWindow(target);
  isTextInput = isTextInput || target instanceof win.HTMLInputElement && !nonTextInputTypes.has(target == null ? void 0 : target.type) || target instanceof win.HTMLTextAreaElement || target instanceof win.HTMLElement && target.isContentEditable;
  return !(isTextInput && modality === "keyboard" && e instanceof win.KeyboardEvent && !Reflect.has(FOCUS_VISIBLE_INPUT_KEYS, e.key));
}
var currentModality = null;
var changeHandlers = /* @__PURE__ */ new Set();
var listenerMap = /* @__PURE__ */ new Map();
var hasEventBeforeFocus = false;
var hasBlurredWindowRecently = false;
var FOCUS_VISIBLE_INPUT_KEYS = {
  Tab: true,
  Escape: true
};
function triggerChangeHandlers(modality, e) {
  for (let handler of changeHandlers) {
    handler(modality, e);
  }
}
function handleKeyboardEvent(e) {
  hasEventBeforeFocus = true;
  if (isValidKey(e)) {
    currentModality = "keyboard";
    triggerChangeHandlers("keyboard", e);
  }
}
function handlePointerEvent(e) {
  currentModality = "pointer";
  if (e.type === "mousedown" || e.type === "pointerdown") {
    hasEventBeforeFocus = true;
    triggerChangeHandlers("pointer", e);
  }
}
function handleClickEvent(e) {
  if (isVirtualClick(e)) {
    hasEventBeforeFocus = true;
    currentModality = "virtual";
  }
}
function handleFocusEvent(e) {
  const target = getEventTarget(e);
  if (target === getWindow(target) || target === getDocument(target)) {
    return;
  }
  if (!hasEventBeforeFocus && !hasBlurredWindowRecently) {
    currentModality = "virtual";
    triggerChangeHandlers("virtual", e);
  }
  hasEventBeforeFocus = false;
  hasBlurredWindowRecently = false;
}
function handleWindowBlur() {
  hasEventBeforeFocus = false;
  hasBlurredWindowRecently = true;
}
function setupGlobalFocusEvents(root) {
  if (typeof window === "undefined" || listenerMap.get(getWindow(root))) {
    return;
  }
  const win = getWindow(root);
  const doc = getDocument(root);
  let focus = win.HTMLElement.prototype.focus;
  function patchedFocus() {
    currentModality = "virtual";
    triggerChangeHandlers("virtual", null);
    hasEventBeforeFocus = true;
    focus.apply(this, arguments);
  }
  Object.defineProperty(win.HTMLElement.prototype, "focus", {
    configurable: true,
    value: patchedFocus
  });
  doc.addEventListener("keydown", handleKeyboardEvent, true);
  doc.addEventListener("keyup", handleKeyboardEvent, true);
  doc.addEventListener("click", handleClickEvent, true);
  win.addEventListener("focus", handleFocusEvent, true);
  win.addEventListener("blur", handleWindowBlur, false);
  if (typeof win.PointerEvent !== "undefined") {
    doc.addEventListener("pointerdown", handlePointerEvent, true);
    doc.addEventListener("pointermove", handlePointerEvent, true);
    doc.addEventListener("pointerup", handlePointerEvent, true);
  } else {
    doc.addEventListener("mousedown", handlePointerEvent, true);
    doc.addEventListener("mousemove", handlePointerEvent, true);
    doc.addEventListener("mouseup", handlePointerEvent, true);
  }
  win.addEventListener(
    "beforeunload",
    () => {
      tearDownWindowFocusTracking(root);
    },
    { once: true }
  );
  listenerMap.set(win, { focus });
}
var tearDownWindowFocusTracking = (root, loadListener) => {
  const win = getWindow(root);
  const doc = getDocument(root);
  if (!listenerMap.has(win)) {
    return;
  }
  win.HTMLElement.prototype.focus = listenerMap.get(win).focus;
  doc.removeEventListener("keydown", handleKeyboardEvent, true);
  doc.removeEventListener("keyup", handleKeyboardEvent, true);
  doc.removeEventListener("click", handleClickEvent, true);
  win.removeEventListener("focus", handleFocusEvent, true);
  win.removeEventListener("blur", handleWindowBlur, false);
  if (typeof win.PointerEvent !== "undefined") {
    doc.removeEventListener("pointerdown", handlePointerEvent, true);
    doc.removeEventListener("pointermove", handlePointerEvent, true);
    doc.removeEventListener("pointerup", handlePointerEvent, true);
  } else {
    doc.removeEventListener("mousedown", handlePointerEvent, true);
    doc.removeEventListener("mousemove", handlePointerEvent, true);
    doc.removeEventListener("mouseup", handlePointerEvent, true);
  }
  listenerMap.delete(win);
};
function getInteractionModality() {
  return currentModality;
}
function isFocusVisible() {
  return currentModality === "keyboard";
}
function trackFocusVisible(props43 = {}) {
  const { isTextInput, autoFocus, onChange, root } = props43;
  setupGlobalFocusEvents(root);
  onChange == null ? void 0 : onChange({ isFocusVisible: autoFocus || isFocusVisible(), modality: currentModality });
  const handler = (modality, e) => {
    if (!isKeyboardFocusEvent(!!isTextInput, modality, e)) return;
    onChange == null ? void 0 : onChange({ isFocusVisible: isFocusVisible(), modality });
  };
  changeHandlers.add(handler);
  return () => {
    changeHandlers.delete(handler);
  };
}

// node_modules/@zag-js/checkbox/dist/index.mjs
var anatomy8 = createAnatomy("checkbox").parts("root", "label", "control", "indicator");
var parts8 = anatomy8.build();
var getRootId8 = (ctx) => {
  var _a8;
  return ((_a8 = ctx.ids) == null ? void 0 : _a8.root) ?? `checkbox:${ctx.id}`;
};
var getLabelId3 = (ctx) => {
  var _a8;
  return ((_a8 = ctx.ids) == null ? void 0 : _a8.label) ?? `checkbox:${ctx.id}:label`;
};
var getControlId4 = (ctx) => {
  var _a8;
  return ((_a8 = ctx.ids) == null ? void 0 : _a8.control) ?? `checkbox:${ctx.id}:control`;
};
var getHiddenInputId3 = (ctx) => {
  var _a8;
  return ((_a8 = ctx.ids) == null ? void 0 : _a8.hiddenInput) ?? `checkbox:${ctx.id}:input`;
};
var getRootEl3 = (ctx) => ctx.getById(getRootId8(ctx));
var getHiddenInputEl3 = (ctx) => ctx.getById(getHiddenInputId3(ctx));
function connect9(service, normalize4) {
  const { send, context, prop, computed, scope } = service;
  const disabled = prop("disabled");
  const readOnly = prop("readOnly");
  const invalid = prop("invalid");
  const focused = !disabled && context.get("focused");
  const focusVisible = !disabled && context.get("focusVisible");
  const checked = computed("checked");
  const indeterminate = computed("indeterminate");
  const dataAttrs = {
    "data-active": dataAttr(context.get("active")),
    "data-focus": dataAttr(focused),
    "data-focus-visible": dataAttr(focusVisible),
    "data-readonly": dataAttr(readOnly),
    "data-hover": dataAttr(context.get("hovered")),
    "data-disabled": dataAttr(disabled),
    "data-state": indeterminate ? "indeterminate" : checked ? "checked" : "unchecked",
    "data-invalid": dataAttr(invalid)
  };
  return {
    checked,
    disabled,
    indeterminate,
    focused,
    checkedState: checked,
    setChecked(checked2) {
      send({ type: "CHECKED.SET", checked: checked2, isTrusted: false });
    },
    toggleChecked() {
      send({ type: "CHECKED.TOGGLE", checked, isTrusted: false });
    },
    getRootProps() {
      return normalize4.label({
        ...parts8.root.attrs,
        ...dataAttrs,
        dir: prop("dir"),
        id: getRootId8(scope),
        htmlFor: getHiddenInputId3(scope),
        onPointerMove() {
          if (disabled) return;
          send({ type: "CONTEXT.SET", context: { hovered: true } });
        },
        onPointerLeave() {
          if (disabled) return;
          send({ type: "CONTEXT.SET", context: { hovered: false } });
        },
        onClick(event) {
          const target = getEventTarget(event);
          if (target === getHiddenInputEl3(scope)) {
            event.stopPropagation();
          }
        }
      });
    },
    getLabelProps() {
      return normalize4.element({
        ...parts8.label.attrs,
        ...dataAttrs,
        dir: prop("dir"),
        id: getLabelId3(scope)
      });
    },
    getControlProps() {
      return normalize4.element({
        ...parts8.control.attrs,
        ...dataAttrs,
        dir: prop("dir"),
        id: getControlId4(scope),
        "aria-hidden": true
      });
    },
    getIndicatorProps() {
      return normalize4.element({
        ...parts8.indicator.attrs,
        ...dataAttrs,
        dir: prop("dir"),
        hidden: !indeterminate && !checked
      });
    },
    getHiddenInputProps() {
      return normalize4.input({
        id: getHiddenInputId3(scope),
        type: "checkbox",
        required: prop("required"),
        defaultChecked: checked,
        disabled,
        "aria-labelledby": getLabelId3(scope),
        "aria-invalid": invalid,
        name: prop("name"),
        form: prop("form"),
        value: prop("value"),
        style: visuallyHiddenStyle,
        onFocus() {
          const focusVisible2 = isFocusVisible();
          send({ type: "CONTEXT.SET", context: { focused: true, focusVisible: focusVisible2 } });
        },
        onBlur() {
          send({ type: "CONTEXT.SET", context: { focused: false, focusVisible: false } });
        },
        onClick(event) {
          if (readOnly) {
            event.preventDefault();
            return;
          }
          const checked2 = event.currentTarget.checked;
          send({ type: "CHECKED.SET", checked: checked2, isTrusted: true });
        }
      });
    }
  };
}
var { not: not2 } = createGuards();
var machine9 = createMachine({
  props({ props: props210 }) {
    return {
      value: "on",
      ...props210,
      defaultChecked: !!props210.defaultChecked
    };
  },
  initialState() {
    return "ready";
  },
  context({ prop, bindable }) {
    return {
      checked: bindable(() => ({
        defaultValue: prop("defaultChecked"),
        value: prop("checked"),
        onChange(checked) {
          var _a8;
          (_a8 = prop("onCheckedChange")) == null ? void 0 : _a8({ checked });
        }
      })),
      fieldsetDisabled: bindable(() => ({ defaultValue: false })),
      focusVisible: bindable(() => ({ defaultValue: false })),
      active: bindable(() => ({ defaultValue: false })),
      focused: bindable(() => ({ defaultValue: false })),
      hovered: bindable(() => ({ defaultValue: false }))
    };
  },
  watch({ track, context, prop, action }) {
    track([() => prop("disabled")], () => {
      action(["removeFocusIfNeeded"]);
    });
    track([() => context.get("checked")], () => {
      action(["syncInputElement"]);
    });
  },
  effects: ["trackFormControlState", "trackPressEvent", "trackFocusVisible"],
  on: {
    "CHECKED.TOGGLE": [
      {
        guard: not2("isTrusted"),
        actions: ["toggleChecked", "dispatchChangeEvent"]
      },
      {
        actions: ["toggleChecked"]
      }
    ],
    "CHECKED.SET": [
      {
        guard: not2("isTrusted"),
        actions: ["setChecked", "dispatchChangeEvent"]
      },
      {
        actions: ["setChecked"]
      }
    ],
    "CONTEXT.SET": {
      actions: ["setContext"]
    }
  },
  computed: {
    indeterminate: ({ context }) => isIndeterminate(context.get("checked")),
    checked: ({ context }) => isChecked(context.get("checked")),
    disabled: ({ context, prop }) => !!prop("disabled") || context.get("fieldsetDisabled")
  },
  states: {
    ready: {}
  },
  implementations: {
    guards: {
      isTrusted: ({ event }) => !!event.isTrusted
    },
    effects: {
      trackPressEvent({ context, computed, scope }) {
        if (computed("disabled")) return;
        return trackPress({
          pointerNode: getRootEl3(scope),
          keyboardNode: getHiddenInputEl3(scope),
          isValidKey: (event) => event.key === " ",
          onPress: () => context.set("active", false),
          onPressStart: () => context.set("active", true),
          onPressEnd: () => context.set("active", false)
        });
      },
      trackFocusVisible({ computed, scope }) {
        var _a8;
        if (computed("disabled")) return;
        return trackFocusVisible({ root: (_a8 = scope.getRootNode) == null ? void 0 : _a8.call(scope) });
      },
      trackFormControlState({ context, scope }) {
        return trackFormControl(getHiddenInputEl3(scope), {
          onFieldsetDisabledChange(disabled) {
            context.set("fieldsetDisabled", disabled);
          },
          onFormReset() {
            context.set("checked", context.initial("checked"));
          }
        });
      }
    },
    actions: {
      setContext({ context, event }) {
        for (const key in event.context) {
          context.set(key, event.context[key]);
        }
      },
      syncInputElement({ context, computed, scope }) {
        const inputEl = getHiddenInputEl3(scope);
        if (!inputEl) return;
        setElementChecked(inputEl, computed("checked"));
        inputEl.indeterminate = isIndeterminate(context.get("checked"));
      },
      removeFocusIfNeeded({ context, prop }) {
        if (prop("disabled") && context.get("focused")) {
          context.set("focused", false);
          context.set("focusVisible", false);
        }
      },
      setChecked({ context, event }) {
        context.set("checked", event.checked);
      },
      toggleChecked({ context, computed }) {
        const checked = isIndeterminate(computed("checked")) ? true : !computed("checked");
        context.set("checked", checked);
      },
      dispatchChangeEvent({ computed, scope }) {
        queueMicrotask(() => {
          const inputEl = getHiddenInputEl3(scope);
          dispatchInputCheckedEvent(inputEl, { checked: computed("checked") });
        });
      }
    }
  }
});
function isIndeterminate(checked) {
  return checked === "indeterminate";
}
function isChecked(checked) {
  return isIndeterminate(checked) ? false : !!checked;
}
var props9 = createProps()([
  "defaultChecked",
  "checked",
  "dir",
  "disabled",
  "form",
  "getRootNode",
  "id",
  "ids",
  "invalid",
  "name",
  "onCheckedChange",
  "readOnly",
  "required",
  "value"
]);
var splitProps10 = createSplitProps(props9);

// node_modules/@ark-ui/react/dist/components/checkbox/checkbox.anatomy.js
var checkboxAnatomy = anatomy8.extendWith("group");

// node_modules/@ark-ui/react/dist/utils/use-controllable-state.js
var import_react100 = __toESM(require_react(), 1);
function useControllableState2(props43) {
  const { value, onChange, defaultValue } = props43;
  const [uncontrolledValue, setUncontrolledValue] = (0, import_react100.useState)(defaultValue);
  const controlled = value !== void 0;
  const currentValue = controlled ? value : uncontrolledValue;
  const setValue = (0, import_react100.useCallback)(
    (value2) => {
      if (controlled) {
        return onChange == null ? void 0 : onChange(value2);
      }
      setUncontrolledValue(value2);
      return onChange == null ? void 0 : onChange(value2);
    },
    [controlled, onChange]
  );
  return [currentValue, setValue];
}

// node_modules/@ark-ui/react/dist/components/checkbox/use-checkbox-group.js
function useCheckboxGroup(props43 = {}) {
  const { defaultValue, value: controlledValue, onValueChange, disabled, readOnly, name, invalid } = props43;
  const interactive = !(disabled || readOnly);
  const onChangeProp = useEvent(onValueChange, { sync: true });
  const [value, setValue] = useControllableState2({
    value: controlledValue,
    defaultValue: defaultValue || [],
    onChange: onChangeProp
  });
  const isChecked2 = (val) => {
    return value.some((v) => String(v) === String(val));
  };
  const toggleValue = (val) => {
    isChecked2(val) ? removeValue(val) : addValue(val);
  };
  const addValue = (val) => {
    if (!interactive) return;
    if (isChecked2(val)) return;
    setValue(value.concat(val));
  };
  const removeValue = (val) => {
    if (!interactive) return;
    setValue(value.filter((v) => String(v) !== String(val)));
  };
  const getItemProps = (props210) => {
    return {
      checked: props210.value != null ? isChecked2(props210.value) : void 0,
      onCheckedChange() {
        if (props210.value != null) {
          toggleValue(props210.value);
        }
      },
      name,
      disabled,
      readOnly,
      invalid
    };
  };
  return {
    isChecked: isChecked2,
    value,
    name,
    disabled: !!disabled,
    readOnly: !!readOnly,
    invalid: !!invalid,
    setValue,
    addValue,
    toggleValue,
    getItemProps
  };
}

// node_modules/@ark-ui/react/dist/components/checkbox/use-checkbox-group-context.js
var [CheckboxGroupContextProvider, useCheckboxGroupContext] = createContext3({
  name: "CheckboxGroupContext",
  hookName: "useCheckboxGroupContext",
  providerName: "<CheckboxGroupProvider />",
  strict: false
});

// node_modules/@ark-ui/react/dist/components/checkbox/checkbox-group.js
var CheckboxGroup = (0, import_react101.forwardRef)((props43, ref) => {
  const [checkboxGroupProps, localProps] = createSplitProps2()(props43, [
    "defaultValue",
    "value",
    "onValueChange",
    "disabled",
    "invalid",
    "readOnly",
    "name"
  ]);
  const checkboxGroup = useCheckboxGroup(checkboxGroupProps);
  return (0, import_jsx_runtime45.jsx)(CheckboxGroupContextProvider, { value: checkboxGroup, children: (0, import_jsx_runtime45.jsx)(ark.div, { ref, role: "group", ...localProps, ...checkboxAnatomy.build().group.attrs }) });
});
CheckboxGroup.displayName = "CheckboxGroup";

// node_modules/@ark-ui/react/dist/components/checkbox/checkbox-hidden-input.js
var import_jsx_runtime46 = __toESM(require_jsx_runtime(), 1);
var import_react103 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/field/use-field-context.js
var [FieldProvider, useFieldContext] = createContext3({
  name: "FieldContext",
  hookName: "useFieldContext",
  providerName: "<FieldProvider />",
  strict: false
});

// node_modules/@ark-ui/react/dist/components/checkbox/checkbox-hidden-input.js
var CheckboxHiddenInput = (0, import_react103.forwardRef)((props43, ref) => {
  const checkbox = useCheckboxContext();
  const mergedProps = mergeProps2(checkbox.getHiddenInputProps(), props43);
  const field = useFieldContext();
  return (0, import_jsx_runtime46.jsx)(ark.input, { "aria-describedby": field == null ? void 0 : field.ariaDescribedby, ...mergedProps, ref });
});
CheckboxHiddenInput.displayName = "CheckboxHiddenInput";

// node_modules/@ark-ui/react/dist/components/checkbox/checkbox-indicator.js
var import_jsx_runtime47 = __toESM(require_jsx_runtime(), 1);
var import_react105 = __toESM(require_react(), 1);
var CheckboxIndicator = (0, import_react105.forwardRef)((props43, ref) => {
  const { indeterminate, ...rest } = props43;
  const checkbox = useCheckboxContext();
  const mergedProps = mergeProps2(checkbox.getIndicatorProps(), rest);
  const isVisible = indeterminate ? checkbox.indeterminate : checkbox.checked;
  return (0, import_jsx_runtime47.jsx)(ark.div, { ...mergedProps, hidden: !isVisible, ref });
});
CheckboxIndicator.displayName = "CheckboxIndicator";

// node_modules/@ark-ui/react/dist/components/checkbox/checkbox-label.js
var import_jsx_runtime48 = __toESM(require_jsx_runtime(), 1);
var import_react107 = __toESM(require_react(), 1);
var CheckboxLabel = (0, import_react107.forwardRef)((props43, ref) => {
  const checkbox = useCheckboxContext();
  const mergedProps = mergeProps2(checkbox.getLabelProps(), props43);
  return (0, import_jsx_runtime48.jsx)(ark.span, { ...mergedProps, ref });
});
CheckboxLabel.displayName = "CheckboxLabel";

// node_modules/@ark-ui/react/dist/components/checkbox/checkbox-root.js
var import_jsx_runtime49 = __toESM(require_jsx_runtime(), 1);
var import_react111 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/checkbox/use-checkbox.js
var import_react109 = __toESM(require_react(), 1);
var useCheckbox = (ownProps = {}) => {
  const checkboxGroup = useCheckboxGroupContext();
  const field = useFieldContext();
  const props43 = (0, import_react109.useMemo)(() => {
    return mergeProps2(ownProps, (checkboxGroup == null ? void 0 : checkboxGroup.getItemProps({ value: ownProps.value })) ?? {});
  }, [ownProps, checkboxGroup]);
  const id = (0, import_react109.useId)();
  const { getRootNode } = useEnvironmentContext();
  const { dir } = useLocaleContext();
  const machineProps = {
    id,
    ids: {
      label: field == null ? void 0 : field.ids.label,
      hiddenInput: field == null ? void 0 : field.ids.control
    },
    dir,
    disabled: field == null ? void 0 : field.disabled,
    readOnly: field == null ? void 0 : field.readOnly,
    invalid: field == null ? void 0 : field.invalid,
    required: field == null ? void 0 : field.required,
    getRootNode,
    ...props43
  };
  const service = useMachine(machine9, machineProps);
  return connect9(service, normalizeProps);
};

// node_modules/@ark-ui/react/dist/components/checkbox/checkbox-root.js
var CheckboxRoot = (0, import_react111.forwardRef)((props43, ref) => {
  const [useCheckboxProps, localProps] = createSplitProps2()(props43, [
    "checked",
    "defaultChecked",
    "disabled",
    "form",
    "id",
    "ids",
    "invalid",
    "name",
    "onCheckedChange",
    "readOnly",
    "required",
    "value"
  ]);
  const checkbox = useCheckbox(useCheckboxProps);
  const mergedProps = mergeProps2(checkbox.getRootProps(), localProps);
  return (0, import_jsx_runtime49.jsx)(CheckboxProvider, { value: checkbox, children: (0, import_jsx_runtime49.jsx)(ark.label, { ...mergedProps, ref }) });
});
CheckboxRoot.displayName = "CheckboxRoot";

// node_modules/@ark-ui/react/dist/components/checkbox/checkbox-root-provider.js
var import_jsx_runtime50 = __toESM(require_jsx_runtime(), 1);
var import_react113 = __toESM(require_react(), 1);
var CheckboxRootProvider = (0, import_react113.forwardRef)((props43, ref) => {
  const [{ value: checkbox }, localProps] = createSplitProps2()(props43, ["value"]);
  const mergedProps = mergeProps2(checkbox.getRootProps(), localProps);
  return (0, import_jsx_runtime50.jsx)(CheckboxProvider, { value: checkbox, children: (0, import_jsx_runtime50.jsx)(ark.label, { ...mergedProps, ref }) });
});
CheckboxRootProvider.displayName = "CheckboxRootProvider";

// node_modules/@ark-ui/react/dist/components/checkbox/checkbox.js
var checkbox_exports = {};
__export(checkbox_exports, {
  Context: () => CheckboxContext,
  Control: () => CheckboxControl,
  Group: () => CheckboxGroup,
  HiddenInput: () => CheckboxHiddenInput,
  Indicator: () => CheckboxIndicator,
  Label: () => CheckboxLabel,
  Root: () => CheckboxRoot,
  RootProvider: () => CheckboxRootProvider
});

// node_modules/@ark-ui/react/dist/components/client-only/client-only.js
var import_jsx_runtime51 = __toESM(require_jsx_runtime(), 1);
var import_react114 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/clipboard/use-clipboard-context.js
var [ClipboardProvider, useClipboardContext] = createContext3({
  name: "ClipboardContext",
  hookName: "useClipboardContext",
  providerName: "<ClipboardProvider />"
});

// node_modules/@ark-ui/react/dist/components/clipboard/clipboard-context.js
var ClipboardContext = (props43) => props43.children(useClipboardContext());

// node_modules/@ark-ui/react/dist/components/clipboard/clipboard-control.js
var import_jsx_runtime52 = __toESM(require_jsx_runtime(), 1);
var import_react116 = __toESM(require_react(), 1);
var ClipboardControl = (0, import_react116.forwardRef)((props43, ref) => {
  const clipboard = useClipboardContext();
  const mergedProps = mergeProps2(clipboard.getControlProps(), props43);
  return (0, import_jsx_runtime52.jsx)(ark.div, { ...mergedProps, ref });
});
ClipboardControl.displayName = "ClipboardControl";

// node_modules/@ark-ui/react/dist/components/clipboard/clipboard-indicator.js
var import_jsx_runtime53 = __toESM(require_jsx_runtime(), 1);
var import_react118 = __toESM(require_react(), 1);
var ClipboardIndicator = (0, import_react118.forwardRef)((props43, ref) => {
  const { children, copied, ...localProps } = props43;
  const clipboard = useClipboardContext();
  const mergedProps = mergeProps2(clipboard.getIndicatorProps({ copied: clipboard.copied }), localProps);
  return (0, import_jsx_runtime53.jsx)(ark.div, { ...mergedProps, ref, children: clipboard.copied ? copied : children });
});
ClipboardIndicator.displayName = "ClipboardIndicator";

// node_modules/@ark-ui/react/dist/components/clipboard/clipboard-input.js
var import_jsx_runtime54 = __toESM(require_jsx_runtime(), 1);
var import_react120 = __toESM(require_react(), 1);
var ClipboardInput = (0, import_react120.forwardRef)((props43, ref) => {
  const clipboard = useClipboardContext();
  const mergedProps = mergeProps2(clipboard.getInputProps(), props43);
  return (0, import_jsx_runtime54.jsx)(ark.input, { ...mergedProps, ref });
});
ClipboardInput.displayName = "ClipboardInput";

// node_modules/@ark-ui/react/dist/components/clipboard/clipboard-label.js
var import_jsx_runtime55 = __toESM(require_jsx_runtime(), 1);
var import_react122 = __toESM(require_react(), 1);
var ClipboardLabel = (0, import_react122.forwardRef)((props43, ref) => {
  const clipboard = useClipboardContext();
  const mergedProps = mergeProps2(clipboard.getLabelProps(), props43);
  return (0, import_jsx_runtime55.jsx)(ark.label, { ...mergedProps, ref });
});
ClipboardLabel.displayName = "ClipboardLabel";

// node_modules/@ark-ui/react/dist/components/clipboard/clipboard-root.js
var import_jsx_runtime56 = __toESM(require_jsx_runtime(), 1);
var import_react126 = __toESM(require_react(), 1);

// node_modules/@zag-js/clipboard/dist/index.mjs
var anatomy9 = createAnatomy("clipboard").parts("root", "control", "trigger", "indicator", "input", "label");
var parts9 = anatomy9.build();
var getRootId9 = (ctx) => {
  var _a8;
  return ((_a8 = ctx.ids) == null ? void 0 : _a8.root) ?? `clip:${ctx.id}`;
};
var getInputId2 = (ctx) => {
  var _a8;
  return ((_a8 = ctx.ids) == null ? void 0 : _a8.input) ?? `clip:${ctx.id}:input`;
};
var getLabelId4 = (ctx) => {
  var _a8;
  return ((_a8 = ctx.ids) == null ? void 0 : _a8.label) ?? `clip:${ctx.id}:label`;
};
var getInputEl = (ctx) => ctx.getById(getInputId2(ctx));
var writeToClipboard = (ctx, value) => copyText(ctx.getDoc(), value);
function createNode(doc, text) {
  const node = doc.createElement("pre");
  Object.assign(node.style, {
    width: "1px",
    height: "1px",
    position: "fixed",
    top: "5px"
  });
  node.textContent = text;
  return node;
}
function copyNode(node) {
  const win = getWindow(node);
  const selection = win.getSelection();
  if (selection == null) {
    return Promise.reject(new Error());
  }
  selection.removeAllRanges();
  const doc = node.ownerDocument;
  const range2 = doc.createRange();
  range2.selectNodeContents(node);
  selection.addRange(range2);
  doc.execCommand("copy");
  selection.removeAllRanges();
  return Promise.resolve();
}
function copyText(doc, text) {
  var _a8;
  const win = doc.defaultView || window;
  if (((_a8 = win.navigator.clipboard) == null ? void 0 : _a8.writeText) !== void 0) {
    return win.navigator.clipboard.writeText(text);
  }
  if (!doc.body) {
    return Promise.reject(new Error());
  }
  const node = createNode(doc, text);
  doc.body.appendChild(node);
  copyNode(node);
  doc.body.removeChild(node);
  return Promise.resolve();
}
function connect10(service, normalize4) {
  const { state: state2, send, context, scope } = service;
  const copied = state2.matches("copied");
  return {
    copied,
    value: context.get("value"),
    setValue(value) {
      send({ type: "VALUE.SET", value });
    },
    copy() {
      send({ type: "COPY" });
    },
    getRootProps() {
      return normalize4.element({
        ...parts9.root.attrs,
        "data-copied": dataAttr(copied),
        id: getRootId9(scope)
      });
    },
    getLabelProps() {
      return normalize4.label({
        ...parts9.label.attrs,
        htmlFor: getInputId2(scope),
        "data-copied": dataAttr(copied),
        id: getLabelId4(scope)
      });
    },
    getControlProps() {
      return normalize4.element({
        ...parts9.control.attrs,
        "data-copied": dataAttr(copied)
      });
    },
    getInputProps() {
      return normalize4.input({
        ...parts9.input.attrs,
        defaultValue: context.get("value"),
        "data-copied": dataAttr(copied),
        readOnly: true,
        "data-readonly": "true",
        id: getInputId2(scope),
        onFocus(event) {
          event.currentTarget.select();
        },
        onCopy() {
          send({ type: "INPUT.COPY" });
        }
      });
    },
    getTriggerProps() {
      return normalize4.button({
        ...parts9.trigger.attrs,
        type: "button",
        "aria-label": copied ? "Copied to clipboard" : "Copy to clipboard",
        "data-copied": dataAttr(copied),
        onClick() {
          send({ type: "COPY" });
        }
      });
    },
    getIndicatorProps(props210) {
      return normalize4.element({
        ...parts9.indicator.attrs,
        hidden: props210.copied !== copied
      });
    }
  };
}
var machine10 = createMachine({
  props({ props: props210 }) {
    return {
      timeout: 3e3,
      defaultValue: "",
      ...props210
    };
  },
  initialState() {
    return "idle";
  },
  context({ prop, bindable }) {
    return {
      value: bindable(() => ({
        defaultValue: prop("defaultValue"),
        value: prop("value"),
        onChange(value) {
          var _a8;
          (_a8 = prop("onValueChange")) == null ? void 0 : _a8({ value });
        }
      }))
    };
  },
  watch({ track, context, action }) {
    track([() => context.get("value")], () => {
      action(["syncInputElement"]);
    });
  },
  on: {
    "VALUE.SET": {
      actions: ["setValue"]
    },
    COPY: {
      target: "copied",
      actions: ["copyToClipboard", "invokeOnCopy"]
    }
  },
  states: {
    idle: {
      on: {
        "INPUT.COPY": {
          target: "copied",
          actions: ["invokeOnCopy"]
        }
      }
    },
    copied: {
      effects: ["waitForTimeout"],
      on: {
        "COPY.DONE": {
          target: "idle"
        },
        COPY: {
          target: "copied",
          actions: ["copyToClipboard", "invokeOnCopy"]
        },
        "INPUT.COPY": {
          actions: ["invokeOnCopy"]
        }
      }
    }
  },
  implementations: {
    effects: {
      waitForTimeout({ prop, send }) {
        return setRafTimeout(() => {
          send({ type: "COPY.DONE" });
        }, prop("timeout"));
      }
    },
    actions: {
      setValue({ context, event }) {
        context.set("value", event.value);
      },
      copyToClipboard({ context, scope }) {
        writeToClipboard(scope, context.get("value"));
      },
      invokeOnCopy({ prop }) {
        var _a8;
        (_a8 = prop("onStatusChange")) == null ? void 0 : _a8({ copied: true });
      },
      syncInputElement({ context, scope }) {
        const inputEl = getInputEl(scope);
        if (!inputEl) return;
        setElementValue(inputEl, context.get("value"));
      }
    }
  }
});
var props10 = createProps()([
  "getRootNode",
  "id",
  "ids",
  "value",
  "defaultValue",
  "timeout",
  "onStatusChange",
  "onValueChange"
]);
var contextProps = createSplitProps(props10);
var indicatorProps2 = createProps()(["copied"]);
var splitIndicatorProps2 = createSplitProps(indicatorProps2);

// node_modules/@ark-ui/react/dist/components/clipboard/use-clipboard.js
var import_react124 = __toESM(require_react(), 1);
var useClipboard = (props43) => {
  const id = (0, import_react124.useId)();
  const { getRootNode } = useEnvironmentContext();
  const machineProps = {
    id,
    getRootNode,
    ...props43
  };
  const service = useMachine(machine10, machineProps);
  return connect10(service, normalizeProps);
};

// node_modules/@ark-ui/react/dist/components/clipboard/clipboard-root.js
var ClipboardRoot = (0, import_react126.forwardRef)((props43, ref) => {
  const [useClipboardProps, localProps] = createSplitProps2()(props43, [
    "defaultValue",
    "id",
    "ids",
    "onStatusChange",
    "onValueChange",
    "timeout",
    "value"
  ]);
  const clipboard = useClipboard(useClipboardProps);
  const mergedProps = mergeProps2(clipboard.getRootProps(), localProps);
  return (0, import_jsx_runtime56.jsx)(ClipboardProvider, { value: clipboard, children: (0, import_jsx_runtime56.jsx)(ark.div, { ref, ...mergedProps }) });
});
ClipboardRoot.displayName = "ClipboardRoot";

// node_modules/@ark-ui/react/dist/components/clipboard/clipboard-root-provider.js
var import_jsx_runtime57 = __toESM(require_jsx_runtime(), 1);
var import_react128 = __toESM(require_react(), 1);
var ClipboardRootProvider = (0, import_react128.forwardRef)((props43, ref) => {
  const [{ value: clipboard }, localProps] = createSplitProps2()(props43, ["value"]);
  const mergedProps = mergeProps2(clipboard.getRootProps(), localProps);
  return (0, import_jsx_runtime57.jsx)(ClipboardProvider, { value: clipboard, children: (0, import_jsx_runtime57.jsx)(ark.div, { ref, ...mergedProps }) });
});
ClipboardRootProvider.displayName = "ClipboardRootProvider";

// node_modules/@ark-ui/react/dist/components/clipboard/clipboard-trigger.js
var import_jsx_runtime58 = __toESM(require_jsx_runtime(), 1);
var import_react130 = __toESM(require_react(), 1);
var ClipboardTrigger = (0, import_react130.forwardRef)((props43, ref) => {
  const clipboard = useClipboardContext();
  const mergedProps = mergeProps2(clipboard.getTriggerProps(), props43);
  return (0, import_jsx_runtime58.jsx)(ark.button, { ...mergedProps, ref });
});
ClipboardTrigger.displayName = "ClipboardTrigger";

// node_modules/@ark-ui/react/dist/components/clipboard/clipboard-value-text.js
var import_jsx_runtime59 = __toESM(require_jsx_runtime(), 1);
var import_react131 = __toESM(require_react(), 1);
var ClipboardValueText = (0, import_react131.forwardRef)((props43, ref) => {
  const clipboard = useClipboardContext();
  return (0, import_jsx_runtime59.jsx)(ark.span, { ...props43, ref, children: props43.children || clipboard.value });
});
ClipboardValueText.displayName = "ClipboardValueText";

// node_modules/@ark-ui/react/dist/components/clipboard/clipboard.js
var clipboard_exports = {};
__export(clipboard_exports, {
  Context: () => ClipboardContext,
  Control: () => ClipboardControl,
  Indicator: () => ClipboardIndicator,
  Input: () => ClipboardInput,
  Label: () => ClipboardLabel,
  Root: () => ClipboardRoot,
  RootProvider: () => ClipboardRootProvider,
  Trigger: () => ClipboardTrigger,
  ValueText: () => ClipboardValueText
});

// node_modules/@ark-ui/react/dist/components/collapsible/collapsible-context.js
var CollapsibleContext = (props43) => props43.children(useCollapsibleContext());

// node_modules/@ark-ui/react/dist/components/collapsible/collapsible-indicator.js
var import_jsx_runtime60 = __toESM(require_jsx_runtime(), 1);
var import_react133 = __toESM(require_react(), 1);
var CollapsibleIndicator = (0, import_react133.forwardRef)((props43, ref) => {
  const collapsible = useCollapsibleContext();
  const mergedProps = mergeProps2(collapsible.getIndicatorProps(), props43);
  return (0, import_jsx_runtime60.jsx)(ark.div, { ...mergedProps, ref });
});
CollapsibleIndicator.displayName = "CollapsibleIndicator";

// node_modules/@ark-ui/react/dist/components/collapsible/collapsible-root-provider.js
var import_jsx_runtime61 = __toESM(require_jsx_runtime(), 1);
var import_react135 = __toESM(require_react(), 1);
var CollapsibleRootProvider = (0, import_react135.forwardRef)((props43, ref) => {
  const [{ value: collapsible }, localProps] = createSplitProps2()(props43, ["value"]);
  const mergedProps = mergeProps2(collapsible.getRootProps(), localProps);
  return (0, import_jsx_runtime61.jsx)(CollapsibleProvider, { value: collapsible, children: (0, import_jsx_runtime61.jsx)(ark.div, { ...mergedProps, ref }) });
});
CollapsibleRootProvider.displayName = "CollapsibleRootProvider";

// node_modules/@ark-ui/react/dist/components/collapsible/collapsible-trigger.js
var import_jsx_runtime62 = __toESM(require_jsx_runtime(), 1);
var import_react137 = __toESM(require_react(), 1);
var CollapsibleTrigger = (0, import_react137.forwardRef)((props43, ref) => {
  const collapsible = useCollapsibleContext();
  const mergedProps = mergeProps2(collapsible.getTriggerProps(), props43);
  return (0, import_jsx_runtime62.jsx)(ark.button, { ...mergedProps, ref });
});
CollapsibleTrigger.displayName = "CollapsibleTrigger";

// node_modules/@ark-ui/react/dist/components/collapsible/collapsible.js
var collapsible_exports = {};
__export(collapsible_exports, {
  Content: () => CollapsibleContent,
  Context: () => CollapsibleContext,
  Indicator: () => CollapsibleIndicator,
  Root: () => CollapsibleRoot,
  RootProvider: () => CollapsibleRootProvider,
  Trigger: () => CollapsibleTrigger
});

// node_modules/@ark-ui/react/dist/components/color-picker/color-picker-area.js
var import_jsx_runtime63 = __toESM(require_jsx_runtime(), 1);
var import_react139 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/color-picker/use-color-picker-area-props-context.js
var [ColorPickerAreaPropsProvider, useColorPickerAreaPropsContext] = createContext3({
  name: "ColorPickerAreaContext",
  hookName: "useColorPickerAreaContext",
  providerName: "<ColorPickerAreaProvider />"
});

// node_modules/@ark-ui/react/dist/components/color-picker/use-color-picker-context.js
var [ColorPickerProvider, useColorPickerContext] = createContext3({
  name: "ColorPickerContext",
  hookName: "useColorPickerContext",
  providerName: "<ColorPickerProvider />"
});

// node_modules/@ark-ui/react/dist/components/color-picker/color-picker-area.js
var ColorPickerArea = (0, import_react139.forwardRef)((props43, ref) => {
  const [areaProps2, localProps] = createSplitProps2()(props43, ["xChannel", "yChannel"]);
  const colorPicker = useColorPickerContext();
  const mergedProps = mergeProps2(colorPicker.getAreaProps(areaProps2), localProps);
  return (0, import_jsx_runtime63.jsx)(ColorPickerAreaPropsProvider, { value: areaProps2, children: (0, import_jsx_runtime63.jsx)(ark.div, { ...mergedProps, ref }) });
});
ColorPickerArea.displayName = "ColorPickerArea";

// node_modules/@ark-ui/react/dist/components/color-picker/color-picker-area-background.js
var import_jsx_runtime64 = __toESM(require_jsx_runtime(), 1);
var import_react141 = __toESM(require_react(), 1);
var ColorPickerAreaBackground = (0, import_react141.forwardRef)((props43, ref) => {
  const colorPicker = useColorPickerContext();
  const areaProps2 = useColorPickerAreaPropsContext();
  const mergedProps = mergeProps2(colorPicker.getAreaBackgroundProps(areaProps2), props43);
  return (0, import_jsx_runtime64.jsx)(ark.div, { ...mergedProps, ref });
});
ColorPickerAreaBackground.displayName = "ColorPickerAreaBackground";

// node_modules/@ark-ui/react/dist/components/color-picker/color-picker-area-thumb.js
var import_jsx_runtime65 = __toESM(require_jsx_runtime(), 1);
var import_react143 = __toESM(require_react(), 1);
var ColorPickerAreaThumb = (0, import_react143.forwardRef)((props43, ref) => {
  const colorPicker = useColorPickerContext();
  const areaProps2 = useColorPickerAreaPropsContext();
  const mergedProps = mergeProps2(colorPicker.getAreaThumbProps(areaProps2), props43);
  return (0, import_jsx_runtime65.jsx)(ark.div, { ...mergedProps, ref });
});
ColorPickerAreaThumb.displayName = "ColorPickerAreaThumb";

// node_modules/@ark-ui/react/dist/components/color-picker/color-picker-channel-input.js
var import_jsx_runtime66 = __toESM(require_jsx_runtime(), 1);
var import_react145 = __toESM(require_react(), 1);
var ColorPickerChannelInput = (0, import_react145.forwardRef)((props43, ref) => {
  const [channelProps2, localProps] = createSplitProps2()(props43, ["channel", "orientation"]);
  const colorPicker = useColorPickerContext();
  const mergedProps = mergeProps2(colorPicker.getChannelInputProps(channelProps2), localProps);
  return (0, import_jsx_runtime66.jsx)(ark.input, { ...mergedProps, ref });
});
ColorPickerChannelInput.displayName = "ColorPickerChannelInput";

// node_modules/@ark-ui/react/dist/components/color-picker/color-picker-channel-slider.js
var import_jsx_runtime67 = __toESM(require_jsx_runtime(), 1);
var import_react147 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/color-picker/use-color-picker-channel-props-context.js
var [ColorPickerChannelPropsProvider, useColorPickerChannelPropsContext] = createContext3({
  name: "ColorPickerChannelSliderContext",
  hookName: "useColorPickerChannelSliderContext",
  providerName: "<ColorPickerChannelSliderProvider />"
});

// node_modules/@ark-ui/react/dist/components/color-picker/use-color-picker-format-context.js
var [ColorPickerFormatPropsProvider, useColorPickerFormatPropsContext] = createContext3({
  name: "ColorPickerFormatContext",
  hookName: "useColorPickerFormatPropsContext",
  providerName: "<ColorPickerFormatPropsProvider />",
  strict: false
});

// node_modules/@ark-ui/react/dist/components/color-picker/color-picker-channel-slider.js
var ColorPickerChannelSlider = (0, import_react147.forwardRef)((props43, ref) => {
  const [channelProps2, localProps] = createSplitProps2()(props43, ["channel", "orientation"]);
  const colorPicker = useColorPickerContext();
  const formatProps = useColorPickerFormatPropsContext();
  const channelSliderProps = { ...channelProps2, ...formatProps };
  const mergedProps = mergeProps2(colorPicker.getChannelSliderProps(channelSliderProps), localProps);
  return (0, import_jsx_runtime67.jsx)(ColorPickerChannelPropsProvider, { value: channelProps2, children: (0, import_jsx_runtime67.jsx)(ark.div, { ...mergedProps, ref }) });
});
ColorPickerChannelSlider.displayName = "ColorPickerChannelSlider";

// node_modules/@ark-ui/react/dist/components/color-picker/color-picker-channel-slider-label.js
var import_jsx_runtime68 = __toESM(require_jsx_runtime(), 1);
var import_react149 = __toESM(require_react(), 1);
var ColorPickerChannelSliderLabel = (0, import_react149.forwardRef)(
  (props43, ref) => {
    const colorPicker = useColorPickerContext();
    const channelProps2 = useColorPickerChannelPropsContext();
    const mergedProps = mergeProps2(colorPicker.getChannelSliderLabelProps(channelProps2), props43);
    return (0, import_jsx_runtime68.jsx)(ark.label, { ...mergedProps, ref });
  }
);
ColorPickerChannelSliderLabel.displayName = "ColorPickerChannelSliderLabel";

// node_modules/@ark-ui/react/dist/components/color-picker/color-picker-channel-slider-thumb.js
var import_jsx_runtime69 = __toESM(require_jsx_runtime(), 1);
var import_react151 = __toESM(require_react(), 1);
var ColorPickerChannelSliderThumb = (0, import_react151.forwardRef)(
  (props43, ref) => {
    const colorPicker = useColorPickerContext();
    const channelProps2 = useColorPickerChannelPropsContext();
    const formatProps = useColorPickerFormatPropsContext();
    const channelSliderProps = { ...channelProps2, ...formatProps };
    const mergedProps = mergeProps2(colorPicker.getChannelSliderThumbProps(channelSliderProps), props43);
    return (0, import_jsx_runtime69.jsx)(ark.div, { ...mergedProps, ref });
  }
);
ColorPickerChannelSliderThumb.displayName = "ColorPickerChannelSliderThumb";

// node_modules/@ark-ui/react/dist/components/color-picker/color-picker-channel-slider-track.js
var import_jsx_runtime70 = __toESM(require_jsx_runtime(), 1);
var import_react153 = __toESM(require_react(), 1);
var ColorPickerChannelSliderTrack = (0, import_react153.forwardRef)(
  (props43, ref) => {
    const colorPicker = useColorPickerContext();
    const channelProps2 = useColorPickerChannelPropsContext();
    const formatProps = useColorPickerFormatPropsContext();
    const channelSliderProps = { ...channelProps2, ...formatProps };
    const mergedProps = mergeProps2(colorPicker.getChannelSliderTrackProps(channelSliderProps), props43);
    return (0, import_jsx_runtime70.jsx)(ark.div, { ...mergedProps, ref });
  }
);
ColorPickerChannelSliderTrack.displayName = "ColorPickerChannelSliderTrack";

// node_modules/@ark-ui/react/dist/components/color-picker/color-picker-channel-slider-value-text.js
var import_jsx_runtime71 = __toESM(require_jsx_runtime(), 1);
var import_react155 = __toESM(require_react(), 1);
var ColorPickerChannelSliderValueText = (0, import_react155.forwardRef)(
  (props43, ref) => {
    const { locale } = useLocaleContext();
    const colorPicker = useColorPickerContext();
    const channelProps2 = useColorPickerChannelPropsContext();
    const mergedProps = mergeProps2(colorPicker.getChannelSliderValueTextProps(channelProps2), props43);
    return (0, import_jsx_runtime71.jsx)(ark.span, { ...mergedProps, ref, children: props43.children || colorPicker.getChannelValueText(channelProps2.channel, locale) });
  }
);
ColorPickerChannelSliderValueText.displayName = "ColorPickerChannelSliderValueText";

// node_modules/@ark-ui/react/dist/components/color-picker/color-picker-content.js
var import_jsx_runtime72 = __toESM(require_jsx_runtime(), 1);
var import_react157 = __toESM(require_react(), 1);
var ColorPickerContent = (0, import_react157.forwardRef)((props43, ref) => {
  const colorPicker = useColorPickerContext();
  const presence = usePresenceContext();
  const mergedProps = mergeProps2(colorPicker.getContentProps(), presence.getPresenceProps(), props43);
  if (presence.unmounted) {
    return null;
  }
  return (0, import_jsx_runtime72.jsx)(ark.div, { ...mergedProps, ref: composeRefs(presence.ref, ref) });
});
ColorPickerContent.displayName = "ColorPickerContent";

// node_modules/@ark-ui/react/dist/components/color-picker/color-picker-context.js
var ColorPickerContext = (props43) => props43.children(useColorPickerContext());

// node_modules/@ark-ui/react/dist/components/color-picker/color-picker-control.js
var import_jsx_runtime73 = __toESM(require_jsx_runtime(), 1);
var import_react159 = __toESM(require_react(), 1);
var ColorPickerControl = (0, import_react159.forwardRef)((props43, ref) => {
  const colorPicker = useColorPickerContext();
  const mergedProps = mergeProps2(colorPicker.getControlProps(), props43);
  return (0, import_jsx_runtime73.jsx)(ark.div, { ...mergedProps, ref });
});
ColorPickerControl.displayName = "ColorPickerControl";

// node_modules/@ark-ui/react/dist/components/color-picker/color-picker-eye-dropper-trigger.js
var import_jsx_runtime74 = __toESM(require_jsx_runtime(), 1);
var import_react161 = __toESM(require_react(), 1);
var ColorPickerEyeDropperTrigger = (0, import_react161.forwardRef)(
  (props43, ref) => {
    const colorPicker = useColorPickerContext();
    const mergedProps = mergeProps2(colorPicker.getEyeDropperTriggerProps(), props43);
    return (0, import_jsx_runtime74.jsx)(ark.button, { ...mergedProps, ref });
  }
);
ColorPickerEyeDropperTrigger.displayName = "ColorPickerEyeDropperTrigger";

// node_modules/@ark-ui/react/dist/components/color-picker/color-picker-format-select.js
var import_jsx_runtime75 = __toESM(require_jsx_runtime(), 1);
var import_react163 = __toESM(require_react(), 1);
var ColorPickerFormatSelect = (0, import_react163.forwardRef)((props43, ref) => {
  const colorPicker = useColorPickerContext();
  const mergedProps = mergeProps2(colorPicker.getFormatSelectProps(), props43);
  return (0, import_jsx_runtime75.jsx)(ark.select, { ...mergedProps, ref, children: ["rgba", "hsla", "hsba"].map((format) => (0, import_jsx_runtime75.jsx)(ark.option, { value: format, children: format }, format)) });
});
ColorPickerFormatSelect.displayName = "ColorPickerFormatSelect";

// node_modules/@ark-ui/react/dist/components/color-picker/color-picker-format-trigger.js
var import_jsx_runtime76 = __toESM(require_jsx_runtime(), 1);
var import_react165 = __toESM(require_react(), 1);
var ColorPickerFormatTrigger = (0, import_react165.forwardRef)((props43, ref) => {
  const colorPicker = useColorPickerContext();
  const mergedProps = mergeProps2(colorPicker.getFormatTriggerProps(), props43);
  return (0, import_jsx_runtime76.jsx)(ark.button, { ...mergedProps, ref });
});
ColorPickerFormatTrigger.displayName = "ColorPickerFormatTrigger";

// node_modules/@ark-ui/react/dist/components/color-picker/color-picker-hidden-input.js
var import_jsx_runtime77 = __toESM(require_jsx_runtime(), 1);
var import_react167 = __toESM(require_react(), 1);
var ColorPickerHiddenInput = (0, import_react167.forwardRef)((props43, ref) => {
  const colorPicker = useColorPickerContext();
  const mergedProps = mergeProps2(colorPicker.getHiddenInputProps(), props43);
  const field = useFieldContext();
  return (0, import_jsx_runtime77.jsx)(ark.input, { "aria-describedby": field == null ? void 0 : field.ariaDescribedby, ...mergedProps, ref });
});
ColorPickerHiddenInput.displayName = "ColorPickerHiddenInput";

// node_modules/@ark-ui/react/dist/components/color-picker/color-picker-label.js
var import_jsx_runtime78 = __toESM(require_jsx_runtime(), 1);
var import_react169 = __toESM(require_react(), 1);
var ColorPickerLabel = (0, import_react169.forwardRef)((props43, ref) => {
  const colorPicker = useColorPickerContext();
  const mergedProps = mergeProps2(colorPicker.getLabelProps(), props43);
  return (0, import_jsx_runtime78.jsx)(ark.label, { ...mergedProps, ref });
});
ColorPickerLabel.displayName = "ColorPickerLabel";

// node_modules/@ark-ui/react/dist/components/color-picker/color-picker-positioner.js
var import_jsx_runtime79 = __toESM(require_jsx_runtime(), 1);
var import_react171 = __toESM(require_react(), 1);
var ColorPickerPositioner = (0, import_react171.forwardRef)((props43, ref) => {
  const colorPicker = useColorPickerContext();
  const mergedProps = mergeProps2(colorPicker.getPositionerProps(), props43);
  const presence = usePresenceContext();
  if (presence.unmounted) {
    return null;
  }
  return (0, import_jsx_runtime79.jsx)(ark.div, { ...mergedProps, ref });
});
ColorPickerPositioner.displayName = "ColorPickerPositioner";

// node_modules/@ark-ui/react/dist/components/color-picker/color-picker-root.js
var import_jsx_runtime80 = __toESM(require_jsx_runtime(), 1);
var import_react175 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/color-picker/use-color-picker.js
var import_react173 = __toESM(require_react(), 1);
var useColorPicker = (props43) => {
  const id = (0, import_react173.useId)();
  const { getRootNode } = useEnvironmentContext();
  const { dir } = useLocaleContext();
  const field = useFieldContext();
  const machineProps = {
    id,
    ids: {
      label: field == null ? void 0 : field.ids.label,
      input: field == null ? void 0 : field.ids.control
    },
    dir,
    disabled: field == null ? void 0 : field.disabled,
    invalid: field == null ? void 0 : field.invalid,
    readOnly: field == null ? void 0 : field.readOnly,
    required: field == null ? void 0 : field.required,
    getRootNode,
    ...props43
  };
  const service = useMachine(machine3, machineProps);
  return connect3(service, normalizeProps);
};

// node_modules/@ark-ui/react/dist/components/color-picker/color-picker-root.js
var ColorPickerRoot = (0, import_react175.forwardRef)((props43, ref) => {
  const [presenceProps, colorPickerProps] = splitPresenceProps(props43);
  const [useColorPickerProps, localProps] = createSplitProps2()(colorPickerProps, [
    "closeOnSelect",
    "defaultOpen",
    "defaultValue",
    "defaultFormat",
    "disabled",
    "format",
    "id",
    "ids",
    "initialFocusEl",
    "invalid",
    "name",
    "name",
    "onFocusOutside",
    "onFormatChange",
    "onInteractOutside",
    "onOpenChange",
    "onPointerDownOutside",
    "onValueChange",
    "onValueChangeEnd",
    "open",
    "openAutoFocus",
    "positioning",
    "readOnly",
    "required",
    "value"
  ]);
  const colorPicker = useColorPicker(useColorPickerProps);
  const presence = usePresence(mergeProps2({ present: colorPicker.open }, presenceProps));
  const mergedProps = mergeProps2(colorPicker.getRootProps(), localProps);
  return (0, import_jsx_runtime80.jsx)(ColorPickerProvider, { value: colorPicker, children: (0, import_jsx_runtime80.jsx)(PresenceProvider, { value: presence, children: (0, import_jsx_runtime80.jsx)(ark.div, { ...mergedProps, ref }) }) });
});
ColorPickerRoot.displayName = "ColorPickerRoot";

// node_modules/@ark-ui/react/dist/components/color-picker/color-picker-root-provider.js
var import_jsx_runtime81 = __toESM(require_jsx_runtime(), 1);
var import_react177 = __toESM(require_react(), 1);
var ColorPickerRootProvider = (0, import_react177.forwardRef)((props43, ref) => {
  const [presenceProps, colorPickerProps] = splitPresenceProps(props43);
  const [{ value: colorPicker }, localProps] = createSplitProps2()(colorPickerProps, ["value"]);
  const presence = usePresence(mergeProps2({ present: colorPicker.open }, presenceProps));
  const mergedProps = mergeProps2(colorPicker.getRootProps(), localProps);
  return (0, import_jsx_runtime81.jsx)(ColorPickerProvider, { value: colorPicker, children: (0, import_jsx_runtime81.jsx)(PresenceProvider, { value: presence, children: (0, import_jsx_runtime81.jsx)(ark.div, { ...mergedProps, ref }) }) });
});
ColorPickerRootProvider.displayName = "ColorPickerRootProvider";

// node_modules/@ark-ui/react/dist/components/color-picker/color-picker-swatch.js
var import_jsx_runtime82 = __toESM(require_jsx_runtime(), 1);
var import_react179 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/color-picker/use-color-picker-swatch-props-context.js
var [ColorPickerSwatchPropsProvider, useColorPickerSwatchPropsContext] = createContext3({
  name: "ColorPickerSwatchContext",
  hookName: "useColorPickerSwatchContext",
  providerName: "<ColorPickerSwatchProvider />"
});

// node_modules/@ark-ui/react/dist/components/color-picker/color-picker-swatch.js
var ColorPickerSwatch = (0, import_react179.forwardRef)((props43, ref) => {
  const [swatwchProps, localProps] = createSplitProps2()(props43, ["respectAlpha", "value"]);
  const colorPicker = useColorPickerContext();
  const mergedProps = mergeProps2(colorPicker.getSwatchProps(swatwchProps), localProps);
  return (0, import_jsx_runtime82.jsx)(ColorPickerSwatchPropsProvider, { value: swatwchProps, children: (0, import_jsx_runtime82.jsx)(ark.div, { ...mergedProps, ref }) });
});
ColorPickerSwatch.displayName = "ColorPickerSwatch";

// node_modules/@ark-ui/react/dist/components/color-picker/color-picker-swatch-group.js
var import_jsx_runtime83 = __toESM(require_jsx_runtime(), 1);
var import_react181 = __toESM(require_react(), 1);
var ColorPickerSwatchGroup = (0, import_react181.forwardRef)((props43, ref) => {
  const colorPicker = useColorPickerContext();
  const mergedProps = mergeProps2(colorPicker.getSwatchGroupProps(), props43);
  return (0, import_jsx_runtime83.jsx)(ark.div, { ...mergedProps, ref });
});
ColorPickerSwatchGroup.displayName = "ColorPickerSwatchGroup";

// node_modules/@ark-ui/react/dist/components/color-picker/color-picker-swatch-indicator.js
var import_jsx_runtime84 = __toESM(require_jsx_runtime(), 1);
var import_react183 = __toESM(require_react(), 1);
var ColorPickerSwatchIndicator = (0, import_react183.forwardRef)((props43, ref) => {
  const colorPicker = useColorPickerContext();
  const swatchProps2 = useColorPickerSwatchPropsContext();
  const mergedProps = mergeProps2(colorPicker.getSwatchIndicatorProps(swatchProps2), props43);
  return (0, import_jsx_runtime84.jsx)(ark.div, { ...mergedProps, ref });
});
ColorPickerSwatchIndicator.displayName = "ColorPickerSwatchIndicator";

// node_modules/@ark-ui/react/dist/components/color-picker/color-picker-swatch-trigger.js
var import_jsx_runtime85 = __toESM(require_jsx_runtime(), 1);
var import_react185 = __toESM(require_react(), 1);
var ColorPickerSwatchTrigger = (0, import_react185.forwardRef)((props43, ref) => {
  const [triggerProps2, localProps] = createSplitProps2()(props43, ["value", "disabled"]);
  const colorPicker = useColorPickerContext();
  const mergedProps = mergeProps2(colorPicker.getSwatchTriggerProps(triggerProps2), localProps);
  return (0, import_jsx_runtime85.jsx)(ark.button, { ...mergedProps, ref });
});
ColorPickerSwatchTrigger.displayName = "ColorPickerSwatchTrigger";

// node_modules/@ark-ui/react/dist/components/color-picker/color-picker-transparency-grid.js
var import_jsx_runtime86 = __toESM(require_jsx_runtime(), 1);
var import_react187 = __toESM(require_react(), 1);
var ColorPickerTransparencyGrid = (0, import_react187.forwardRef)(
  (props43, ref) => {
    const [gridProps, localProps] = createSplitProps2()(props43, ["size"]);
    const colorPicker = useColorPickerContext();
    const mergedProps = mergeProps2(colorPicker.getTransparencyGridProps(gridProps), localProps);
    return (0, import_jsx_runtime86.jsx)(ark.div, { ...mergedProps, ref });
  }
);
ColorPickerTransparencyGrid.displayName = "ColorPickerTransparencyGrid";

// node_modules/@ark-ui/react/dist/components/color-picker/color-picker-trigger.js
var import_jsx_runtime87 = __toESM(require_jsx_runtime(), 1);
var import_react189 = __toESM(require_react(), 1);
var ColorPickerTrigger = (0, import_react189.forwardRef)((props43, ref) => {
  const colorPicker = useColorPickerContext();
  const mergedProps = mergeProps2(colorPicker.getTriggerProps(), props43);
  return (0, import_jsx_runtime87.jsx)(ark.button, { ...mergedProps, ref });
});
ColorPickerTrigger.displayName = "ColorPickerTrigger";

// node_modules/@ark-ui/react/dist/components/color-picker/color-picker-value-swatch.js
var import_jsx_runtime88 = __toESM(require_jsx_runtime(), 1);
var import_react191 = __toESM(require_react(), 1);
var ColorPickerValueSwatch = (0, import_react191.forwardRef)((props43, ref) => {
  const [{ respectAlpha }, localProps] = createSplitProps2()(props43, ["respectAlpha"]);
  const colorPicker = useColorPickerContext();
  const swatchProps2 = {
    respectAlpha,
    value: colorPicker.valueAsString
  };
  const mergedProps = mergeProps2(colorPicker.getSwatchProps(swatchProps2), localProps);
  return (0, import_jsx_runtime88.jsx)(ColorPickerSwatchPropsProvider, { value: swatchProps2, children: (0, import_jsx_runtime88.jsx)(ark.div, { ...mergedProps, ref }) });
});
ColorPickerValueSwatch.displayName = "ColorPickerValueSwatch";

// node_modules/@ark-ui/react/dist/components/color-picker/color-picker-value-text.js
var import_jsx_runtime89 = __toESM(require_jsx_runtime(), 1);
var import_react193 = __toESM(require_react(), 1);
var ColorPickerValueText = (0, import_react193.forwardRef)((props43, ref) => {
  const { children, format, ...localprops } = props43;
  const colorPicker = useColorPickerContext();
  const mergedProps = mergeProps2(colorPicker.getValueTextProps(), localprops);
  const valueAsString = format ? colorPicker.value.toString(format) : colorPicker.valueAsString;
  return (0, import_jsx_runtime89.jsx)(ark.span, { ...mergedProps, ref, children: props43.children || valueAsString });
});
ColorPickerValueText.displayName = "ColorPickerValueText";

// node_modules/@ark-ui/react/dist/components/color-picker/color-picker-view.js
var import_jsx_runtime90 = __toESM(require_jsx_runtime(), 1);
var import_react194 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/color-picker/color-picker.anatomy.js
var colorPickerAnatomy = anatomy2.extendWith("view");

// node_modules/@ark-ui/react/dist/components/color-picker/color-picker-view.js
var ColorPickerView = (0, import_react194.forwardRef)((props43, ref) => {
  const colorPicker = useColorPickerContext();
  const [formatProps, restProps] = createSplitProps2()(props43, ["format"]);
  if (colorPicker.format !== formatProps.format) {
    return null;
  }
  return (0, import_jsx_runtime90.jsx)(ColorPickerFormatPropsProvider, { value: formatProps, children: (0, import_jsx_runtime90.jsx)(ark.div, { ref, "data-format": props43.format, ...colorPickerAnatomy.build().view.attrs, ...restProps }) });
});
ColorPickerView.displayName = "ColorPickerView";

// node_modules/@ark-ui/react/dist/components/color-picker/color-picker.js
var color_picker_exports = {};
__export(color_picker_exports, {
  Area: () => ColorPickerArea,
  AreaBackground: () => ColorPickerAreaBackground,
  AreaThumb: () => ColorPickerAreaThumb,
  ChannelInput: () => ColorPickerChannelInput,
  ChannelSlider: () => ColorPickerChannelSlider,
  ChannelSliderLabel: () => ColorPickerChannelSliderLabel,
  ChannelSliderThumb: () => ColorPickerChannelSliderThumb,
  ChannelSliderTrack: () => ColorPickerChannelSliderTrack,
  ChannelSliderValueText: () => ColorPickerChannelSliderValueText,
  Content: () => ColorPickerContent,
  Context: () => ColorPickerContext,
  Control: () => ColorPickerControl,
  EyeDropperTrigger: () => ColorPickerEyeDropperTrigger,
  FormatSelect: () => ColorPickerFormatSelect,
  FormatTrigger: () => ColorPickerFormatTrigger,
  HiddenInput: () => ColorPickerHiddenInput,
  Label: () => ColorPickerLabel,
  Positioner: () => ColorPickerPositioner,
  Root: () => ColorPickerRoot,
  RootProvider: () => ColorPickerRootProvider,
  Swatch: () => ColorPickerSwatch,
  SwatchGroup: () => ColorPickerSwatchGroup,
  SwatchIndicator: () => ColorPickerSwatchIndicator,
  SwatchTrigger: () => ColorPickerSwatchTrigger,
  TransparencyGrid: () => ColorPickerTransparencyGrid,
  Trigger: () => ColorPickerTrigger,
  ValueSwatch: () => ColorPickerValueSwatch,
  ValueText: () => ColorPickerValueText,
  View: () => ColorPickerView
});

// node_modules/@zag-js/collection/dist/index.mjs
var __defProp3 = Object.defineProperty;
var __defNormalProp3 = (obj, key, value) => key in obj ? __defProp3(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField3 = (obj, key, value) => __defNormalProp3(obj, typeof key !== "symbol" ? key + "" : key, value);
var fallback = {
  itemToValue(item) {
    if (typeof item === "string") return item;
    if (isObject2(item) && hasProp2(item, "value")) return item.value;
    return "";
  },
  itemToString(item) {
    if (typeof item === "string") return item;
    if (isObject2(item) && hasProp2(item, "label")) return item.label;
    return fallback.itemToValue(item);
  },
  isItemDisabled(item) {
    if (isObject2(item) && hasProp2(item, "disabled")) return !!item.disabled;
    return false;
  }
};
var ListCollection = class _ListCollection {
  constructor(options) {
    this.options = options;
    __publicField3(this, "items");
    __publicField3(this, "copy", (items) => {
      return new _ListCollection({ ...this.options, items: items ?? [...this.items] });
    });
    __publicField3(this, "isEqual", (other) => {
      return isEqual(this.items, other.items);
    });
    __publicField3(this, "setItems", (items) => {
      return this.copy(items);
    });
    __publicField3(this, "getValues", (items = this.items) => {
      return Array.from(items).map((item) => this.getItemValue(item)).filter(Boolean);
    });
    __publicField3(this, "find", (value) => {
      if (value == null) return null;
      const index = this.indexOf(value);
      return index != null ? this.at(index) : null;
    });
    __publicField3(this, "findMany", (values) => {
      return Array.from(values).map((value) => this.find(value)).filter((item) => item != null);
    });
    __publicField3(this, "at", (index) => {
      if (!this.options.groupBy && !this.options.groupSort) {
        return this.items[index] ?? null;
      }
      let idx = 0;
      const groups = this.group();
      for (const [, items] of groups) {
        for (const item of items) {
          if (idx === index) return item;
          idx++;
        }
      }
      return null;
    });
    __publicField3(this, "sortFn", (valueA, valueB) => {
      const indexA = this.indexOf(valueA);
      const indexB = this.indexOf(valueB);
      return (indexA ?? 0) - (indexB ?? 0);
    });
    __publicField3(this, "sort", (values) => {
      return [...values].sort(this.sortFn.bind(this));
    });
    __publicField3(this, "getItemValue", (item) => {
      var _a8, _b7;
      if (item == null) return null;
      return ((_b7 = (_a8 = this.options).itemToValue) == null ? void 0 : _b7.call(_a8, item)) ?? fallback.itemToValue(item);
    });
    __publicField3(this, "getItemDisabled", (item) => {
      var _a8, _b7;
      if (item == null) return false;
      return ((_b7 = (_a8 = this.options).isItemDisabled) == null ? void 0 : _b7.call(_a8, item)) ?? fallback.isItemDisabled(item);
    });
    __publicField3(this, "stringifyItem", (item) => {
      var _a8, _b7;
      if (item == null) return null;
      return ((_b7 = (_a8 = this.options).itemToString) == null ? void 0 : _b7.call(_a8, item)) ?? fallback.itemToString(item);
    });
    __publicField3(this, "stringify", (value) => {
      if (value == null) return null;
      return this.stringifyItem(this.find(value));
    });
    __publicField3(this, "stringifyItems", (items, separator = ", ") => {
      return Array.from(items).map((item) => this.stringifyItem(item)).filter(Boolean).join(separator);
    });
    __publicField3(this, "stringifyMany", (value, separator) => {
      return this.stringifyItems(this.findMany(value), separator);
    });
    __publicField3(this, "has", (value) => {
      return this.indexOf(value) !== -1;
    });
    __publicField3(this, "hasItem", (item) => {
      if (item == null) return false;
      return this.has(this.getItemValue(item));
    });
    __publicField3(this, "group", () => {
      const { groupBy, groupSort } = this.options;
      if (!groupBy) return [["", [...this.items]]];
      const groups = /* @__PURE__ */ new Map();
      this.items.forEach((item, index) => {
        const groupKey = groupBy(item, index);
        if (!groups.has(groupKey)) {
          groups.set(groupKey, []);
        }
        groups.get(groupKey).push(item);
      });
      let entries = Array.from(groups.entries());
      if (groupSort) {
        entries.sort(([a2], [b2]) => {
          if (typeof groupSort === "function") return groupSort(a2, b2);
          if (Array.isArray(groupSort)) {
            const indexA = groupSort.indexOf(a2);
            const indexB = groupSort.indexOf(b2);
            if (indexA === -1) return 1;
            if (indexB === -1) return -1;
            return indexA - indexB;
          }
          if (groupSort === "asc") return a2.localeCompare(b2);
          if (groupSort === "desc") return b2.localeCompare(a2);
          return 0;
        });
      }
      return entries;
    });
    __publicField3(this, "getNextValue", (value, step = 1, clamp5 = false) => {
      let index = this.indexOf(value);
      if (index === -1) return null;
      index = clamp5 ? Math.min(index + step, this.size - 1) : index + step;
      while (index <= this.size && this.getItemDisabled(this.at(index))) index++;
      return this.getItemValue(this.at(index));
    });
    __publicField3(this, "getPreviousValue", (value, step = 1, clamp5 = false) => {
      let index = this.indexOf(value);
      if (index === -1) return null;
      index = clamp5 ? Math.max(index - step, 0) : index - step;
      while (index >= 0 && this.getItemDisabled(this.at(index))) index--;
      return this.getItemValue(this.at(index));
    });
    __publicField3(this, "indexOf", (value) => {
      if (value == null) return -1;
      if (!this.options.groupBy && !this.options.groupSort) {
        return this.items.findIndex((item) => this.getItemValue(item) === value);
      }
      let idx = 0;
      const groups = this.group();
      for (const [, items] of groups) {
        for (const item of items) {
          if (this.getItemValue(item) === value) return idx;
          idx++;
        }
      }
      return -1;
    });
    __publicField3(this, "getByText", (text, current) => {
      let items = current != null ? wrap3(this.items, this.indexOf(current)) : this.items;
      const isSingleKey = text.length === 1;
      if (isSingleKey) items = items.filter((item) => this.getItemValue(item) !== current);
      return items.find((item) => match3(this.stringifyItem(item), text));
    });
    __publicField3(this, "search", (queryString, options2) => {
      const { state: state2, currentValue, timeout = 350 } = options2;
      const search = state2.keysSoFar + queryString;
      const isRepeated = search.length > 1 && Array.from(search).every((char) => char === search[0]);
      const query2 = isRepeated ? search[0] : search;
      const item = this.getByText(query2, currentValue);
      const value = this.getItemValue(item);
      function cleanup() {
        clearTimeout(state2.timer);
        state2.timer = -1;
      }
      function update(value2) {
        state2.keysSoFar = value2;
        cleanup();
        if (value2 !== "") {
          state2.timer = +setTimeout(() => {
            update("");
            cleanup();
          }, timeout);
        }
      }
      update(search);
      return value;
    });
    __publicField3(this, "update", (value, item) => {
      let index = this.items.findIndex((item2) => this.getItemValue(item2) === value);
      if (index === -1) return this;
      return this.copy([...this.items.slice(0, index), item, ...this.items.slice(index + 1)]);
    });
    __publicField3(this, "insert", (index, ...items) => {
      return this.copy(insert(this.items, index, ...items));
    });
    __publicField3(this, "insertBefore", (value, ...items) => {
      let toIndex = this.indexOf(value);
      if (toIndex === -1) {
        if (this.items.length === 0) toIndex = 0;
        else return this;
      }
      return this.copy(insert(this.items, toIndex, ...items));
    });
    __publicField3(this, "insertAfter", (value, ...items) => {
      let toIndex = this.indexOf(value);
      if (toIndex === -1) {
        if (this.items.length === 0) toIndex = 0;
        else return this;
      }
      return this.copy(insert(this.items, toIndex + 1, ...items));
    });
    __publicField3(this, "prepend", (...items) => {
      return this.copy(insert(this.items, 0, ...items));
    });
    __publicField3(this, "append", (...items) => {
      return this.copy(insert(this.items, this.items.length, ...items));
    });
    __publicField3(this, "filter", (fn) => {
      const filteredItems = this.items.filter((item, index) => fn(this.stringifyItem(item), index));
      return this.copy(filteredItems);
    });
    __publicField3(this, "remove", (...itemsOrValues) => {
      const values = itemsOrValues.map(
        (itemOrValue) => typeof itemOrValue === "string" ? itemOrValue : this.getItemValue(itemOrValue)
      );
      return this.copy(
        this.items.filter((item) => {
          const value = this.getItemValue(item);
          if (value == null) return false;
          return !values.includes(value);
        })
      );
    });
    __publicField3(this, "move", (value, toIndex) => {
      const fromIndex = this.indexOf(value);
      if (fromIndex === -1) return this;
      return this.copy(move(this.items, [fromIndex], toIndex));
    });
    __publicField3(this, "moveBefore", (value, ...values) => {
      let toIndex = this.items.findIndex((item) => this.getItemValue(item) === value);
      if (toIndex === -1) return this;
      let indices = values.map((value2) => this.items.findIndex((item) => this.getItemValue(item) === value2)).sort((a2, b2) => a2 - b2);
      return this.copy(move(this.items, indices, toIndex));
    });
    __publicField3(this, "moveAfter", (value, ...values) => {
      let toIndex = this.items.findIndex((item) => this.getItemValue(item) === value);
      if (toIndex === -1) return this;
      let indices = values.map((value2) => this.items.findIndex((item) => this.getItemValue(item) === value2)).sort((a2, b2) => a2 - b2);
      return this.copy(move(this.items, indices, toIndex + 1));
    });
    __publicField3(this, "reorder", (fromIndex, toIndex) => {
      return this.copy(move(this.items, [fromIndex], toIndex));
    });
    __publicField3(this, "compareValue", (a2, b2) => {
      const indexA = this.indexOf(a2);
      const indexB = this.indexOf(b2);
      if (indexA < indexB) return -1;
      if (indexA > indexB) return 1;
      return 0;
    });
    __publicField3(this, "range", (from, to) => {
      let keys = [];
      let key = from;
      while (key != null) {
        let item = this.find(key);
        if (item) keys.push(key);
        if (key === to) return keys;
        key = this.getNextValue(key);
      }
      return [];
    });
    __publicField3(this, "getValueRange", (from, to) => {
      if (from && to) {
        if (this.compareValue(from, to) <= 0) {
          return this.range(from, to);
        }
        return this.range(to, from);
      }
      return [];
    });
    __publicField3(this, "toString", () => {
      let result = "";
      for (const item of this.items) {
        const value = this.getItemValue(item);
        const label = this.stringifyItem(item);
        const disabled = this.getItemDisabled(item);
        const itemString = [value, label, disabled].filter(Boolean).join(":");
        result += itemString + ",";
      }
      return result;
    });
    __publicField3(this, "toJSON", () => {
      return {
        size: this.size,
        first: this.firstValue,
        last: this.lastValue
      };
    });
    this.items = [...options.items];
  }
  /**
   * Returns the number of items in the collection
   */
  get size() {
    return this.items.length;
  }
  /**
   * Returns the first value in the collection
   */
  get firstValue() {
    let index = 0;
    while (this.getItemDisabled(this.at(index))) index++;
    return this.getItemValue(this.at(index));
  }
  /**
   * Returns the last value in the collection
   */
  get lastValue() {
    let index = this.size - 1;
    while (this.getItemDisabled(this.at(index))) index--;
    return this.getItemValue(this.at(index));
  }
  *[Symbol.iterator]() {
    yield* this.items;
  }
};
var match3 = (label, query2) => {
  return !!(label == null ? void 0 : label.toLowerCase().startsWith(query2.toLowerCase()));
};
var wrap3 = (v, idx) => {
  return v.map((_, index) => v[(Math.max(idx, 0) + index) % v.length]);
};
function insert(items, index, ...values) {
  return [...items.slice(0, index), ...values, ...items.slice(index)];
}
function move(items, indices, toIndex) {
  indices = [...indices].sort((a2, b2) => a2 - b2);
  const itemsToMove = indices.map((i) => items[i]);
  for (let i = indices.length - 1; i >= 0; i--) {
    items = [...items.slice(0, indices[i]), ...items.slice(indices[i] + 1)];
  }
  toIndex = Math.max(0, toIndex - indices.filter((i) => i < toIndex).length);
  return [...items.slice(0, toIndex), ...itemsToMove, ...items.slice(toIndex)];
}
var GridCollection = class extends ListCollection {
  constructor(options) {
    const { columnCount } = options;
    super(options);
    __publicField3(this, "columnCount");
    __publicField3(this, "getRows", () => {
      return chunk([...this.items], this.columnCount);
    });
    __publicField3(this, "getRowCount", () => {
      return this.getRows().length;
    });
    __publicField3(this, "getCellIndex", (row, column) => {
      return row * this.columnCount + column;
    });
    __publicField3(this, "getCell", (row, column) => {
      return this.at(this.getCellIndex(row, column));
    });
    __publicField3(this, "getValueCell", (value) => {
      const index = this.indexOf(value);
      if (index === -1) return null;
      const row = Math.floor(index / this.columnCount);
      const column = index % this.columnCount;
      return { row, column };
    });
    __publicField3(this, "getLastEnabledColumnIndex", (row) => {
      for (let col = this.columnCount - 1; col >= 0; col--) {
        const cell = this.getCell(row, col);
        if (cell && !this.getItemDisabled(cell)) {
          return col;
        }
      }
      return null;
    });
    __publicField3(this, "getFirstEnabledColumnIndex", (row) => {
      for (let col = 0; col < this.columnCount; col++) {
        const cell = this.getCell(row, col);
        if (cell && !this.getItemDisabled(cell)) {
          return col;
        }
      }
      return null;
    });
    __publicField3(this, "getPreviousRowValue", (value, loop = false) => {
      const currentCell = this.getValueCell(value);
      if (currentCell === null) return null;
      const rows = this.getRows();
      const rowCount = this.getRowCount();
      let prevRowIndex = currentCell.row;
      let prevColumnIndex = currentCell.column;
      for (let i = 1; i <= rowCount; i++) {
        prevRowIndex = prevIndex(rows, prevRowIndex, { loop });
        const prevRow = rows[prevRowIndex];
        if (!prevRow) continue;
        const prevCell = prevRow[prevColumnIndex];
        if (!prevCell) {
          const lastColumnIndex = this.getLastEnabledColumnIndex(prevRowIndex);
          if (lastColumnIndex != null) {
            prevColumnIndex = lastColumnIndex;
          }
        }
        const cell = this.getCell(prevRowIndex, prevColumnIndex);
        if (!this.getItemDisabled(cell)) {
          return this.getItemValue(cell);
        }
      }
      return this.firstValue;
    });
    __publicField3(this, "getNextRowValue", (value, loop = false) => {
      const currentCell = this.getValueCell(value);
      if (currentCell === null) return null;
      const rows = this.getRows();
      const rowCount = this.getRowCount();
      let nextRowIndex = currentCell.row;
      let nextColumnIndex = currentCell.column;
      for (let i = 1; i <= rowCount; i++) {
        nextRowIndex = nextIndex(rows, nextRowIndex, { loop });
        const nextRow = rows[nextRowIndex];
        if (!nextRow) continue;
        const nextCell = nextRow[nextColumnIndex];
        if (!nextCell) {
          const lastColumnIndex = this.getLastEnabledColumnIndex(nextRowIndex);
          if (lastColumnIndex != null) {
            nextColumnIndex = lastColumnIndex;
          }
        }
        const cell = this.getCell(nextRowIndex, nextColumnIndex);
        if (!this.getItemDisabled(cell)) {
          return this.getItemValue(cell);
        }
      }
      return this.lastValue;
    });
    this.columnCount = columnCount;
  }
};
function isGridCollection(v) {
  return v instanceof GridCollection;
}
function access(node, indexPath, options) {
  for (let i = 0; i < indexPath.length; i++) node = options.getChildren(node, indexPath.slice(i + 1))[indexPath[i]];
  return node;
}
function ancestorIndexPaths(indexPaths) {
  const sortedPaths = sortIndexPaths(indexPaths);
  const result = [];
  const seen = /* @__PURE__ */ new Set();
  for (const indexPath of sortedPaths) {
    const key = indexPath.join();
    if (!seen.has(key)) {
      seen.add(key);
      result.push(indexPath);
    }
  }
  return result;
}
function compareIndexPaths(a2, b2) {
  for (let i = 0; i < Math.min(a2.length, b2.length); i++) {
    if (a2[i] < b2[i]) return -1;
    if (a2[i] > b2[i]) return 1;
  }
  return a2.length - b2.length;
}
function sortIndexPaths(indexPaths) {
  return indexPaths.sort(compareIndexPaths);
}
function find(node, options) {
  let found;
  visit(node, {
    ...options,
    onEnter: (child, indexPath) => {
      if (options.predicate(child, indexPath)) {
        found = child;
        return "stop";
      }
    }
  });
  return found;
}
function findIndexPath(node, options) {
  let found;
  visit(node, {
    onEnter: (child, indexPath) => {
      if (options.predicate(child, indexPath)) {
        found = [...indexPath];
        return "stop";
      }
    },
    getChildren: options.getChildren
  });
  return found;
}
function reduce(node, options) {
  let result = options.initialResult;
  visit(node, {
    ...options,
    onEnter: (child, indexPath) => {
      result = options.nextResult(result, child, indexPath);
    }
  });
  return result;
}
function flatMap(node, options) {
  return reduce(node, {
    ...options,
    initialResult: [],
    nextResult: (result, child, indexPath) => {
      result.push(...options.transform(child, indexPath));
      return result;
    }
  });
}
function insertOperation(index, nodes) {
  return { type: "insert", index, nodes };
}
function removeOperation(indexes) {
  return { type: "remove", indexes };
}
function replaceOperation() {
  return { type: "replace" };
}
function splitIndexPath(indexPath) {
  return [indexPath.slice(0, -1), indexPath[indexPath.length - 1]];
}
function getInsertionOperations(indexPath, nodes, operations = /* @__PURE__ */ new Map()) {
  var _a8;
  const [parentIndexPath, index] = splitIndexPath(indexPath);
  for (let i = parentIndexPath.length - 1; i >= 0; i--) {
    const parentKey = parentIndexPath.slice(0, i).join();
    switch ((_a8 = operations.get(parentKey)) == null ? void 0 : _a8.type) {
      case "remove":
        continue;
    }
    operations.set(parentKey, replaceOperation());
  }
  const operation = operations.get(parentIndexPath.join());
  switch (operation == null ? void 0 : operation.type) {
    case "remove":
      operations.set(parentIndexPath.join(), {
        type: "removeThenInsert",
        removeIndexes: operation.indexes,
        insertIndex: index,
        insertNodes: nodes
      });
      break;
    default:
      operations.set(parentIndexPath.join(), insertOperation(index, nodes));
  }
  return operations;
}
function getRemovalOperations(indexPaths) {
  const operations = /* @__PURE__ */ new Map();
  const indexesToRemove = /* @__PURE__ */ new Map();
  for (const indexPath of indexPaths) {
    const parentKey = indexPath.slice(0, -1).join();
    const value = indexesToRemove.get(parentKey) ?? [];
    value.push(indexPath[indexPath.length - 1]);
    indexesToRemove.set(
      parentKey,
      value.sort((a2, b2) => a2 - b2)
    );
  }
  for (const indexPath of indexPaths) {
    for (let i = indexPath.length - 2; i >= 0; i--) {
      const parentKey = indexPath.slice(0, i).join();
      if (!operations.has(parentKey)) {
        operations.set(parentKey, replaceOperation());
      }
    }
  }
  for (const [parentKey, indexes] of indexesToRemove) {
    operations.set(parentKey, removeOperation(indexes));
  }
  return operations;
}
function getReplaceOperations(indexPath, node) {
  const operations = /* @__PURE__ */ new Map();
  const [parentIndexPath, index] = splitIndexPath(indexPath);
  for (let i = parentIndexPath.length - 1; i >= 0; i--) {
    const parentKey = parentIndexPath.slice(0, i).join();
    operations.set(parentKey, replaceOperation());
  }
  operations.set(parentIndexPath.join(), {
    type: "removeThenInsert",
    removeIndexes: [index],
    insertIndex: index,
    insertNodes: [node]
  });
  return operations;
}
function mutate(node, operations, options) {
  return map(node, {
    ...options,
    getChildren: (node2, indexPath) => {
      const key = indexPath.join();
      const operation = operations.get(key);
      switch (operation == null ? void 0 : operation.type) {
        case "replace":
        case "remove":
        case "removeThenInsert":
        case "insert":
          return options.getChildren(node2, indexPath);
        default:
          return [];
      }
    },
    transform: (node2, children, indexPath) => {
      const key = indexPath.join();
      const operation = operations.get(key);
      switch (operation == null ? void 0 : operation.type) {
        case "remove":
          return options.create(
            node2,
            children.filter((_, index) => !operation.indexes.includes(index)),
            indexPath
          );
        case "removeThenInsert":
          const updatedChildren = children.filter((_, index) => !operation.removeIndexes.includes(index));
          const adjustedIndex = operation.removeIndexes.reduce(
            (index, removedIndex) => removedIndex < index ? index - 1 : index,
            operation.insertIndex
          );
          return options.create(node2, splice(updatedChildren, adjustedIndex, 0, ...operation.insertNodes), indexPath);
        case "insert":
          return options.create(node2, splice(children, operation.index, 0, ...operation.nodes), indexPath);
        case "replace":
          return options.create(node2, children, indexPath);
        default:
          return node2;
      }
    }
  });
}
function splice(array, start, deleteCount, ...items) {
  return [...array.slice(0, start), ...items, ...array.slice(start + deleteCount)];
}
function map(node, options) {
  const childrenMap = {};
  visit(node, {
    ...options,
    onLeave: (child, indexPath) => {
      const keyIndexPath = [0, ...indexPath];
      const key = keyIndexPath.join();
      const transformed = options.transform(child, childrenMap[key] ?? [], indexPath);
      const parentKey = keyIndexPath.slice(0, -1).join();
      const parentChildren = childrenMap[parentKey] ?? [];
      parentChildren.push(transformed);
      childrenMap[parentKey] = parentChildren;
    }
  });
  return childrenMap[""][0];
}
function insert2(node, options) {
  const { nodes, at } = options;
  if (at.length === 0) throw new Error(`Can't insert nodes at the root`);
  const state2 = getInsertionOperations(at, nodes);
  return mutate(node, state2, options);
}
function replace(node, options) {
  if (options.at.length === 0) return options.node;
  const operations = getReplaceOperations(options.at, options.node);
  return mutate(node, operations, options);
}
function remove2(node, options) {
  if (options.indexPaths.length === 0) return node;
  for (const indexPath of options.indexPaths) {
    if (indexPath.length === 0) throw new Error(`Can't remove the root node`);
  }
  const operations = getRemovalOperations(options.indexPaths);
  return mutate(node, operations, options);
}
function move2(node, options) {
  if (options.indexPaths.length === 0) return node;
  for (const indexPath of options.indexPaths) {
    if (indexPath.length === 0) throw new Error(`Can't move the root node`);
  }
  if (options.to.length === 0) throw new Error(`Can't move nodes to the root`);
  const _ancestorIndexPaths = ancestorIndexPaths(options.indexPaths);
  const nodesToInsert = _ancestorIndexPaths.map((indexPath) => access(node, indexPath, options));
  const operations = getInsertionOperations(options.to, nodesToInsert, getRemovalOperations(_ancestorIndexPaths));
  return mutate(node, operations, options);
}
function visit(node, options) {
  const { onEnter, onLeave, getChildren } = options;
  let indexPath = [];
  let stack = [{ node }];
  const getIndexPath = options.reuseIndexPath ? () => indexPath : () => indexPath.slice();
  while (stack.length > 0) {
    let wrapper = stack[stack.length - 1];
    if (wrapper.state === void 0) {
      const enterResult = onEnter == null ? void 0 : onEnter(wrapper.node, getIndexPath());
      if (enterResult === "stop") return;
      wrapper.state = enterResult === "skip" ? -1 : 0;
    }
    const children = wrapper.children || getChildren(wrapper.node, getIndexPath());
    wrapper.children || (wrapper.children = children);
    if (wrapper.state !== -1) {
      if (wrapper.state < children.length) {
        let currentIndex = wrapper.state;
        indexPath.push(currentIndex);
        stack.push({ node: children[currentIndex] });
        wrapper.state = currentIndex + 1;
        continue;
      }
      const leaveResult = onLeave == null ? void 0 : onLeave(wrapper.node, getIndexPath());
      if (leaveResult === "stop") return;
    }
    indexPath.pop();
    stack.pop();
  }
}
var TreeCollection = class _TreeCollection {
  constructor(options) {
    this.options = options;
    __publicField3(this, "rootNode");
    __publicField3(this, "isEqual", (other) => {
      return isEqual(this.rootNode, other.rootNode);
    });
    __publicField3(this, "getNodeChildren", (node) => {
      var _a8, _b7;
      return ((_b7 = (_a8 = this.options).nodeToChildren) == null ? void 0 : _b7.call(_a8, node)) ?? fallback2.nodeToChildren(node) ?? [];
    });
    __publicField3(this, "_indexPath", (valueOrIndexPath) => {
      return typeof valueOrIndexPath === "string" ? this.getIndexPath(valueOrIndexPath) : valueOrIndexPath;
    });
    __publicField3(this, "getNodeChildrenCount", (node) => {
      var _a8, _b7;
      return ((_b7 = (_a8 = this.options).nodeToChildrenCount) == null ? void 0 : _b7.call(_a8, node)) ?? fallback2.nodeToChildrenCount(node);
    });
    __publicField3(this, "getNodeValue", (node) => {
      var _a8, _b7;
      return ((_b7 = (_a8 = this.options).nodeToValue) == null ? void 0 : _b7.call(_a8, node)) ?? fallback2.nodeToValue(node);
    });
    __publicField3(this, "getNodeDisabled", (node) => {
      var _a8, _b7;
      return ((_b7 = (_a8 = this.options).isNodeDisabled) == null ? void 0 : _b7.call(_a8, node)) ?? fallback2.isNodeDisabled(node);
    });
    __publicField3(this, "stringify", (value) => {
      const node = this.findNode(value);
      if (!node) return null;
      return this.stringifyNode(node);
    });
    __publicField3(this, "stringifyNode", (node) => {
      var _a8, _b7;
      return ((_b7 = (_a8 = this.options).nodeToString) == null ? void 0 : _b7.call(_a8, node)) ?? fallback2.nodeToString(node);
    });
    __publicField3(this, "getFirstNode", (rootNode = this.rootNode) => {
      let firstChild;
      visit(rootNode, {
        getChildren: this.getNodeChildren,
        onEnter: (node, indexPath) => {
          if (!firstChild && indexPath.length > 0 && !this.getNodeDisabled(node)) {
            firstChild = node;
            return "stop";
          }
        }
      });
      return firstChild;
    });
    __publicField3(this, "getLastNode", (rootNode = this.rootNode, opts = {}) => {
      let lastChild;
      visit(rootNode, {
        getChildren: this.getNodeChildren,
        onEnter: (node, indexPath) => {
          var _a8;
          const nodeValue = this.getNodeValue(node);
          if ((_a8 = opts.skip) == null ? void 0 : _a8.call(opts, { value: nodeValue, node, indexPath })) return "skip";
          if (indexPath.length > 1) return "skip";
          if (!this.getNodeDisabled(node)) {
            lastChild = node;
          }
        }
      });
      return lastChild;
    });
    __publicField3(this, "at", (indexPath) => {
      return access(this.rootNode, indexPath, {
        getChildren: this.getNodeChildren
      });
    });
    __publicField3(this, "findNode", (value, rootNode = this.rootNode) => {
      return find(rootNode, {
        getChildren: this.getNodeChildren,
        predicate: (node) => this.getNodeValue(node) === value
      });
    });
    __publicField3(this, "sort", (values) => {
      return values.reduce((acc, value) => {
        const indexPath = this.getIndexPath(value);
        if (indexPath) acc.push({ value, indexPath });
        return acc;
      }, []).sort((a2, b2) => compareIndexPaths(a2.indexPath, b2.indexPath)).map(({ value }) => value);
    });
    __publicField3(this, "getIndexPath", (value) => {
      return findIndexPath(this.rootNode, {
        getChildren: this.getNodeChildren,
        predicate: (node) => this.getNodeValue(node) === value
      });
    });
    __publicField3(this, "getValue", (indexPath) => {
      const node = this.at(indexPath);
      return node ? this.getNodeValue(node) : void 0;
    });
    __publicField3(this, "getValuePath", (indexPath) => {
      if (!indexPath) return [];
      const valuePath = [];
      let currentPath = [...indexPath];
      while (currentPath.length > 0) {
        const node = this.at(currentPath);
        if (node) valuePath.unshift(this.getNodeValue(node));
        currentPath.pop();
      }
      return valuePath;
    });
    __publicField3(this, "getDepth", (value) => {
      const indexPath = findIndexPath(this.rootNode, {
        getChildren: this.getNodeChildren,
        predicate: (node) => this.getNodeValue(node) === value
      });
      return (indexPath == null ? void 0 : indexPath.length) ?? 0;
    });
    __publicField3(this, "isRootNode", (node) => {
      return this.getNodeValue(node) === this.getNodeValue(this.rootNode);
    });
    __publicField3(this, "contains", (parentIndexPath, valueIndexPath) => {
      if (!parentIndexPath || !valueIndexPath) return false;
      return valueIndexPath.slice(0, parentIndexPath.length).every((_, i) => parentIndexPath[i] === valueIndexPath[i]);
    });
    __publicField3(this, "getNextNode", (value, opts = {}) => {
      let found = false;
      let nextNode;
      visit(this.rootNode, {
        getChildren: this.getNodeChildren,
        onEnter: (node, indexPath) => {
          var _a8;
          if (this.isRootNode(node)) return;
          const nodeValue = this.getNodeValue(node);
          if ((_a8 = opts.skip) == null ? void 0 : _a8.call(opts, { value: nodeValue, node, indexPath })) {
            if (nodeValue === value) {
              found = true;
            }
            return "skip";
          }
          if (found && !this.getNodeDisabled(node)) {
            nextNode = node;
            return "stop";
          }
          if (nodeValue === value) {
            found = true;
          }
        }
      });
      return nextNode;
    });
    __publicField3(this, "getPreviousNode", (value, opts = {}) => {
      let previousNode;
      let found = false;
      visit(this.rootNode, {
        getChildren: this.getNodeChildren,
        onEnter: (node, indexPath) => {
          var _a8;
          if (this.isRootNode(node)) return;
          const nodeValue = this.getNodeValue(node);
          if ((_a8 = opts.skip) == null ? void 0 : _a8.call(opts, { value: nodeValue, node, indexPath })) {
            return "skip";
          }
          if (nodeValue === value) {
            found = true;
            return "stop";
          }
          if (!this.getNodeDisabled(node)) {
            previousNode = node;
          }
        }
      });
      return found ? previousNode : void 0;
    });
    __publicField3(this, "getParentNodes", (valueOrIndexPath) => {
      const indexPath = this._indexPath(valueOrIndexPath);
      const result = [];
      while (indexPath && indexPath.length > 0) {
        indexPath.pop();
        const parentNode = this.at(indexPath);
        if (parentNode && !this.isRootNode(parentNode)) {
          result.unshift(parentNode);
        }
      }
      return result;
    });
    __publicField3(this, "getParentIndexPath", (indexPath) => {
      return indexPath.slice(0, -1);
    });
    __publicField3(this, "getParentNode", (valueOrIndexPath) => {
      const indexPath = this._indexPath(valueOrIndexPath);
      return indexPath ? this.at(this.getParentIndexPath(indexPath)) : void 0;
    });
    __publicField3(this, "visit", (opts) => {
      const { skip, ...rest } = opts;
      visit(this.rootNode, {
        ...rest,
        getChildren: this.getNodeChildren,
        onEnter: (node, indexPath) => {
          var _a8;
          if (this.isRootNode(node)) return;
          if (skip == null ? void 0 : skip({ value: this.getNodeValue(node), node, indexPath })) return "skip";
          return (_a8 = rest.onEnter) == null ? void 0 : _a8.call(rest, node, indexPath);
        }
      });
    });
    __publicField3(this, "getPreviousSibling", (indexPath) => {
      const parentNode = this.getParentNode(indexPath);
      if (!parentNode) return;
      const siblings = this.getNodeChildren(parentNode);
      let idx = siblings.findIndex((sibling) => this.getValue(indexPath) === this.getNodeValue(sibling));
      while (--idx >= 0) {
        const sibling = siblings[idx];
        if (!this.getNodeDisabled(sibling)) return sibling;
      }
      return;
    });
    __publicField3(this, "getNextSibling", (indexPath) => {
      const parentNode = this.getParentNode(indexPath);
      if (!parentNode) return;
      const siblings = this.getNodeChildren(parentNode);
      let idx = siblings.findIndex((sibling) => this.getValue(indexPath) === this.getNodeValue(sibling));
      while (++idx < siblings.length) {
        const sibling = siblings[idx];
        if (!this.getNodeDisabled(sibling)) return sibling;
      }
      return;
    });
    __publicField3(this, "getSiblingNodes", (indexPath) => {
      const parentNode = this.getParentNode(indexPath);
      return parentNode ? this.getNodeChildren(parentNode) : [];
    });
    __publicField3(this, "getValues", (rootNode = this.rootNode) => {
      const values = flatMap(rootNode, {
        getChildren: this.getNodeChildren,
        transform: (node) => [this.getNodeValue(node)]
      });
      return values.slice(1);
    });
    __publicField3(this, "isSameDepth", (indexPath, depth) => {
      if (depth == null) return true;
      return indexPath.length === depth;
    });
    __publicField3(this, "isBranchNode", (node) => {
      return this.getNodeChildren(node).length > 0 || this.getNodeChildrenCount(node) != null;
    });
    __publicField3(this, "getBranchValues", (rootNode = this.rootNode, opts = {}) => {
      let values = [];
      visit(rootNode, {
        getChildren: this.getNodeChildren,
        onEnter: (node, indexPath) => {
          var _a8;
          const nodeValue = this.getNodeValue(node);
          if ((_a8 = opts.skip) == null ? void 0 : _a8.call(opts, { value: nodeValue, node, indexPath })) return "skip";
          if (this.isBranchNode(node) && this.isSameDepth(indexPath, opts.depth)) {
            values.push(this.getNodeValue(node));
          }
        }
      });
      return values.slice(1);
    });
    __publicField3(this, "flatten", (rootNode = this.rootNode) => {
      const nodes = flatMap(rootNode, {
        getChildren: this.getNodeChildren,
        transform: (node, indexPath) => {
          const children = this.getNodeChildren(node).map((child) => this.getNodeValue(child));
          return [
            compact2({
              label: this.stringifyNode(node),
              value: this.getNodeValue(node),
              indexPath,
              children: children.length > 0 ? children : void 0
            })
          ];
        }
      });
      return nodes.slice(1);
    });
    __publicField3(this, "_create", (node, children) => {
      return compact2({ ...node, children });
    });
    __publicField3(this, "_insert", (rootNode, indexPath, nodes) => {
      return this.copy(
        insert2(rootNode, { at: indexPath, nodes, getChildren: this.getNodeChildren, create: this._create })
      );
    });
    __publicField3(this, "copy", (rootNode) => {
      return new _TreeCollection({ ...this.options, rootNode });
    });
    __publicField3(this, "_replace", (rootNode, indexPath, node) => {
      return this.copy(
        replace(rootNode, { at: indexPath, node, getChildren: this.getNodeChildren, create: this._create })
      );
    });
    __publicField3(this, "_move", (rootNode, indexPaths, to) => {
      return this.copy(move2(rootNode, { indexPaths, to, getChildren: this.getNodeChildren, create: this._create }));
    });
    __publicField3(this, "_remove", (rootNode, indexPaths) => {
      return this.copy(remove2(rootNode, { indexPaths, getChildren: this.getNodeChildren, create: this._create }));
    });
    __publicField3(this, "replace", (indexPath, node) => {
      return this._replace(this.rootNode, indexPath, node);
    });
    __publicField3(this, "remove", (indexPaths) => {
      return this._remove(this.rootNode, indexPaths);
    });
    __publicField3(this, "insertBefore", (indexPath, nodes) => {
      const parentNode = this.getParentNode(indexPath);
      return parentNode ? this._insert(this.rootNode, indexPath, nodes) : void 0;
    });
    __publicField3(this, "insertAfter", (indexPath, nodes) => {
      const parentNode = this.getParentNode(indexPath);
      if (!parentNode) return;
      const nextIndex2 = [...indexPath.slice(0, -1), indexPath[indexPath.length - 1] + 1];
      return this._insert(this.rootNode, nextIndex2, nodes);
    });
    __publicField3(this, "move", (fromIndexPaths, toIndexPath) => {
      return this._move(this.rootNode, fromIndexPaths, toIndexPath);
    });
    __publicField3(this, "toJSON", () => {
      return this.getValues(this.rootNode);
    });
    this.rootNode = options.rootNode;
  }
};
var fallback2 = {
  nodeToValue(node) {
    if (typeof node === "string") return node;
    if (isObject2(node) && hasProp2(node, "value")) return node.value;
    return "";
  },
  nodeToString(node) {
    if (typeof node === "string") return node;
    if (isObject2(node) && hasProp2(node, "label")) return node.label;
    return fallback2.nodeToValue(node);
  },
  isNodeDisabled(node) {
    if (isObject2(node) && hasProp2(node, "disabled")) return !!node.disabled;
    return false;
  },
  nodeToChildren(node) {
    return node.children;
  },
  nodeToChildrenCount(node) {
    if (isObject2(node) && hasProp2(node, "childrenCount")) return node.childrenCount;
  }
};
var Selection = class _Selection extends Set {
  constructor(values = []) {
    super(values);
    __publicField3(this, "selectionMode", "single");
    __publicField3(this, "deselectable", true);
    __publicField3(this, "copy", () => {
      const clone2 = new _Selection([...this]);
      return this.sync(clone2);
    });
    __publicField3(this, "sync", (other) => {
      other.selectionMode = this.selectionMode;
      other.deselectable = this.deselectable;
      return other;
    });
    __publicField3(this, "isEmpty", () => {
      return this.size === 0;
    });
    __publicField3(this, "isSelected", (value) => {
      if (this.selectionMode === "none" || value == null) {
        return false;
      }
      return this.has(value);
    });
    __publicField3(this, "canSelect", (collection5, value) => {
      return this.selectionMode !== "none" || !collection5.getItemDisabled(collection5.find(value));
    });
    __publicField3(this, "firstSelectedValue", (collection5) => {
      let firstValue = null;
      for (let value of this) {
        if (!firstValue || collection5.compareValue(value, firstValue) < 0) {
          firstValue = value;
        }
      }
      return firstValue;
    });
    __publicField3(this, "lastSelectedValue", (collection5) => {
      let lastValue = null;
      for (let value of this) {
        if (!lastValue || collection5.compareValue(value, lastValue) > 0) {
          lastValue = value;
        }
      }
      return lastValue;
    });
    __publicField3(this, "extendSelection", (collection5, anchorValue, targetValue) => {
      if (this.selectionMode === "none") {
        return this;
      }
      if (this.selectionMode === "single") {
        return this.replaceSelection(collection5, targetValue);
      }
      const selection = this.copy();
      const lastSelected = Array.from(this).pop();
      for (let key of collection5.getValueRange(anchorValue, lastSelected ?? targetValue)) {
        selection.delete(key);
      }
      for (let key of collection5.getValueRange(targetValue, anchorValue)) {
        if (this.canSelect(collection5, key)) {
          selection.add(key);
        }
      }
      return selection;
    });
    __publicField3(this, "toggleSelection", (collection5, value) => {
      if (this.selectionMode === "none") {
        return this;
      }
      if (this.selectionMode === "single" && !this.isSelected(value)) {
        return this.replaceSelection(collection5, value);
      }
      const selection = this.copy();
      if (selection.has(value)) {
        selection.delete(value);
      } else if (selection.canSelect(collection5, value)) {
        selection.add(value);
      }
      return selection;
    });
    __publicField3(this, "replaceSelection", (collection5, value) => {
      if (this.selectionMode === "none") {
        return this;
      }
      if (value == null) {
        return this;
      }
      if (!this.canSelect(collection5, value)) {
        return this;
      }
      const selection = new _Selection([value]);
      return this.sync(selection);
    });
    __publicField3(this, "setSelection", (values2) => {
      if (this.selectionMode === "none") {
        return this;
      }
      let selection = new _Selection();
      for (let value of values2) {
        if (value != null) {
          selection.add(value);
          if (this.selectionMode === "single") {
            break;
          }
        }
      }
      return this.sync(selection);
    });
    __publicField3(this, "clearSelection", () => {
      const selection = this.copy();
      if (selection.deselectable && selection.size > 0) {
        selection.clear();
      }
      return selection;
    });
    __publicField3(this, "select", (collection5, value, forceToggle) => {
      if (this.selectionMode === "none") {
        return this;
      }
      if (this.selectionMode === "single") {
        if (this.isSelected(value) && this.deselectable) {
          return this.toggleSelection(collection5, value);
        } else {
          return this.replaceSelection(collection5, value);
        }
      } else if (this.selectionMode === "multiple" || forceToggle) {
        return this.toggleSelection(collection5, value);
      } else {
        return this.replaceSelection(collection5, value);
      }
    });
    __publicField3(this, "deselect", (value) => {
      const selection = this.copy();
      selection.delete(value);
      return selection;
    });
    __publicField3(this, "isEqual", (other) => {
      return isEqual(Array.from(this), Array.from(other));
    });
  }
};

// node_modules/@ark-ui/react/dist/components/collection/list-collection.js
var createListCollection = (options) => new ListCollection(options);

// node_modules/@ark-ui/react/dist/components/collection/use-list-collection.js
var import_react195 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/combobox/combobox-clear-trigger.js
var import_jsx_runtime91 = __toESM(require_jsx_runtime(), 1);
var import_react197 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/combobox/use-combobox-context.js
var [ComboboxProvider, useComboboxContext] = createContext3({
  name: "ComboboxContext",
  hookName: "useComboboxContext",
  providerName: "<ComboboxProvider />"
});

// node_modules/@ark-ui/react/dist/components/combobox/combobox-clear-trigger.js
var ComboboxClearTrigger = (0, import_react197.forwardRef)((props43, ref) => {
  const combobox = useComboboxContext();
  const mergedProps = mergeProps2(combobox.getClearTriggerProps(), props43);
  return (0, import_jsx_runtime91.jsx)(ark.button, { ...mergedProps, ref });
});
ComboboxClearTrigger.displayName = "ComboboxClearTrigger";

// node_modules/@ark-ui/react/dist/components/combobox/combobox-content.js
var import_jsx_runtime92 = __toESM(require_jsx_runtime(), 1);
var import_react199 = __toESM(require_react(), 1);
var ComboboxContent = (0, import_react199.forwardRef)((props43, ref) => {
  const combobox = useComboboxContext();
  const presence = usePresenceContext();
  const mergedProps = mergeProps2(combobox.getContentProps(), presence.getPresenceProps(), props43);
  if (presence.unmounted) {
    return null;
  }
  return (0, import_jsx_runtime92.jsx)(ark.div, { ...mergedProps, ref: composeRefs(presence.ref, ref) });
});
ComboboxContent.displayName = "ComboboxContent";

// node_modules/@ark-ui/react/dist/components/combobox/combobox-context.js
var ComboboxContext = (props43) => props43.children(useComboboxContext());

// node_modules/@ark-ui/react/dist/components/combobox/combobox-control.js
var import_jsx_runtime93 = __toESM(require_jsx_runtime(), 1);
var import_react201 = __toESM(require_react(), 1);
var ComboboxControl = (0, import_react201.forwardRef)((props43, ref) => {
  const combobox = useComboboxContext();
  const mergedProps = mergeProps2(combobox.getControlProps(), props43);
  return (0, import_jsx_runtime93.jsx)(ark.div, { ...mergedProps, ref });
});
ComboboxControl.displayName = "ComboboxControl";

// node_modules/@ark-ui/react/dist/components/combobox/combobox-input.js
var import_jsx_runtime94 = __toESM(require_jsx_runtime(), 1);
var import_react203 = __toESM(require_react(), 1);
var ComboboxInput = (0, import_react203.forwardRef)((props43, ref) => {
  const combobox = useComboboxContext();
  const mergedProps = mergeProps2(combobox.getInputProps(), props43);
  const field = useFieldContext();
  return (0, import_jsx_runtime94.jsx)(ark.input, { "aria-describedby": field == null ? void 0 : field.ariaDescribedby, ...mergedProps, ref });
});
ComboboxInput.displayName = "ComboboxInput";

// node_modules/@ark-ui/react/dist/components/combobox/combobox-item.js
var import_jsx_runtime95 = __toESM(require_jsx_runtime(), 1);
var import_react205 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/combobox/use-combobox-item-context.js
var [ComboboxItemProvider, useComboboxItemContext] = createContext3({
  name: "ComboboxItemContext",
  hookName: "useComboboxItemContext",
  providerName: "<ComboboxItemProvider />"
});

// node_modules/@ark-ui/react/dist/components/combobox/use-combobox-item-props-context.js
var [ComboboxItemPropsProvider, useComboboxItemPropsContext] = createContext3({
  name: "ComboboxItemPropsContext",
  hookName: "useComboboxItemPropsContext",
  providerName: "<ComboboxItemPropsProvider />"
});

// node_modules/@ark-ui/react/dist/components/combobox/combobox-item.js
var ComboboxItem = (0, import_react205.forwardRef)((props43, ref) => {
  const [itemProps14, localProps] = createSplitProps2()(props43, ["item", "persistFocus"]);
  const combobox = useComboboxContext();
  const mergedProps = mergeProps2(combobox.getItemProps(itemProps14), localProps);
  const itemState = combobox.getItemState(itemProps14);
  return (0, import_jsx_runtime95.jsx)(ComboboxItemPropsProvider, { value: itemProps14, children: (0, import_jsx_runtime95.jsx)(ComboboxItemProvider, { value: itemState, children: (0, import_jsx_runtime95.jsx)(ark.div, { ...mergedProps, ref }) }) });
});
ComboboxItem.displayName = "ComboboxItem";

// node_modules/@ark-ui/react/dist/components/combobox/combobox-item-context.js
var ComboboxItemContext = (props43) => props43.children(useComboboxItemContext());

// node_modules/@ark-ui/react/dist/components/combobox/combobox-item-group.js
var import_jsx_runtime96 = __toESM(require_jsx_runtime(), 1);
var import_react207 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/combobox/use-combobox-item-group-props-context.js
var [ComboboxItemGroupPropsProvider, useComboboxItemGroupPropsContext] = createContext3({
  name: "ComboboxItemGroupPropsContext",
  hookName: "useComboboxItemGroupPropsContext",
  providerName: "<ComboboxItemGroupPropsProvider />"
});

// node_modules/@ark-ui/react/dist/components/combobox/combobox-item-group.js
var ComboboxItemGroup = (0, import_react207.forwardRef)((props43, ref) => {
  const id = (0, import_react207.useId)();
  const [_itemGroupProps, localProps] = createSplitProps2()(props43, ["id"]);
  const itemGroupProps5 = { id, ..._itemGroupProps };
  const combobox = useComboboxContext();
  const mergedProps = mergeProps2(combobox.getItemGroupProps(itemGroupProps5), localProps);
  return (0, import_jsx_runtime96.jsx)(ComboboxItemGroupPropsProvider, { value: itemGroupProps5, children: (0, import_jsx_runtime96.jsx)(ark.div, { ...mergedProps, ref }) });
});
ComboboxItemGroup.displayName = "ComboboxItemGroup";

// node_modules/@ark-ui/react/dist/components/combobox/combobox-item-group-label.js
var import_jsx_runtime97 = __toESM(require_jsx_runtime(), 1);
var import_react209 = __toESM(require_react(), 1);
var ComboboxItemGroupLabel = (0, import_react209.forwardRef)((props43, ref) => {
  const combobox = useComboboxContext();
  const itemGroupProps5 = useComboboxItemGroupPropsContext();
  const mergedProps = mergeProps2(combobox.getItemGroupLabelProps({ htmlFor: itemGroupProps5.id }), props43);
  return (0, import_jsx_runtime97.jsx)(ark.div, { ...mergedProps, ref });
});
ComboboxItemGroupLabel.displayName = "ComboboxItemGroupLabel";

// node_modules/@ark-ui/react/dist/components/combobox/combobox-item-indicator.js
var import_jsx_runtime98 = __toESM(require_jsx_runtime(), 1);
var import_react211 = __toESM(require_react(), 1);
var ComboboxItemIndicator = (0, import_react211.forwardRef)((props43, ref) => {
  const combobox = useComboboxContext();
  const itemProps14 = useComboboxItemPropsContext();
  const mergedProps = mergeProps2(combobox.getItemIndicatorProps(itemProps14), props43);
  return (0, import_jsx_runtime98.jsx)(ark.div, { ...mergedProps, ref });
});
ComboboxItemIndicator.displayName = "ComboboxItemIndicator";

// node_modules/@ark-ui/react/dist/components/combobox/combobox-item-text.js
var import_jsx_runtime99 = __toESM(require_jsx_runtime(), 1);
var import_react213 = __toESM(require_react(), 1);
var ComboboxItemText = (0, import_react213.forwardRef)((props43, ref) => {
  const combobox = useComboboxContext();
  const itemProps14 = useComboboxItemPropsContext();
  const mergedProps = mergeProps2(combobox.getItemTextProps(itemProps14), props43);
  return (0, import_jsx_runtime99.jsx)(ark.span, { ...mergedProps, ref });
});
ComboboxItemText.displayName = "ComboboxItemText";

// node_modules/@ark-ui/react/dist/components/combobox/combobox-label.js
var import_jsx_runtime100 = __toESM(require_jsx_runtime(), 1);
var import_react215 = __toESM(require_react(), 1);
var ComboboxLabel = (0, import_react215.forwardRef)((props43, ref) => {
  const combobox = useComboboxContext();
  const mergedProps = mergeProps2(combobox.getLabelProps(), props43);
  return (0, import_jsx_runtime100.jsx)(ark.label, { ...mergedProps, ref });
});
ComboboxLabel.displayName = "ComboboxLabel";

// node_modules/@ark-ui/react/dist/components/combobox/combobox-list.js
var import_jsx_runtime101 = __toESM(require_jsx_runtime(), 1);
var import_react217 = __toESM(require_react(), 1);
var ComboboxList = (0, import_react217.forwardRef)((props43, ref) => {
  const combobox = useComboboxContext();
  const mergedProps = mergeProps2(combobox.getListProps(), props43);
  return (0, import_jsx_runtime101.jsx)(ark.div, { ...mergedProps, ref });
});
ComboboxList.displayName = "ComboboxList";

// node_modules/@ark-ui/react/dist/components/combobox/combobox-positioner.js
var import_jsx_runtime102 = __toESM(require_jsx_runtime(), 1);
var import_react219 = __toESM(require_react(), 1);
var ComboboxPositioner = (0, import_react219.forwardRef)((props43, ref) => {
  const combobox = useComboboxContext();
  const presence = usePresenceContext();
  const mergedProps = mergeProps2(combobox.getPositionerProps(), props43);
  if (presence.unmounted) {
    return null;
  }
  return (0, import_jsx_runtime102.jsx)(ark.div, { ...mergedProps, ref });
});
ComboboxPositioner.displayName = "ComboboxPositioner";

// node_modules/@ark-ui/react/dist/components/combobox/combobox-root.js
var import_jsx_runtime103 = __toESM(require_jsx_runtime(), 1);
var import_react223 = __toESM(require_react(), 1);

// node_modules/@zag-js/aria-hidden/dist/index.mjs
var counterMap = /* @__PURE__ */ new WeakMap();
var uncontrolledNodes = /* @__PURE__ */ new WeakMap();
var markerMap = {};
var lockCount = 0;
var unwrapHost = (node) => node && (node.host || unwrapHost(node.parentNode));
var correctTargets = (parent, targets) => targets.map((target) => {
  if (parent.contains(target)) return target;
  const correctedTarget = unwrapHost(target);
  if (correctedTarget && parent.contains(correctedTarget)) {
    return correctedTarget;
  }
  console.error("[zag-js > ariaHidden] target", target, "in not contained inside", parent, ". Doing nothing");
  return null;
}).filter((x) => Boolean(x));
var isIgnoredNode = (node) => {
  if (node.localName === "next-route-announcer") return true;
  if (node.localName === "script") return true;
  if (node.hasAttribute("aria-live")) return true;
  return node.matches("[data-live-announcer]");
};
var walkTreeOutside = (originalTarget, props43) => {
  const { parentNode, markerName, controlAttribute } = props43;
  const targets = correctTargets(parentNode, Array.isArray(originalTarget) ? originalTarget : [originalTarget]);
  markerMap[markerName] || (markerMap[markerName] = /* @__PURE__ */ new WeakMap());
  const markerCounter = markerMap[markerName];
  const hiddenNodes = [];
  const elementsToKeep = /* @__PURE__ */ new Set();
  const elementsToStop = new Set(targets);
  const keep = (el) => {
    if (!el || elementsToKeep.has(el)) return;
    elementsToKeep.add(el);
    keep(el.parentNode);
  };
  targets.forEach(keep);
  const deep = (parent) => {
    if (!parent || elementsToStop.has(parent)) {
      return;
    }
    Array.prototype.forEach.call(parent.children, (node) => {
      if (elementsToKeep.has(node)) {
        deep(node);
      } else {
        try {
          if (isIgnoredNode(node)) return;
          const attr = node.getAttribute(controlAttribute);
          const alreadyHidden = attr === "true";
          const counterValue = (counterMap.get(node) || 0) + 1;
          const markerValue = (markerCounter.get(node) || 0) + 1;
          counterMap.set(node, counterValue);
          markerCounter.set(node, markerValue);
          hiddenNodes.push(node);
          if (counterValue === 1 && alreadyHidden) {
            uncontrolledNodes.set(node, true);
          }
          if (markerValue === 1) {
            node.setAttribute(markerName, "");
          }
          if (!alreadyHidden) {
            node.setAttribute(controlAttribute, "true");
          }
        } catch (e) {
          console.error("[zag-js > ariaHidden] cannot operate on ", node, e);
        }
      }
    });
  };
  deep(parentNode);
  elementsToKeep.clear();
  lockCount++;
  return () => {
    hiddenNodes.forEach((node) => {
      const counterValue = counterMap.get(node) - 1;
      const markerValue = markerCounter.get(node) - 1;
      counterMap.set(node, counterValue);
      markerCounter.set(node, markerValue);
      if (!counterValue) {
        if (!uncontrolledNodes.has(node)) {
          node.removeAttribute(controlAttribute);
        }
        uncontrolledNodes.delete(node);
      }
      if (!markerValue) {
        node.removeAttribute(markerName);
      }
    });
    lockCount--;
    if (!lockCount) {
      counterMap = /* @__PURE__ */ new WeakMap();
      counterMap = /* @__PURE__ */ new WeakMap();
      uncontrolledNodes = /* @__PURE__ */ new WeakMap();
      markerMap = {};
    }
  };
};
var getParentNode3 = (originalTarget) => {
  const target = Array.isArray(originalTarget) ? originalTarget[0] : originalTarget;
  return target.ownerDocument.body;
};
var hideOthers = (originalTarget, parentNode = getParentNode3(originalTarget), markerName = "data-aria-hidden") => {
  if (!parentNode) return;
  return walkTreeOutside(originalTarget, {
    parentNode,
    markerName,
    controlAttribute: "aria-hidden"
  });
};
var raf2 = (fn) => {
  const frameId = requestAnimationFrame(() => fn());
  return () => cancelAnimationFrame(frameId);
};
function ariaHidden(targetsOrFn, options = {}) {
  const { defer = true } = options;
  const func = defer ? raf2 : (v) => v();
  const cleanups = [];
  cleanups.push(
    func(() => {
      const targets = typeof targetsOrFn === "function" ? targetsOrFn() : targetsOrFn;
      const elements = targets.filter(Boolean);
      if (elements.length === 0) return;
      cleanups.push(hideOthers(elements));
    })
  );
  return () => {
    cleanups.forEach((fn) => fn == null ? void 0 : fn());
  };
}

// node_modules/@zag-js/combobox/dist/index.mjs
var anatomy10 = createAnatomy("combobox").parts(
  "root",
  "clearTrigger",
  "content",
  "control",
  "input",
  "item",
  "itemGroup",
  "itemGroupLabel",
  "itemIndicator",
  "itemText",
  "label",
  "list",
  "positioner",
  "trigger"
);
var parts10 = anatomy10.build();
var collection = (options) => {
  return new ListCollection(options);
};
collection.empty = () => {
  return new ListCollection({ items: [] });
};
var getRootId10 = (ctx) => {
  var _a8;
  return ((_a8 = ctx.ids) == null ? void 0 : _a8.root) ?? `combobox:${ctx.id}`;
};
var getLabelId5 = (ctx) => {
  var _a8;
  return ((_a8 = ctx.ids) == null ? void 0 : _a8.label) ?? `combobox:${ctx.id}:label`;
};
var getControlId5 = (ctx) => {
  var _a8;
  return ((_a8 = ctx.ids) == null ? void 0 : _a8.control) ?? `combobox:${ctx.id}:control`;
};
var getInputId3 = (ctx) => {
  var _a8;
  return ((_a8 = ctx.ids) == null ? void 0 : _a8.input) ?? `combobox:${ctx.id}:input`;
};
var getContentId4 = (ctx) => {
  var _a8;
  return ((_a8 = ctx.ids) == null ? void 0 : _a8.content) ?? `combobox:${ctx.id}:content`;
};
var getPositionerId3 = (ctx) => {
  var _a8;
  return ((_a8 = ctx.ids) == null ? void 0 : _a8.positioner) ?? `combobox:${ctx.id}:popper`;
};
var getTriggerId4 = (ctx) => {
  var _a8;
  return ((_a8 = ctx.ids) == null ? void 0 : _a8.trigger) ?? `combobox:${ctx.id}:toggle-btn`;
};
var getClearTriggerId2 = (ctx) => {
  var _a8;
  return ((_a8 = ctx.ids) == null ? void 0 : _a8.clearTrigger) ?? `combobox:${ctx.id}:clear-btn`;
};
var getItemGroupId2 = (ctx, id) => {
  var _a8, _b7;
  return ((_b7 = (_a8 = ctx.ids) == null ? void 0 : _a8.itemGroup) == null ? void 0 : _b7.call(_a8, id)) ?? `combobox:${ctx.id}:optgroup:${id}`;
};
var getItemGroupLabelId = (ctx, id) => {
  var _a8, _b7;
  return ((_b7 = (_a8 = ctx.ids) == null ? void 0 : _a8.itemGroupLabel) == null ? void 0 : _b7.call(_a8, id)) ?? `combobox:${ctx.id}:optgroup-label:${id}`;
};
var getItemId3 = (ctx, id) => {
  var _a8, _b7;
  return ((_b7 = (_a8 = ctx.ids) == null ? void 0 : _a8.item) == null ? void 0 : _b7.call(_a8, id)) ?? `combobox:${ctx.id}:option:${id}`;
};
var getContentEl4 = (ctx) => ctx.getById(getContentId4(ctx));
var getInputEl2 = (ctx) => ctx.getById(getInputId3(ctx));
var getPositionerEl3 = (ctx) => ctx.getById(getPositionerId3(ctx));
var getControlEl4 = (ctx) => ctx.getById(getControlId5(ctx));
var getTriggerEl3 = (ctx) => ctx.getById(getTriggerId4(ctx));
var getClearTriggerEl2 = (ctx) => ctx.getById(getClearTriggerId2(ctx));
var getItemEl = (ctx, value) => {
  if (value == null) return;
  const selector = `[role=option][data-value="${CSS.escape(value)}"]`;
  return query(getContentEl4(ctx), selector);
};
var focusInputEl = (ctx) => {
  const inputEl = getInputEl2(ctx);
  if (ctx.isActiveElement(inputEl)) return;
  inputEl == null ? void 0 : inputEl.focus({ preventScroll: true });
};
var focusTriggerEl = (ctx) => {
  const triggerEl = getTriggerEl3(ctx);
  if (ctx.isActiveElement(triggerEl)) return;
  triggerEl == null ? void 0 : triggerEl.focus({ preventScroll: true });
};
function connect11(service, normalize4) {
  const { context, prop, state: state2, send, scope, computed, event } = service;
  const translations = prop("translations");
  const collection22 = prop("collection");
  const disabled = prop("disabled");
  const interactive = computed("isInteractive");
  const invalid = prop("invalid");
  const readOnly = prop("readOnly");
  const open = state2.hasTag("open");
  const focused = state2.hasTag("focused");
  const composite = prop("composite");
  const highlightedValue = context.get("highlightedValue");
  const popperStyles = getPlacementStyles({
    ...prop("positioning"),
    placement: context.get("currentPlacement")
  });
  function getItemState(props210) {
    const disabled2 = collection22.getItemDisabled(props210.item);
    const value = collection22.getItemValue(props210.item);
    ensure(value, () => `[zag-js] No value found for item ${JSON.stringify(props210.item)}`);
    return {
      value,
      disabled: Boolean(disabled2 || disabled2),
      highlighted: highlightedValue === value,
      selected: context.get("value").includes(value)
    };
  }
  return {
    focused,
    open,
    inputValue: context.get("inputValue"),
    highlightedValue,
    highlightedItem: context.get("highlightedItem"),
    value: context.get("value"),
    valueAsString: context.get("valueAsString"),
    hasSelectedItems: computed("hasSelectedItems"),
    selectedItems: context.get("selectedItems"),
    collection: prop("collection"),
    multiple: !!prop("multiple"),
    disabled: !!disabled,
    syncSelectedItems() {
      send({ type: "SELECTED_ITEMS.SYNC" });
    },
    reposition(options = {}) {
      send({ type: "POSITIONING.SET", options });
    },
    setHighlightValue(value) {
      send({ type: "HIGHLIGHTED_VALUE.SET", value });
    },
    selectValue(value) {
      send({ type: "ITEM.SELECT", value });
    },
    setValue(value) {
      send({ type: "VALUE.SET", value });
    },
    setInputValue(value) {
      send({ type: "INPUT_VALUE.SET", value });
    },
    clearValue(value) {
      if (value != null) {
        send({ type: "ITEM.CLEAR", value });
      } else {
        send({ type: "VALUE.CLEAR" });
      }
    },
    focus() {
      var _a8;
      (_a8 = getInputEl2(scope)) == null ? void 0 : _a8.focus();
    },
    setOpen(nextOpen) {
      const open2 = state2.hasTag("open");
      if (open2 === nextOpen) return;
      send({ type: nextOpen ? "OPEN" : "CLOSE" });
    },
    getRootProps() {
      return normalize4.element({
        ...parts10.root.attrs,
        dir: prop("dir"),
        id: getRootId10(scope),
        "data-invalid": dataAttr(invalid),
        "data-readonly": dataAttr(readOnly)
      });
    },
    getLabelProps() {
      return normalize4.label({
        ...parts10.label.attrs,
        dir: prop("dir"),
        htmlFor: getInputId3(scope),
        id: getLabelId5(scope),
        "data-readonly": dataAttr(readOnly),
        "data-disabled": dataAttr(disabled),
        "data-invalid": dataAttr(invalid),
        "data-focus": dataAttr(focused),
        onClick(event2) {
          var _a8;
          if (composite) return;
          event2.preventDefault();
          (_a8 = getTriggerEl3(scope)) == null ? void 0 : _a8.focus({ preventScroll: true });
        }
      });
    },
    getControlProps() {
      return normalize4.element({
        ...parts10.control.attrs,
        dir: prop("dir"),
        id: getControlId5(scope),
        "data-state": open ? "open" : "closed",
        "data-focus": dataAttr(focused),
        "data-disabled": dataAttr(disabled),
        "data-invalid": dataAttr(invalid)
      });
    },
    getPositionerProps() {
      return normalize4.element({
        ...parts10.positioner.attrs,
        dir: prop("dir"),
        id: getPositionerId3(scope),
        style: popperStyles.floating
      });
    },
    getInputProps() {
      return normalize4.input({
        ...parts10.input.attrs,
        dir: prop("dir"),
        "aria-invalid": ariaAttr(invalid),
        "data-invalid": dataAttr(invalid),
        "data-autofocus": dataAttr(prop("autoFocus")),
        name: prop("name"),
        form: prop("form"),
        disabled,
        required: prop("required"),
        autoComplete: "off",
        autoCorrect: "off",
        autoCapitalize: "none",
        spellCheck: "false",
        readOnly,
        placeholder: prop("placeholder"),
        id: getInputId3(scope),
        type: "text",
        role: "combobox",
        defaultValue: context.get("inputValue"),
        "aria-autocomplete": computed("autoComplete") ? "both" : "list",
        "aria-controls": getContentId4(scope),
        "aria-expanded": open,
        "data-state": open ? "open" : "closed",
        "aria-activedescendant": highlightedValue ? getItemId3(scope, highlightedValue) : void 0,
        onClick(event2) {
          if (event2.defaultPrevented) return;
          if (!prop("openOnClick")) return;
          if (!interactive) return;
          send({ type: "INPUT.CLICK" });
        },
        onFocus() {
          if (disabled) return;
          send({ type: "INPUT.FOCUS" });
        },
        onBlur() {
          if (disabled) return;
          send({ type: "INPUT.BLUR" });
        },
        onChange(event2) {
          send({ type: "INPUT.CHANGE", value: event2.currentTarget.value });
        },
        onKeyDown(event2) {
          if (event2.defaultPrevented) return;
          if (!interactive) return;
          if (event2.ctrlKey || event2.shiftKey || isComposingEvent(event2)) return;
          const openOnKeyPress = prop("openOnKeyPress");
          const isModifierKey2 = event2.ctrlKey || event2.metaKey || event2.shiftKey;
          const keypress = true;
          const keymap = {
            ArrowDown(event3) {
              if (!openOnKeyPress && !open) return;
              send({ type: event3.altKey ? "OPEN" : "INPUT.ARROW_DOWN", keypress });
              event3.preventDefault();
            },
            ArrowUp() {
              if (!openOnKeyPress && !open) return;
              send({ type: event2.altKey ? "CLOSE" : "INPUT.ARROW_UP", keypress });
              event2.preventDefault();
            },
            Home(event3) {
              if (isModifierKey2) return;
              send({ type: "INPUT.HOME", keypress });
              if (open) {
                event3.preventDefault();
              }
            },
            End(event3) {
              if (isModifierKey2) return;
              send({ type: "INPUT.END", keypress });
              if (open) {
                event3.preventDefault();
              }
            },
            Enter(event3) {
              var _a8;
              send({ type: "INPUT.ENTER", keypress });
              if (open) {
                event3.preventDefault();
              }
              if (highlightedValue == null) return;
              const itemEl = getItemEl(scope, highlightedValue);
              if (isAnchorElement(itemEl)) {
                (_a8 = prop("navigate")) == null ? void 0 : _a8({ value: highlightedValue, node: itemEl, href: itemEl.href });
              }
            },
            Escape() {
              send({ type: "INPUT.ESCAPE", keypress });
              event2.preventDefault();
            }
          };
          const key = getEventKey(event2, { dir: prop("dir") });
          const exec = keymap[key];
          exec == null ? void 0 : exec(event2);
        }
      });
    },
    getTriggerProps(props210 = {}) {
      return normalize4.button({
        ...parts10.trigger.attrs,
        dir: prop("dir"),
        id: getTriggerId4(scope),
        "aria-haspopup": composite ? "listbox" : "dialog",
        type: "button",
        tabIndex: props210.focusable ? void 0 : -1,
        "aria-label": translations.triggerLabel,
        "aria-expanded": open,
        "data-state": open ? "open" : "closed",
        "aria-controls": open ? getContentId4(scope) : void 0,
        disabled,
        "data-invalid": dataAttr(invalid),
        "data-focusable": dataAttr(props210.focusable),
        "data-readonly": dataAttr(readOnly),
        "data-disabled": dataAttr(disabled),
        onFocus() {
          if (!props210.focusable) return;
          send({ type: "INPUT.FOCUS", src: "trigger" });
        },
        onClick(event2) {
          if (event2.defaultPrevented) return;
          if (!interactive) return;
          if (!isLeftClick(event2)) return;
          send({ type: "TRIGGER.CLICK" });
        },
        onPointerDown(event2) {
          if (!interactive) return;
          if (event2.pointerType === "touch") return;
          event2.preventDefault();
          queueMicrotask(() => {
            var _a8;
            (_a8 = getInputEl2(scope)) == null ? void 0 : _a8.focus({ preventScroll: true });
          });
        },
        onKeyDown(event2) {
          if (event2.defaultPrevented) return;
          if (composite) return;
          const keyMap2 = {
            ArrowDown() {
              send({ type: "INPUT.ARROW_DOWN", src: "trigger" });
            },
            ArrowUp() {
              send({ type: "INPUT.ARROW_UP", src: "trigger" });
            }
          };
          const key = getEventKey(event2, { dir: prop("dir") });
          const exec = keyMap2[key];
          if (exec) {
            exec(event2);
            event2.preventDefault();
          }
        }
      });
    },
    getContentProps() {
      return normalize4.element({
        ...parts10.content.attrs,
        dir: prop("dir"),
        id: getContentId4(scope),
        role: !composite ? "dialog" : "listbox",
        tabIndex: -1,
        hidden: !open,
        "data-state": open ? "open" : "closed",
        "data-placement": context.get("currentPlacement"),
        "aria-labelledby": getLabelId5(scope),
        "aria-multiselectable": prop("multiple") && composite ? true : void 0,
        "data-empty": dataAttr(collection22.size === 0),
        onPointerDown(event2) {
          event2.preventDefault();
        }
      });
    },
    getListProps() {
      return normalize4.element({
        ...parts10.list.attrs,
        role: !composite ? "listbox" : void 0,
        "data-empty": dataAttr(collection22.size === 0),
        "aria-labelledby": getLabelId5(scope),
        "aria-multiselectable": prop("multiple") && !composite ? true : void 0
      });
    },
    getClearTriggerProps() {
      return normalize4.button({
        ...parts10.clearTrigger.attrs,
        dir: prop("dir"),
        id: getClearTriggerId2(scope),
        type: "button",
        tabIndex: -1,
        disabled,
        "data-invalid": dataAttr(invalid),
        "aria-label": translations.clearTriggerLabel,
        "aria-controls": getInputId3(scope),
        hidden: !context.get("value").length,
        onPointerDown(event2) {
          event2.preventDefault();
        },
        onClick(event2) {
          if (event2.defaultPrevented) return;
          if (!interactive) return;
          send({ type: "VALUE.CLEAR", src: "clear-trigger" });
        }
      });
    },
    getItemState,
    getItemProps(props210) {
      const itemState = getItemState(props210);
      const value = itemState.value;
      return normalize4.element({
        ...parts10.item.attrs,
        dir: prop("dir"),
        id: getItemId3(scope, value),
        role: "option",
        tabIndex: -1,
        "data-highlighted": dataAttr(itemState.highlighted),
        "data-state": itemState.selected ? "checked" : "unchecked",
        "aria-selected": ariaAttr(itemState.highlighted),
        "aria-disabled": ariaAttr(itemState.disabled),
        "data-disabled": dataAttr(itemState.disabled),
        "data-value": itemState.value,
        onPointerMove() {
          if (itemState.disabled) return;
          if (itemState.highlighted) return;
          send({ type: "ITEM.POINTER_MOVE", value });
        },
        onPointerLeave() {
          if (props210.persistFocus) return;
          if (itemState.disabled) return;
          const prev2 = event.previous();
          const mouseMoved = prev2 == null ? void 0 : prev2.type.includes("POINTER");
          if (!mouseMoved) return;
          send({ type: "ITEM.POINTER_LEAVE", value });
        },
        onClick(event2) {
          if (isDownloadingEvent(event2)) return;
          if (isOpeningInNewTab(event2)) return;
          if (isContextMenuEvent(event2)) return;
          if (itemState.disabled) return;
          send({ type: "ITEM.CLICK", src: "click", value });
        }
      });
    },
    getItemTextProps(props210) {
      const itemState = getItemState(props210);
      return normalize4.element({
        ...parts10.itemText.attrs,
        dir: prop("dir"),
        "data-state": itemState.selected ? "checked" : "unchecked",
        "data-disabled": dataAttr(itemState.disabled),
        "data-highlighted": dataAttr(itemState.highlighted)
      });
    },
    getItemIndicatorProps(props210) {
      const itemState = getItemState(props210);
      return normalize4.element({
        "aria-hidden": true,
        ...parts10.itemIndicator.attrs,
        dir: prop("dir"),
        "data-state": itemState.selected ? "checked" : "unchecked",
        hidden: !itemState.selected
      });
    },
    getItemGroupProps(props210) {
      const { id } = props210;
      return normalize4.element({
        ...parts10.itemGroup.attrs,
        dir: prop("dir"),
        id: getItemGroupId2(scope, id),
        "aria-labelledby": getItemGroupLabelId(scope, id),
        "data-empty": dataAttr(collection22.size === 0),
        role: "group"
      });
    },
    getItemGroupLabelProps(props210) {
      const { htmlFor } = props210;
      return normalize4.element({
        ...parts10.itemGroupLabel.attrs,
        dir: prop("dir"),
        id: getItemGroupLabelId(scope, htmlFor),
        role: "presentation"
      });
    }
  };
}
var { guards, createMachine: createMachine2, choose } = setup();
var { and: and4, not: not3 } = guards;
var machine11 = createMachine2({
  props({ props: props210 }) {
    return {
      loopFocus: true,
      openOnClick: false,
      defaultValue: [],
      closeOnSelect: !props210.multiple,
      allowCustomValue: false,
      inputBehavior: "none",
      selectionBehavior: props210.multiple ? "clear" : "replace",
      openOnKeyPress: true,
      openOnChange: true,
      composite: true,
      navigate({ node }) {
        clickIfLink(node);
      },
      collection: collection.empty(),
      ...props210,
      positioning: {
        placement: "bottom",
        sameWidth: true,
        ...props210.positioning
      },
      translations: {
        triggerLabel: "Toggle suggestions",
        clearTriggerLabel: "Clear value",
        ...props210.translations
      }
    };
  },
  initialState({ prop }) {
    const open = prop("open") || prop("defaultOpen");
    return open ? "suggesting" : "idle";
  },
  context({ prop, bindable, getContext }) {
    return {
      currentPlacement: bindable(() => ({
        defaultValue: void 0
      })),
      value: bindable(() => ({
        defaultValue: prop("defaultValue"),
        value: prop("value"),
        isEqual,
        hash(value) {
          return value.join(",");
        },
        onChange(value) {
          var _a8;
          const context = getContext();
          const prevSelectedItems = context.get("selectedItems");
          const collection22 = prop("collection");
          const nextItems = value.map((v) => {
            const item = prevSelectedItems.find((item2) => collection22.getItemValue(item2) === v);
            return item || collection22.find(v);
          });
          context.set("selectedItems", nextItems);
          context.set("valueAsString", collection22.stringifyItems(nextItems));
          (_a8 = prop("onValueChange")) == null ? void 0 : _a8({ value, items: nextItems });
        }
      })),
      highlightedValue: bindable(() => ({
        defaultValue: prop("defaultHighlightedValue") || null,
        value: prop("highlightedValue"),
        onChange(value) {
          var _a8;
          const item = prop("collection").find(value);
          (_a8 = prop("onHighlightChange")) == null ? void 0 : _a8({ highlightedValue: value, highlightedItem: item });
        }
      })),
      inputValue: bindable(() => {
        let inputValue = prop("inputValue") || prop("defaultInputValue") || "";
        const value = prop("defaultValue") || prop("value") || [];
        if (!inputValue.trim() && !prop("multiple")) {
          const valueAsString = prop("collection").stringifyMany(value);
          inputValue = match(prop("selectionBehavior"), {
            preserve: inputValue || valueAsString,
            replace: valueAsString,
            clear: ""
          });
        }
        return {
          defaultValue: inputValue,
          value: prop("inputValue"),
          onChange(value2) {
            var _a8;
            (_a8 = prop("onInputValueChange")) == null ? void 0 : _a8({ inputValue: value2 });
          }
        };
      }),
      highlightedItem: bindable(() => {
        const highlightedValue = prop("highlightedValue");
        const highlightedItem = prop("collection").find(highlightedValue);
        return { defaultValue: highlightedItem };
      }),
      selectedItems: bindable(() => {
        const value = prop("value") || prop("defaultValue") || [];
        const selectedItems = prop("collection").findMany(value);
        return { defaultValue: selectedItems };
      }),
      valueAsString: bindable(() => {
        const value = prop("value") || prop("defaultValue") || [];
        const valueAsString = prop("collection").stringifyMany(value);
        return { sync: true, defaultValue: valueAsString };
      })
    };
  },
  computed: {
    isInputValueEmpty: ({ context }) => context.get("inputValue").length === 0,
    isInteractive: ({ prop }) => !(prop("readOnly") || prop("disabled")),
    autoComplete: ({ prop }) => prop("inputBehavior") === "autocomplete",
    autoHighlight: ({ prop }) => prop("inputBehavior") === "autohighlight",
    hasSelectedItems: ({ context }) => context.get("value").length > 0
  },
  watch({ context, prop, track, action }) {
    track([() => context.hash("value")], () => {
      action(["syncSelectedItems"]);
    });
    track([() => context.get("inputValue")], () => {
      action(["syncInputValue"]);
    });
    track([() => context.get("highlightedValue")], () => {
      action(["syncHighlightedItem", "autofillInputValue"]);
    });
    track([() => prop("open")], () => {
      action(["toggleVisibility"]);
    });
  },
  on: {
    "SELECTED_ITEMS.SYNC": {
      actions: ["syncSelectedItems"]
    },
    "HIGHLIGHTED_VALUE.SET": {
      actions: ["setHighlightedItem"]
    },
    "ITEM.SELECT": {
      actions: ["selectItem"]
    },
    "ITEM.CLEAR": {
      actions: ["clearItem"]
    },
    "VALUE.SET": {
      actions: ["setValue"]
    },
    "INPUT_VALUE.SET": {
      actions: ["setInputValue"]
    },
    "POSITIONING.SET": {
      actions: ["reposition"]
    }
  },
  entry: choose([
    {
      guard: "autoFocus",
      actions: ["setInitialFocus"]
    }
  ]),
  states: {
    idle: {
      tags: ["idle", "closed"],
      entry: ["scrollContentToTop", "clearHighlightedItem"],
      on: {
        "CONTROLLED.OPEN": {
          target: "interacting"
        },
        "TRIGGER.CLICK": [
          {
            guard: "isOpenControlled",
            actions: ["setInitialFocus", "highlightFirstSelectedItem", "invokeOnOpen"]
          },
          {
            target: "interacting",
            actions: ["setInitialFocus", "highlightFirstSelectedItem", "invokeOnOpen"]
          }
        ],
        "INPUT.CLICK": [
          {
            guard: "isOpenControlled",
            actions: ["highlightFirstSelectedItem", "invokeOnOpen"]
          },
          {
            target: "interacting",
            actions: ["highlightFirstSelectedItem", "invokeOnOpen"]
          }
        ],
        "INPUT.FOCUS": {
          target: "focused"
        },
        OPEN: [
          {
            guard: "isOpenControlled",
            actions: ["invokeOnOpen"]
          },
          {
            target: "interacting",
            actions: ["invokeOnOpen"]
          }
        ],
        "VALUE.CLEAR": {
          target: "focused",
          actions: ["clearInputValue", "clearSelectedItems", "setInitialFocus"]
        }
      }
    },
    focused: {
      tags: ["focused", "closed"],
      entry: ["scrollContentToTop", "clearHighlightedItem"],
      on: {
        "CONTROLLED.OPEN": [
          {
            guard: "isChangeEvent",
            target: "suggesting"
          },
          {
            target: "interacting"
          }
        ],
        "INPUT.CHANGE": [
          {
            guard: and4("isOpenControlled", "openOnChange"),
            actions: ["setInputValue", "invokeOnOpen", "highlightFirstItemIfNeeded"]
          },
          {
            guard: "openOnChange",
            target: "suggesting",
            actions: ["setInputValue", "invokeOnOpen", "highlightFirstItemIfNeeded"]
          },
          {
            actions: ["setInputValue"]
          }
        ],
        "LAYER.INTERACT_OUTSIDE": {
          target: "idle"
        },
        "INPUT.ESCAPE": {
          guard: and4("isCustomValue", not3("allowCustomValue")),
          actions: ["revertInputValue"]
        },
        "INPUT.BLUR": {
          target: "idle"
        },
        "INPUT.CLICK": [
          {
            guard: "isOpenControlled",
            actions: ["highlightFirstSelectedItem", "invokeOnOpen"]
          },
          {
            target: "interacting",
            actions: ["highlightFirstSelectedItem", "invokeOnOpen"]
          }
        ],
        "TRIGGER.CLICK": [
          {
            guard: "isOpenControlled",
            actions: ["setInitialFocus", "highlightFirstSelectedItem", "invokeOnOpen"]
          },
          {
            target: "interacting",
            actions: ["setInitialFocus", "highlightFirstSelectedItem", "invokeOnOpen"]
          }
        ],
        "INPUT.ARROW_DOWN": [
          // == group 1 ==
          {
            guard: and4("isOpenControlled", "autoComplete"),
            actions: ["invokeOnOpen"]
          },
          {
            guard: "autoComplete",
            target: "interacting",
            actions: ["invokeOnOpen"]
          },
          // == group 2 ==
          {
            guard: "isOpenControlled",
            actions: ["highlightFirstOrSelectedItem", "invokeOnOpen"]
          },
          {
            target: "interacting",
            actions: ["highlightFirstOrSelectedItem", "invokeOnOpen"]
          }
        ],
        "INPUT.ARROW_UP": [
          // == group 1 ==
          {
            guard: "autoComplete",
            target: "interacting",
            actions: ["invokeOnOpen"]
          },
          {
            guard: "autoComplete",
            target: "interacting",
            actions: ["invokeOnOpen"]
          },
          // == group 2 ==
          {
            target: "interacting",
            actions: ["highlightLastOrSelectedItem", "invokeOnOpen"]
          },
          {
            target: "interacting",
            actions: ["highlightLastOrSelectedItem", "invokeOnOpen"]
          }
        ],
        OPEN: [
          {
            guard: "isOpenControlled",
            actions: ["invokeOnOpen"]
          },
          {
            target: "interacting",
            actions: ["invokeOnOpen"]
          }
        ],
        "VALUE.CLEAR": {
          actions: ["clearInputValue", "clearSelectedItems"]
        }
      }
    },
    interacting: {
      tags: ["open", "focused"],
      entry: ["setInitialFocus"],
      effects: ["scrollToHighlightedItem", "trackDismissableLayer", "trackPlacement", "hideOtherElements"],
      on: {
        "CONTROLLED.CLOSE": [
          {
            guard: "restoreFocus",
            target: "focused",
            actions: ["setFinalFocus"]
          },
          {
            target: "idle"
          }
        ],
        "INPUT.HOME": {
          actions: ["highlightFirstItem"]
        },
        "INPUT.END": {
          actions: ["highlightLastItem"]
        },
        "INPUT.ARROW_DOWN": [
          {
            guard: and4("autoComplete", "isLastItemHighlighted"),
            actions: ["clearHighlightedItem", "scrollContentToTop"]
          },
          {
            actions: ["highlightNextItem"]
          }
        ],
        "INPUT.ARROW_UP": [
          {
            guard: and4("autoComplete", "isFirstItemHighlighted"),
            actions: ["clearHighlightedItem"]
          },
          {
            actions: ["highlightPrevItem"]
          }
        ],
        "INPUT.ENTER": [
          // == group 1 ==
          {
            guard: and4("isOpenControlled", "isCustomValue", not3("hasHighlightedItem"), not3("allowCustomValue")),
            actions: ["revertInputValue", "invokeOnClose"]
          },
          {
            guard: and4("isCustomValue", not3("hasHighlightedItem"), not3("allowCustomValue")),
            target: "focused",
            actions: ["revertInputValue", "invokeOnClose"]
          },
          // == group 2 ==
          {
            guard: and4("isOpenControlled", "closeOnSelect"),
            actions: ["selectHighlightedItem", "invokeOnClose"]
          },
          {
            guard: "closeOnSelect",
            target: "focused",
            actions: ["selectHighlightedItem", "invokeOnClose", "setFinalFocus"]
          },
          {
            actions: ["selectHighlightedItem"]
          }
        ],
        "INPUT.CHANGE": [
          {
            guard: "autoComplete",
            target: "suggesting",
            actions: ["setInputValue"]
          },
          {
            target: "suggesting",
            actions: ["clearHighlightedItem", "setInputValue"]
          }
        ],
        "ITEM.POINTER_MOVE": {
          actions: ["setHighlightedItem"]
        },
        "ITEM.POINTER_LEAVE": {
          actions: ["clearHighlightedItem"]
        },
        "ITEM.CLICK": [
          {
            guard: and4("isOpenControlled", "closeOnSelect"),
            actions: ["selectItem", "invokeOnClose"]
          },
          {
            guard: "closeOnSelect",
            target: "focused",
            actions: ["selectItem", "invokeOnClose", "setFinalFocus"]
          },
          {
            actions: ["selectItem"]
          }
        ],
        "LAYER.ESCAPE": [
          {
            guard: and4("isOpenControlled", "autoComplete"),
            actions: ["syncInputValue", "invokeOnClose"]
          },
          {
            guard: "autoComplete",
            target: "focused",
            actions: ["syncInputValue", "invokeOnClose"]
          },
          {
            guard: "isOpenControlled",
            actions: ["invokeOnClose"]
          },
          {
            target: "focused",
            actions: ["invokeOnClose", "setFinalFocus"]
          }
        ],
        "TRIGGER.CLICK": [
          {
            guard: "isOpenControlled",
            actions: ["invokeOnClose"]
          },
          {
            target: "focused",
            actions: ["invokeOnClose"]
          }
        ],
        "LAYER.INTERACT_OUTSIDE": [
          // == group 1 ==
          {
            guard: and4("isOpenControlled", "isCustomValue", not3("allowCustomValue")),
            actions: ["revertInputValue", "invokeOnClose"]
          },
          {
            guard: and4("isCustomValue", not3("allowCustomValue")),
            target: "idle",
            actions: ["revertInputValue", "invokeOnClose"]
          },
          // == group 2 ==
          {
            guard: "isOpenControlled",
            actions: ["invokeOnClose"]
          },
          {
            target: "idle",
            actions: ["invokeOnClose"]
          }
        ],
        CLOSE: [
          {
            guard: "isOpenControlled",
            actions: ["invokeOnClose"]
          },
          {
            target: "focused",
            actions: ["invokeOnClose", "setFinalFocus"]
          }
        ],
        "VALUE.CLEAR": [
          {
            guard: "isOpenControlled",
            actions: ["clearInputValue", "clearSelectedItems", "invokeOnClose"]
          },
          {
            target: "focused",
            actions: ["clearInputValue", "clearSelectedItems", "invokeOnClose", "setFinalFocus"]
          }
        ]
      }
    },
    suggesting: {
      tags: ["open", "focused"],
      effects: [
        "trackDismissableLayer",
        "scrollToHighlightedItem",
        "trackPlacement",
        "trackChildNodes",
        "hideOtherElements"
      ],
      entry: ["setInitialFocus"],
      on: {
        "CONTROLLED.CLOSE": [
          {
            guard: "restoreFocus",
            target: "focused",
            actions: ["setFinalFocus"]
          },
          {
            target: "idle"
          }
        ],
        CHILDREN_CHANGE: {
          guard: "autoHighlight",
          actions: ["highlightFirstItem"]
        },
        "INPUT.ARROW_DOWN": {
          target: "interacting",
          actions: ["highlightNextItem"]
        },
        "INPUT.ARROW_UP": {
          target: "interacting",
          actions: ["highlightPrevItem"]
        },
        "INPUT.HOME": {
          target: "interacting",
          actions: ["highlightFirstItem"]
        },
        "INPUT.END": {
          target: "interacting",
          actions: ["highlightLastItem"]
        },
        "INPUT.ENTER": [
          // == group 1 ==
          {
            guard: and4("isOpenControlled", "isCustomValue", not3("hasHighlightedItem"), not3("allowCustomValue")),
            actions: ["revertInputValue", "invokeOnClose"]
          },
          {
            guard: and4("isCustomValue", not3("hasHighlightedItem"), not3("allowCustomValue")),
            target: "focused",
            actions: ["revertInputValue", "invokeOnClose"]
          },
          // == group 2 ==
          {
            guard: and4("isOpenControlled", "closeOnSelect"),
            actions: ["selectHighlightedItem", "invokeOnClose"]
          },
          {
            guard: "closeOnSelect",
            target: "focused",
            actions: ["selectHighlightedItem", "invokeOnClose", "setFinalFocus"]
          },
          {
            actions: ["selectHighlightedItem"]
          }
        ],
        "INPUT.CHANGE": {
          actions: ["setInputValue"]
        },
        "LAYER.ESCAPE": [
          {
            guard: "isOpenControlled",
            actions: ["invokeOnClose"]
          },
          {
            target: "focused",
            actions: ["invokeOnClose"]
          }
        ],
        "ITEM.POINTER_MOVE": {
          target: "interacting",
          actions: ["setHighlightedItem"]
        },
        "ITEM.POINTER_LEAVE": {
          actions: ["clearHighlightedItem"]
        },
        "LAYER.INTERACT_OUTSIDE": [
          // == group 1 ==
          {
            guard: and4("isOpenControlled", "isCustomValue", not3("allowCustomValue")),
            actions: ["revertInputValue", "invokeOnClose"]
          },
          {
            guard: and4("isCustomValue", not3("allowCustomValue")),
            target: "idle",
            actions: ["revertInputValue", "invokeOnClose"]
          },
          // == group 2 ==
          {
            guard: "isOpenControlled",
            actions: ["invokeOnClose"]
          },
          {
            target: "idle",
            actions: ["invokeOnClose"]
          }
        ],
        "TRIGGER.CLICK": [
          {
            guard: "isOpenControlled",
            actions: ["invokeOnClose"]
          },
          {
            target: "focused",
            actions: ["invokeOnClose"]
          }
        ],
        "ITEM.CLICK": [
          {
            guard: and4("isOpenControlled", "closeOnSelect"),
            actions: ["selectItem", "invokeOnClose"]
          },
          {
            guard: "closeOnSelect",
            target: "focused",
            actions: ["selectItem", "invokeOnClose", "setFinalFocus"]
          },
          {
            actions: ["selectItem"]
          }
        ],
        CLOSE: [
          {
            guard: "isOpenControlled",
            actions: ["invokeOnClose"]
          },
          {
            target: "focused",
            actions: ["invokeOnClose", "setFinalFocus"]
          }
        ],
        "VALUE.CLEAR": [
          {
            guard: "isOpenControlled",
            actions: ["clearInputValue", "clearSelectedItems", "invokeOnClose"]
          },
          {
            target: "focused",
            actions: ["clearInputValue", "clearSelectedItems", "invokeOnClose", "setFinalFocus"]
          }
        ]
      }
    }
  },
  implementations: {
    guards: {
      isInputValueEmpty: ({ computed }) => computed("isInputValueEmpty"),
      autoComplete: ({ computed, prop }) => computed("autoComplete") && !prop("multiple"),
      autoHighlight: ({ computed }) => computed("autoHighlight"),
      isFirstItemHighlighted: ({ prop, context }) => prop("collection").firstValue === context.get("highlightedValue"),
      isLastItemHighlighted: ({ prop, context }) => prop("collection").lastValue === context.get("highlightedValue"),
      isCustomValue: ({ context }) => context.get("inputValue") !== context.get("valueAsString"),
      allowCustomValue: ({ prop }) => !!prop("allowCustomValue"),
      hasHighlightedItem: ({ context }) => context.get("highlightedValue") != null,
      closeOnSelect: ({ prop }) => !!prop("closeOnSelect"),
      isOpenControlled: ({ prop }) => prop("open") != null,
      openOnChange: ({ prop, context }) => {
        const openOnChange = prop("openOnChange");
        if (isBoolean(openOnChange)) return openOnChange;
        return !!(openOnChange == null ? void 0 : openOnChange({ inputValue: context.get("inputValue") }));
      },
      restoreFocus: ({ event }) => event.restoreFocus == null ? true : !!event.restoreFocus,
      isChangeEvent: ({ event }) => {
        var _a8;
        return ((_a8 = event.previousEvent) == null ? void 0 : _a8.type) === "INPUT.CHANGE";
      },
      autoFocus: ({ prop }) => !!prop("autoFocus")
    },
    effects: {
      trackDismissableLayer({ send, prop, scope }) {
        if (prop("disableLayer")) return;
        const contentEl = () => getContentEl4(scope);
        return trackDismissableElement(contentEl, {
          defer: true,
          exclude: () => [getInputEl2(scope), getTriggerEl3(scope), getClearTriggerEl2(scope)],
          onFocusOutside: prop("onFocusOutside"),
          onPointerDownOutside: prop("onPointerDownOutside"),
          onInteractOutside: prop("onInteractOutside"),
          onEscapeKeyDown(event) {
            event.preventDefault();
            event.stopPropagation();
            send({ type: "LAYER.ESCAPE" });
          },
          onDismiss() {
            send({ type: "LAYER.INTERACT_OUTSIDE", restoreFocus: false });
          }
        });
      },
      hideOtherElements({ scope }) {
        return ariaHidden([
          getInputEl2(scope),
          getContentEl4(scope),
          getTriggerEl3(scope),
          getClearTriggerEl2(scope)
        ]);
      },
      trackPlacement({ context, prop, scope }) {
        const anchorEl = () => getControlEl4(scope) || getTriggerEl3(scope);
        const positionerEl = () => getPositionerEl3(scope);
        context.set("currentPlacement", prop("positioning").placement);
        return getPlacement(anchorEl, positionerEl, {
          ...prop("positioning"),
          defer: true,
          onComplete(data) {
            context.set("currentPlacement", data.placement);
          }
        });
      },
      // in event the options are fetched (async), we still want to auto-highlight the first option
      trackChildNodes({ scope, computed, send }) {
        if (!computed("autoHighlight")) return;
        const exec = () => send({ type: "CHILDREN_CHANGE" });
        const contentEl = () => getContentEl4(scope);
        return observeChildren(contentEl, {
          callback: exec,
          defer: true
        });
      },
      scrollToHighlightedItem({ context, prop, scope, event }) {
        const inputEl = getInputEl2(scope);
        let cleanups = [];
        const exec = (immediate) => {
          const pointer = event.current().type.includes("POINTER");
          const highlightedValue = context.get("highlightedValue");
          if (pointer || !highlightedValue) return;
          const itemEl = getItemEl(scope, highlightedValue);
          const contentEl = getContentEl4(scope);
          const scrollToIndexFn = prop("scrollToIndexFn");
          if (scrollToIndexFn) {
            const highlightedIndex = prop("collection").indexOf(highlightedValue);
            scrollToIndexFn({ index: highlightedIndex, immediate });
            return;
          }
          const raf_cleanup = raf(() => {
            scrollIntoView(itemEl, { rootEl: contentEl, block: "nearest" });
          });
          cleanups.push(raf_cleanup);
        };
        const rafCleanup = raf(() => exec(true));
        cleanups.push(rafCleanup);
        const observerCleanup = observeAttributes(inputEl, {
          attributes: ["aria-activedescendant"],
          callback: () => exec(false)
        });
        cleanups.push(observerCleanup);
        return () => {
          cleanups.forEach((cleanup) => cleanup());
        };
      }
    },
    actions: {
      reposition({ context, prop, scope, event }) {
        const controlEl = () => getControlEl4(scope);
        const positionerEl = () => getPositionerEl3(scope);
        getPlacement(controlEl, positionerEl, {
          ...prop("positioning"),
          ...event.options,
          defer: true,
          listeners: false,
          onComplete(data) {
            context.set("currentPlacement", data.placement);
          }
        });
      },
      setHighlightedItem(params) {
        const { context, event } = params;
        if (event.value == null) return;
        context.set("highlightedValue", event.value);
      },
      clearHighlightedItem(params) {
        const { context } = params;
        context.set("highlightedValue", null);
      },
      selectHighlightedItem(params) {
        var _a8;
        const { context, prop } = params;
        const highlightedValue = context.get("highlightedValue");
        if (!highlightedValue) return;
        const nextValue = prop("multiple") ? addOrRemove(context.get("value"), highlightedValue) : [highlightedValue];
        (_a8 = prop("onSelect")) == null ? void 0 : _a8({ value: nextValue, itemValue: highlightedValue });
        context.set("value", nextValue);
        context.set("inputValue", getInputValue(params));
      },
      selectItem(params) {
        const { context, event, flush: flush2, prop } = params;
        if (event.value == null) return;
        flush2(() => {
          var _a8;
          const nextValue = prop("multiple") ? addOrRemove(context.get("value"), event.value) : [event.value];
          (_a8 = prop("onSelect")) == null ? void 0 : _a8({ value: nextValue, itemValue: event.value });
          context.set("value", nextValue);
          context.set("inputValue", getInputValue(params));
        });
      },
      clearItem(params) {
        const { context, event, flush: flush2 } = params;
        if (event.value == null) return;
        flush2(() => {
          const nextValue = remove(context.get("value"), event.value);
          context.set("value", nextValue);
          context.set("inputValue", getInputValue(params));
        });
      },
      setInitialFocus({ scope }) {
        raf(() => {
          focusInputEl(scope);
        });
      },
      setFinalFocus({ scope }) {
        raf(() => {
          const triggerEl = getTriggerEl3(scope);
          if ((triggerEl == null ? void 0 : triggerEl.dataset.focusable) == null) {
            focusInputEl(scope);
          } else {
            focusTriggerEl(scope);
          }
        });
      },
      syncInputValue({ context, scope, event }) {
        const inputEl = getInputEl2(scope);
        if (!inputEl) return;
        inputEl.value = context.get("inputValue");
        queueMicrotask(() => {
          if (event.current().type === "INPUT.CHANGE") return;
          setCaretToEnd(inputEl);
        });
      },
      setInputValue({ context, event }) {
        context.set("inputValue", event.value);
      },
      clearInputValue({ context }) {
        context.set("inputValue", "");
      },
      revertInputValue({ context, prop, computed }) {
        const selectionBehavior = prop("selectionBehavior");
        const inputValue = match(selectionBehavior, {
          replace: computed("hasSelectedItems") ? context.get("valueAsString") : "",
          preserve: context.get("inputValue"),
          clear: ""
        });
        context.set("inputValue", inputValue);
      },
      setValue(params) {
        const { context, flush: flush2, event } = params;
        flush2(() => {
          context.set("value", event.value);
          context.set("inputValue", getInputValue(params));
        });
      },
      clearSelectedItems(params) {
        const { context, flush: flush2 } = params;
        flush2(() => {
          context.set("value", []);
          context.set("inputValue", getInputValue(params));
        });
      },
      scrollContentToTop({ prop, scope }) {
        const scrollToIndexFn = prop("scrollToIndexFn");
        if (scrollToIndexFn) {
          scrollToIndexFn({ index: 0, immediate: true });
        } else {
          const contentEl = getContentEl4(scope);
          if (!contentEl) return;
          contentEl.scrollTop = 0;
        }
      },
      invokeOnOpen({ prop }) {
        var _a8;
        (_a8 = prop("onOpenChange")) == null ? void 0 : _a8({ open: true });
      },
      invokeOnClose({ prop }) {
        var _a8;
        (_a8 = prop("onOpenChange")) == null ? void 0 : _a8({ open: false });
      },
      highlightFirstItem({ context, prop, scope }) {
        const exec = getContentEl4(scope) ? queueMicrotask : raf;
        exec(() => {
          const value = prop("collection").firstValue;
          if (value) context.set("highlightedValue", value);
        });
      },
      highlightFirstItemIfNeeded({ computed, action }) {
        if (!computed("autoHighlight")) return;
        action(["highlightFirstItem"]);
      },
      highlightLastItem({ context, prop, scope }) {
        const exec = getContentEl4(scope) ? queueMicrotask : raf;
        exec(() => {
          const value = prop("collection").lastValue;
          if (value) context.set("highlightedValue", value);
        });
      },
      highlightNextItem({ context, prop }) {
        let value = null;
        const highlightedValue = context.get("highlightedValue");
        const collection22 = prop("collection");
        if (highlightedValue) {
          value = collection22.getNextValue(highlightedValue);
          if (!value && prop("loopFocus")) value = collection22.firstValue;
        } else {
          value = collection22.firstValue;
        }
        if (value) context.set("highlightedValue", value);
      },
      highlightPrevItem({ context, prop }) {
        let value = null;
        const highlightedValue = context.get("highlightedValue");
        const collection22 = prop("collection");
        if (highlightedValue) {
          value = collection22.getPreviousValue(highlightedValue);
          if (!value && prop("loopFocus")) value = collection22.lastValue;
        } else {
          value = collection22.lastValue;
        }
        if (value) context.set("highlightedValue", value);
      },
      highlightFirstSelectedItem({ context, prop }) {
        raf(() => {
          const [value] = prop("collection").sort(context.get("value"));
          if (value) context.set("highlightedValue", value);
        });
      },
      highlightFirstOrSelectedItem({ context, prop, computed }) {
        raf(() => {
          let value = null;
          if (computed("hasSelectedItems")) {
            value = prop("collection").sort(context.get("value"))[0];
          } else {
            value = prop("collection").firstValue;
          }
          if (value) context.set("highlightedValue", value);
        });
      },
      highlightLastOrSelectedItem({ context, prop, computed }) {
        raf(() => {
          const collection22 = prop("collection");
          let value = null;
          if (computed("hasSelectedItems")) {
            value = collection22.sort(context.get("value"))[0];
          } else {
            value = collection22.lastValue;
          }
          if (value) context.set("highlightedValue", value);
        });
      },
      autofillInputValue({ context, computed, prop, event, scope }) {
        const inputEl = getInputEl2(scope);
        const collection22 = prop("collection");
        if (!computed("autoComplete") || !inputEl || !event.keypress) return;
        const valueText = collection22.stringify(context.get("highlightedValue"));
        raf(() => {
          inputEl.value = valueText || context.get("inputValue");
        });
      },
      syncSelectedItems(params) {
        const { context, prop } = params;
        const inputValue = match(prop("selectionBehavior"), {
          preserve: context.get("inputValue"),
          replace: prop("collection").stringifyMany(context.get("value")),
          clear: ""
        });
        context.set("selectedItems", getSelectedItems(params));
        context.set("inputValue", inputValue);
      },
      syncHighlightedItem({ context, prop }) {
        const item = prop("collection").find(context.get("highlightedValue"));
        context.set("highlightedItem", item);
      },
      toggleVisibility({ event, send, prop }) {
        send({ type: prop("open") ? "CONTROLLED.OPEN" : "CONTROLLED.CLOSE", previousEvent: event });
      }
    }
  }
});
function getInputValue({ context, prop }) {
  return match(prop("selectionBehavior"), {
    preserve: context.get("inputValue"),
    replace: context.get("valueAsString"),
    clear: ""
  });
}
function getSelectedItems({ context, prop }) {
  const collection22 = prop("collection");
  return context.get("value").map((v) => {
    const foundItem = context.get("selectedItems").find((item) => collection22.getItemValue(item) === v);
    if (foundItem) return foundItem;
    return collection22.find(v);
  });
}
var props11 = createProps()([
  "allowCustomValue",
  "autoFocus",
  "closeOnSelect",
  "collection",
  "composite",
  "defaultHighlightedValue",
  "defaultInputValue",
  "defaultOpen",
  "defaultValue",
  "dir",
  "disabled",
  "disableLayer",
  "form",
  "getRootNode",
  "highlightedValue",
  "id",
  "ids",
  "inputBehavior",
  "inputValue",
  "invalid",
  "loopFocus",
  "multiple",
  "name",
  "navigate",
  "onFocusOutside",
  "onHighlightChange",
  "onInputValueChange",
  "onInteractOutside",
  "onOpenChange",
  "onOpenChange",
  "onPointerDownOutside",
  "onSelect",
  "onValueChange",
  "open",
  "openOnChange",
  "openOnClick",
  "openOnKeyPress",
  "placeholder",
  "positioning",
  "readOnly",
  "required",
  "scrollToIndexFn",
  "selectionBehavior",
  "translations",
  "value"
]);
var splitProps11 = createSplitProps(props11);
var itemGroupLabelProps = createProps()(["htmlFor"]);
var splitItemGroupLabelProps = createSplitProps(itemGroupLabelProps);
var itemGroupProps = createProps()(["id"]);
var splitItemGroupProps = createSplitProps(itemGroupProps);
var itemProps3 = createProps()(["item", "persistFocus"]);
var splitItemProps3 = createSplitProps(itemProps3);

// node_modules/@ark-ui/react/dist/components/combobox/use-combobox.js
var import_react221 = __toESM(require_react(), 1);
var useCombobox = (props43) => {
  const id = (0, import_react221.useId)();
  const { dir } = useLocaleContext();
  const { getRootNode } = useEnvironmentContext();
  const field = useFieldContext();
  const machineProps = {
    id,
    ids: {
      label: field == null ? void 0 : field.ids.label,
      input: field == null ? void 0 : field.ids.control
    },
    disabled: field == null ? void 0 : field.disabled,
    readOnly: field == null ? void 0 : field.readOnly,
    required: field == null ? void 0 : field.required,
    invalid: field == null ? void 0 : field.invalid,
    dir,
    getRootNode,
    ...props43
  };
  const service = useMachine(machine11, machineProps);
  return connect11(service, normalizeProps);
};

// node_modules/@ark-ui/react/dist/components/combobox/combobox-root.js
var ComboboxImpl = (props43, ref) => {
  const [presenceProps, comboboxProps] = splitPresenceProps(props43);
  const [useComboboxProps, localProps] = createSplitProps2()(comboboxProps, [
    "allowCustomValue",
    "autoFocus",
    "closeOnSelect",
    "collection",
    "composite",
    "defaultHighlightedValue",
    "defaultInputValue",
    "defaultOpen",
    "defaultValue",
    "disabled",
    "disableLayer",
    "form",
    "highlightedValue",
    "id",
    "ids",
    "inputBehavior",
    "inputValue",
    "invalid",
    "loopFocus",
    "multiple",
    "name",
    "navigate",
    "onFocusOutside",
    "onHighlightChange",
    "onInputValueChange",
    "onInteractOutside",
    "onOpenChange",
    "onPointerDownOutside",
    "onSelect",
    "onValueChange",
    "open",
    "openOnChange",
    "openOnClick",
    "openOnKeyPress",
    "placeholder",
    "positioning",
    "readOnly",
    "required",
    "scrollToIndexFn",
    "selectionBehavior",
    "translations",
    "value"
  ]);
  const combobox = useCombobox(useComboboxProps);
  const presence = usePresence(mergeProps2({ present: combobox.open }, presenceProps));
  const mergedProps = mergeProps2(combobox.getRootProps(), localProps);
  return (0, import_jsx_runtime103.jsx)(ComboboxProvider, { value: combobox, children: (0, import_jsx_runtime103.jsx)(PresenceProvider, { value: presence, children: (0, import_jsx_runtime103.jsx)(ark.div, { ...mergedProps, ref }) }) });
};
var ComboboxRoot = (0, import_react223.forwardRef)(ComboboxImpl);

// node_modules/@ark-ui/react/dist/components/combobox/combobox-root-provider.js
var import_jsx_runtime104 = __toESM(require_jsx_runtime(), 1);
var import_react225 = __toESM(require_react(), 1);
var ComboboxImpl2 = (props43, ref) => {
  const [presenceProps, comboboxProps] = splitPresenceProps(props43);
  const [{ value: combobox }, localProps] = createSplitProps2()(comboboxProps, ["value"]);
  const presence = usePresence(mergeProps2({ present: combobox.open }, presenceProps));
  const mergedProps = mergeProps2(combobox.getRootProps(), localProps);
  return (0, import_jsx_runtime104.jsx)(ComboboxProvider, { value: combobox, children: (0, import_jsx_runtime104.jsx)(PresenceProvider, { value: presence, children: (0, import_jsx_runtime104.jsx)(ark.div, { ...mergedProps, ref }) }) });
};
var ComboboxRootProvider = (0, import_react225.forwardRef)(ComboboxImpl2);

// node_modules/@ark-ui/react/dist/components/combobox/combobox-trigger.js
var import_jsx_runtime105 = __toESM(require_jsx_runtime(), 1);
var import_react227 = __toESM(require_react(), 1);
var ComboboxTrigger = (0, import_react227.forwardRef)((props43, ref) => {
  const [triggerProps2, localProps] = createSplitProps2()(props43, ["focusable"]);
  const combobox = useComboboxContext();
  const mergedProps = mergeProps2(combobox.getTriggerProps(triggerProps2), localProps);
  return (0, import_jsx_runtime105.jsx)(ark.button, { ...mergedProps, ref });
});
ComboboxTrigger.displayName = "ComboboxTrigger";

// node_modules/@ark-ui/react/dist/components/combobox/combobox.js
var combobox_exports = {};
__export(combobox_exports, {
  ClearTrigger: () => ComboboxClearTrigger,
  Content: () => ComboboxContent,
  Context: () => ComboboxContext,
  Control: () => ComboboxControl,
  Input: () => ComboboxInput,
  Item: () => ComboboxItem,
  ItemContext: () => ComboboxItemContext,
  ItemGroup: () => ComboboxItemGroup,
  ItemGroupLabel: () => ComboboxItemGroupLabel,
  ItemIndicator: () => ComboboxItemIndicator,
  ItemText: () => ComboboxItemText,
  Label: () => ComboboxLabel,
  List: () => ComboboxList,
  Positioner: () => ComboboxPositioner,
  Root: () => ComboboxRoot,
  RootProvider: () => ComboboxRootProvider,
  Trigger: () => ComboboxTrigger
});

// node_modules/@ark-ui/react/dist/components/date-picker/date-picker-clear-trigger.js
var import_jsx_runtime106 = __toESM(require_jsx_runtime(), 1);
var import_react229 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/date-picker/use-date-picker-context.js
var [DatePickerProvider, useDatePickerContext] = createContext3({
  name: "DatePickerContext",
  hookName: "useDatePickerContext",
  providerName: "<DatePickerProvider />"
});

// node_modules/@ark-ui/react/dist/components/date-picker/date-picker-clear-trigger.js
var DatePickerClearTrigger = (0, import_react229.forwardRef)((props43, ref) => {
  const datePicker = useDatePickerContext();
  const mergedProps = mergeProps2(datePicker.getClearTriggerProps(), props43);
  return (0, import_jsx_runtime106.jsx)(ark.button, { ...mergedProps, ref });
});
DatePickerClearTrigger.displayName = "DatePickerClearTrigger";

// node_modules/@ark-ui/react/dist/components/date-picker/date-picker-content.js
var import_jsx_runtime107 = __toESM(require_jsx_runtime(), 1);
var import_react231 = __toESM(require_react(), 1);
var DatePickerContent = (0, import_react231.forwardRef)((props43, ref) => {
  const datePicker = useDatePickerContext();
  const presence = usePresenceContext();
  const mergedProps = mergeProps2(datePicker.getContentProps(), presence.getPresenceProps(), props43);
  if (presence.unmounted) {
    return null;
  }
  return (0, import_jsx_runtime107.jsx)(ark.div, { ...mergedProps, ref: composeRefs(presence.ref, ref) });
});
DatePickerContent.displayName = "DatePickerContent";

// node_modules/@ark-ui/react/dist/components/date-picker/date-picker-control.js
var import_jsx_runtime108 = __toESM(require_jsx_runtime(), 1);
var import_react233 = __toESM(require_react(), 1);
var DatePickerControl = (0, import_react233.forwardRef)((props43, ref) => {
  const datePicker = useDatePickerContext();
  const mergedProps = mergeProps2(datePicker.getControlProps(), props43);
  return (0, import_jsx_runtime108.jsx)(ark.div, { ...mergedProps, ref });
});
DatePickerControl.displayName = "DatePickerControl";

// node_modules/@ark-ui/react/dist/components/date-picker/date-picker-input.js
var import_jsx_runtime109 = __toESM(require_jsx_runtime(), 1);
var import_react235 = __toESM(require_react(), 1);
var DatePickerInput = (0, import_react235.forwardRef)((props43, ref) => {
  const [inputProps2, localProps] = createSplitProps2()(props43, ["index", "fixOnBlur"]);
  const datePicker = useDatePickerContext();
  const mergedProps = mergeProps2(datePicker.getInputProps(inputProps2), localProps);
  return (0, import_jsx_runtime109.jsx)(ark.input, { ...mergedProps, ref });
});
DatePickerInput.displayName = "DatePickerInput";

// node_modules/@ark-ui/react/dist/components/date-picker/date-picker-label.js
var import_jsx_runtime110 = __toESM(require_jsx_runtime(), 1);
var import_react237 = __toESM(require_react(), 1);
var DatePickerLabel = (0, import_react237.forwardRef)((props43, ref) => {
  const datePicker = useDatePickerContext();
  const mergedProps = mergeProps2(datePicker.getLabelProps(), props43);
  return (0, import_jsx_runtime110.jsx)(ark.label, { ...mergedProps, ref });
});
DatePickerLabel.displayName = "DatePickerLabel";

// node_modules/@ark-ui/react/dist/components/date-picker/date-picker-month-select.js
var import_jsx_runtime111 = __toESM(require_jsx_runtime(), 1);
var import_react239 = __toESM(require_react(), 1);
var DatePickerMonthSelect = (0, import_react239.forwardRef)((props43, ref) => {
  const datePicker = useDatePickerContext();
  const mergedProps = mergeProps2(datePicker.getMonthSelectProps(), props43);
  return (0, import_jsx_runtime111.jsx)(ark.select, { ...mergedProps, ref, children: datePicker.getMonths().map((month, i) => (0, import_jsx_runtime111.jsx)("option", { value: month.value, children: month.label }, i)) });
});
DatePickerMonthSelect.displayName = "DatePickerMonthSelect";

// node_modules/@ark-ui/react/dist/components/date-picker/date-picker-next-trigger.js
var import_jsx_runtime112 = __toESM(require_jsx_runtime(), 1);
var import_react241 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/date-picker/use-date-picker-view-props-context.js
var [DatePickerViewPropsProvider, useDatePickerViewPropsContext] = createContext3({
  name: "DatePickerViewContext",
  hookName: "useDatePickerViewContext",
  providerName: "<DatePickerViewProvider />",
  strict: false,
  defaultValue: { view: "day" }
});

// node_modules/@ark-ui/react/dist/components/date-picker/date-picker-next-trigger.js
var DatePickerNextTrigger = (0, import_react241.forwardRef)((props43, ref) => {
  const datePicker = useDatePickerContext();
  const viewProps2 = useDatePickerViewPropsContext();
  const mergedProps = mergeProps2(datePicker.getNextTriggerProps(viewProps2), props43);
  return (0, import_jsx_runtime112.jsx)(ark.button, { ...mergedProps, ref });
});
DatePickerNextTrigger.displayName = "DatePickerNextTrigger";

// node_modules/@ark-ui/react/dist/components/date-picker/date-picker-positioner.js
var import_jsx_runtime113 = __toESM(require_jsx_runtime(), 1);
var import_react243 = __toESM(require_react(), 1);
var DatePickerPositioner = (0, import_react243.forwardRef)((props43, ref) => {
  const datePicker = useDatePickerContext();
  const mergedProps = mergeProps2(datePicker.getPositionerProps(), props43);
  const presence = usePresenceContext();
  if (presence.unmounted) {
    return null;
  }
  return (0, import_jsx_runtime113.jsx)(ark.div, { ...mergedProps, ref });
});
DatePickerPositioner.displayName = "DatePickerPositioner";

// node_modules/@ark-ui/react/dist/components/date-picker/date-picker-preset-trigger.js
var import_jsx_runtime114 = __toESM(require_jsx_runtime(), 1);
var import_react245 = __toESM(require_react(), 1);
var DatePickerPresetTrigger = (0, import_react245.forwardRef)((props43, ref) => {
  const [presetTriggerProps2, localProps] = createSplitProps2()(props43, ["value"]);
  const datePicker = useDatePickerContext();
  const mergedProps = mergeProps2(datePicker.getPresetTriggerProps(presetTriggerProps2), localProps);
  return (0, import_jsx_runtime114.jsx)(ark.button, { ...mergedProps, ref });
});
DatePickerPresetTrigger.displayName = "DatePickerPresetTrigger";

// node_modules/@ark-ui/react/dist/components/date-picker/date-picker-prev-trigger.js
var import_jsx_runtime115 = __toESM(require_jsx_runtime(), 1);
var import_react247 = __toESM(require_react(), 1);
var DatePickerPrevTrigger = (0, import_react247.forwardRef)((props43, ref) => {
  const datePicker = useDatePickerContext();
  const viewProps2 = useDatePickerViewPropsContext();
  const mergedProps = mergeProps2(datePicker.getPrevTriggerProps(viewProps2), props43);
  return (0, import_jsx_runtime115.jsx)(ark.button, { ...mergedProps, ref });
});
DatePickerPrevTrigger.displayName = "DatePickerPrevTrigger";

// node_modules/@ark-ui/react/dist/components/date-picker/date-picker-range-text.js
var import_jsx_runtime116 = __toESM(require_jsx_runtime(), 1);
var import_react249 = __toESM(require_react(), 1);
var DatePickerRangeText = (0, import_react249.forwardRef)((props43, ref) => {
  const datePicker = useDatePickerContext();
  const mergedProps = mergeProps2(datePicker.getRangeTextProps(), props43);
  return (0, import_jsx_runtime116.jsx)(ark.div, { ...mergedProps, ref, children: datePicker.visibleRangeText.start });
});
DatePickerRangeText.displayName = "DatePickerRangeText";

// node_modules/@ark-ui/react/dist/components/date-picker/date-picker-root.js
var import_jsx_runtime117 = __toESM(require_jsx_runtime(), 1);
var import_react253 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/date-picker/use-date-picker.js
var import_react251 = __toESM(require_react(), 1);
var useDatePicker = (props43) => {
  const id = (0, import_react251.useId)();
  const { getRootNode } = useEnvironmentContext();
  const { dir, locale } = useLocaleContext();
  const machineProps = {
    id,
    dir,
    locale,
    getRootNode,
    ...props43
  };
  const service = useMachine(machine4, machineProps);
  return connect4(service, normalizeProps);
};

// node_modules/@ark-ui/react/dist/components/date-picker/date-picker-root.js
var DatePickerRoot = (0, import_react253.forwardRef)((props43, ref) => {
  const [presenceProps, datePickerProps] = splitPresenceProps(props43);
  const [useDatePickerProps, localProps] = createSplitProps2()(datePickerProps, [
    "closeOnSelect",
    "defaultFocusedValue",
    "defaultOpen",
    "defaultValue",
    "defaultView",
    "disabled",
    "fixedWeeks",
    "focusedValue",
    "format",
    "id",
    "ids",
    "isDateUnavailable",
    "locale",
    "max",
    "maxView",
    "min",
    "minView",
    "name",
    "numOfMonths",
    "onFocusChange",
    "onOpenChange",
    "onValueChange",
    "onViewChange",
    "open",
    "outsideDaySelectable",
    "parse",
    "placeholder",
    "positioning",
    "readOnly",
    "selectionMode",
    "startOfWeek",
    "timeZone",
    "translations",
    "value",
    "view"
  ]);
  const datePicker = useDatePicker(useDatePickerProps);
  const presence = usePresence(mergeProps2({ present: datePicker.open }, presenceProps));
  const mergedProps = mergeProps2(datePicker.getRootProps(), localProps);
  return (0, import_jsx_runtime117.jsx)(DatePickerProvider, { value: datePicker, children: (0, import_jsx_runtime117.jsx)(PresenceProvider, { value: presence, children: (0, import_jsx_runtime117.jsx)(ark.div, { ...mergedProps, ref }) }) });
});
DatePickerRoot.displayName = "DatePickerRoot";

// node_modules/@ark-ui/react/dist/components/date-picker/date-picker-root-provider.js
var import_jsx_runtime118 = __toESM(require_jsx_runtime(), 1);
var import_react255 = __toESM(require_react(), 1);
var DatePickerRootProvider = (0, import_react255.forwardRef)((props43, ref) => {
  const [presenceProps, datePickerProps] = splitPresenceProps(props43);
  const [{ value: datePicker }, localProps] = createSplitProps2()(datePickerProps, ["value"]);
  const presence = usePresence(mergeProps2({ present: datePicker.open }, presenceProps));
  const mergedProps = mergeProps2(datePicker.getRootProps(), localProps);
  return (0, import_jsx_runtime118.jsx)(DatePickerProvider, { value: datePicker, children: (0, import_jsx_runtime118.jsx)(PresenceProvider, { value: presence, children: (0, import_jsx_runtime118.jsx)(ark.div, { ...mergedProps, ref }) }) });
});
DatePickerRootProvider.displayName = "DatePickerRootProvider";

// node_modules/@ark-ui/react/dist/components/date-picker/date-picker-table.js
var import_jsx_runtime119 = __toESM(require_jsx_runtime(), 1);
var import_react257 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/date-picker/use-date-picker-table-props-context.js
var [DatePickerTablePropsProvider, useDatePickerTablePropsContext] = createContext3({
  name: "DatePickerTableContext",
  hookName: "useDatePickerTableContext",
  providerName: "<DatePickerTableProvider />"
});

// node_modules/@ark-ui/react/dist/components/date-picker/date-picker-table.js
var DatePickerTable = (0, import_react257.forwardRef)((props43, ref) => {
  const [{ columns }, localProps] = createSplitProps2()(props43, ["columns"]);
  const datePicker = useDatePickerContext();
  const viewProps2 = useDatePickerViewPropsContext();
  const tableProps2 = { columns, id: (0, import_react257.useId)(), ...viewProps2 };
  const mergedProps = mergeProps2(datePicker.getTableProps(tableProps2), localProps);
  return (0, import_jsx_runtime119.jsx)(DatePickerTablePropsProvider, { value: tableProps2, children: (0, import_jsx_runtime119.jsx)(ark.table, { ...mergedProps, ref }) });
});
DatePickerTable.displayName = "DatePickerTable";

// node_modules/@ark-ui/react/dist/components/date-picker/date-picker-table-body.js
var import_jsx_runtime120 = __toESM(require_jsx_runtime(), 1);
var import_react259 = __toESM(require_react(), 1);
var DatePickerTableBody = (0, import_react259.forwardRef)((props43, ref) => {
  const datePicker = useDatePickerContext();
  const tableProps2 = useDatePickerTablePropsContext();
  const mergedProps = mergeProps2(datePicker.getTableBodyProps(tableProps2), props43);
  return (0, import_jsx_runtime120.jsx)(ark.tbody, { ...mergedProps, ref });
});
DatePickerTableBody.displayName = "DatePickerTableBody";

// node_modules/@ark-ui/react/dist/components/date-picker/date-picker-table-cell.js
var import_jsx_runtime121 = __toESM(require_jsx_runtime(), 1);
var import_react261 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/date-picker/use-date-picker-table-cell-props-context.js
var [DatePickerTableCellPropsProvider, useDatePickerTableCellPropsContext] = createContext3({
  name: "DatePickerTableCellContext",
  hookName: "useDatePickerTableCellContext",
  providerName: "<DatePickerTableCellProvider />"
});

// node_modules/@ark-ui/react/dist/components/date-picker/date-picker-table-cell.js
var DatePickerTableCell = (0, import_react261.forwardRef)((props43, ref) => {
  const [cellProps, localProps] = createSplitProps2()(props43, [
    "disabled",
    "value",
    "visibleRange",
    "columns"
  ]);
  const datePicker = useDatePickerContext();
  const viewProps2 = useDatePickerViewPropsContext();
  const tableCellProps2 = {
    day: datePicker.getDayTableCellProps,
    month: datePicker.getMonthTableCellProps,
    year: datePicker.getYearTableCellProps
    // @ts-expect-error value is number filter
  }[viewProps2.view](cellProps);
  const mergedProps = mergeProps2(tableCellProps2, localProps);
  return (0, import_jsx_runtime121.jsx)(DatePickerTableCellPropsProvider, { value: cellProps, children: (0, import_jsx_runtime121.jsx)(ark.td, { ref, ...mergedProps }) });
});
DatePickerTableCell.displayName = "DatePickerTableCell";

// node_modules/@ark-ui/react/dist/components/date-picker/date-picker-table-cell-trigger.js
var import_jsx_runtime122 = __toESM(require_jsx_runtime(), 1);
var import_react263 = __toESM(require_react(), 1);
var DatePickerTableCellTrigger = (0, import_react263.forwardRef)((props43, ref) => {
  const datePicker = useDatePickerContext();
  const tableCellProps2 = useDatePickerTableCellPropsContext();
  const viewProps2 = useDatePickerViewPropsContext();
  const viewMap = {
    day: datePicker.getDayTableCellTriggerProps,
    month: datePicker.getMonthTableCellTriggerProps,
    year: datePicker.getYearTableCellTriggerProps
  };
  const viewFn = viewMap[viewProps2.view];
  const triggerProps2 = viewFn(tableCellProps2);
  const mergedProps = mergeProps2(triggerProps2, props43);
  return (0, import_jsx_runtime122.jsx)(ark.div, { ref, ...mergedProps });
});
DatePickerTableCellTrigger.displayName = "DatePickerTableCellTrigger";

// node_modules/@ark-ui/react/dist/components/date-picker/date-picker-table-head.js
var import_jsx_runtime123 = __toESM(require_jsx_runtime(), 1);
var import_react265 = __toESM(require_react(), 1);
var DatePickerTableHead = (0, import_react265.forwardRef)((props43, ref) => {
  const datePicker = useDatePickerContext();
  const tableProps2 = useDatePickerTablePropsContext();
  const mergedProps = mergeProps2(datePicker.getTableHeadProps(tableProps2), props43);
  return (0, import_jsx_runtime123.jsx)(ark.thead, { ...mergedProps, ref });
});
DatePickerTableHead.displayName = "DatePickerTableHead";

// node_modules/@ark-ui/react/dist/components/date-picker/date-picker-table-header.js
var import_jsx_runtime124 = __toESM(require_jsx_runtime(), 1);
var import_react267 = __toESM(require_react(), 1);
var DatePickerTableHeader = (0, import_react267.forwardRef)((props43, ref) => {
  const datePicker = useDatePickerContext();
  const tableProps2 = useDatePickerTablePropsContext();
  const mergedProps = mergeProps2(datePicker.getTableHeaderProps(tableProps2), props43);
  return (0, import_jsx_runtime124.jsx)(ark.th, { ...mergedProps, ref });
});
DatePickerTableHeader.displayName = "DatePickerTableHeader";

// node_modules/@ark-ui/react/dist/components/date-picker/date-picker-table-row.js
var import_jsx_runtime125 = __toESM(require_jsx_runtime(), 1);
var import_react269 = __toESM(require_react(), 1);
var DatePickerTableRow = (0, import_react269.forwardRef)((props43, ref) => {
  const datePicker = useDatePickerContext();
  const tableProps2 = useDatePickerTablePropsContext();
  const mergedProps = mergeProps2(datePicker.getTableRowProps(tableProps2), props43);
  return (0, import_jsx_runtime125.jsx)(ark.tr, { ...mergedProps, ref });
});
DatePickerTableRow.displayName = "DatePickerTableRow";

// node_modules/@ark-ui/react/dist/components/date-picker/date-picker-trigger.js
var import_jsx_runtime126 = __toESM(require_jsx_runtime(), 1);
var import_react271 = __toESM(require_react(), 1);
var DatePickerTrigger = (0, import_react271.forwardRef)((props43, ref) => {
  const datePicker = useDatePickerContext();
  const mergedProps = mergeProps2(datePicker.getTriggerProps(), props43);
  return (0, import_jsx_runtime126.jsx)(ark.button, { ...mergedProps, ref });
});
DatePickerTrigger.displayName = "DatePickerTrigger";

// node_modules/@ark-ui/react/dist/components/date-picker/date-picker-view.js
var import_jsx_runtime127 = __toESM(require_jsx_runtime(), 1);
var import_react272 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/date-picker/date-picker.anatomy.js
var datePickerAnatomy = anatomy3.extendWith("view");

// node_modules/@ark-ui/react/dist/components/date-picker/date-picker-view.js
var DatePickerView = (0, import_react272.forwardRef)((props43, ref) => {
  const [viewProps2, localProps] = createSplitProps2()(props43, ["view"]);
  const datePicker = useDatePickerContext();
  return (0, import_jsx_runtime127.jsx)(DatePickerViewPropsProvider, { value: viewProps2, children: (0, import_jsx_runtime127.jsx)(
    ark.div,
    {
      hidden: datePicker.view !== viewProps2.view,
      ...datePickerAnatomy.build().view.attrs,
      ...localProps,
      ref
    }
  ) });
});
DatePickerView.displayName = "DatePickerView";

// node_modules/@ark-ui/react/dist/components/date-picker/date-picker-view-control.js
var import_jsx_runtime128 = __toESM(require_jsx_runtime(), 1);
var import_react274 = __toESM(require_react(), 1);
var DatePickerViewControl = (0, import_react274.forwardRef)((props43, ref) => {
  const datePicker = useDatePickerContext();
  const viewProps2 = useDatePickerViewPropsContext();
  const mergedProps = mergeProps2(datePicker.getViewControlProps(viewProps2), props43);
  return (0, import_jsx_runtime128.jsx)(ark.div, { ...mergedProps, ref });
});
DatePickerViewControl.displayName = "DatePickerViewControl";

// node_modules/@ark-ui/react/dist/components/date-picker/date-picker-view-trigger.js
var import_jsx_runtime129 = __toESM(require_jsx_runtime(), 1);
var import_react276 = __toESM(require_react(), 1);
var DatePickerViewTrigger = (0, import_react276.forwardRef)((props43, ref) => {
  const datePicker = useDatePickerContext();
  const viewProps2 = useDatePickerViewPropsContext();
  const mergedProps = mergeProps2(datePicker.getViewTriggerProps(viewProps2), props43);
  return (0, import_jsx_runtime129.jsx)(ark.button, { ...mergedProps, ref });
});
DatePickerViewTrigger.displayName = "DatePickerViewTrigger";

// node_modules/@ark-ui/react/dist/components/date-picker/date-picker-year-select.js
var import_jsx_runtime130 = __toESM(require_jsx_runtime(), 1);
var import_react278 = __toESM(require_react(), 1);
var DatePickerYearSelect = (0, import_react278.forwardRef)((props43, ref) => {
  const datePicker = useDatePickerContext();
  const mergedProps = mergeProps2(datePicker.getYearSelectProps(), props43);
  return (0, import_jsx_runtime130.jsx)(ark.select, { ...mergedProps, ref, children: datePicker.getYears().map((year, i) => (0, import_jsx_runtime130.jsx)("option", { value: year.value, children: year.label }, i)) });
});
DatePickerYearSelect.displayName = "DatePickerYearSelect";

// node_modules/@ark-ui/react/dist/components/dialog/dialog-backdrop.js
var import_jsx_runtime131 = __toESM(require_jsx_runtime(), 1);
var import_react280 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/dialog/use-dialog-context.js
var [DialogProvider, useDialogContext] = createContext3({
  name: "DialogContext",
  hookName: "useDialogContext",
  providerName: "<DialogProvider />"
});

// node_modules/@ark-ui/react/dist/components/dialog/dialog-backdrop.js
var DialogBackdrop = (0, import_react280.forwardRef)((props43, ref) => {
  const dialog = useDialogContext();
  const renderStrategyProps = useRenderStrategyPropsContext();
  const presence = usePresence({ ...renderStrategyProps, present: dialog.open });
  const mergedProps = mergeProps2(dialog.getBackdropProps(), presence.getPresenceProps(), props43);
  if (presence.unmounted) {
    return null;
  }
  return (0, import_jsx_runtime131.jsx)(ark.div, { ...mergedProps, ref: composeRefs(presence.ref, ref) });
});
DialogBackdrop.displayName = "DialogBackdrop";

// node_modules/@ark-ui/react/dist/components/dialog/dialog-close-trigger.js
var import_jsx_runtime132 = __toESM(require_jsx_runtime(), 1);
var import_react282 = __toESM(require_react(), 1);
var DialogCloseTrigger = (0, import_react282.forwardRef)((props43, ref) => {
  const dialog = useDialogContext();
  const mergedProps = mergeProps2(dialog.getCloseTriggerProps(), props43);
  return (0, import_jsx_runtime132.jsx)(ark.button, { ...mergedProps, ref });
});
DialogCloseTrigger.displayName = "DialogCloseTrigger";

// node_modules/@ark-ui/react/dist/components/dialog/dialog-content.js
var import_jsx_runtime133 = __toESM(require_jsx_runtime(), 1);
var import_react284 = __toESM(require_react(), 1);
var DialogContent = (0, import_react284.forwardRef)((props43, ref) => {
  const dialog = useDialogContext();
  const presence = usePresenceContext();
  const mergedProps = mergeProps2(dialog.getContentProps(), presence.getPresenceProps(), props43);
  if (presence.unmounted) {
    return null;
  }
  return (0, import_jsx_runtime133.jsx)(ark.div, { ...mergedProps, ref: composeRefs(presence.ref, ref) });
});
DialogContent.displayName = "DialogContent";

// node_modules/@ark-ui/react/dist/components/dialog/dialog-context.js
var DialogContext = (props43) => props43.children(useDialogContext());

// node_modules/@ark-ui/react/dist/components/dialog/dialog-description.js
var import_jsx_runtime134 = __toESM(require_jsx_runtime(), 1);
var import_react286 = __toESM(require_react(), 1);
var DialogDescription = (0, import_react286.forwardRef)((props43, ref) => {
  const dialog = useDialogContext();
  const mergedProps = mergeProps2(dialog.getDescriptionProps(), props43);
  return (0, import_jsx_runtime134.jsx)(ark.div, { ...mergedProps, ref });
});
DialogDescription.displayName = "DialogDescription";

// node_modules/@ark-ui/react/dist/components/dialog/dialog-positioner.js
var import_jsx_runtime135 = __toESM(require_jsx_runtime(), 1);
var import_react288 = __toESM(require_react(), 1);
var DialogPositioner = (0, import_react288.forwardRef)((props43, ref) => {
  const dialog = useDialogContext();
  const mergedProps = mergeProps2(dialog.getPositionerProps(), props43);
  const presence = usePresenceContext();
  if (presence.unmounted) {
    return null;
  }
  return (0, import_jsx_runtime135.jsx)(ark.div, { ...mergedProps, ref });
});
DialogPositioner.displayName = "DialogPositioner";

// node_modules/@ark-ui/react/dist/components/dialog/dialog-root.js
var import_jsx_runtime136 = __toESM(require_jsx_runtime(), 1);

// node_modules/@zag-js/focus-trap/dist/index.mjs
var __defProp4 = Object.defineProperty;
var __defNormalProp4 = (obj, key, value) => key in obj ? __defProp4(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField4 = (obj, key, value) => __defNormalProp4(obj, typeof key !== "symbol" ? key + "" : key, value);
var activeFocusTraps = {
  activateTrap(trapStack, trap) {
    if (trapStack.length > 0) {
      const activeTrap = trapStack[trapStack.length - 1];
      if (activeTrap !== trap) {
        activeTrap.pause();
      }
    }
    const trapIndex = trapStack.indexOf(trap);
    if (trapIndex === -1) {
      trapStack.push(trap);
    } else {
      trapStack.splice(trapIndex, 1);
      trapStack.push(trap);
    }
  },
  deactivateTrap(trapStack, trap) {
    const trapIndex = trapStack.indexOf(trap);
    if (trapIndex !== -1) {
      trapStack.splice(trapIndex, 1);
    }
    if (trapStack.length > 0) {
      trapStack[trapStack.length - 1].unpause();
    }
  }
};
var sharedTrapStack = [];
var FocusTrap = class {
  constructor(elements, options) {
    __publicField4(this, "trapStack");
    __publicField4(this, "config");
    __publicField4(this, "doc");
    __publicField4(this, "state", {
      containers: [],
      containerGroups: [],
      tabbableGroups: [],
      nodeFocusedBeforeActivation: null,
      mostRecentlyFocusedNode: null,
      active: false,
      paused: false,
      delayInitialFocusTimer: void 0,
      recentNavEvent: void 0
    });
    __publicField4(this, "listenerCleanups", []);
    __publicField4(this, "handleFocus", (event) => {
      const target = getEventTarget(event);
      const targetContained = this.findContainerIndex(target, event) >= 0;
      if (targetContained || isDocument(target)) {
        if (targetContained) {
          this.state.mostRecentlyFocusedNode = target;
        }
      } else {
        event.stopImmediatePropagation();
        let nextNode;
        let navAcrossContainers = true;
        if (this.state.mostRecentlyFocusedNode) {
          if (getTabIndex(this.state.mostRecentlyFocusedNode) > 0) {
            const mruContainerIdx = this.findContainerIndex(this.state.mostRecentlyFocusedNode);
            const { tabbableNodes } = this.state.containerGroups[mruContainerIdx];
            if (tabbableNodes.length > 0) {
              const mruTabIdx = tabbableNodes.findIndex((node) => node === this.state.mostRecentlyFocusedNode);
              if (mruTabIdx >= 0) {
                if (this.config.isKeyForward(this.state.recentNavEvent)) {
                  if (mruTabIdx + 1 < tabbableNodes.length) {
                    nextNode = tabbableNodes[mruTabIdx + 1];
                    navAcrossContainers = false;
                  }
                } else {
                  if (mruTabIdx - 1 >= 0) {
                    nextNode = tabbableNodes[mruTabIdx - 1];
                    navAcrossContainers = false;
                  }
                }
              }
            }
          } else {
            if (!this.state.containerGroups.some((g) => g.tabbableNodes.some((n) => getTabIndex(n) > 0))) {
              navAcrossContainers = false;
            }
          }
        } else {
          navAcrossContainers = false;
        }
        if (navAcrossContainers) {
          nextNode = this.findNextNavNode({
            // move FROM the MRU node, not event-related node (which will be the node that is
            //  outside the trap causing the focus escape we're trying to fix)
            target: this.state.mostRecentlyFocusedNode,
            isBackward: this.config.isKeyBackward(this.state.recentNavEvent)
          });
        }
        if (nextNode) {
          this.tryFocus(nextNode);
        } else {
          this.tryFocus(this.state.mostRecentlyFocusedNode || this.getInitialFocusNode());
        }
      }
      this.state.recentNavEvent = void 0;
    });
    __publicField4(this, "handlePointerDown", (event) => {
      const target = getEventTarget(event);
      if (this.findContainerIndex(target, event) >= 0) {
        return;
      }
      if (valueOrHandler(this.config.clickOutsideDeactivates, event)) {
        this.deactivate({ returnFocus: this.config.returnFocusOnDeactivate });
        return;
      }
      if (valueOrHandler(this.config.allowOutsideClick, event)) {
        return;
      }
      event.preventDefault();
    });
    __publicField4(this, "handleClick", (event) => {
      const target = getEventTarget(event);
      if (this.findContainerIndex(target, event) >= 0) {
        return;
      }
      if (valueOrHandler(this.config.clickOutsideDeactivates, event)) {
        return;
      }
      if (valueOrHandler(this.config.allowOutsideClick, event)) {
        return;
      }
      event.preventDefault();
      event.stopImmediatePropagation();
    });
    __publicField4(this, "handleTabKey", (event) => {
      if (this.config.isKeyForward(event) || this.config.isKeyBackward(event)) {
        this.state.recentNavEvent = event;
        const isBackward = this.config.isKeyBackward(event);
        const destinationNode = this.findNextNavNode({ event, isBackward });
        if (!destinationNode) return;
        if (isTabEvent(event)) {
          event.preventDefault();
        }
        this.tryFocus(destinationNode);
      }
    });
    __publicField4(this, "handleEscapeKey", (event) => {
      if (isEscapeEvent(event) && valueOrHandler(this.config.escapeDeactivates, event) !== false) {
        event.preventDefault();
        this.deactivate();
      }
    });
    __publicField4(this, "_mutationObserver");
    __publicField4(this, "setupMutationObserver", () => {
      const win = this.doc.defaultView || window;
      this._mutationObserver = new win.MutationObserver((mutations) => {
        const isFocusedNodeRemoved = mutations.some((mutation) => {
          const removedNodes = Array.from(mutation.removedNodes);
          return removedNodes.some((node) => node === this.state.mostRecentlyFocusedNode);
        });
        if (isFocusedNodeRemoved) {
          this.tryFocus(this.getInitialFocusNode());
        }
      });
    });
    __publicField4(this, "updateObservedNodes", () => {
      var _a8;
      (_a8 = this._mutationObserver) == null ? void 0 : _a8.disconnect();
      if (this.state.active && !this.state.paused) {
        this.state.containers.map((container) => {
          var _a9;
          (_a9 = this._mutationObserver) == null ? void 0 : _a9.observe(container, { subtree: true, childList: true });
        });
      }
    });
    __publicField4(this, "getInitialFocusNode", () => {
      let node = this.getNodeForOption("initialFocus", { hasFallback: true });
      if (node === false) {
        return false;
      }
      if (node === void 0 || node && !isFocusable(node)) {
        if (this.findContainerIndex(this.doc.activeElement) >= 0) {
          node = this.doc.activeElement;
        } else {
          const firstTabbableGroup = this.state.tabbableGroups[0];
          const firstTabbableNode = firstTabbableGroup && firstTabbableGroup.firstTabbableNode;
          node = firstTabbableNode || this.getNodeForOption("fallbackFocus");
        }
      } else if (node === null) {
        node = this.getNodeForOption("fallbackFocus");
      }
      if (!node) {
        throw new Error("Your focus-trap needs to have at least one focusable element");
      }
      if (!node.isConnected) {
        node = this.getNodeForOption("fallbackFocus");
      }
      return node;
    });
    __publicField4(this, "tryFocus", (node) => {
      if (node === false) return;
      if (node === getActiveElement(this.doc)) return;
      if (!node || !node.focus) {
        this.tryFocus(this.getInitialFocusNode());
        return;
      }
      node.focus({ preventScroll: !!this.config.preventScroll });
      this.state.mostRecentlyFocusedNode = node;
      if (isSelectableInput(node)) {
        node.select();
      }
    });
    __publicField4(this, "deactivate", (deactivateOptions) => {
      if (!this.state.active) return this;
      const options2 = {
        onDeactivate: this.config.onDeactivate,
        onPostDeactivate: this.config.onPostDeactivate,
        checkCanReturnFocus: this.config.checkCanReturnFocus,
        ...deactivateOptions
      };
      clearTimeout(this.state.delayInitialFocusTimer);
      this.state.delayInitialFocusTimer = void 0;
      this.removeListeners();
      this.state.active = false;
      this.state.paused = false;
      this.updateObservedNodes();
      activeFocusTraps.deactivateTrap(this.trapStack, this);
      const onDeactivate = this.getOption(options2, "onDeactivate");
      const onPostDeactivate = this.getOption(options2, "onPostDeactivate");
      const checkCanReturnFocus = this.getOption(options2, "checkCanReturnFocus");
      const returnFocus = this.getOption(options2, "returnFocus", "returnFocusOnDeactivate");
      onDeactivate == null ? void 0 : onDeactivate();
      const finishDeactivation = () => {
        delay(() => {
          if (returnFocus) {
            const returnFocusNode = this.getReturnFocusNode(this.state.nodeFocusedBeforeActivation);
            this.tryFocus(returnFocusNode);
          }
          onPostDeactivate == null ? void 0 : onPostDeactivate();
        });
      };
      if (returnFocus && checkCanReturnFocus) {
        const returnFocusNode = this.getReturnFocusNode(this.state.nodeFocusedBeforeActivation);
        checkCanReturnFocus(returnFocusNode).then(finishDeactivation, finishDeactivation);
        return this;
      }
      finishDeactivation();
      return this;
    });
    __publicField4(this, "pause", (pauseOptions) => {
      if (this.state.paused || !this.state.active) {
        return this;
      }
      const onPause = this.getOption(pauseOptions, "onPause");
      const onPostPause = this.getOption(pauseOptions, "onPostPause");
      this.state.paused = true;
      onPause == null ? void 0 : onPause();
      this.removeListeners();
      this.updateObservedNodes();
      onPostPause == null ? void 0 : onPostPause();
      return this;
    });
    __publicField4(this, "unpause", (unpauseOptions) => {
      if (!this.state.paused || !this.state.active) {
        return this;
      }
      const onUnpause = this.getOption(unpauseOptions, "onUnpause");
      const onPostUnpause = this.getOption(unpauseOptions, "onPostUnpause");
      this.state.paused = false;
      onUnpause == null ? void 0 : onUnpause();
      this.updateTabbableNodes();
      this.addListeners();
      this.updateObservedNodes();
      onPostUnpause == null ? void 0 : onPostUnpause();
      return this;
    });
    __publicField4(this, "updateContainerElements", (containerElements) => {
      this.state.containers = Array.isArray(containerElements) ? containerElements.filter(Boolean) : [containerElements].filter(Boolean);
      if (this.state.active) {
        this.updateTabbableNodes();
      }
      this.updateObservedNodes();
      return this;
    });
    __publicField4(this, "getReturnFocusNode", (previousActiveElement) => {
      const node = this.getNodeForOption("setReturnFocus", {
        params: [previousActiveElement]
      });
      return node ? node : node === false ? false : previousActiveElement;
    });
    __publicField4(this, "getOption", (configOverrideOptions, optionName, configOptionName) => {
      return configOverrideOptions && configOverrideOptions[optionName] !== void 0 ? configOverrideOptions[optionName] : (
        // @ts-expect-error
        this.config[configOptionName || optionName]
      );
    });
    __publicField4(this, "getNodeForOption", (optionName, { hasFallback = false, params = [] } = {}) => {
      let optionValue = this.config[optionName];
      if (typeof optionValue === "function") optionValue = optionValue(...params);
      if (optionValue === true) optionValue = void 0;
      if (!optionValue) {
        if (optionValue === void 0 || optionValue === false) {
          return optionValue;
        }
        throw new Error(`\`${optionName}\` was specified but was not a node, or did not return a node`);
      }
      let node = optionValue;
      if (typeof optionValue === "string") {
        try {
          node = this.doc.querySelector(optionValue);
        } catch (err) {
          throw new Error(`\`${optionName}\` appears to be an invalid selector; error="${err.message}"`);
        }
        if (!node) {
          if (!hasFallback) {
            throw new Error(`\`${optionName}\` as selector refers to no known node`);
          }
        }
      }
      return node;
    });
    __publicField4(this, "findNextNavNode", (opts) => {
      const { event, isBackward = false } = opts;
      const target = opts.target || getEventTarget(event);
      this.updateTabbableNodes();
      let destinationNode = null;
      if (this.state.tabbableGroups.length > 0) {
        const containerIndex = this.findContainerIndex(target, event);
        const containerGroup = containerIndex >= 0 ? this.state.containerGroups[containerIndex] : void 0;
        if (containerIndex < 0) {
          if (isBackward) {
            destinationNode = this.state.tabbableGroups[this.state.tabbableGroups.length - 1].lastTabbableNode;
          } else {
            destinationNode = this.state.tabbableGroups[0].firstTabbableNode;
          }
        } else if (isBackward) {
          let startOfGroupIndex = this.state.tabbableGroups.findIndex(
            ({ firstTabbableNode }) => target === firstTabbableNode
          );
          if (startOfGroupIndex < 0 && ((containerGroup == null ? void 0 : containerGroup.container) === target || isFocusable(target) && !isTabbable(target) && !(containerGroup == null ? void 0 : containerGroup.nextTabbableNode(target, false)))) {
            startOfGroupIndex = containerIndex;
          }
          if (startOfGroupIndex >= 0) {
            const destinationGroupIndex = startOfGroupIndex === 0 ? this.state.tabbableGroups.length - 1 : startOfGroupIndex - 1;
            const destinationGroup = this.state.tabbableGroups[destinationGroupIndex];
            destinationNode = getTabIndex(target) >= 0 ? destinationGroup.lastTabbableNode : destinationGroup.lastDomTabbableNode;
          } else if (!isTabEvent(event)) {
            destinationNode = containerGroup == null ? void 0 : containerGroup.nextTabbableNode(target, false);
          }
        } else {
          let lastOfGroupIndex = this.state.tabbableGroups.findIndex(
            ({ lastTabbableNode }) => target === lastTabbableNode
          );
          if (lastOfGroupIndex < 0 && ((containerGroup == null ? void 0 : containerGroup.container) === target || isFocusable(target) && !isTabbable(target) && !(containerGroup == null ? void 0 : containerGroup.nextTabbableNode(target)))) {
            lastOfGroupIndex = containerIndex;
          }
          if (lastOfGroupIndex >= 0) {
            const destinationGroupIndex = lastOfGroupIndex === this.state.tabbableGroups.length - 1 ? 0 : lastOfGroupIndex + 1;
            const destinationGroup = this.state.tabbableGroups[destinationGroupIndex];
            destinationNode = getTabIndex(target) >= 0 ? destinationGroup.firstTabbableNode : destinationGroup.firstDomTabbableNode;
          } else if (!isTabEvent(event)) {
            destinationNode = containerGroup == null ? void 0 : containerGroup.nextTabbableNode(target);
          }
        }
      } else {
        destinationNode = this.getNodeForOption("fallbackFocus");
      }
      return destinationNode;
    });
    this.trapStack = options.trapStack || sharedTrapStack;
    const config = {
      returnFocusOnDeactivate: true,
      escapeDeactivates: true,
      delayInitialFocus: true,
      isKeyForward(e) {
        return isTabEvent(e) && !e.shiftKey;
      },
      isKeyBackward(e) {
        return isTabEvent(e) && e.shiftKey;
      },
      ...options
    };
    this.doc = config.document || getDocument(Array.isArray(elements) ? elements[0] : elements);
    this.config = config;
    this.updateContainerElements(elements);
    this.setupMutationObserver();
  }
  get active() {
    return this.state.active;
  }
  get paused() {
    return this.state.paused;
  }
  findContainerIndex(element, event) {
    const composedPath = typeof (event == null ? void 0 : event.composedPath) === "function" ? event.composedPath() : void 0;
    return this.state.containerGroups.findIndex(
      ({ container, tabbableNodes }) => container.contains(element) || (composedPath == null ? void 0 : composedPath.includes(container)) || tabbableNodes.find((node) => node === element)
    );
  }
  updateTabbableNodes() {
    this.state.containerGroups = this.state.containers.map((container) => {
      const tabbableNodes = getTabbables(container);
      const focusableNodes = getFocusables(container);
      const firstTabbableNode = tabbableNodes.length > 0 ? tabbableNodes[0] : void 0;
      const lastTabbableNode = tabbableNodes.length > 0 ? tabbableNodes[tabbableNodes.length - 1] : void 0;
      const firstDomTabbableNode = focusableNodes.find((node) => isTabbable(node));
      const lastDomTabbableNode = focusableNodes.slice().reverse().find((node) => isTabbable(node));
      const posTabIndexesFound = !!tabbableNodes.find((node) => getTabIndex(node) > 0);
      function nextTabbableNode(node, forward = true) {
        const nodeIdx = tabbableNodes.indexOf(node);
        if (nodeIdx < 0) {
          if (forward) {
            return focusableNodes.slice(focusableNodes.indexOf(node) + 1).find((el) => isTabbable(el));
          }
          return focusableNodes.slice(0, focusableNodes.indexOf(node)).reverse().find((el) => isTabbable(el));
        }
        return tabbableNodes[nodeIdx + (forward ? 1 : -1)];
      }
      return {
        container,
        tabbableNodes,
        focusableNodes,
        posTabIndexesFound,
        firstTabbableNode,
        lastTabbableNode,
        firstDomTabbableNode,
        lastDomTabbableNode,
        nextTabbableNode
      };
    });
    this.state.tabbableGroups = this.state.containerGroups.filter((group2) => group2.tabbableNodes.length > 0);
    if (this.state.tabbableGroups.length <= 0 && !this.getNodeForOption("fallbackFocus")) {
      throw new Error(
        "Your focus-trap must have at least one container with at least one tabbable node in it at all times"
      );
    }
    if (this.state.containerGroups.find((g) => g.posTabIndexesFound) && this.state.containerGroups.length > 1) {
      throw new Error(
        "At least one node with a positive tabindex was found in one of your focus-trap's multiple containers. Positive tabindexes are only supported in single-container focus-traps."
      );
    }
  }
  addListeners() {
    if (!this.state.active) return;
    activeFocusTraps.activateTrap(this.trapStack, this);
    this.state.delayInitialFocusTimer = this.config.delayInitialFocus ? delay(() => {
      this.tryFocus(this.getInitialFocusNode());
    }) : this.tryFocus(this.getInitialFocusNode());
    this.listenerCleanups.push(
      addDomEvent(this.doc, "focusin", this.handleFocus, true),
      addDomEvent(this.doc, "mousedown", this.handlePointerDown, { capture: true, passive: false }),
      addDomEvent(this.doc, "touchstart", this.handlePointerDown, { capture: true, passive: false }),
      addDomEvent(this.doc, "click", this.handleClick, { capture: true, passive: false }),
      addDomEvent(this.doc, "keydown", this.handleTabKey, { capture: true, passive: false }),
      addDomEvent(this.doc, "keydown", this.handleEscapeKey)
    );
    return this;
  }
  removeListeners() {
    if (!this.state.active) return;
    this.listenerCleanups.forEach((cleanup) => cleanup());
    this.listenerCleanups = [];
    return this;
  }
  activate(activateOptions) {
    if (this.state.active) {
      return this;
    }
    const onActivate = this.getOption(activateOptions, "onActivate");
    const onPostActivate = this.getOption(activateOptions, "onPostActivate");
    const checkCanFocusTrap = this.getOption(activateOptions, "checkCanFocusTrap");
    if (!checkCanFocusTrap) {
      this.updateTabbableNodes();
    }
    this.state.active = true;
    this.state.paused = false;
    this.state.nodeFocusedBeforeActivation = this.doc.activeElement || null;
    onActivate == null ? void 0 : onActivate();
    const finishActivation = () => {
      if (checkCanFocusTrap) {
        this.updateTabbableNodes();
      }
      this.addListeners();
      this.updateObservedNodes();
      onPostActivate == null ? void 0 : onPostActivate();
    };
    if (checkCanFocusTrap) {
      checkCanFocusTrap(this.state.containers.concat()).then(finishActivation, finishActivation);
      return this;
    }
    finishActivation();
    return this;
  }
};
var isTabEvent = (event) => event.key === "Tab";
var valueOrHandler = (value, ...params) => typeof value === "function" ? value(...params) : value;
var isEscapeEvent = (event) => !event.isComposing && event.key === "Escape";
var delay = (fn) => setTimeout(fn, 0);
var isSelectableInput = (node) => node.localName === "input" && "select" in node && typeof node.select === "function";
function trapFocus(el, options = {}) {
  let trap;
  const cleanup = raf(() => {
    const contentEl = typeof el === "function" ? el() : el;
    if (!contentEl) return;
    trap = new FocusTrap(contentEl, {
      escapeDeactivates: false,
      allowOutsideClick: true,
      preventScroll: true,
      returnFocusOnDeactivate: true,
      delayInitialFocus: false,
      fallbackFocus: contentEl,
      ...options,
      document: getDocument(contentEl)
    });
    try {
      trap.activate();
    } catch {
    }
  });
  return function destroy() {
    trap == null ? void 0 : trap.deactivate();
    cleanup();
  };
}

// node_modules/@zag-js/remove-scroll/dist/index.mjs
var LOCK_CLASSNAME = "data-scroll-lock";
function getPaddingProperty(documentElement) {
  const documentLeft = documentElement.getBoundingClientRect().left;
  const scrollbarX = Math.round(documentLeft) + documentElement.scrollLeft;
  return scrollbarX ? "paddingLeft" : "paddingRight";
}
function preventBodyScroll(_document) {
  const doc = _document ?? document;
  const win = doc.defaultView ?? window;
  const { documentElement, body } = doc;
  const locked = body.hasAttribute(LOCK_CLASSNAME);
  if (locked) return;
  const scrollbarWidth = win.innerWidth - documentElement.clientWidth;
  body.setAttribute(LOCK_CLASSNAME, "");
  const setScrollbarWidthProperty = () => setStyleProperty(documentElement, "--scrollbar-width", `${scrollbarWidth}px`);
  const paddingProperty = getPaddingProperty(documentElement);
  const setBodyStyle = () => setStyle(body, {
    overflow: "hidden",
    [paddingProperty]: `${scrollbarWidth}px`
  });
  const setBodyStyleIOS = () => {
    const { scrollX, scrollY, visualViewport: visualViewport2 } = win;
    const offsetLeft = (visualViewport2 == null ? void 0 : visualViewport2.offsetLeft) ?? 0;
    const offsetTop = (visualViewport2 == null ? void 0 : visualViewport2.offsetTop) ?? 0;
    const restoreStyle = setStyle(body, {
      position: "fixed",
      overflow: "hidden",
      top: `${-(scrollY - Math.floor(offsetTop))}px`,
      left: `${-(scrollX - Math.floor(offsetLeft))}px`,
      right: "0",
      [paddingProperty]: `${scrollbarWidth}px`
    });
    return () => {
      restoreStyle == null ? void 0 : restoreStyle();
      win.scrollTo({ left: scrollX, top: scrollY, behavior: "instant" });
    };
  };
  const cleanups = [setScrollbarWidthProperty(), isIos() ? setBodyStyleIOS() : setBodyStyle()];
  return () => {
    cleanups.forEach((fn) => fn == null ? void 0 : fn());
    body.removeAttribute(LOCK_CLASSNAME);
  };
}

// node_modules/@zag-js/dialog/dist/index.mjs
var anatomy11 = createAnatomy("dialog").parts(
  "trigger",
  "backdrop",
  "positioner",
  "content",
  "title",
  "description",
  "closeTrigger"
);
var parts11 = anatomy11.build();
var getPositionerId4 = (ctx) => {
  var _a8;
  return ((_a8 = ctx.ids) == null ? void 0 : _a8.positioner) ?? `dialog:${ctx.id}:positioner`;
};
var getBackdropId = (ctx) => {
  var _a8;
  return ((_a8 = ctx.ids) == null ? void 0 : _a8.backdrop) ?? `dialog:${ctx.id}:backdrop`;
};
var getContentId5 = (ctx) => {
  var _a8;
  return ((_a8 = ctx.ids) == null ? void 0 : _a8.content) ?? `dialog:${ctx.id}:content`;
};
var getTriggerId5 = (ctx) => {
  var _a8;
  return ((_a8 = ctx.ids) == null ? void 0 : _a8.trigger) ?? `dialog:${ctx.id}:trigger`;
};
var getTitleId = (ctx) => {
  var _a8;
  return ((_a8 = ctx.ids) == null ? void 0 : _a8.title) ?? `dialog:${ctx.id}:title`;
};
var getDescriptionId = (ctx) => {
  var _a8;
  return ((_a8 = ctx.ids) == null ? void 0 : _a8.description) ?? `dialog:${ctx.id}:description`;
};
var getCloseTriggerId = (ctx) => {
  var _a8;
  return ((_a8 = ctx.ids) == null ? void 0 : _a8.closeTrigger) ?? `dialog:${ctx.id}:close`;
};
var getContentEl5 = (ctx) => ctx.getById(getContentId5(ctx));
var getPositionerEl4 = (ctx) => ctx.getById(getPositionerId4(ctx));
var getBackdropEl = (ctx) => ctx.getById(getBackdropId(ctx));
var getTriggerEl4 = (ctx) => ctx.getById(getTriggerId5(ctx));
var getTitleEl = (ctx) => ctx.getById(getTitleId(ctx));
var getDescriptionEl = (ctx) => ctx.getById(getDescriptionId(ctx));
var getCloseTriggerEl = (ctx) => ctx.getById(getCloseTriggerId(ctx));
function connect12(service, normalize4) {
  const { state: state2, send, context, prop, scope } = service;
  const ariaLabel = prop("aria-label");
  const open = state2.matches("open");
  return {
    open,
    setOpen(nextOpen) {
      const open2 = state2.matches("open");
      if (open2 === nextOpen) return;
      send({ type: nextOpen ? "OPEN" : "CLOSE" });
    },
    getTriggerProps() {
      return normalize4.button({
        ...parts11.trigger.attrs,
        dir: prop("dir"),
        id: getTriggerId5(scope),
        "aria-haspopup": "dialog",
        type: "button",
        "aria-expanded": open,
        "data-state": open ? "open" : "closed",
        "aria-controls": getContentId5(scope),
        onClick(event) {
          if (event.defaultPrevented) return;
          send({ type: "TOGGLE" });
        }
      });
    },
    getBackdropProps() {
      return normalize4.element({
        ...parts11.backdrop.attrs,
        dir: prop("dir"),
        hidden: !open,
        id: getBackdropId(scope),
        "data-state": open ? "open" : "closed"
      });
    },
    getPositionerProps() {
      return normalize4.element({
        ...parts11.positioner.attrs,
        dir: prop("dir"),
        id: getPositionerId4(scope),
        style: {
          pointerEvents: open ? void 0 : "none"
        }
      });
    },
    getContentProps() {
      const rendered = context.get("rendered");
      return normalize4.element({
        ...parts11.content.attrs,
        dir: prop("dir"),
        role: prop("role"),
        hidden: !open,
        id: getContentId5(scope),
        tabIndex: -1,
        "data-state": open ? "open" : "closed",
        "aria-modal": true,
        "aria-label": ariaLabel || void 0,
        "aria-labelledby": ariaLabel || !rendered.title ? void 0 : getTitleId(scope),
        "aria-describedby": rendered.description ? getDescriptionId(scope) : void 0
      });
    },
    getTitleProps() {
      return normalize4.element({
        ...parts11.title.attrs,
        dir: prop("dir"),
        id: getTitleId(scope)
      });
    },
    getDescriptionProps() {
      return normalize4.element({
        ...parts11.description.attrs,
        dir: prop("dir"),
        id: getDescriptionId(scope)
      });
    },
    getCloseTriggerProps() {
      return normalize4.button({
        ...parts11.closeTrigger.attrs,
        dir: prop("dir"),
        id: getCloseTriggerId(scope),
        type: "button",
        onClick(event) {
          if (event.defaultPrevented) return;
          event.stopPropagation();
          send({ type: "CLOSE" });
        }
      });
    }
  };
}
var machine12 = createMachine({
  props({ props: props210, scope }) {
    const alertDialog = props210.role === "alertdialog";
    const initialFocusEl = alertDialog ? () => getCloseTriggerEl(scope) : void 0;
    return {
      role: "dialog",
      modal: true,
      trapFocus: true,
      preventScroll: true,
      closeOnInteractOutside: !alertDialog,
      closeOnEscape: true,
      restoreFocus: true,
      initialFocusEl,
      ...props210
    };
  },
  initialState({ prop }) {
    const open = prop("open") || prop("defaultOpen");
    return open ? "open" : "closed";
  },
  context({ bindable }) {
    return {
      rendered: bindable(() => ({
        defaultValue: { title: true, description: true }
      }))
    };
  },
  watch({ track, action, prop }) {
    track([() => prop("open")], () => {
      action(["toggleVisibility"]);
    });
  },
  states: {
    open: {
      entry: ["checkRenderedElements", "syncZIndex"],
      effects: ["trackDismissableElement", "trapFocus", "preventScroll", "hideContentBelow"],
      on: {
        "CONTROLLED.CLOSE": {
          target: "closed"
        },
        CLOSE: [
          {
            guard: "isOpenControlled",
            actions: ["invokeOnClose"]
          },
          {
            target: "closed",
            actions: ["invokeOnClose"]
          }
        ],
        TOGGLE: [
          {
            guard: "isOpenControlled",
            actions: ["invokeOnClose"]
          },
          {
            target: "closed",
            actions: ["invokeOnClose"]
          }
        ]
      }
    },
    closed: {
      on: {
        "CONTROLLED.OPEN": {
          target: "open"
        },
        OPEN: [
          {
            guard: "isOpenControlled",
            actions: ["invokeOnOpen"]
          },
          {
            target: "open",
            actions: ["invokeOnOpen"]
          }
        ],
        TOGGLE: [
          {
            guard: "isOpenControlled",
            actions: ["invokeOnOpen"]
          },
          {
            target: "open",
            actions: ["invokeOnOpen"]
          }
        ]
      }
    }
  },
  implementations: {
    guards: {
      isOpenControlled: ({ prop }) => prop("open") != void 0
    },
    effects: {
      trackDismissableElement({ scope, send, prop }) {
        const getContentEl22 = () => getContentEl5(scope);
        return trackDismissableElement(getContentEl22, {
          defer: true,
          pointerBlocking: prop("modal"),
          exclude: [getTriggerEl4(scope)],
          onInteractOutside(event) {
            var _a8;
            (_a8 = prop("onInteractOutside")) == null ? void 0 : _a8(event);
            if (!prop("closeOnInteractOutside")) {
              event.preventDefault();
            }
          },
          persistentElements: prop("persistentElements"),
          onFocusOutside: prop("onFocusOutside"),
          onPointerDownOutside: prop("onPointerDownOutside"),
          onEscapeKeyDown(event) {
            var _a8;
            (_a8 = prop("onEscapeKeyDown")) == null ? void 0 : _a8(event);
            if (!prop("closeOnEscape")) {
              event.preventDefault();
            }
          },
          onDismiss() {
            send({ type: "CLOSE", src: "interact-outside" });
          }
        });
      },
      preventScroll({ scope, prop }) {
        if (!prop("preventScroll")) return;
        return preventBodyScroll(scope.getDoc());
      },
      trapFocus({ scope, prop }) {
        if (!prop("trapFocus") || !prop("modal")) return;
        const contentEl = () => getContentEl5(scope);
        return trapFocus(contentEl, {
          preventScroll: true,
          returnFocusOnDeactivate: !!prop("restoreFocus"),
          initialFocus: prop("initialFocusEl"),
          setReturnFocus: (el) => {
            var _a8;
            return ((_a8 = prop("finalFocusEl")) == null ? void 0 : _a8()) ?? el;
          }
        });
      },
      hideContentBelow({ scope, prop }) {
        if (!prop("modal")) return;
        const getElements4 = () => [getContentEl5(scope)];
        return ariaHidden(getElements4, { defer: true });
      }
    },
    actions: {
      checkRenderedElements({ context, scope }) {
        raf(() => {
          context.set("rendered", {
            title: !!getTitleEl(scope),
            description: !!getDescriptionEl(scope)
          });
        });
      },
      syncZIndex({ scope }) {
        raf(() => {
          const contentEl = getContentEl5(scope);
          if (!contentEl) return;
          const styles = getComputedStyle2(contentEl);
          const elems = [getPositionerEl4(scope), getBackdropEl(scope)];
          elems.forEach((node) => {
            node == null ? void 0 : node.style.setProperty("--z-index", styles.zIndex);
          });
        });
      },
      invokeOnClose({ prop }) {
        var _a8;
        (_a8 = prop("onOpenChange")) == null ? void 0 : _a8({ open: false });
      },
      invokeOnOpen({ prop }) {
        var _a8;
        (_a8 = prop("onOpenChange")) == null ? void 0 : _a8({ open: true });
      },
      toggleVisibility({ prop, send, event }) {
        send({
          type: prop("open") ? "CONTROLLED.OPEN" : "CONTROLLED.CLOSE",
          previousEvent: event
        });
      }
    }
  }
});
var props12 = createProps()([
  "aria-label",
  "closeOnEscape",
  "closeOnInteractOutside",
  "dir",
  "finalFocusEl",
  "getRootNode",
  "getRootNode",
  "id",
  "id",
  "ids",
  "initialFocusEl",
  "modal",
  "onEscapeKeyDown",
  "onFocusOutside",
  "onInteractOutside",
  "onOpenChange",
  "onPointerDownOutside",
  "defaultOpen",
  "open",
  "persistentElements",
  "preventScroll",
  "restoreFocus",
  "role",
  "trapFocus"
]);
var splitProps12 = createSplitProps(props12);

// node_modules/@ark-ui/react/dist/components/dialog/use-dialog.js
var import_react290 = __toESM(require_react(), 1);
var useDialog = (props43) => {
  const id = (0, import_react290.useId)();
  const { getRootNode } = useEnvironmentContext();
  const { dir } = useLocaleContext();
  const machineProps = {
    id,
    getRootNode,
    dir,
    ...props43
  };
  const service = useMachine(machine12, machineProps);
  return connect12(service, normalizeProps);
};

// node_modules/@ark-ui/react/dist/components/dialog/dialog-root.js
var DialogRoot = (props43) => {
  const [presenceProps, { children, ...localProps }] = splitPresenceProps(props43);
  const [renderStrategyProps] = splitRenderStrategyProps(presenceProps);
  const dialog = useDialog(localProps);
  const presence = usePresence(mergeProps2({ present: dialog.open }, presenceProps));
  return (0, import_jsx_runtime136.jsx)(DialogProvider, { value: dialog, children: (0, import_jsx_runtime136.jsx)(RenderStrategyPropsProvider, { value: renderStrategyProps, children: (0, import_jsx_runtime136.jsx)(PresenceProvider, { value: presence, children }) }) });
};

// node_modules/@ark-ui/react/dist/components/dialog/dialog-root-provider.js
var import_jsx_runtime137 = __toESM(require_jsx_runtime(), 1);
var DialogRootProvider = (props43) => {
  const [presenceProps, { value: dialog, children }] = splitPresenceProps(props43);
  const [renderStrategyProps] = splitRenderStrategyProps(presenceProps);
  const presence = usePresence(mergeProps2({ present: dialog.open }, presenceProps));
  return (0, import_jsx_runtime137.jsx)(DialogProvider, { value: dialog, children: (0, import_jsx_runtime137.jsx)(RenderStrategyPropsProvider, { value: renderStrategyProps, children: (0, import_jsx_runtime137.jsx)(PresenceProvider, { value: presence, children }) }) });
};

// node_modules/@ark-ui/react/dist/components/dialog/dialog-title.js
var import_jsx_runtime138 = __toESM(require_jsx_runtime(), 1);
var import_react294 = __toESM(require_react(), 1);
var DialogTitle = (0, import_react294.forwardRef)((props43, ref) => {
  const dialog = useDialogContext();
  const mergedProps = mergeProps2(dialog.getTitleProps(), props43);
  return (0, import_jsx_runtime138.jsx)(ark.h2, { ...mergedProps, ref });
});
DialogTitle.displayName = "DialogTitle";

// node_modules/@ark-ui/react/dist/components/dialog/dialog-trigger.js
var import_jsx_runtime139 = __toESM(require_jsx_runtime(), 1);
var import_react296 = __toESM(require_react(), 1);
var DialogTrigger = (0, import_react296.forwardRef)((props43, ref) => {
  const dialog = useDialogContext();
  const presence = usePresenceContext();
  const mergedProps = mergeProps2(
    {
      ...dialog.getTriggerProps(),
      "aria-controls": presence.unmounted ? void 0 : dialog.getTriggerProps()["aria-controls"]
    },
    props43
  );
  return (0, import_jsx_runtime139.jsx)(ark.button, { ...mergedProps, ref });
});
DialogTrigger.displayName = "DialogTrigger";

// node_modules/@ark-ui/react/dist/components/dialog/dialog.js
var dialog_exports = {};
__export(dialog_exports, {
  Backdrop: () => DialogBackdrop,
  CloseTrigger: () => DialogCloseTrigger,
  Content: () => DialogContent,
  Context: () => DialogContext,
  Description: () => DialogDescription,
  Positioner: () => DialogPositioner,
  Root: () => DialogRoot,
  RootProvider: () => DialogRootProvider,
  Title: () => DialogTitle,
  Trigger: () => DialogTrigger
});

// node_modules/@ark-ui/react/dist/components/editable/editable-area.js
var import_jsx_runtime140 = __toESM(require_jsx_runtime(), 1);
var import_react298 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/editable/use-editable-context.js
var [EditableProvider, useEditableContext] = createContext3({
  name: "EditableContext",
  hookName: "useEditableContext",
  providerName: "<EditableProvider />"
});

// node_modules/@ark-ui/react/dist/components/editable/editable-area.js
var EditableArea = (0, import_react298.forwardRef)((props43, ref) => {
  const editable = useEditableContext();
  const mergedProps = mergeProps2(editable.getAreaProps(), props43);
  return (0, import_jsx_runtime140.jsx)(ark.div, { ...mergedProps, ref });
});
EditableArea.displayName = "EditableArea";

// node_modules/@ark-ui/react/dist/components/editable/editable-cancel-trigger.js
var import_jsx_runtime141 = __toESM(require_jsx_runtime(), 1);
var import_react300 = __toESM(require_react(), 1);
var EditableCancelTrigger = (0, import_react300.forwardRef)((props43, ref) => {
  const editable = useEditableContext();
  const mergedProps = mergeProps2(editable.getCancelTriggerProps(), props43);
  return (0, import_jsx_runtime141.jsx)(ark.button, { ...mergedProps, ref });
});
EditableCancelTrigger.displayName = "EditableCancelTrigger";

// node_modules/@ark-ui/react/dist/components/editable/editable-context.js
var EditableContext = (props43) => props43.children(useEditableContext());

// node_modules/@ark-ui/react/dist/components/editable/editable-control.js
var import_jsx_runtime142 = __toESM(require_jsx_runtime(), 1);
var import_react302 = __toESM(require_react(), 1);
var EditableControl = (0, import_react302.forwardRef)((props43, ref) => {
  const editable = useEditableContext();
  const mergedProps = mergeProps2(editable.getControlProps(), props43);
  return (0, import_jsx_runtime142.jsx)(ark.div, { ...mergedProps, ref });
});
EditableControl.displayName = "EditableControl";

// node_modules/@ark-ui/react/dist/components/editable/editable-edit-trigger.js
var import_jsx_runtime143 = __toESM(require_jsx_runtime(), 1);
var import_react304 = __toESM(require_react(), 1);
var EditableEditTrigger = (0, import_react304.forwardRef)((props43, ref) => {
  const editable = useEditableContext();
  const mergedProps = mergeProps2(editable.getEditTriggerProps(), props43);
  return (0, import_jsx_runtime143.jsx)(ark.button, { ...mergedProps, ref });
});
EditableEditTrigger.displayName = "EditableEditTrigger";

// node_modules/@ark-ui/react/dist/components/editable/editable-input.js
var import_jsx_runtime144 = __toESM(require_jsx_runtime(), 1);
var import_react306 = __toESM(require_react(), 1);
var EditableInput = (0, import_react306.forwardRef)((props43, ref) => {
  const editable = useEditableContext();
  const mergedProps = mergeProps2(editable.getInputProps(), props43);
  const field = useFieldContext();
  return (0, import_jsx_runtime144.jsx)(ark.input, { "aria-describedby": field == null ? void 0 : field.ariaDescribedby, ...mergedProps, ref });
});
EditableInput.displayName = "EditableInput";

// node_modules/@ark-ui/react/dist/components/editable/editable-label.js
var import_jsx_runtime145 = __toESM(require_jsx_runtime(), 1);
var import_react308 = __toESM(require_react(), 1);
var EditableLabel = (0, import_react308.forwardRef)((props43, ref) => {
  const editable = useEditableContext();
  const mergedProps = mergeProps2(editable.getLabelProps(), props43);
  return (0, import_jsx_runtime145.jsx)(ark.label, { ...mergedProps, ref });
});
EditableLabel.displayName = "EditableLabel";

// node_modules/@ark-ui/react/dist/components/editable/editable-preview.js
var import_jsx_runtime146 = __toESM(require_jsx_runtime(), 1);
var import_react310 = __toESM(require_react(), 1);
var EditablePreview = (0, import_react310.forwardRef)((props43, ref) => {
  const editable = useEditableContext();
  const mergedProps = mergeProps2(editable.getPreviewProps(), props43);
  return (0, import_jsx_runtime146.jsx)(ark.span, { ...mergedProps, ref });
});
EditablePreview.displayName = "EditablePreview";

// node_modules/@ark-ui/react/dist/components/editable/editable-root.js
var import_jsx_runtime147 = __toESM(require_jsx_runtime(), 1);
var import_react314 = __toESM(require_react(), 1);

// node_modules/@zag-js/editable/dist/index.mjs
var anatomy12 = createAnatomy("editable").parts(
  "root",
  "area",
  "label",
  "preview",
  "input",
  "editTrigger",
  "submitTrigger",
  "cancelTrigger",
  "control"
);
var parts12 = anatomy12.build();
var getRootId11 = (ctx) => {
  var _a8;
  return ((_a8 = ctx.ids) == null ? void 0 : _a8.root) ?? `editable:${ctx.id}`;
};
var getAreaId2 = (ctx) => {
  var _a8;
  return ((_a8 = ctx.ids) == null ? void 0 : _a8.area) ?? `editable:${ctx.id}:area`;
};
var getLabelId6 = (ctx) => {
  var _a8;
  return ((_a8 = ctx.ids) == null ? void 0 : _a8.label) ?? `editable:${ctx.id}:label`;
};
var getPreviewId = (ctx) => {
  var _a8;
  return ((_a8 = ctx.ids) == null ? void 0 : _a8.preview) ?? `editable:${ctx.id}:preview`;
};
var getInputId4 = (ctx) => {
  var _a8;
  return ((_a8 = ctx.ids) == null ? void 0 : _a8.input) ?? `editable:${ctx.id}:input`;
};
var getControlId6 = (ctx) => {
  var _a8;
  return ((_a8 = ctx.ids) == null ? void 0 : _a8.control) ?? `editable:${ctx.id}:control`;
};
var getSubmitTriggerId = (ctx) => {
  var _a8;
  return ((_a8 = ctx.ids) == null ? void 0 : _a8.submitTrigger) ?? `editable:${ctx.id}:submit`;
};
var getCancelTriggerId = (ctx) => {
  var _a8;
  return ((_a8 = ctx.ids) == null ? void 0 : _a8.cancelTrigger) ?? `editable:${ctx.id}:cancel`;
};
var getEditTriggerId = (ctx) => {
  var _a8;
  return ((_a8 = ctx.ids) == null ? void 0 : _a8.editTrigger) ?? `editable:${ctx.id}:edit`;
};
var getInputEl3 = (ctx) => ctx.getById(getInputId4(ctx));
var getPreviewEl = (ctx) => ctx.getById(getPreviewId(ctx));
var getSubmitTriggerEl = (ctx) => ctx.getById(getSubmitTriggerId(ctx));
var getCancelTriggerEl = (ctx) => ctx.getById(getCancelTriggerId(ctx));
var getEditTriggerEl = (ctx) => ctx.getById(getEditTriggerId(ctx));
function connect13(service, normalize4) {
  const { state: state2, context, send, prop, scope, computed } = service;
  const disabled = prop("disabled");
  const interactive = computed("isInteractive");
  const readOnly = prop("readOnly");
  const invalid = prop("invalid");
  const autoResize = prop("autoResize");
  const translations = prop("translations");
  const editing = state2.matches("edit");
  const placeholderProp = prop("placeholder");
  const placeholder = typeof placeholderProp === "string" ? { edit: placeholderProp, preview: placeholderProp } : placeholderProp;
  const value = context.get("value");
  const empty2 = value.trim() === "";
  const valueText = empty2 ? (placeholder == null ? void 0 : placeholder.preview) ?? "" : value;
  return {
    editing,
    empty: empty2,
    value,
    valueText,
    setValue(value2) {
      send({ type: "VALUE.SET", value: value2, src: "setValue" });
    },
    clearValue() {
      send({ type: "VALUE.SET", value: "", src: "clearValue" });
    },
    edit() {
      if (!interactive) return;
      send({ type: "EDIT" });
    },
    cancel() {
      if (!interactive) return;
      send({ type: "CANCEL" });
    },
    submit() {
      if (!interactive) return;
      send({ type: "SUBMIT" });
    },
    getRootProps() {
      return normalize4.element({
        ...parts12.root.attrs,
        id: getRootId11(scope),
        dir: prop("dir")
      });
    },
    getAreaProps() {
      return normalize4.element({
        ...parts12.area.attrs,
        id: getAreaId2(scope),
        dir: prop("dir"),
        style: autoResize ? { display: "inline-grid" } : void 0,
        "data-focus": dataAttr(editing),
        "data-disabled": dataAttr(disabled),
        "data-placeholder-shown": dataAttr(empty2)
      });
    },
    getLabelProps() {
      return normalize4.label({
        ...parts12.label.attrs,
        id: getLabelId6(scope),
        dir: prop("dir"),
        htmlFor: getInputId4(scope),
        "data-focus": dataAttr(editing),
        "data-invalid": dataAttr(invalid),
        onClick() {
          if (editing) return;
          const previewEl = getPreviewEl(scope);
          previewEl == null ? void 0 : previewEl.focus({ preventScroll: true });
        }
      });
    },
    getInputProps() {
      return normalize4.input({
        ...parts12.input.attrs,
        dir: prop("dir"),
        "aria-label": translations == null ? void 0 : translations.input,
        name: prop("name"),
        form: prop("form"),
        id: getInputId4(scope),
        hidden: autoResize ? void 0 : !editing,
        placeholder: placeholder == null ? void 0 : placeholder.edit,
        maxLength: prop("maxLength"),
        required: prop("required"),
        disabled,
        "data-disabled": dataAttr(disabled),
        readOnly,
        "data-readonly": dataAttr(readOnly),
        "aria-invalid": ariaAttr(invalid),
        "data-invalid": dataAttr(invalid),
        "data-autoresize": dataAttr(autoResize),
        defaultValue: value,
        size: autoResize ? 1 : void 0,
        onChange(event) {
          send({
            type: "VALUE.SET",
            src: "input.change",
            value: event.currentTarget.value
          });
        },
        onKeyDown(event) {
          if (event.defaultPrevented) return;
          if (isComposingEvent(event)) return;
          const keyMap2 = {
            Escape() {
              send({ type: "CANCEL" });
              event.preventDefault();
            },
            Enter(event2) {
              if (!computed("submitOnEnter")) return;
              const { localName } = event2.currentTarget;
              if (localName === "textarea") {
                const submitMod = isApple() ? event2.metaKey : event2.ctrlKey;
                if (!submitMod) return;
                send({ type: "SUBMIT", src: "keydown.enter" });
                return;
              }
              if (localName === "input" && !event2.shiftKey && !event2.metaKey) {
                send({ type: "SUBMIT", src: "keydown.enter" });
                event2.preventDefault();
              }
            }
          };
          const exec = keyMap2[event.key];
          if (exec) {
            exec(event);
          }
        },
        style: autoResize ? {
          gridArea: "1 / 1 / auto / auto",
          visibility: !editing ? "hidden" : void 0
        } : void 0
      });
    },
    getPreviewProps() {
      return normalize4.element({
        id: getPreviewId(scope),
        ...parts12.preview.attrs,
        dir: prop("dir"),
        "data-placeholder-shown": dataAttr(empty2),
        "aria-readonly": ariaAttr(readOnly),
        "data-readonly": dataAttr(disabled),
        "data-disabled": dataAttr(disabled),
        "aria-disabled": ariaAttr(disabled),
        "aria-invalid": ariaAttr(invalid),
        "data-invalid": dataAttr(invalid),
        "aria-label": translations == null ? void 0 : translations.edit,
        "data-autoresize": dataAttr(autoResize),
        children: valueText,
        hidden: autoResize ? void 0 : editing,
        tabIndex: interactive ? 0 : void 0,
        onClick() {
          if (!interactive) return;
          if (prop("activationMode") !== "click") return;
          send({ type: "EDIT", src: "click" });
        },
        onFocus() {
          if (!interactive) return;
          if (prop("activationMode") !== "focus") return;
          send({ type: "EDIT", src: "focus" });
        },
        onDoubleClick(event) {
          if (event.defaultPrevented) return;
          if (!interactive) return;
          if (prop("activationMode") !== "dblclick") return;
          send({ type: "EDIT", src: "dblclick" });
        },
        style: autoResize ? {
          whiteSpace: "pre",
          userSelect: "none",
          gridArea: "1 / 1 / auto / auto",
          visibility: editing ? "hidden" : void 0,
          // in event the preview overflow's the parent element
          overflow: "hidden",
          textOverflow: "ellipsis"
        } : void 0
      });
    },
    getEditTriggerProps() {
      return normalize4.button({
        ...parts12.editTrigger.attrs,
        id: getEditTriggerId(scope),
        dir: prop("dir"),
        "aria-label": translations == null ? void 0 : translations.edit,
        hidden: editing,
        type: "button",
        disabled,
        onClick(event) {
          if (event.defaultPrevented) return;
          if (!interactive) return;
          send({ type: "EDIT", src: "edit.click" });
        }
      });
    },
    getControlProps() {
      return normalize4.element({
        id: getControlId6(scope),
        ...parts12.control.attrs,
        dir: prop("dir")
      });
    },
    getSubmitTriggerProps() {
      return normalize4.button({
        ...parts12.submitTrigger.attrs,
        dir: prop("dir"),
        id: getSubmitTriggerId(scope),
        "aria-label": translations == null ? void 0 : translations.submit,
        hidden: !editing,
        disabled,
        type: "button",
        onClick(event) {
          if (event.defaultPrevented) return;
          if (!interactive) return;
          send({ type: "SUBMIT", src: "submit.click" });
        }
      });
    },
    getCancelTriggerProps() {
      return normalize4.button({
        ...parts12.cancelTrigger.attrs,
        dir: prop("dir"),
        "aria-label": translations == null ? void 0 : translations.cancel,
        id: getCancelTriggerId(scope),
        hidden: !editing,
        type: "button",
        disabled,
        onClick(event) {
          if (event.defaultPrevented) return;
          if (!interactive) return;
          send({ type: "CANCEL", src: "cancel.click" });
        }
      });
    }
  };
}
var machine13 = createMachine({
  props({ props: props210 }) {
    return {
      activationMode: "focus",
      submitMode: "both",
      defaultValue: "",
      selectOnFocus: true,
      ...props210,
      translations: {
        input: "editable input",
        edit: "edit",
        submit: "submit",
        cancel: "cancel",
        ...props210.translations
      }
    };
  },
  initialState({ prop }) {
    const edit = prop("edit") || prop("defaultEdit");
    return edit ? "edit" : "preview";
  },
  entry: ["focusInputIfNeeded"],
  context: ({ bindable, prop }) => {
    return {
      value: bindable(() => ({
        defaultValue: prop("defaultValue"),
        value: prop("value"),
        onChange(value) {
          var _a8;
          return (_a8 = prop("onValueChange")) == null ? void 0 : _a8({ value });
        }
      })),
      previousValue: bindable(() => ({
        defaultValue: ""
      }))
    };
  },
  watch({ track, action, context, prop }) {
    track([() => context.get("value")], () => {
      action(["syncInputValue"]);
    });
    track([() => prop("edit")], () => {
      action(["toggleEditing"]);
    });
  },
  computed: {
    submitOnEnter({ prop }) {
      return ["both", "enter"].includes(prop("submitMode"));
    },
    submitOnBlur({ prop }) {
      return ["both", "blur"].includes(prop("submitMode"));
    },
    isInteractive({ prop }) {
      return !(prop("disabled") || prop("readOnly"));
    }
  },
  on: {
    "VALUE.SET": {
      actions: ["setValue"]
    }
  },
  states: {
    preview: {
      entry: ["blurInputIfNeeded"],
      on: {
        "CONTROLLED.EDIT": {
          target: "edit",
          actions: ["setPreviousValue", "focusInput"]
        },
        EDIT: [
          {
            guard: "isEditControlled",
            actions: ["invokeOnEdit"]
          },
          {
            target: "edit",
            actions: ["setPreviousValue", "focusInput", "invokeOnEdit"]
          }
        ]
      }
    },
    edit: {
      effects: ["trackInteractOutside"],
      on: {
        "CONTROLLED.PREVIEW": [
          {
            guard: "isSubmitEvent",
            target: "preview",
            actions: ["setPreviousValue", "restoreFocus", "invokeOnSubmit"]
          },
          {
            target: "preview",
            actions: ["revertValue", "restoreFocus", "invokeOnCancel"]
          }
        ],
        CANCEL: [
          {
            guard: "isEditControlled",
            actions: ["invokeOnPreview"]
          },
          {
            target: "preview",
            actions: ["revertValue", "restoreFocus", "invokeOnCancel", "invokeOnPreview"]
          }
        ],
        SUBMIT: [
          {
            guard: "isEditControlled",
            actions: ["invokeOnPreview"]
          },
          {
            target: "preview",
            actions: ["setPreviousValue", "restoreFocus", "invokeOnSubmit", "invokeOnPreview"]
          }
        ]
      }
    }
  },
  implementations: {
    guards: {
      isEditControlled: ({ prop }) => prop("edit") != void 0,
      isSubmitEvent: ({ event }) => {
        var _a8;
        return ((_a8 = event.previousEvent) == null ? void 0 : _a8.type) === "SUBMIT";
      }
    },
    effects: {
      trackInteractOutside({ send, scope, prop, computed }) {
        return trackInteractOutside(getInputEl3(scope), {
          exclude(target) {
            const ignore = [getCancelTriggerEl(scope), getSubmitTriggerEl(scope)];
            return ignore.some((el) => contains(el, target));
          },
          onFocusOutside: prop("onFocusOutside"),
          onPointerDownOutside: prop("onPointerDownOutside"),
          onInteractOutside(event) {
            var _a8;
            (_a8 = prop("onInteractOutside")) == null ? void 0 : _a8(event);
            if (event.defaultPrevented) return;
            const { focusable } = event.detail;
            send({
              type: computed("submitOnBlur") ? "SUBMIT" : "CANCEL",
              src: "interact-outside",
              focusable
            });
          }
        });
      }
    },
    actions: {
      restoreFocus({ event, scope, prop }) {
        if (event.focusable) return;
        raf(() => {
          var _a8;
          const finalEl = ((_a8 = prop("finalFocusEl")) == null ? void 0 : _a8()) ?? getEditTriggerEl(scope);
          finalEl == null ? void 0 : finalEl.focus({ preventScroll: true });
        });
      },
      clearValue({ context }) {
        context.set("value", "");
      },
      focusInputIfNeeded({ action, prop }) {
        const edit = prop("edit") || prop("defaultEdit");
        if (!edit) return;
        action(["focusInput"]);
      },
      focusInput({ scope, prop }) {
        raf(() => {
          const inputEl = getInputEl3(scope);
          if (!inputEl) return;
          if (prop("selectOnFocus")) {
            inputEl.select();
          } else {
            inputEl.focus({ preventScroll: true });
          }
        });
      },
      invokeOnCancel({ prop, context }) {
        var _a8;
        const prev2 = context.get("previousValue");
        (_a8 = prop("onValueRevert")) == null ? void 0 : _a8({ value: prev2 });
      },
      invokeOnSubmit({ prop, context }) {
        var _a8;
        const value = context.get("value");
        (_a8 = prop("onValueCommit")) == null ? void 0 : _a8({ value });
      },
      invokeOnEdit({ prop }) {
        var _a8;
        (_a8 = prop("onEditChange")) == null ? void 0 : _a8({ edit: true });
      },
      invokeOnPreview({ prop }) {
        var _a8;
        (_a8 = prop("onEditChange")) == null ? void 0 : _a8({ edit: false });
      },
      toggleEditing({ prop, send, event }) {
        send({
          type: prop("edit") ? "CONTROLLED.EDIT" : "CONTROLLED.PREVIEW",
          previousEvent: event
        });
      },
      syncInputValue({ context, scope }) {
        const inputEl = getInputEl3(scope);
        if (!inputEl) return;
        setElementValue(inputEl, context.get("value"));
      },
      setValue({ context, prop, event }) {
        const max4 = prop("maxLength");
        const value = max4 != null ? event.value.slice(0, max4) : event.value;
        context.set("value", value);
      },
      setPreviousValue({ context }) {
        context.set("previousValue", context.get("value"));
      },
      revertValue({ context }) {
        const value = context.get("previousValue");
        if (!value) return;
        context.set("value", value);
      },
      blurInputIfNeeded({ scope }) {
        var _a8;
        (_a8 = getInputEl3(scope)) == null ? void 0 : _a8.blur();
      }
    }
  }
});
var props13 = createProps()([
  "activationMode",
  "autoResize",
  "dir",
  "disabled",
  "finalFocusEl",
  "form",
  "getRootNode",
  "id",
  "ids",
  "invalid",
  "maxLength",
  "name",
  "onEditChange",
  "onFocusOutside",
  "onInteractOutside",
  "onPointerDownOutside",
  "onValueChange",
  "onValueCommit",
  "onValueRevert",
  "placeholder",
  "readOnly",
  "required",
  "selectOnFocus",
  "edit",
  "defaultEdit",
  "submitMode",
  "translations",
  "defaultValue",
  "value"
]);
var splitProps13 = createSplitProps(props13);

// node_modules/@ark-ui/react/dist/components/editable/use-editable.js
var import_react312 = __toESM(require_react(), 1);
var useEditable = (props43) => {
  const id = (0, import_react312.useId)();
  const { getRootNode } = useEnvironmentContext();
  const { dir } = useLocaleContext();
  const field = useFieldContext();
  const machineProps = {
    id,
    ids: {
      label: field == null ? void 0 : field.ids.label,
      input: field == null ? void 0 : field.ids.control
    },
    dir,
    disabled: field == null ? void 0 : field.disabled,
    invalid: field == null ? void 0 : field.invalid,
    readOnly: field == null ? void 0 : field.readOnly,
    required: field == null ? void 0 : field.required,
    getRootNode,
    ...props43
  };
  const service = useMachine(machine13, machineProps);
  return connect13(service, normalizeProps);
};

// node_modules/@ark-ui/react/dist/components/editable/editable-root.js
var EditableRoot = (0, import_react314.forwardRef)((props43, ref) => {
  const [useEditableProps, localProps] = createSplitProps2()(props43, [
    "activationMode",
    "autoResize",
    "defaultEdit",
    "defaultValue",
    "disabled",
    "edit",
    "finalFocusEl",
    "form",
    "id",
    "ids",
    "invalid",
    "maxLength",
    "name",
    "onEditChange",
    "onFocusOutside",
    "onInteractOutside",
    "onPointerDownOutside",
    "onValueChange",
    "onValueCommit",
    "onValueRevert",
    "placeholder",
    "readOnly",
    "required",
    "selectOnFocus",
    "submitMode",
    "translations",
    "value"
  ]);
  const editable = useEditable(useEditableProps);
  const mergedProps = mergeProps2(editable.getRootProps(), localProps);
  return (0, import_jsx_runtime147.jsx)(EditableProvider, { value: editable, children: (0, import_jsx_runtime147.jsx)(ark.div, { ...mergedProps, ref }) });
});
EditableRoot.displayName = "EditableRoot";

// node_modules/@ark-ui/react/dist/components/editable/editable-root-provider.js
var import_jsx_runtime148 = __toESM(require_jsx_runtime(), 1);
var import_react316 = __toESM(require_react(), 1);
var EditableRootProvider = (0, import_react316.forwardRef)((props43, ref) => {
  const [{ value: editable }, localProps] = createSplitProps2()(props43, ["value"]);
  const mergedProps = mergeProps2(editable.getRootProps(), localProps);
  return (0, import_jsx_runtime148.jsx)(EditableProvider, { value: editable, children: (0, import_jsx_runtime148.jsx)(ark.div, { ...mergedProps, ref }) });
});
EditableRootProvider.displayName = "EditableRootProvider";

// node_modules/@ark-ui/react/dist/components/editable/editable-submit-trigger.js
var import_jsx_runtime149 = __toESM(require_jsx_runtime(), 1);
var import_react318 = __toESM(require_react(), 1);
var EditableSubmitTrigger = (0, import_react318.forwardRef)((props43, ref) => {
  const editable = useEditableContext();
  const mergedProps = mergeProps2(editable.getSubmitTriggerProps(), props43);
  return (0, import_jsx_runtime149.jsx)(ark.button, { ...mergedProps, ref });
});
EditableSubmitTrigger.displayName = "EditableSubmitTrigger";

// node_modules/@ark-ui/react/dist/components/editable/editable.js
var editable_exports = {};
__export(editable_exports, {
  Area: () => EditableArea,
  CancelTrigger: () => EditableCancelTrigger,
  Context: () => EditableContext,
  Control: () => EditableControl,
  EditTrigger: () => EditableEditTrigger,
  Input: () => EditableInput,
  Label: () => EditableLabel,
  Preview: () => EditablePreview,
  Root: () => EditableRoot,
  RootProvider: () => EditableRootProvider,
  SubmitTrigger: () => EditableSubmitTrigger
});

// node_modules/@ark-ui/react/dist/components/field/field-context.js
var FieldContext = (props43) => props43.children(useFieldContext());

// node_modules/@ark-ui/react/dist/components/field/field-error-text.js
var import_jsx_runtime150 = __toESM(require_jsx_runtime(), 1);
var import_react320 = __toESM(require_react(), 1);
var FieldErrorText = (0, import_react320.forwardRef)((props43, ref) => {
  const field = useFieldContext();
  const mergedProps = mergeProps2(field.getErrorTextProps(), props43);
  if (field == null ? void 0 : field.invalid) {
    return (0, import_jsx_runtime150.jsx)(ark.span, { ...mergedProps, ref });
  }
  return null;
});
FieldErrorText.displayName = "FieldErrorText";

// node_modules/@ark-ui/react/dist/components/field/field-helper-text.js
var import_jsx_runtime151 = __toESM(require_jsx_runtime(), 1);
var import_react322 = __toESM(require_react(), 1);
var FieldHelperText = (0, import_react322.forwardRef)((props43, ref) => {
  const field = useFieldContext();
  const mergedProps = mergeProps2(field == null ? void 0 : field.getHelperTextProps(), props43);
  return (0, import_jsx_runtime151.jsx)(ark.span, { ...mergedProps, ref });
});
FieldHelperText.displayName = "FieldHelperText";

// node_modules/@ark-ui/react/dist/components/field/field-input.js
var import_jsx_runtime152 = __toESM(require_jsx_runtime(), 1);
var import_react324 = __toESM(require_react(), 1);
var FieldInput = (0, import_react324.forwardRef)((props43, ref) => {
  const field = useFieldContext();
  const mergedProps = mergeProps2(field == null ? void 0 : field.getInputProps(), props43);
  return (0, import_jsx_runtime152.jsx)(ark.input, { ...mergedProps, ref });
});
FieldInput.displayName = "FieldInput";

// node_modules/@ark-ui/react/dist/components/field/field-label.js
var import_jsx_runtime153 = __toESM(require_jsx_runtime(), 1);
var import_react326 = __toESM(require_react(), 1);
var FieldLabel = (0, import_react326.forwardRef)((props43, ref) => {
  const field = useFieldContext();
  const mergedProps = mergeProps2(field == null ? void 0 : field.getLabelProps(), props43);
  return (0, import_jsx_runtime153.jsx)(ark.label, { ...mergedProps, ref });
});
FieldLabel.displayName = "FieldLabel";

// node_modules/@ark-ui/react/dist/components/field/field-required-indicator.js
var import_jsx_runtime154 = __toESM(require_jsx_runtime(), 1);
var import_react327 = __toESM(require_react(), 1);
var FieldRequiredIndicator = (0, import_react327.forwardRef)(
  ({ fallback: fallback4, ...props43 }, ref) => {
    const field = useFieldContext();
    if (!field.required) {
      return fallback4;
    }
    const mergedProps = mergeProps2(field.getRequiredIndicatorProps(), props43);
    return (0, import_jsx_runtime154.jsx)(ark.span, { ...mergedProps, ref, children: props43.children ?? "*" });
  }
);
FieldRequiredIndicator.displayName = "FieldRequiredIndicator";

// node_modules/@ark-ui/react/dist/components/field/field-root.js
var import_jsx_runtime155 = __toESM(require_jsx_runtime(), 1);
var import_react331 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/field/use-field.js
var import_react329 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/utils/use-safe-layout-effect.js
var import_react328 = __toESM(require_react(), 1);
var useSafeLayoutEffect2 = typeof window !== "undefined" ? import_react328.useLayoutEffect : import_react328.useEffect;

// node_modules/@ark-ui/react/dist/components/fieldset/use-fieldset-context.js
var [FieldsetProvider, useFieldsetContext] = createContext3({
  name: "FieldsetContext",
  hookName: "useFieldsetContext",
  providerName: "<FieldsetProvider />",
  strict: false
});

// node_modules/@ark-ui/react/dist/components/field/field.anatomy.js
var fieldAnatomy = createAnatomy("field").parts(
  "root",
  "errorText",
  "helperText",
  "input",
  "label",
  "select",
  "textarea",
  "requiredIndicator"
);
var parts13 = fieldAnatomy.build();

// node_modules/@ark-ui/react/dist/components/field/use-field.js
var useField = (props43 = {}) => {
  const fieldset = useFieldsetContext();
  const env = useEnvironmentContext();
  const { ids, disabled = Boolean(fieldset == null ? void 0 : fieldset.disabled), invalid = false, readOnly = false, required = false } = props43;
  const [hasErrorText, setHasErrorText] = (0, import_react329.useState)(false);
  const [hasHelperText, setHasHelperText] = (0, import_react329.useState)(false);
  const id = props43.id ?? (0, import_react329.useId)();
  const rootRef = (0, import_react329.useRef)(null);
  const rootId = (ids == null ? void 0 : ids.control) ?? `field::${id}`;
  const errorTextId = (ids == null ? void 0 : ids.errorText) ?? `field::${id}::error-text`;
  const helperTextId = (ids == null ? void 0 : ids.helperText) ?? `field::${id}::helper-text`;
  const labelId = (ids == null ? void 0 : ids.label) ?? `field::${id}::label`;
  useSafeLayoutEffect2(() => {
    const rootNode = rootRef.current;
    if (!rootNode) return;
    const checkTextElements = () => {
      const docOrShadowRoot = env.getRootNode();
      setHasErrorText(!!docOrShadowRoot.getElementById(errorTextId));
      setHasHelperText(!!docOrShadowRoot.getElementById(helperTextId));
    };
    checkTextElements();
    const win = env.getWindow();
    const observer = new win.MutationObserver(checkTextElements);
    observer.observe(rootNode, { childList: true, subtree: true });
    return () => observer.disconnect();
  }, [env, errorTextId, helperTextId]);
  const labelIds = (0, import_react329.useMemo)(() => {
    const ids2 = [];
    if (hasErrorText && invalid) ids2.push(errorTextId);
    if (hasHelperText) ids2.push(helperTextId);
    return ids2.join(" ") || void 0;
  }, [invalid, errorTextId, helperTextId, hasErrorText, hasHelperText]);
  const getRootProps = (0, import_react329.useMemo)(
    () => () => ({
      ...parts13.root.attrs,
      id: rootId,
      ref: rootRef,
      role: "group",
      "data-disabled": dataAttr(disabled),
      "data-invalid": dataAttr(invalid),
      "data-readonly": dataAttr(readOnly)
    }),
    [disabled, invalid, readOnly, rootId]
  );
  const getLabelProps = (0, import_react329.useMemo)(
    () => () => ({
      ...parts13.label.attrs,
      id: labelId,
      "data-disabled": dataAttr(disabled),
      "data-invalid": dataAttr(invalid),
      "data-readonly": dataAttr(readOnly),
      htmlFor: id
    }),
    [disabled, invalid, readOnly, id, labelId]
  );
  const getControlProps = (0, import_react329.useMemo)(
    () => () => ({
      "aria-describedby": labelIds,
      "aria-invalid": ariaAttr(invalid),
      "data-invalid": dataAttr(invalid),
      "data-required": dataAttr(required),
      "data-readonly": dataAttr(readOnly),
      id,
      required,
      disabled,
      readOnly
    }),
    [labelIds, invalid, required, readOnly, id, disabled]
  );
  const getInputProps = (0, import_react329.useMemo)(
    () => () => ({
      ...getControlProps(),
      ...parts13.input.attrs
    }),
    [getControlProps]
  );
  const getTextareaProps = (0, import_react329.useMemo)(
    () => () => ({
      ...getControlProps(),
      ...parts13.textarea.attrs
    }),
    [getControlProps]
  );
  const getSelectProps = (0, import_react329.useMemo)(
    () => () => ({
      ...getControlProps(),
      ...parts13.select.attrs
    }),
    [getControlProps]
  );
  const getHelperTextProps = (0, import_react329.useMemo)(
    () => () => ({
      id: helperTextId,
      ...parts13.helperText.attrs,
      "data-disabled": dataAttr(disabled)
    }),
    [disabled, helperTextId]
  );
  const getErrorTextProps = (0, import_react329.useMemo)(
    () => () => ({
      id: errorTextId,
      ...parts13.errorText.attrs,
      "aria-live": "polite"
    }),
    [errorTextId]
  );
  const getRequiredIndicatorProps = (0, import_react329.useMemo)(
    () => () => ({
      "aria-hidden": true,
      ...parts13.requiredIndicator.attrs
    }),
    []
  );
  return {
    ariaDescribedby: labelIds,
    ids: {
      root: rootId,
      control: id,
      label: labelId,
      errorText: errorTextId,
      helperText: helperTextId
    },
    refs: {
      rootRef
    },
    disabled,
    invalid,
    readOnly,
    required,
    getLabelProps,
    getRootProps,
    getInputProps,
    getTextareaProps,
    getSelectProps,
    getHelperTextProps,
    getErrorTextProps,
    getRequiredIndicatorProps
  };
};

// node_modules/@ark-ui/react/dist/components/field/field-root.js
var FieldRoot = (0, import_react331.forwardRef)((props43, ref) => {
  const [useFieldProps, localProps] = createSplitProps2()(props43, [
    "id",
    "ids",
    "disabled",
    "invalid",
    "readOnly",
    "required"
  ]);
  const field = useField(useFieldProps);
  const mergedProps = mergeProps2(field.getRootProps(), localProps);
  return (0, import_jsx_runtime155.jsx)(FieldProvider, { value: field, children: (0, import_jsx_runtime155.jsx)(ark.div, { ...mergedProps, ref: composeRefs(ref, field.refs.rootRef) }) });
});
FieldRoot.displayName = "FieldRoot";

// node_modules/@ark-ui/react/dist/components/field/field-root-provider.js
var import_jsx_runtime156 = __toESM(require_jsx_runtime(), 1);
var import_react333 = __toESM(require_react(), 1);
var FieldRootProvider = (0, import_react333.forwardRef)((props43, ref) => {
  const [{ value: field }, localProps] = createSplitProps2()(props43, ["value"]);
  const mergedProps = mergeProps2(field.getRootProps(), localProps);
  return (0, import_jsx_runtime156.jsx)(FieldProvider, { value: field, children: (0, import_jsx_runtime156.jsx)(ark.div, { ...mergedProps, ref }) });
});
FieldRootProvider.displayName = "FieldRootProvider";

// node_modules/@ark-ui/react/dist/components/field/field-select.js
var import_jsx_runtime157 = __toESM(require_jsx_runtime(), 1);
var import_react335 = __toESM(require_react(), 1);
var FieldSelect = (0, import_react335.forwardRef)((props43, ref) => {
  const field = useFieldContext();
  const mergedProps = mergeProps2(field == null ? void 0 : field.getSelectProps(), props43);
  return (0, import_jsx_runtime157.jsx)(ark.select, { ...mergedProps, ref });
});
FieldSelect.displayName = "FieldSelect";

// node_modules/@ark-ui/react/dist/components/field/field-textarea.js
var import_jsx_runtime158 = __toESM(require_jsx_runtime(), 1);

// node_modules/@zag-js/auto-resize/dist/index.mjs
function getVisualStyles(node) {
  if (!node) return;
  const style = getComputedStyle2(node);
  return "box-sizing:" + style.boxSizing + ";border-left:" + style.borderLeftWidth + " solid red;border-right:" + style.borderRightWidth + " solid red;font-family:" + style.fontFamily + ";font-feature-settings:" + style.fontFeatureSettings + ";font-kerning:" + style.fontKerning + ";font-size:" + style.fontSize + ";font-stretch:" + style.fontStretch + ";font-style:" + style.fontStyle + ";font-variant:" + style.fontVariant + ";font-variant-caps:" + style.fontVariantCaps + ";font-variant-ligatures:" + style.fontVariantLigatures + ";font-variant-numeric:" + style.fontVariantNumeric + ";font-weight:" + style.fontWeight + ";letter-spacing:" + style.letterSpacing + ";margin-left:" + style.marginLeft + ";margin-right:" + style.marginRight + ";padding-left:" + style.paddingLeft + ";padding-right:" + style.paddingRight + ";text-indent:" + style.textIndent + ";text-transform:" + style.textTransform;
}
function createGhostElement(doc) {
  var el = doc.createElement("div");
  el.id = "ghost";
  el.style.cssText = "display:inline-block;height:0;overflow:hidden;position:absolute;top:0;visibility:hidden;white-space:nowrap;";
  doc.body.appendChild(el);
  return el;
}
function autoResizeInput(input) {
  if (!input) return;
  const doc = getDocument(input);
  const win = getWindow(input);
  const ghost = createGhostElement(doc);
  const cssText = getVisualStyles(input);
  if (cssText) ghost.style.cssText += cssText;
  function resize() {
    win.requestAnimationFrame(() => {
      ghost.innerHTML = input.value;
      const rect = win.getComputedStyle(ghost);
      input == null ? void 0 : input.style.setProperty("width", rect.width);
    });
  }
  resize();
  input == null ? void 0 : input.addEventListener("input", resize);
  input == null ? void 0 : input.addEventListener("change", resize);
  return () => {
    doc.body.removeChild(ghost);
    input == null ? void 0 : input.removeEventListener("input", resize);
    input == null ? void 0 : input.removeEventListener("change", resize);
  };
}
var autoresizeTextarea = (el) => {
  var _a8, _b7;
  if (!el) return;
  const style = getComputedStyle2(el);
  const win = getWindow(el);
  const doc = getDocument(el);
  const resize = () => {
    requestAnimationFrame(() => {
      el.style.height = "auto";
      let newHeight;
      if (style.boxSizing === "content-box") {
        newHeight = el.scrollHeight - (parseFloat(style.paddingTop) + parseFloat(style.paddingBottom));
      } else {
        newHeight = el.scrollHeight + parseFloat(style.borderTopWidth) + parseFloat(style.borderBottomWidth);
      }
      if (style.maxHeight !== "none" && newHeight > parseFloat(style.maxHeight)) {
        if (style.overflowY === "hidden") {
          el.style.overflowY = "scroll";
        }
        newHeight = parseFloat(style.maxHeight);
      } else if (style.overflowY !== "hidden") {
        el.style.overflowY = "hidden";
      }
      el.style.height = `${newHeight}px`;
    });
  };
  el.addEventListener("input", resize);
  (_a8 = el.form) == null ? void 0 : _a8.addEventListener("reset", resize);
  const elementPrototype = Object.getPrototypeOf(el);
  const descriptor = Object.getOwnPropertyDescriptor(elementPrototype, "value");
  Object.defineProperty(el, "value", {
    ...descriptor,
    set() {
      var _a9;
      (_a9 = descriptor == null ? void 0 : descriptor.set) == null ? void 0 : _a9.apply(this, arguments);
      resize();
    }
  });
  const resizeObserver = new win.ResizeObserver(() => {
    requestAnimationFrame(() => resize());
  });
  resizeObserver.observe(el);
  const attrObserver = new win.MutationObserver(() => resize());
  attrObserver.observe(el, { attributes: true, attributeFilter: ["rows", "placeholder"] });
  (_b7 = doc.fonts) == null ? void 0 : _b7.addEventListener("loadingdone", resize);
  return () => {
    var _a9, _b8;
    el.removeEventListener("input", resize);
    (_a9 = el.form) == null ? void 0 : _a9.removeEventListener("reset", resize);
    (_b8 = doc.fonts) == null ? void 0 : _b8.removeEventListener("loadingdone", resize);
    resizeObserver.disconnect();
    attrObserver.disconnect();
  };
};

// node_modules/@ark-ui/react/dist/components/field/field-textarea.js
var import_react337 = __toESM(require_react(), 1);
var FieldTextarea = (0, import_react337.forwardRef)((props43, ref) => {
  const { autoresize, ...textareaProps } = props43;
  const textareaRef = (0, import_react337.useRef)(null);
  const field = useFieldContext();
  const mergedProps = mergeProps2(
    field == null ? void 0 : field.getTextareaProps(),
    { style: { resize: autoresize ? "none" : void 0 } },
    textareaProps
  );
  (0, import_react337.useEffect)(() => {
    if (!autoresize) return;
    return autoresizeTextarea(textareaRef.current);
  }, [autoresize]);
  return (0, import_jsx_runtime158.jsx)(ark.textarea, { ...mergedProps, ref: composeRefs(ref, textareaRef) });
});
FieldTextarea.displayName = "FieldTextarea";

// node_modules/@ark-ui/react/dist/components/field/field.js
var field_exports = {};
__export(field_exports, {
  Context: () => FieldContext,
  ErrorText: () => FieldErrorText,
  HelperText: () => FieldHelperText,
  Input: () => FieldInput,
  Label: () => FieldLabel,
  RequiredIndicator: () => FieldRequiredIndicator,
  Root: () => FieldRoot,
  RootProvider: () => FieldRootProvider,
  Select: () => FieldSelect,
  Textarea: () => FieldTextarea
});

// node_modules/@ark-ui/react/dist/components/fieldset/fieldset-context.js
var FieldsetContext = (props43) => props43.children(useFieldsetContext());

// node_modules/@ark-ui/react/dist/components/fieldset/fieldset-error-text.js
var import_jsx_runtime159 = __toESM(require_jsx_runtime(), 1);
var import_react339 = __toESM(require_react(), 1);
var FieldsetErrorText = (0, import_react339.forwardRef)((props43, ref) => {
  const fieldset = useFieldsetContext();
  const mergedProps = mergeProps2(fieldset.getErrorTextProps(), props43);
  return fieldset.invalid ? (0, import_jsx_runtime159.jsx)(ark.span, { ...mergedProps, ref }) : null;
});
FieldsetErrorText.displayName = "FieldsetErrorText";

// node_modules/@ark-ui/react/dist/components/fieldset/fieldset-helper-text.js
var import_jsx_runtime160 = __toESM(require_jsx_runtime(), 1);
var import_react341 = __toESM(require_react(), 1);
var FieldsetHelperText = (0, import_react341.forwardRef)((props43, ref) => {
  const fieldset = useFieldsetContext();
  const mergedProps = mergeProps2(fieldset.getHelperTextProps(), props43);
  return (0, import_jsx_runtime160.jsx)(ark.span, { ...mergedProps, ref });
});
FieldsetHelperText.displayName = "FieldsetHelperText";

// node_modules/@ark-ui/react/dist/components/fieldset/fieldset-legend.js
var import_jsx_runtime161 = __toESM(require_jsx_runtime(), 1);
var import_react343 = __toESM(require_react(), 1);
var FieldsetLegend = (0, import_react343.forwardRef)((props43, ref) => {
  const fieldset = useFieldsetContext();
  const mergedProps = mergeProps2(fieldset.getLegendProps(), props43);
  return (0, import_jsx_runtime161.jsx)(ark.legend, { ...mergedProps, ref });
});
FieldsetLegend.displayName = "FieldsetLegend";

// node_modules/@ark-ui/react/dist/components/fieldset/fieldset-root.js
var import_jsx_runtime162 = __toESM(require_jsx_runtime(), 1);
var import_react346 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/fieldset/use-fieldset.js
var import_react344 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/fieldset/fieldset.anatomy.js
var fieldsetAnatomy = createAnatomy("fieldset").parts("root", "errorText", "helperText", "legend");
var parts14 = fieldsetAnatomy.build();

// node_modules/@ark-ui/react/dist/components/fieldset/use-fieldset.js
var useFieldset = (props43 = {}) => {
  const { disabled = false, invalid = false } = props43;
  const env = useEnvironmentContext();
  const hasErrorText = (0, import_react344.useRef)(false);
  const hasHelperText = (0, import_react344.useRef)(false);
  const id = props43.id ?? (0, import_react344.useId)();
  const rootRef = (0, import_react344.useRef)(null);
  const errorTextId = `fieldset::${id}::error-text`;
  const helperTextId = `fieldset::${id}::helper-text`;
  useSafeLayoutEffect2(() => {
    const rootNode = rootRef.current;
    if (!rootNode) return;
    const checkTextElements = () => {
      const docOrShadowRoot = env.getRootNode();
      hasErrorText.current = !!docOrShadowRoot.getElementById(errorTextId);
      hasHelperText.current = !!docOrShadowRoot.getElementById(helperTextId);
    };
    checkTextElements();
    const win = env.getWindow();
    const observer = new win.MutationObserver(checkTextElements);
    observer.observe(rootNode, { childList: true, subtree: true });
    return () => observer.disconnect();
  }, [env, errorTextId, helperTextId]);
  const labelIds = (0, import_react344.useMemo)(() => {
    const ids = [];
    if (hasErrorText.current && invalid) ids.push(errorTextId);
    if (hasHelperText.current) ids.push(helperTextId);
    return ids.join(" ") || void 0;
  }, [invalid, errorTextId, helperTextId]);
  const getRootProps = (0, import_react344.useMemo)(
    () => () => ({
      ...parts14.root.attrs,
      ref: rootRef,
      disabled,
      "data-disabled": dataAttr(disabled),
      "data-invalid": dataAttr(invalid),
      "aria-describedby": labelIds
    }),
    [disabled, invalid, labelIds]
  );
  const getLegendProps = (0, import_react344.useMemo)(
    () => () => ({
      ...parts14.legend.attrs,
      "data-disabled": dataAttr(disabled),
      "data-invalid": dataAttr(invalid)
    }),
    [disabled, invalid]
  );
  const getHelperTextProps = (0, import_react344.useMemo)(
    () => () => ({
      id: helperTextId,
      ...parts14.helperText.attrs
    }),
    [helperTextId]
  );
  const getErrorTextProps = (0, import_react344.useMemo)(
    () => () => ({
      id: errorTextId,
      ...parts14.errorText.attrs,
      "aria-live": "polite"
    }),
    [errorTextId]
  );
  return {
    refs: {
      rootRef
    },
    disabled,
    invalid,
    getRootProps,
    getLegendProps,
    getHelperTextProps,
    getErrorTextProps
  };
};

// node_modules/@ark-ui/react/dist/components/fieldset/fieldset-root.js
var FieldsetRoot = (0, import_react346.forwardRef)((props43, ref) => {
  const [useFieldsetProps, localProps] = createSplitProps2()(props43, ["id", "disabled", "invalid"]);
  const fieldset = useFieldset(useFieldsetProps);
  const mergedProps = mergeProps2(fieldset.getRootProps(), localProps);
  return (0, import_jsx_runtime162.jsx)(FieldsetProvider, { value: fieldset, children: (0, import_jsx_runtime162.jsx)(ark.fieldset, { ...mergedProps, ref: composeRefs(ref, fieldset.refs.rootRef) }) });
});
FieldsetRoot.displayName = "FieldsetRoot";

// node_modules/@ark-ui/react/dist/components/fieldset/fieldset-root-provider.js
var import_jsx_runtime163 = __toESM(require_jsx_runtime(), 1);
var import_react348 = __toESM(require_react(), 1);
var FieldsetRootProvider = (0, import_react348.forwardRef)((props43, ref) => {
  const [{ value: fieldset }, localProps] = createSplitProps2()(props43, ["value"]);
  const mergedProps = mergeProps2(fieldset.getRootProps(), localProps);
  return (0, import_jsx_runtime163.jsx)(FieldsetProvider, { value: fieldset, children: (0, import_jsx_runtime163.jsx)(ark.fieldset, { ...mergedProps, ref }) });
});
FieldsetRootProvider.displayName = "FieldsetRootProvider";

// node_modules/@ark-ui/react/dist/components/fieldset/fieldset.js
var fieldset_exports = {};
__export(fieldset_exports, {
  Context: () => FieldsetContext,
  ErrorText: () => FieldsetErrorText,
  HelperText: () => FieldsetHelperText,
  Legend: () => FieldsetLegend,
  Root: () => FieldsetRoot,
  RootProvider: () => FieldsetRootProvider
});

// node_modules/@ark-ui/react/dist/components/file-upload/file-upload-clear-trigger.js
var import_jsx_runtime164 = __toESM(require_jsx_runtime(), 1);
var import_react350 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/file-upload/use-file-upload-context.js
var [FileUploadProvider, useFileUploadContext] = createContext3({
  name: "FileUploadContext",
  hookName: "useFileUploadContext",
  providerName: "<FileUploadProvider />"
});

// node_modules/@ark-ui/react/dist/components/file-upload/file-upload-clear-trigger.js
var FileUploadClearTrigger = (0, import_react350.forwardRef)((props43, ref) => {
  const fileUpload = useFileUploadContext();
  const mergedProps = mergeProps2(fileUpload.getClearTriggerProps(), props43);
  return (0, import_jsx_runtime164.jsx)(ark.button, { ...mergedProps, ref });
});
FileUploadClearTrigger.displayName = "FileUploadClearTrigger";

// node_modules/@ark-ui/react/dist/components/file-upload/file-upload-context.js
var FileUploadContext = (props43) => props43.children(useFileUploadContext());

// node_modules/@ark-ui/react/dist/components/file-upload/file-upload-dropzone.js
var import_jsx_runtime165 = __toESM(require_jsx_runtime(), 1);
var import_react352 = __toESM(require_react(), 1);
var FileUploadDropzone = (0, import_react352.forwardRef)((props43, ref) => {
  const [dropzoneProps, localProps] = createSplitProps2()(props43, ["disableClick"]);
  const fileUpload = useFileUploadContext();
  const mergedProps = mergeProps2(fileUpload.getDropzoneProps(dropzoneProps), localProps);
  return (0, import_jsx_runtime165.jsx)(ark.div, { ...mergedProps, ref });
});
FileUploadDropzone.displayName = "FileUploadDropzone";

// node_modules/@ark-ui/react/dist/components/file-upload/file-upload-hidden-input.js
var import_jsx_runtime166 = __toESM(require_jsx_runtime(), 1);
var import_react354 = __toESM(require_react(), 1);
var FileUploadHiddenInput = (0, import_react354.forwardRef)((props43, ref) => {
  const fileUpload = useFileUploadContext();
  const mergedProps = mergeProps2(fileUpload.getHiddenInputProps(), props43);
  const field = useFieldContext();
  return (0, import_jsx_runtime166.jsx)(ark.input, { "aria-describedby": field == null ? void 0 : field.ariaDescribedby, ...mergedProps, ref });
});
FileUploadHiddenInput.displayName = "FileUploadHiddenInput";

// node_modules/@ark-ui/react/dist/components/file-upload/file-upload-item.js
var import_jsx_runtime167 = __toESM(require_jsx_runtime(), 1);
var import_react356 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/file-upload/use-file-upload-item-props-context.js
var [FileUploadItemPropsProvider, useFileUploadItemPropsContext] = createContext3({
  name: "FileUploadItemPropsContext",
  hookName: "useFileUploadItemPropsContext",
  providerName: "<FileUploadItemPropsProvider />"
});

// node_modules/@ark-ui/react/dist/components/file-upload/file-upload-item.js
var FileUploadItem = (0, import_react356.forwardRef)((props43, ref) => {
  const [itemProps14, localProps] = createSplitProps2()(props43, ["file"]);
  const fileUpload = useFileUploadContext();
  const mergedProps = mergeProps2(fileUpload.getItemProps(itemProps14), localProps);
  return (0, import_jsx_runtime167.jsx)(FileUploadItemPropsProvider, { value: itemProps14, children: (0, import_jsx_runtime167.jsx)(ark.li, { ...mergedProps, ref }) });
});
FileUploadItem.displayName = "FileUploadItem";

// node_modules/@ark-ui/react/dist/components/file-upload/file-upload-item-delete-trigger.js
var import_jsx_runtime168 = __toESM(require_jsx_runtime(), 1);
var import_react358 = __toESM(require_react(), 1);
var FileUploadItemDeleteTrigger = (0, import_react358.forwardRef)(
  (props43, ref) => {
    const fileUpload = useFileUploadContext();
    const itemProps14 = useFileUploadItemPropsContext();
    const mergedProps = mergeProps2(fileUpload.getItemDeleteTriggerProps(itemProps14), props43);
    return (0, import_jsx_runtime168.jsx)(ark.button, { ...mergedProps, ref });
  }
);
FileUploadItemDeleteTrigger.displayName = "FileUploadItemDeleteTrigger";

// node_modules/@ark-ui/react/dist/components/file-upload/file-upload-item-group.js
var import_jsx_runtime169 = __toESM(require_jsx_runtime(), 1);
var import_react360 = __toESM(require_react(), 1);
var FileUploadItemGroup = (0, import_react360.forwardRef)((props43, ref) => {
  const fileUpload = useFileUploadContext();
  const mergedProps = mergeProps2(fileUpload.getItemGroupProps(), props43);
  return (0, import_jsx_runtime169.jsx)(ark.ul, { ...mergedProps, ref });
});
FileUploadItemGroup.displayName = "FileUploadItemGroup";

// node_modules/@ark-ui/react/dist/components/file-upload/file-upload-item-name.js
var import_jsx_runtime170 = __toESM(require_jsx_runtime(), 1);
var import_react362 = __toESM(require_react(), 1);
var FileUploadItemName = (0, import_react362.forwardRef)((props43, ref) => {
  const { children, ...rest } = props43;
  const fileUpload = useFileUploadContext();
  const itemProps14 = useFileUploadItemPropsContext();
  const mergedProps = mergeProps2(fileUpload.getItemNameProps(itemProps14), rest);
  return (0, import_jsx_runtime170.jsx)(ark.div, { ...mergedProps, ref, children: children || itemProps14.file.name });
});
FileUploadItemName.displayName = "FileUploadItemName";

// node_modules/@ark-ui/react/dist/components/file-upload/file-upload-item-preview.js
var import_jsx_runtime171 = __toESM(require_jsx_runtime(), 1);
var import_react364 = __toESM(require_react(), 1);
var FileUploadItemPreview = (0, import_react364.forwardRef)((props43, ref) => {
  const fileUpload = useFileUploadContext();
  const itemProps14 = useFileUploadItemPropsContext();
  const mergedProps = mergeProps2(fileUpload.getItemPreviewProps(itemProps14), props43);
  if (!itemProps14.file.type.match(props43.type ?? ".*")) return null;
  return (0, import_jsx_runtime171.jsx)(ark.div, { ...mergedProps, ref });
});
FileUploadItemPreview.displayName = "FileUploadItemPreview";

// node_modules/@ark-ui/react/dist/components/file-upload/file-upload-item-preview-image.js
var import_jsx_runtime172 = __toESM(require_jsx_runtime(), 1);
var import_react366 = __toESM(require_react(), 1);
var FileUploadItemPreviewImage = (0, import_react366.forwardRef)(
  (props43, ref) => {
    const [url, setUrl] = (0, import_react366.useState)("");
    const fileUpload = useFileUploadContext();
    const itemProps14 = useFileUploadItemPropsContext();
    const mergedProps = mergeProps2(fileUpload.getItemPreviewImageProps({ ...itemProps14, url }), props43);
    (0, import_react366.useEffect)(() => {
      return fileUpload.createFileUrl(itemProps14.file, (url2) => setUrl(url2));
    }, [itemProps14, fileUpload]);
    if (!url) return null;
    return (0, import_jsx_runtime172.jsx)(ark.img, { ...mergedProps, ref });
  }
);
FileUploadItemPreviewImage.displayName = "FileUploadItemPreviewImage";

// node_modules/@ark-ui/react/dist/components/file-upload/file-upload-item-size-text.js
var import_jsx_runtime173 = __toESM(require_jsx_runtime(), 1);
var import_react368 = __toESM(require_react(), 1);
var FileUploadItemSizeText = (0, import_react368.forwardRef)((props43, ref) => {
  const { children, ...rest } = props43;
  const fileUpload = useFileUploadContext();
  const itemProps14 = useFileUploadItemPropsContext();
  const mergedProps = mergeProps2(fileUpload.getItemSizeTextProps(itemProps14), rest);
  return (0, import_jsx_runtime173.jsx)(ark.div, { ...mergedProps, ref, children: children || fileUpload.getFileSize(itemProps14.file) });
});
FileUploadItemSizeText.displayName = "FileUploadItemSizeText";

// node_modules/@ark-ui/react/dist/components/file-upload/file-upload-label.js
var import_jsx_runtime174 = __toESM(require_jsx_runtime(), 1);
var import_react370 = __toESM(require_react(), 1);
var FileUploadLabel = (0, import_react370.forwardRef)((props43, ref) => {
  const fileUpload = useFileUploadContext();
  const mergedProps = mergeProps2(fileUpload.getLabelProps(), props43);
  return (0, import_jsx_runtime174.jsx)(ark.label, { ...mergedProps, ref });
});
FileUploadLabel.displayName = "FileUploadLabel";

// node_modules/@ark-ui/react/dist/components/file-upload/file-upload-root.js
var import_jsx_runtime175 = __toESM(require_jsx_runtime(), 1);
var import_react374 = __toESM(require_react(), 1);

// node_modules/@zag-js/file-upload/dist/index.mjs
var anatomy13 = createAnatomy("file-upload").parts(
  "root",
  "dropzone",
  "item",
  "itemDeleteTrigger",
  "itemGroup",
  "itemName",
  "itemPreview",
  "itemPreviewImage",
  "itemSizeText",
  "label",
  "trigger",
  "clearTrigger"
);
var parts15 = anatomy13.build();
var getRootId12 = (ctx) => {
  var _a8;
  return ((_a8 = ctx.ids) == null ? void 0 : _a8.root) ?? `file:${ctx.id}`;
};
var getDropzoneId = (ctx) => {
  var _a8;
  return ((_a8 = ctx.ids) == null ? void 0 : _a8.dropzone) ?? `file:${ctx.id}:dropzone`;
};
var getHiddenInputId4 = (ctx) => {
  var _a8;
  return ((_a8 = ctx.ids) == null ? void 0 : _a8.hiddenInput) ?? `file:${ctx.id}:input`;
};
var getTriggerId6 = (ctx) => {
  var _a8;
  return ((_a8 = ctx.ids) == null ? void 0 : _a8.trigger) ?? `file:${ctx.id}:trigger`;
};
var getLabelId7 = (ctx) => {
  var _a8;
  return ((_a8 = ctx.ids) == null ? void 0 : _a8.label) ?? `file:${ctx.id}:label`;
};
var getItemId4 = (ctx, id) => {
  var _a8, _b7;
  return ((_b7 = (_a8 = ctx.ids) == null ? void 0 : _a8.item) == null ? void 0 : _b7.call(_a8, id)) ?? `file:${ctx.id}:item:${id}`;
};
var getItemNameId = (ctx, id) => {
  var _a8, _b7;
  return ((_b7 = (_a8 = ctx.ids) == null ? void 0 : _a8.itemName) == null ? void 0 : _b7.call(_a8, id)) ?? `file:${ctx.id}:item-name:${id}`;
};
var getItemSizeTextId = (ctx, id) => {
  var _a8, _b7;
  return ((_b7 = (_a8 = ctx.ids) == null ? void 0 : _a8.itemSizeText) == null ? void 0 : _b7.call(_a8, id)) ?? `file:${ctx.id}:item-size:${id}`;
};
var getItemPreviewId = (ctx, id) => {
  var _a8, _b7;
  return ((_b7 = (_a8 = ctx.ids) == null ? void 0 : _a8.itemPreview) == null ? void 0 : _b7.call(_a8, id)) ?? `file:${ctx.id}:item-preview:${id}`;
};
var getRootEl4 = (ctx) => ctx.getById(getRootId12(ctx));
var getHiddenInputEl4 = (ctx) => ctx.getById(getHiddenInputId4(ctx));
var getDropzoneEl = (ctx) => ctx.getById(getDropzoneId(ctx));
function isEventWithFiles(event) {
  const target = getEventTarget(event);
  if (!event.dataTransfer) return !!target && "files" in target;
  return event.dataTransfer.types.some((type) => {
    return type === "Files" || type === "application/x-moz-file";
  });
}
function isFilesWithinRange(ctx, incomingCount) {
  const { context, prop, computed } = ctx;
  if (!computed("multiple") && incomingCount > 1) return false;
  if (!computed("multiple") && incomingCount + context.get("acceptedFiles").length === 2) return true;
  if (incomingCount + context.get("acceptedFiles").length > prop("maxFiles")) return false;
  return true;
}
function getEventFiles(ctx, files) {
  const { context, prop, computed } = ctx;
  const acceptedFiles = [];
  const rejectedFiles = [];
  files.forEach((file) => {
    var _a8;
    const [accepted, acceptError] = isValidFileType(file, computed("acceptAttr"));
    const [sizeMatch, sizeError] = isValidFileSize(file, prop("minFileSize"), prop("maxFileSize"));
    const validateErrors = (_a8 = prop("validate")) == null ? void 0 : _a8(file, {
      acceptedFiles: context.get("acceptedFiles"),
      rejectedFiles: context.get("rejectedFiles")
    });
    const valid = validateErrors ? validateErrors.length === 0 : true;
    if (accepted && sizeMatch && valid) {
      acceptedFiles.push(file);
    } else {
      const errors = [acceptError, sizeError];
      if (!valid) errors.push(...validateErrors ?? []);
      rejectedFiles.push({ file, errors: errors.filter(Boolean) });
    }
  });
  if (!isFilesWithinRange(ctx, acceptedFiles.length)) {
    acceptedFiles.forEach((file) => {
      rejectedFiles.push({ file, errors: ["TOO_MANY_FILES"] });
    });
    acceptedFiles.splice(0);
  }
  return {
    acceptedFiles,
    rejectedFiles
  };
}
function setInputFiles(inputEl, files) {
  const win = getWindow(inputEl);
  try {
    if ("DataTransfer" in win) {
      const dataTransfer = new win.DataTransfer();
      files.forEach((file) => {
        dataTransfer.items.add(file);
      });
      inputEl.files = dataTransfer.files;
    }
  } catch {
  }
}
function connect14(service, normalize4) {
  const { state: state2, send, prop, computed, scope, context } = service;
  const disabled = prop("disabled");
  const allowDrop = prop("allowDrop");
  const translations = prop("translations");
  const dragging = state2.matches("dragging");
  const focused = state2.matches("focused") && !disabled;
  return {
    dragging,
    focused,
    disabled: !!disabled,
    openFilePicker() {
      if (disabled) return;
      send({ type: "OPEN" });
    },
    deleteFile(file) {
      send({ type: "FILE.DELETE", file });
    },
    acceptedFiles: context.get("acceptedFiles"),
    rejectedFiles: context.get("rejectedFiles"),
    setFiles(files) {
      send({ type: "FILES.SET", files, count: files.length });
    },
    clearRejectedFiles() {
      send({ type: "REJECTED_FILES.CLEAR" });
    },
    clearFiles() {
      send({ type: "FILES.CLEAR" });
    },
    getFileSize(file) {
      return formatBytes(file.size, prop("locale"));
    },
    createFileUrl(file, cb) {
      const win = scope.getWin();
      const url = win.URL.createObjectURL(file);
      cb(url);
      return () => win.URL.revokeObjectURL(url);
    },
    setClipboardFiles(dt) {
      if (disabled) return false;
      const items = Array.from((dt == null ? void 0 : dt.items) ?? []);
      const files = items.reduce((acc, item) => {
        if (item.kind !== "file") return acc;
        const file = item.getAsFile();
        if (!file) return acc;
        return [...acc, file];
      }, []);
      if (!files.length) return false;
      send({ type: "FILES.SET", files });
      return true;
    },
    getRootProps() {
      return normalize4.element({
        ...parts15.root.attrs,
        dir: prop("dir"),
        id: getRootId12(scope),
        "data-disabled": dataAttr(disabled),
        "data-dragging": dataAttr(dragging)
      });
    },
    getDropzoneProps(props210 = {}) {
      return normalize4.element({
        ...parts15.dropzone.attrs,
        dir: prop("dir"),
        id: getDropzoneId(scope),
        tabIndex: disabled || props210.disableClick ? void 0 : 0,
        role: props210.disableClick ? "application" : "button",
        "aria-label": translations.dropzone,
        "aria-disabled": disabled,
        "data-invalid": dataAttr(prop("invalid")),
        "data-disabled": dataAttr(disabled),
        "data-dragging": dataAttr(dragging),
        onKeyDown(event) {
          if (disabled) return;
          if (event.defaultPrevented) return;
          if (!isSelfTarget(event)) return;
          if (props210.disableClick) return;
          if (event.key !== "Enter" && event.key !== " ") return;
          send({ type: "DROPZONE.CLICK", src: "keydown" });
        },
        onClick(event) {
          if (disabled) return;
          if (event.defaultPrevented) return;
          if (props210.disableClick) return;
          if (!isSelfTarget(event)) return;
          if (event.currentTarget.localName === "label") {
            event.preventDefault();
          }
          send({ type: "DROPZONE.CLICK" });
        },
        onDragOver(event) {
          if (disabled) return;
          if (!allowDrop) return;
          event.preventDefault();
          event.stopPropagation();
          try {
            event.dataTransfer.dropEffect = "copy";
          } catch {
          }
          const hasFiles = isEventWithFiles(event);
          if (!hasFiles) return;
          const count = event.dataTransfer.items.length;
          send({ type: "DROPZONE.DRAG_OVER", count });
        },
        onDragLeave(event) {
          if (disabled) return;
          if (!allowDrop) return;
          if (contains(event.currentTarget, event.relatedTarget)) return;
          send({ type: "DROPZONE.DRAG_LEAVE" });
        },
        onDrop(event) {
          if (disabled) return;
          if (allowDrop) {
            event.preventDefault();
            event.stopPropagation();
          }
          const hasFiles = isEventWithFiles(event);
          if (disabled || !hasFiles) return;
          getFileEntries(event.dataTransfer.items, prop("directory")).then((files) => {
            send({ type: "DROPZONE.DROP", files: flatArray(files) });
          });
        },
        onFocus() {
          if (disabled) return;
          send({ type: "DROPZONE.FOCUS" });
        },
        onBlur() {
          if (disabled) return;
          send({ type: "DROPZONE.BLUR" });
        }
      });
    },
    getTriggerProps() {
      return normalize4.button({
        ...parts15.trigger.attrs,
        dir: prop("dir"),
        id: getTriggerId6(scope),
        disabled,
        "data-disabled": dataAttr(disabled),
        "data-invalid": dataAttr(prop("invalid")),
        type: "button",
        onClick(event) {
          if (disabled) return;
          if (contains(getDropzoneEl(scope), event.currentTarget)) {
            event.stopPropagation();
          }
          send({ type: "OPEN" });
        }
      });
    },
    getHiddenInputProps() {
      return normalize4.input({
        id: getHiddenInputId4(scope),
        tabIndex: -1,
        disabled,
        type: "file",
        required: prop("required"),
        capture: prop("capture"),
        name: prop("name"),
        accept: computed("acceptAttr"),
        webkitdirectory: prop("directory") ? "" : void 0,
        multiple: computed("multiple") || prop("maxFiles") > 1,
        onClick(event) {
          event.stopPropagation();
          event.currentTarget.value = "";
        },
        onInput(event) {
          if (disabled) return;
          const { files } = event.currentTarget;
          send({ type: "FILE.SELECT", files: files ? Array.from(files) : [] });
        },
        style: visuallyHiddenStyle
      });
    },
    getItemGroupProps() {
      return normalize4.element({
        ...parts15.itemGroup.attrs,
        dir: prop("dir"),
        "data-disabled": dataAttr(disabled)
      });
    },
    getItemProps(props210) {
      const { file } = props210;
      return normalize4.element({
        ...parts15.item.attrs,
        dir: prop("dir"),
        id: getItemId4(scope, file.name),
        "data-disabled": dataAttr(disabled)
      });
    },
    getItemNameProps(props210) {
      const { file } = props210;
      return normalize4.element({
        ...parts15.itemName.attrs,
        dir: prop("dir"),
        id: getItemNameId(scope, file.name),
        "data-disabled": dataAttr(disabled)
      });
    },
    getItemSizeTextProps(props210) {
      const { file } = props210;
      return normalize4.element({
        ...parts15.itemSizeText.attrs,
        dir: prop("dir"),
        id: getItemSizeTextId(scope, file.name),
        "data-disabled": dataAttr(disabled)
      });
    },
    getItemPreviewProps(props210) {
      const { file } = props210;
      return normalize4.element({
        ...parts15.itemPreview.attrs,
        dir: prop("dir"),
        id: getItemPreviewId(scope, file.name),
        "data-disabled": dataAttr(disabled)
      });
    },
    getItemPreviewImageProps(props210) {
      var _a8;
      const { file, url } = props210;
      const isImage = file.type.startsWith("image/");
      if (!isImage) {
        throw new Error("Preview Image is only supported for image files");
      }
      return normalize4.img({
        ...parts15.itemPreviewImage.attrs,
        alt: (_a8 = translations.itemPreview) == null ? void 0 : _a8.call(translations, file),
        src: url,
        "data-disabled": dataAttr(disabled)
      });
    },
    getItemDeleteTriggerProps(props210) {
      var _a8;
      const { file } = props210;
      return normalize4.button({
        ...parts15.itemDeleteTrigger.attrs,
        dir: prop("dir"),
        type: "button",
        disabled,
        "data-disabled": dataAttr(disabled),
        "aria-label": (_a8 = translations.deleteFile) == null ? void 0 : _a8.call(translations, file),
        onClick() {
          if (disabled) return;
          send({ type: "FILE.DELETE", file });
        }
      });
    },
    getLabelProps() {
      return normalize4.label({
        ...parts15.label.attrs,
        dir: prop("dir"),
        id: getLabelId7(scope),
        htmlFor: getHiddenInputId4(scope),
        "data-disabled": dataAttr(disabled)
      });
    },
    getClearTriggerProps() {
      return normalize4.button({
        ...parts15.clearTrigger.attrs,
        dir: prop("dir"),
        type: "button",
        disabled,
        hidden: context.get("acceptedFiles").length === 0,
        "data-disabled": dataAttr(disabled),
        onClick(event) {
          if (event.defaultPrevented) return;
          if (disabled) return;
          send({ type: "FILES.CLEAR" });
        }
      });
    }
  };
}
var machine14 = createMachine({
  props({ props: props210 }) {
    return {
      minFileSize: 0,
      maxFileSize: Number.POSITIVE_INFINITY,
      maxFiles: 1,
      allowDrop: true,
      preventDocumentDrop: true,
      ...props210,
      translations: {
        dropzone: "dropzone",
        itemPreview: (file) => `preview of ${file.name}`,
        deleteFile: (file) => `delete file ${file.name}`,
        ...props210.translations
      }
    };
  },
  initialState() {
    return "idle";
  },
  context({ prop, bindable, getContext }) {
    return {
      acceptedFiles: bindable(() => ({
        defaultValue: [],
        isEqual: (a2, b2) => a2.length === (b2 == null ? void 0 : b2.length) && a2.every((file, i) => isFileEqual(file, b2[i])),
        hash(value) {
          return value.map((file) => `${file.name}-${file.size}`).join(",");
        },
        onChange(value) {
          var _a8, _b7;
          const ctx = getContext();
          (_a8 = prop("onFileAccept")) == null ? void 0 : _a8({ files: value });
          (_b7 = prop("onFileChange")) == null ? void 0 : _b7({ acceptedFiles: value, rejectedFiles: ctx.get("rejectedFiles") });
        }
      })),
      rejectedFiles: bindable(() => ({
        defaultValue: [],
        isEqual: (a2, b2) => a2.length === (b2 == null ? void 0 : b2.length) && a2.every((file, i) => isFileEqual(file.file, b2[i].file)),
        onChange(value) {
          var _a8, _b7;
          const ctx = getContext();
          (_a8 = prop("onFileReject")) == null ? void 0 : _a8({ files: value });
          (_b7 = prop("onFileChange")) == null ? void 0 : _b7({ acceptedFiles: ctx.get("acceptedFiles"), rejectedFiles: value });
        }
      }))
    };
  },
  computed: {
    acceptAttr: ({ prop }) => getAcceptAttrString(prop("accept")),
    multiple: ({ prop }) => prop("maxFiles") > 1
  },
  watch({ track, context, action }) {
    track([() => context.hash("acceptedFiles")], () => {
      action(["syncInputElement"]);
    });
  },
  on: {
    "FILES.SET": {
      actions: ["setFiles"]
    },
    "FILE.SELECT": {
      actions: ["setEventFiles"]
    },
    "FILE.DELETE": {
      actions: ["removeFile"]
    },
    "FILES.CLEAR": {
      actions: ["clearFiles"]
    },
    "REJECTED_FILES.CLEAR": {
      actions: ["clearRejectedFiles"]
    }
  },
  effects: ["preventDocumentDrop"],
  states: {
    idle: {
      on: {
        OPEN: {
          actions: ["openFilePicker"]
        },
        "DROPZONE.CLICK": {
          actions: ["openFilePicker"]
        },
        "DROPZONE.FOCUS": {
          target: "focused"
        },
        "DROPZONE.DRAG_OVER": {
          target: "dragging"
        }
      }
    },
    focused: {
      on: {
        "DROPZONE.BLUR": {
          target: "idle"
        },
        OPEN: {
          actions: ["openFilePicker"]
        },
        "DROPZONE.CLICK": {
          actions: ["openFilePicker"]
        },
        "DROPZONE.DRAG_OVER": {
          target: "dragging"
        }
      }
    },
    dragging: {
      on: {
        "DROPZONE.DROP": {
          target: "idle",
          actions: ["setEventFiles"]
        },
        "DROPZONE.DRAG_LEAVE": {
          target: "idle"
        }
      }
    }
  },
  implementations: {
    effects: {
      preventDocumentDrop({ prop, scope }) {
        if (!prop("preventDocumentDrop")) return;
        if (!prop("allowDrop")) return;
        if (prop("disabled")) return;
        const doc = scope.getDoc();
        const onDragOver = (event) => {
          event == null ? void 0 : event.preventDefault();
        };
        const onDrop = (event) => {
          if (contains(getRootEl4(scope), getEventTarget(event))) return;
          event.preventDefault();
        };
        return callAll2(addDomEvent(doc, "dragover", onDragOver, false), addDomEvent(doc, "drop", onDrop, false));
      }
    },
    actions: {
      syncInputElement({ scope, context }) {
        queueMicrotask(() => {
          const inputEl = getHiddenInputEl4(scope);
          if (!inputEl) return;
          setInputFiles(inputEl, context.get("acceptedFiles"));
          const win = scope.getWin();
          inputEl.dispatchEvent(new win.Event("change", { bubbles: true }));
        });
      },
      openFilePicker({ scope }) {
        raf(() => {
          var _a8;
          (_a8 = getHiddenInputEl4(scope)) == null ? void 0 : _a8.click();
        });
      },
      setFiles(params) {
        const { computed, context, event } = params;
        const { acceptedFiles, rejectedFiles } = getEventFiles(params, event.files);
        context.set(
          "acceptedFiles",
          computed("multiple") ? acceptedFiles : acceptedFiles.length > 0 ? [acceptedFiles[0]] : []
        );
        context.set("rejectedFiles", rejectedFiles);
      },
      setEventFiles(params) {
        const { computed, context, event, prop } = params;
        const { acceptedFiles, rejectedFiles } = getEventFiles(params, event.files);
        const set = (files) => {
          if (computed("multiple")) {
            context.set("acceptedFiles", (prev2) => [...prev2, ...files]);
            context.set("rejectedFiles", rejectedFiles);
            return;
          }
          if (files.length) {
            context.set("acceptedFiles", [files[0]]);
            context.set("rejectedFiles", rejectedFiles);
            return;
          }
          if (rejectedFiles.length) {
            context.set("acceptedFiles", context.get("acceptedFiles"));
            context.set("rejectedFiles", rejectedFiles);
          }
        };
        const transform2 = prop("transformFiles");
        if (transform2) {
          transform2(acceptedFiles).then(set).catch((err) => {
            warn(`[zag-js/file-upload] error transforming files
${err}`);
          });
        } else {
          set(acceptedFiles);
        }
      },
      removeFile({ context, event }) {
        const files = context.get("acceptedFiles").filter((file) => !isFileEqual(file, event.file));
        const rejectedFiles = context.get("rejectedFiles").filter((item) => !isFileEqual(item.file, event.file));
        context.set("acceptedFiles", files);
        context.set("rejectedFiles", rejectedFiles);
      },
      clearRejectedFiles({ context }) {
        context.set("rejectedFiles", []);
      },
      clearFiles({ context }) {
        context.set("acceptedFiles", []);
        context.set("rejectedFiles", []);
      }
    }
  }
});
var props14 = createProps()([
  "accept",
  "allowDrop",
  "capture",
  "dir",
  "directory",
  "disabled",
  "getRootNode",
  "id",
  "ids",
  "locale",
  "maxFiles",
  "maxFileSize",
  "minFileSize",
  "name",
  "invalid",
  "onFileAccept",
  "onFileReject",
  "onFileChange",
  "preventDocumentDrop",
  "required",
  "translations",
  "transformFiles",
  "validate"
]);
var splitProps14 = createSplitProps(props14);
var itemProps4 = createProps()(["file"]);
var splitItemProps4 = createSplitProps(itemProps4);

// node_modules/@ark-ui/react/dist/components/file-upload/use-file-upload.js
var import_react372 = __toESM(require_react(), 1);
var useFileUpload = (props43) => {
  const id = (0, import_react372.useId)();
  const { getRootNode } = useEnvironmentContext();
  const { dir, locale } = useLocaleContext();
  const field = useFieldContext();
  const machineProps = {
    id,
    ids: {
      label: field == null ? void 0 : field.ids.label,
      hiddenInput: field == null ? void 0 : field.ids.control
    },
    dir,
    disabled: field == null ? void 0 : field.disabled,
    locale,
    required: field == null ? void 0 : field.required,
    invalid: field == null ? void 0 : field.invalid,
    getRootNode,
    ...props43
  };
  const service = useMachine(machine14, machineProps);
  return connect14(service, normalizeProps);
};

// node_modules/@ark-ui/react/dist/components/file-upload/file-upload-root.js
var FileUploadRoot = (0, import_react374.forwardRef)((props43, ref) => {
  const [useFileUploadProps, localProps] = createSplitProps2()(props43, [
    "accept",
    "allowDrop",
    "capture",
    "directory",
    "disabled",
    "id",
    "ids",
    "invalid",
    "locale",
    "maxFiles",
    "maxFileSize",
    "minFileSize",
    "name",
    "onFileAccept",
    "onFileChange",
    "onFileReject",
    "preventDocumentDrop",
    "required",
    "translations",
    "transformFiles",
    "validate"
  ]);
  const fileUpload = useFileUpload(useFileUploadProps);
  const mergedProps = mergeProps2(fileUpload.getRootProps(), localProps);
  return (0, import_jsx_runtime175.jsx)(FileUploadProvider, { value: fileUpload, children: (0, import_jsx_runtime175.jsx)(ark.div, { ...mergedProps, ref }) });
});
FileUploadRoot.displayName = "FileUploadRoot";

// node_modules/@ark-ui/react/dist/components/file-upload/file-upload-root-provider.js
var import_jsx_runtime176 = __toESM(require_jsx_runtime(), 1);
var import_react376 = __toESM(require_react(), 1);
var FileUploadRootProvider = (0, import_react376.forwardRef)((props43, ref) => {
  const [{ value: fileUpload }, localProps] = createSplitProps2()(props43, ["value"]);
  const mergedProps = mergeProps2(fileUpload.getRootProps(), localProps);
  return (0, import_jsx_runtime176.jsx)(FileUploadProvider, { value: fileUpload, children: (0, import_jsx_runtime176.jsx)(ark.div, { ...mergedProps, ref }) });
});
FileUploadRootProvider.displayName = "FileUploadRootProvider";

// node_modules/@ark-ui/react/dist/components/file-upload/file-upload-trigger.js
var import_jsx_runtime177 = __toESM(require_jsx_runtime(), 1);
var import_react378 = __toESM(require_react(), 1);
var FileUploadTrigger = (0, import_react378.forwardRef)((props43, ref) => {
  const fileUpload = useFileUploadContext();
  const mergedProps = mergeProps2(fileUpload.getTriggerProps(), props43);
  return (0, import_jsx_runtime177.jsx)(ark.button, { ...mergedProps, ref });
});
FileUploadTrigger.displayName = "FileUploadTrigger";

// node_modules/@ark-ui/react/dist/components/file-upload/file-upload.js
var file_upload_exports = {};
__export(file_upload_exports, {
  ClearTrigger: () => FileUploadClearTrigger,
  Context: () => FileUploadContext,
  Dropzone: () => FileUploadDropzone,
  HiddenInput: () => FileUploadHiddenInput,
  Item: () => FileUploadItem,
  ItemDeleteTrigger: () => FileUploadItemDeleteTrigger,
  ItemGroup: () => FileUploadItemGroup,
  ItemName: () => FileUploadItemName,
  ItemPreview: () => FileUploadItemPreview,
  ItemPreviewImage: () => FileUploadItemPreviewImage,
  ItemSizeText: () => FileUploadItemSizeText,
  Label: () => FileUploadLabel,
  Root: () => FileUploadRoot,
  RootProvider: () => FileUploadRootProvider,
  Trigger: () => FileUploadTrigger
});

// node_modules/@ark-ui/react/dist/components/floating-panel/floating-panel-body.js
var import_jsx_runtime178 = __toESM(require_jsx_runtime(), 1);
var import_react380 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/floating-panel/use-floating-panel-context.js
var [FloatingPanelProvider, useFloatingPanelContext] = createContext3({
  name: "FloatingPanelContext",
  hookName: "useFloatingPanelContext",
  providerName: "<FloatingPanelProvider />"
});

// node_modules/@ark-ui/react/dist/components/floating-panel/floating-panel-body.js
var FloatingPanelBody = (0, import_react380.forwardRef)((props43, ref) => {
  const floatingPanel = useFloatingPanelContext();
  const mergedProps = mergeProps2(floatingPanel.getBodyProps(), props43);
  return (0, import_jsx_runtime178.jsx)(ark.div, { ...mergedProps, ref });
});
FloatingPanelBody.displayName = "FloatingPanelBody";

// node_modules/@ark-ui/react/dist/components/floating-panel/floating-panel-close-trigger.js
var import_jsx_runtime179 = __toESM(require_jsx_runtime(), 1);
var import_react382 = __toESM(require_react(), 1);
var FloatingPanelCloseTrigger = (0, import_react382.forwardRef)((props43, ref) => {
  const floatingPanel = useFloatingPanelContext();
  const mergedProps = mergeProps2(floatingPanel.getCloseTriggerProps(), props43);
  return (0, import_jsx_runtime179.jsx)(ark.button, { ...mergedProps, ref });
});
FloatingPanelCloseTrigger.displayName = "FloatingPanelCloseTrigger";

// node_modules/@ark-ui/react/dist/components/floating-panel/floating-panel-content.js
var import_jsx_runtime180 = __toESM(require_jsx_runtime(), 1);
var import_react384 = __toESM(require_react(), 1);
var FloatingPanelContent = (0, import_react384.forwardRef)((props43, ref) => {
  const floatingPanel = useFloatingPanelContext();
  const presence = usePresenceContext();
  const mergedProps = mergeProps2(floatingPanel.getContentProps(), presence.getPresenceProps(), props43);
  if (presence.unmounted) {
    return null;
  }
  return (0, import_jsx_runtime180.jsx)(ark.div, { ...mergedProps, ref: composeRefs(presence.ref, ref) });
});
FloatingPanelContent.displayName = "FloatingPanelContent";

// node_modules/@ark-ui/react/dist/components/floating-panel/floating-panel-drag-trigger.js
var import_jsx_runtime181 = __toESM(require_jsx_runtime(), 1);
var import_react386 = __toESM(require_react(), 1);
var FloatingPanelDragTrigger = (0, import_react386.forwardRef)((props43, ref) => {
  const floatingPanel = useFloatingPanelContext();
  const mergedProps = mergeProps2(floatingPanel.getDragTriggerProps(), props43);
  return (0, import_jsx_runtime181.jsx)(ark.div, { ...mergedProps, ref });
});
FloatingPanelDragTrigger.displayName = "FloatingPanelDragTrigger";

// node_modules/@ark-ui/react/dist/components/floating-panel/floating-panel-header.js
var import_jsx_runtime182 = __toESM(require_jsx_runtime(), 1);
var import_react388 = __toESM(require_react(), 1);
var FloatingPanelHeader = (0, import_react388.forwardRef)((props43, ref) => {
  const floatingPanel = useFloatingPanelContext();
  const mergedProps = mergeProps2(floatingPanel.getHeaderProps(), props43);
  return (0, import_jsx_runtime182.jsx)(ark.div, { ...mergedProps, ref });
});
FloatingPanelHeader.displayName = "FloatingPanelHeader";

// node_modules/@ark-ui/react/dist/components/floating-panel/floating-panel-positioner.js
var import_jsx_runtime183 = __toESM(require_jsx_runtime(), 1);
var import_react390 = __toESM(require_react(), 1);
var FloatingPanelPositioner = (0, import_react390.forwardRef)((props43, ref) => {
  const floatingPanel = useFloatingPanelContext();
  const mergedProps = mergeProps2(floatingPanel.getPositionerProps(), props43);
  const presence = usePresenceContext();
  if (presence.unmounted) {
    return null;
  }
  return (0, import_jsx_runtime183.jsx)(ark.div, { ...mergedProps, ref });
});
FloatingPanelPositioner.displayName = "FloatingPanelPositioner";

// node_modules/@ark-ui/react/dist/components/floating-panel/floating-panel-resize-trigger.js
var import_jsx_runtime184 = __toESM(require_jsx_runtime(), 1);
var import_react392 = __toESM(require_react(), 1);
var FloatingPanelResizeTrigger = (0, import_react392.forwardRef)((props43, ref) => {
  const [resizeProps, localProps] = createSplitProps2()(props43, ["axis"]);
  const floatingPanel = useFloatingPanelContext();
  const mergedProps = mergeProps2(floatingPanel.getResizeTriggerProps(resizeProps), localProps);
  return (0, import_jsx_runtime184.jsx)(ark.div, { ...mergedProps, ref });
});
FloatingPanelResizeTrigger.displayName = "FloatingPanelResizeTrigger";

// node_modules/@ark-ui/react/dist/components/floating-panel/floating-panel-stage-trigger.js
var import_jsx_runtime185 = __toESM(require_jsx_runtime(), 1);
var import_react394 = __toESM(require_react(), 1);
var FloatingPanelStageTrigger = (0, import_react394.forwardRef)((props43, ref) => {
  const [stage, localProps] = createSplitProps2()(props43, ["stage"]);
  const floatingPanel = useFloatingPanelContext();
  const mergedProps = mergeProps2(floatingPanel.getStageTriggerProps(stage), localProps);
  return (0, import_jsx_runtime185.jsx)(ark.button, { ...mergedProps, ref });
});
FloatingPanelStageTrigger.displayName = "FloatingPanelStageTrigger";

// node_modules/@ark-ui/react/dist/components/floating-panel/floating-panel-root.js
var import_jsx_runtime186 = __toESM(require_jsx_runtime(), 1);

// node_modules/proxy-compare/dist/index.js
var TRACK_MEMO_SYMBOL = Symbol();
var GET_ORIGINAL_SYMBOL = Symbol();
var getProto = Object.getPrototypeOf;
var objectsToTrack = /* @__PURE__ */ new WeakMap();
var isObjectToTrack = (obj) => obj && (objectsToTrack.has(obj) ? objectsToTrack.get(obj) : getProto(obj) === Object.prototype || getProto(obj) === Array.prototype);
var getUntracked = (obj) => {
  if (isObjectToTrack(obj)) {
    return obj[GET_ORIGINAL_SYMBOL] || null;
  }
  return null;
};
var markToTrack = (obj, mark = true) => {
  objectsToTrack.set(obj, mark);
};

// node_modules/@zag-js/store/dist/index.mjs
function glob() {
  if (typeof globalThis !== "undefined") return globalThis;
  if (typeof self !== "undefined") return self;
  if (typeof window !== "undefined") return window;
  if (typeof global !== "undefined") return global;
}
function globalRef(key, value) {
  const g = glob();
  if (!g) return value();
  g[key] || (g[key] = value());
  return g[key];
}
var refSet = globalRef("__zag__refSet", () => /* @__PURE__ */ new WeakSet());
var isReactElement = (x) => typeof x === "object" && x !== null && "$$typeof" in x && "props" in x;
var isVueElement = (x) => typeof x === "object" && x !== null && "__v_isVNode" in x;
var isDOMElement = (x) => typeof x === "object" && x !== null && "nodeType" in x && typeof x.nodeName === "string";
var isElement2 = (x) => isReactElement(x) || isVueElement(x) || isDOMElement(x);
var isObject4 = (x) => x !== null && typeof x === "object";
var canProxy = (x) => isObject4(x) && !refSet.has(x) && (Array.isArray(x) || !(Symbol.iterator in x)) && !isElement2(x) && !(x instanceof WeakMap) && !(x instanceof WeakSet) && !(x instanceof Error) && !(x instanceof Number) && !(x instanceof Date) && !(x instanceof String) && !(x instanceof RegExp) && !(x instanceof ArrayBuffer) && !(x instanceof Promise);
var isDev = () => true;
var proxyStateMap = globalRef("__zag__proxyStateMap", () => /* @__PURE__ */ new WeakMap());
var buildProxyFunction = (objectIs = Object.is, newProxy = (target, handler) => new Proxy(target, handler), snapCache = /* @__PURE__ */ new WeakMap(), createSnapshot = (target, version2) => {
  const cache2 = snapCache.get(target);
  if ((cache2 == null ? void 0 : cache2[0]) === version2) {
    return cache2[1];
  }
  const snap = Array.isArray(target) ? [] : Object.create(Object.getPrototypeOf(target));
  markToTrack(snap, true);
  snapCache.set(target, [version2, snap]);
  Reflect.ownKeys(target).forEach((key) => {
    const value = Reflect.get(target, key);
    if (refSet.has(value)) {
      markToTrack(value, false);
      snap[key] = value;
    } else if (proxyStateMap.has(value)) {
      snap[key] = snapshot(value);
    } else {
      snap[key] = value;
    }
  });
  return Object.freeze(snap);
}, proxyCache = /* @__PURE__ */ new WeakMap(), versionHolder = [1, 1], proxyFunction2 = (initialObject) => {
  if (!isObject4(initialObject)) {
    throw new Error("object required");
  }
  const found = proxyCache.get(initialObject);
  if (found) {
    return found;
  }
  let version2 = versionHolder[0];
  const listeners = /* @__PURE__ */ new Set();
  const notifyUpdate = (op, nextVersion = ++versionHolder[0]) => {
    if (version2 !== nextVersion) {
      version2 = nextVersion;
      listeners.forEach((listener) => listener(op, nextVersion));
    }
  };
  let checkVersion = versionHolder[1];
  const ensureVersion = (nextCheckVersion = ++versionHolder[1]) => {
    if (checkVersion !== nextCheckVersion && !listeners.size) {
      checkVersion = nextCheckVersion;
      propProxyStates.forEach(([propProxyState]) => {
        const propVersion = propProxyState[1](nextCheckVersion);
        if (propVersion > version2) {
          version2 = propVersion;
        }
      });
    }
    return version2;
  };
  const createPropListener = (prop) => (op, nextVersion) => {
    const newOp = [...op];
    newOp[1] = [prop, ...newOp[1]];
    notifyUpdate(newOp, nextVersion);
  };
  const propProxyStates = /* @__PURE__ */ new Map();
  const addPropListener = (prop, propProxyState) => {
    if (isDev() && propProxyStates.has(prop)) {
      throw new Error("prop listener already exists");
    }
    if (listeners.size) {
      const remove3 = propProxyState[3](createPropListener(prop));
      propProxyStates.set(prop, [propProxyState, remove3]);
    } else {
      propProxyStates.set(prop, [propProxyState]);
    }
  };
  const removePropListener = (prop) => {
    var _a8;
    const entry = propProxyStates.get(prop);
    if (entry) {
      propProxyStates.delete(prop);
      (_a8 = entry[1]) == null ? void 0 : _a8.call(entry);
    }
  };
  const addListener = (listener) => {
    listeners.add(listener);
    if (listeners.size === 1) {
      propProxyStates.forEach(([propProxyState, prevRemove], prop) => {
        if (isDev() && prevRemove) {
          throw new Error("remove already exists");
        }
        const remove3 = propProxyState[3](createPropListener(prop));
        propProxyStates.set(prop, [propProxyState, remove3]);
      });
    }
    const removeListener = () => {
      listeners.delete(listener);
      if (listeners.size === 0) {
        propProxyStates.forEach(([propProxyState, remove3], prop) => {
          if (remove3) {
            remove3();
            propProxyStates.set(prop, [propProxyState]);
          }
        });
      }
    };
    return removeListener;
  };
  const baseObject = Array.isArray(initialObject) ? [] : Object.create(Object.getPrototypeOf(initialObject));
  const handler = {
    deleteProperty(target, prop) {
      const prevValue = Reflect.get(target, prop);
      removePropListener(prop);
      const deleted = Reflect.deleteProperty(target, prop);
      if (deleted) {
        notifyUpdate(["delete", [prop], prevValue]);
      }
      return deleted;
    },
    set(target, prop, value, receiver) {
      var _a8;
      const hasPrevValue = Reflect.has(target, prop);
      const prevValue = Reflect.get(target, prop, receiver);
      if (hasPrevValue && (objectIs(prevValue, value) || proxyCache.has(value) && objectIs(prevValue, proxyCache.get(value)))) {
        return true;
      }
      removePropListener(prop);
      if (isObject4(value)) {
        value = getUntracked(value) || value;
      }
      let nextValue = value;
      if ((_a8 = Object.getOwnPropertyDescriptor(target, prop)) == null ? void 0 : _a8.set) ;
      else {
        if (!proxyStateMap.has(value) && canProxy(value)) {
          nextValue = proxy(value);
        }
        const childProxyState = !refSet.has(nextValue) && proxyStateMap.get(nextValue);
        if (childProxyState) {
          addPropListener(prop, childProxyState);
        }
      }
      Reflect.set(target, prop, nextValue, receiver);
      notifyUpdate(["set", [prop], value, prevValue]);
      return true;
    }
  };
  const proxyObject = newProxy(baseObject, handler);
  proxyCache.set(initialObject, proxyObject);
  const proxyState = [baseObject, ensureVersion, createSnapshot, addListener];
  proxyStateMap.set(proxyObject, proxyState);
  Reflect.ownKeys(initialObject).forEach((key) => {
    const desc = Object.getOwnPropertyDescriptor(initialObject, key);
    if (desc.get || desc.set) {
      Object.defineProperty(baseObject, key, desc);
    } else {
      proxyObject[key] = initialObject[key];
    }
  });
  return proxyObject;
}) => [
  // public functions
  proxyFunction2,
  // shared state
  proxyStateMap,
  refSet,
  // internal things
  objectIs,
  newProxy,
  canProxy,
  snapCache,
  createSnapshot,
  proxyCache,
  versionHolder
];
var [proxyFunction] = buildProxyFunction();
function proxy(initialObject = {}) {
  return proxyFunction(initialObject);
}
function subscribe(proxyObject, callback, notifyInSync) {
  const proxyState = proxyStateMap.get(proxyObject);
  if (isDev() && !proxyState) {
    console.warn("Please use proxy object");
  }
  let promise;
  const ops = [];
  const addListener = proxyState[3];
  let isListenerActive = false;
  const listener = (op) => {
    ops.push(op);
    if (notifyInSync) {
      callback(ops.splice(0));
      return;
    }
    if (!promise) {
      promise = Promise.resolve().then(() => {
        promise = void 0;
        if (isListenerActive) {
          callback(ops.splice(0));
        }
      });
    }
  };
  const removeListener = addListener(listener);
  isListenerActive = true;
  return () => {
    isListenerActive = false;
    removeListener();
  };
}
function snapshot(proxyObject) {
  const proxyState = proxyStateMap.get(proxyObject);
  if (isDev() && !proxyState) {
    console.warn("Please use proxy object");
  }
  const [target, ensureVersion, createSnapshot] = proxyState;
  return createSnapshot(target, ensureVersion());
}

// node_modules/@zag-js/floating-panel/dist/index.mjs
var anatomy14 = createAnatomy("floating-panel").parts(
  "trigger",
  "positioner",
  "content",
  "header",
  "body",
  "title",
  "resizeTrigger",
  "dragTrigger",
  "stageTrigger",
  "closeTrigger",
  "control"
);
var parts16 = anatomy14.build();
var getTriggerId7 = (ctx) => {
  var _a8;
  return ((_a8 = ctx.ids) == null ? void 0 : _a8.trigger) ?? `float:${ctx.id}:trigger`;
};
var getPositionerId5 = (ctx) => {
  var _a8;
  return ((_a8 = ctx.ids) == null ? void 0 : _a8.positioner) ?? `float:${ctx.id}:positioner`;
};
var getContentId6 = (ctx) => {
  var _a8;
  return ((_a8 = ctx.ids) == null ? void 0 : _a8.content) ?? `float:${ctx.id}:content`;
};
var getHeaderId = (ctx) => {
  var _a8;
  return ((_a8 = ctx.ids) == null ? void 0 : _a8.header) ?? `float:${ctx.id}:header`;
};
var getTriggerEl5 = (ctx) => ctx.getById(getTriggerId7(ctx));
var getPositionerEl5 = (ctx) => ctx.getById(getPositionerId5(ctx));
var getContentEl6 = (ctx) => ctx.getById(getContentId6(ctx));
var getHeaderEl = (ctx) => ctx.getById(getHeaderId(ctx));
var getBoundaryRect = (ctx, boundaryEl, allowOverflow) => {
  let boundaryRect;
  if (isHTMLElement(boundaryEl)) {
    boundaryRect = getElementRect(boundaryEl);
  } else {
    boundaryRect = getWindowRect(ctx.getWin());
  }
  if (allowOverflow) {
    boundaryRect = createRect({
      x: -boundaryRect.width,
      // empty(left)
      y: boundaryRect.minY,
      width: boundaryRect.width * 3,
      // empty(left) + win + empty(right)
      height: boundaryRect.height * 2
      // win + empty(bottom)
    });
  }
  return pick(boundaryRect, ["x", "y", "width", "height"]);
};
var panelStack = proxy({
  stack: [],
  count() {
    return this.stack.length;
  },
  add(panelId) {
    if (this.stack.includes(panelId)) return;
    this.stack.push(panelId);
  },
  remove(panelId) {
    const index = this.stack.indexOf(panelId);
    if (index < 0) return;
    this.stack.splice(index, 1);
  },
  bringToFront(id) {
    this.remove(id);
    this.add(id);
  },
  isTopmost(id) {
    return this.stack[this.stack.length - 1] === id;
  },
  indexOf(id) {
    return this.stack.indexOf(id);
  }
});
var { not: not4, and: and5 } = createGuards();
var defaultTranslations2 = {
  minimize: "Minimize window",
  maximize: "Maximize window",
  restore: "Restore window"
};
var machine15 = createMachine({
  props({ props: props210 }) {
    ensureProps(props210, ["id"], "floating-panel");
    return {
      strategy: "fixed",
      gridSize: 1,
      defaultSize: { width: 320, height: 240 },
      defaultPosition: { x: 300, y: 100 },
      allowOverflow: true,
      resizable: true,
      draggable: true,
      ...props210,
      hasSpecifiedPosition: !!props210.defaultPosition || !!props210.position,
      translations: {
        ...defaultTranslations2,
        ...props210.translations
      }
    };
  },
  initialState({ prop }) {
    const open = prop("open") || prop("defaultOpen");
    return open ? "open" : "closed";
  },
  context({ prop, bindable }) {
    return {
      size: bindable(() => ({
        defaultValue: prop("defaultSize"),
        value: prop("size"),
        isEqual: isSizeEqual,
        sync: true,
        hash(v) {
          return `W:${v.width} H:${v.height}`;
        },
        onChange(value) {
          var _a8;
          (_a8 = prop("onSizeChange")) == null ? void 0 : _a8({ size: value });
        }
      })),
      position: bindable(() => ({
        defaultValue: prop("defaultPosition"),
        value: prop("position"),
        isEqual: isPointEqual,
        sync: true,
        hash(v) {
          return `X:${v.x} Y:${v.y}`;
        },
        onChange(value) {
          var _a8;
          (_a8 = prop("onPositionChange")) == null ? void 0 : _a8({ position: value });
        }
      })),
      stage: bindable(() => ({
        defaultValue: "default",
        onChange(value) {
          var _a8;
          (_a8 = prop("onStageChange")) == null ? void 0 : _a8({ stage: value });
        }
      })),
      lastEventPosition: bindable(() => ({
        defaultValue: null
      })),
      prevPosition: bindable(() => ({
        defaultValue: null
      })),
      prevSize: bindable(() => ({
        defaultValue: null
      })),
      isTopmost: bindable(() => ({
        defaultValue: void 0
      }))
    };
  },
  computed: {
    isMaximized: ({ context }) => context.get("stage") === "maximized",
    isMinimized: ({ context }) => context.get("stage") === "minimized",
    isStaged: ({ context }) => context.get("stage") !== "default",
    canResize: ({ context, prop }) => (prop("resizable") || !prop("disabled")) && context.get("stage") === "default",
    canDrag: ({ prop, computed }) => (prop("draggable") || !prop("disabled")) && !computed("isMaximized")
  },
  watch({ track, context, action, prop }) {
    track([() => context.hash("position")], () => {
      action(["setPositionStyle"]);
    });
    track([() => context.hash("size")], () => {
      action(["setSizeStyle"]);
    });
    track([() => prop("open")], () => {
      action(["toggleVisibility"]);
    });
  },
  effects: ["trackPanelStack"],
  on: {
    CONTENT_FOCUS: {
      actions: ["bringToFrontOfPanelStack"]
    },
    SET_POSITION: {
      actions: ["setPosition"]
    },
    SET_SIZE: {
      actions: ["setSize"]
    }
  },
  states: {
    closed: {
      tags: ["closed"],
      on: {
        "CONTROLLED.OPEN": {
          target: "open",
          actions: ["setAnchorPosition", "setPositionStyle", "setSizeStyle", "focusContentEl"]
        },
        OPEN: [
          {
            guard: "isOpenControlled",
            actions: ["invokeOnOpen"]
          },
          {
            target: "open",
            actions: ["invokeOnOpen", "setAnchorPosition", "setPositionStyle", "setSizeStyle", "focusContentEl"]
          }
        ]
      }
    },
    open: {
      tags: ["open"],
      entry: ["bringToFrontOfPanelStack"],
      effects: ["trackBoundaryRect"],
      on: {
        DRAG_START: {
          guard: not4("isMaximized"),
          target: "open.dragging",
          actions: ["setPrevPosition"]
        },
        RESIZE_START: {
          guard: not4("isMinimized"),
          target: "open.resizing",
          actions: ["setPrevSize"]
        },
        "CONTROLLED.CLOSE": {
          target: "closed",
          actions: ["resetRect", "focusTriggerEl"]
        },
        CLOSE: [
          {
            guard: "isOpenControlled",
            target: "closed",
            actions: ["invokeOnClose"]
          },
          {
            target: "closed",
            actions: ["invokeOnClose", "resetRect", "focusTriggerEl"]
          }
        ],
        ESCAPE: [
          {
            guard: and5("isOpenControlled", "closeOnEsc"),
            actions: ["invokeOnClose"]
          },
          {
            guard: "closeOnEsc",
            target: "closed",
            actions: ["invokeOnClose", "resetRect", "focusTriggerEl"]
          }
        ],
        MINIMIZE: {
          actions: ["setMinimized"]
        },
        MAXIMIZE: {
          actions: ["setMaximized"]
        },
        RESTORE: {
          actions: ["setRestored"]
        },
        MOVE: {
          actions: ["setPositionFromKeyboard"]
        }
      }
    },
    "open.dragging": {
      tags: ["open"],
      effects: ["trackPointerMove"],
      exit: ["clearPrevPosition"],
      on: {
        DRAG: {
          actions: ["setPosition"]
        },
        DRAG_END: {
          target: "open",
          actions: ["invokeOnDragEnd"]
        },
        "CONTROLLED.CLOSE": {
          target: "closed",
          actions: ["resetRect"]
        },
        CLOSE: [
          {
            guard: "isOpenControlled",
            target: "closed",
            actions: ["invokeOnClose"]
          },
          {
            target: "closed",
            actions: ["invokeOnClose", "resetRect"]
          }
        ],
        ESCAPE: {
          target: "open"
        }
      }
    },
    "open.resizing": {
      tags: ["open"],
      effects: ["trackPointerMove"],
      exit: ["clearPrevSize"],
      on: {
        DRAG: {
          actions: ["setSize"]
        },
        DRAG_END: {
          target: "open",
          actions: ["invokeOnResizeEnd"]
        },
        "CONTROLLED.CLOSE": {
          target: "closed",
          actions: ["resetRect"]
        },
        CLOSE: [
          {
            guard: "isOpenControlled",
            target: "closed",
            actions: ["invokeOnClose"]
          },
          {
            target: "closed",
            actions: ["invokeOnClose", "resetRect"]
          }
        ],
        ESCAPE: {
          target: "open"
        }
      }
    }
  },
  implementations: {
    guards: {
      closeOnEsc: ({ prop }) => !!prop("closeOnEscape"),
      isMaximized: ({ context }) => context.get("stage") === "maximized",
      isMinimized: ({ context }) => context.get("stage") === "minimized",
      isOpenControlled: ({ prop }) => prop("open") != void 0
    },
    effects: {
      trackPointerMove({ scope, send, event: evt, prop }) {
        var _a8;
        const doc = scope.getDoc();
        const boundaryEl = (_a8 = prop("getBoundaryEl")) == null ? void 0 : _a8();
        const boundaryRect = getBoundaryRect(scope, boundaryEl, false);
        return trackPointerMove(doc, {
          onPointerMove({ point, event }) {
            const { altKey, shiftKey } = event;
            let x = clampValue(point.x, boundaryRect.x, boundaryRect.x + boundaryRect.width);
            let y = clampValue(point.y, boundaryRect.y, boundaryRect.y + boundaryRect.height);
            send({ type: "DRAG", position: { x, y }, axis: evt.axis, altKey, shiftKey });
          },
          onPointerUp() {
            send({ type: "DRAG_END" });
          }
        });
      },
      trackBoundaryRect({ context, scope, prop, computed }) {
        var _a8;
        const win = scope.getWin();
        let skip = true;
        const exec = () => {
          var _a9;
          if (skip) {
            skip = false;
            return;
          }
          const boundaryEl2 = (_a9 = prop("getBoundaryEl")) == null ? void 0 : _a9();
          let boundaryRect = getBoundaryRect(scope, boundaryEl2, false);
          if (!computed("isMaximized")) {
            const rect = { ...context.get("position"), ...context.get("size") };
            boundaryRect = constrainRect(rect, boundaryRect);
          }
          context.set("size", pick(boundaryRect, ["width", "height"]));
          context.set("position", pick(boundaryRect, ["x", "y"]));
        };
        const boundaryEl = (_a8 = prop("getBoundaryEl")) == null ? void 0 : _a8();
        if (isHTMLElement(boundaryEl)) {
          const obs = new win.ResizeObserver(exec);
          obs.observe(boundaryEl);
          return () => obs.disconnect();
        }
        return addDomEvent(win, "resize", exec);
      },
      trackPanelStack({ context, scope }) {
        const unsub = subscribe(panelStack, () => {
          context.set("isTopmost", panelStack.isTopmost(scope.id));
          const contentEl = getContentEl6(scope);
          if (!contentEl) return;
          const index = panelStack.indexOf(scope.id);
          if (index === -1) return;
          contentEl.style.setProperty("--z-index", `${index + 1}`);
        });
        return () => {
          panelStack.remove(scope.id);
          unsub();
        };
      }
    },
    actions: {
      setAnchorPosition({ context, prop, scope }) {
        if (prop("hasSpecifiedPosition")) return;
        const hasPrevRect = context.get("prevPosition") || context.get("prevSize");
        if (prop("persistRect") && hasPrevRect) return;
        raf(() => {
          var _a8, _b7;
          const triggerRect = getTriggerEl5(scope);
          const boundaryRect = getBoundaryRect(scope, (_a8 = prop("getBoundaryEl")) == null ? void 0 : _a8(), false);
          let anchorPosition = (_b7 = prop("getAnchorPosition")) == null ? void 0 : _b7({
            triggerRect: triggerRect ? DOMRect.fromRect(getElementRect(triggerRect)) : null,
            boundaryRect: DOMRect.fromRect(boundaryRect)
          });
          if (!anchorPosition) {
            const size3 = context.get("size");
            anchorPosition = {
              x: boundaryRect.x + (boundaryRect.width - size3.width) / 2,
              y: boundaryRect.y + (boundaryRect.height - size3.height) / 2
            };
          }
          if (!anchorPosition) return;
          context.set("position", anchorPosition);
        });
      },
      setPrevPosition({ context, event }) {
        context.set("prevPosition", { ...context.get("position") });
        context.set("lastEventPosition", event.position);
      },
      clearPrevPosition({ context, prop }) {
        if (!prop("persistRect")) context.set("prevPosition", null);
        context.set("lastEventPosition", null);
      },
      setPosition({ context, event, prop, scope }) {
        var _a8;
        let diff3 = subtractPoints(event.position, context.get("lastEventPosition"));
        diff3.x = Math.round(diff3.x / prop("gridSize")) * prop("gridSize");
        diff3.y = Math.round(diff3.y / prop("gridSize")) * prop("gridSize");
        const prevPosition = context.get("prevPosition");
        if (!prevPosition) return;
        let position = addPoints(prevPosition, diff3);
        const boundaryEl = (_a8 = prop("getBoundaryEl")) == null ? void 0 : _a8();
        const boundaryRect = getBoundaryRect(scope, boundaryEl, prop("allowOverflow"));
        position = clampPoint(position, context.get("size"), boundaryRect);
        context.set("position", position);
      },
      setPositionStyle({ scope, context }) {
        const el = getPositionerEl5(scope);
        const position = context.get("position");
        el == null ? void 0 : el.style.setProperty("--x", `${position.x}px`);
        el == null ? void 0 : el.style.setProperty("--y", `${position.y}px`);
      },
      resetRect({ context, prop }) {
        context.set("stage", "default");
        if (!prop("persistRect")) {
          context.set("position", context.initial("position"));
          context.set("size", context.initial("size"));
        }
      },
      setPrevSize({ context, event }) {
        context.set("prevSize", { ...context.get("size") });
        context.set("prevPosition", { ...context.get("position") });
        context.set("lastEventPosition", event.position);
      },
      clearPrevSize({ context }) {
        context.set("prevSize", null);
        context.set("prevPosition", null);
        context.set("lastEventPosition", null);
      },
      setSize({ context, event, scope, prop }) {
        var _a8;
        const prevSize = context.get("prevSize");
        const prevPosition = context.get("prevPosition");
        const lastEventPosition = context.get("lastEventPosition");
        if (!prevSize || !prevPosition || !lastEventPosition) return;
        const prevRect = createRect({ ...prevPosition, ...prevSize });
        const offset4 = subtractPoints(event.position, lastEventPosition);
        const nextRect = resizeRect(prevRect, offset4, event.axis, {
          scalingOriginMode: event.altKey ? "center" : "extent",
          lockAspectRatio: !!prop("lockAspectRatio") || event.shiftKey
        });
        let nextSize = pick(nextRect, ["width", "height"]);
        let nextPosition = pick(nextRect, ["x", "y"]);
        const boundaryEl = (_a8 = prop("getBoundaryEl")) == null ? void 0 : _a8();
        const boundaryRect = getBoundaryRect(scope, boundaryEl, false);
        nextSize = clampSize(nextSize, prop("minSize"), prop("maxSize"));
        nextSize = clampSize(nextSize, prop("minSize"), boundaryRect);
        context.set("size", nextSize);
        if (nextPosition) {
          const point = clampPoint(nextPosition, nextSize, boundaryRect);
          context.set("position", point);
        }
      },
      setSizeStyle({ scope, context }) {
        queueMicrotask(() => {
          const el = getPositionerEl5(scope);
          const size3 = context.get("size");
          el == null ? void 0 : el.style.setProperty("--width", `${size3.width}px`);
          el == null ? void 0 : el.style.setProperty("--height", `${size3.height}px`);
        });
      },
      setMaximized({ context, prop, scope }) {
        var _a8;
        context.set("stage", "maximized");
        context.set("prevSize", context.get("size"));
        context.set("prevPosition", context.get("position"));
        const boundaryEl = (_a8 = prop("getBoundaryEl")) == null ? void 0 : _a8();
        const boundaryRect = getBoundaryRect(scope, boundaryEl, false);
        context.set("position", pick(boundaryRect, ["x", "y"]));
        context.set("size", pick(boundaryRect, ["height", "width"]));
      },
      setMinimized({ context, scope }) {
        context.set("stage", "minimized");
        context.set("prevSize", context.get("size"));
        context.set("prevPosition", context.get("position"));
        const headerEl = getHeaderEl(scope);
        if (!headerEl) return;
        const size3 = {
          ...context.get("size"),
          height: headerEl == null ? void 0 : headerEl.offsetHeight
        };
        context.set("size", size3);
      },
      setRestored({ context, prop, scope }) {
        var _a8;
        const boundaryRect = getBoundaryRect(scope, (_a8 = prop("getBoundaryEl")) == null ? void 0 : _a8(), false);
        context.set("stage", "default");
        const prevSize = context.get("prevSize");
        if (prevSize) {
          let nextSize = prevSize;
          nextSize = clampSize(nextSize, prop("minSize"), prop("maxSize"));
          nextSize = clampSize(nextSize, prop("minSize"), boundaryRect);
          context.set("size", nextSize);
          context.set("prevSize", null);
        }
        if (context.get("prevPosition")) {
          let nextPosition = context.get("prevPosition");
          nextPosition = clampPoint(nextPosition, context.get("size"), boundaryRect);
          context.set("position", nextPosition);
          context.set("prevPosition", null);
        }
      },
      setPositionFromKeyboard({ context, event, prop, scope }) {
        var _a8;
        invariant(event.step == null, "step is required");
        const position = context.get("position");
        const step = event.step;
        let nextPosition = match(event.direction, {
          left: { x: position.x - step, y: position.y },
          right: { x: position.x + step, y: position.y },
          up: { x: position.x, y: position.y - step },
          down: { x: position.x, y: position.y + step }
        });
        const boundaryEl = (_a8 = prop("getBoundaryEl")) == null ? void 0 : _a8();
        const boundaryRect = getBoundaryRect(scope, boundaryEl, false);
        nextPosition = clampPoint(nextPosition, context.get("size"), boundaryRect);
        context.set("position", nextPosition);
      },
      bringToFrontOfPanelStack({ prop }) {
        panelStack.bringToFront(prop("id"));
      },
      invokeOnOpen({ prop }) {
        var _a8;
        (_a8 = prop("onOpenChange")) == null ? void 0 : _a8({ open: true });
      },
      invokeOnClose({ prop }) {
        var _a8;
        (_a8 = prop("onOpenChange")) == null ? void 0 : _a8({ open: false });
      },
      invokeOnDragEnd({ context, prop }) {
        var _a8;
        (_a8 = prop("onPositionChangeEnd")) == null ? void 0 : _a8({ position: context.get("position") });
      },
      invokeOnResizeEnd({ context, prop }) {
        var _a8;
        (_a8 = prop("onSizeChangeEnd")) == null ? void 0 : _a8({ size: context.get("size") });
      },
      focusTriggerEl({ scope }) {
        raf(() => {
          var _a8;
          (_a8 = getTriggerEl5(scope)) == null ? void 0 : _a8.focus();
        });
      },
      focusContentEl({ scope }) {
        raf(() => {
          var _a8;
          (_a8 = getContentEl6(scope)) == null ? void 0 : _a8.focus();
        });
      },
      toggleVisibility({ send, prop, event }) {
        send({ type: prop("open") ? "CONTROLLED.OPEN" : "CONTROLLED.CLOSE", previousEvent: event });
      }
    }
  }
});
var props15 = createProps()([
  "allowOverflow",
  "closeOnEscape",
  "defaultOpen",
  "defaultPosition",
  "defaultSize",
  "dir",
  "disabled",
  "draggable",
  "getAnchorPosition",
  "getBoundaryEl",
  "getRootNode",
  "gridSize",
  "id",
  "ids",
  "lockAspectRatio",
  "maxSize",
  "minSize",
  "onOpenChange",
  "onPositionChange",
  "onPositionChangeEnd",
  "onSizeChange",
  "onSizeChangeEnd",
  "onStageChange",
  "open",
  "persistRect",
  "position",
  "resizable",
  "size",
  "strategy",
  "translations"
]);
var splitProps15 = createSplitProps(props15);
var resizeTriggerProps = createProps()(["axis"]);
var splitResizeTriggerProps = createSplitProps(resizeTriggerProps);

// node_modules/@ark-ui/react/dist/components/floating-panel/use-floating-panel.js
var import_react396 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/floating-panel/floating-panel-root-provider.js
var import_jsx_runtime187 = __toESM(require_jsx_runtime(), 1);

// node_modules/@ark-ui/react/dist/components/floating-panel/floating-panel-title.js
var import_jsx_runtime188 = __toESM(require_jsx_runtime(), 1);
var import_react400 = __toESM(require_react(), 1);
var FloatingPanelTitle = (0, import_react400.forwardRef)((props43, ref) => {
  const floatingPanel = useFloatingPanelContext();
  const mergedProps = mergeProps2(floatingPanel.getTitleProps(), props43);
  return (0, import_jsx_runtime188.jsx)(ark.h2, { ...mergedProps, ref });
});
FloatingPanelTitle.displayName = "FloatingPanelTitle";

// node_modules/@ark-ui/react/dist/components/floating-panel/floating-panel-trigger.js
var import_jsx_runtime189 = __toESM(require_jsx_runtime(), 1);
var import_react402 = __toESM(require_react(), 1);
var FloatingPanelTrigger = (0, import_react402.forwardRef)((props43, ref) => {
  const floatingPanel = useFloatingPanelContext();
  const presence = usePresenceContext();
  const triggerProps2 = floatingPanel.getTriggerProps();
  const mergedProps = mergeProps2(
    {
      ...triggerProps2,
      "aria-controls": presence.unmounted ? void 0 : triggerProps2["aria-controls"]
    },
    props43
  );
  return (0, import_jsx_runtime189.jsx)(ark.button, { ...mergedProps, ref });
});
FloatingPanelTrigger.displayName = "FloatingPanelTrigger";

// node_modules/@ark-ui/react/dist/components/floating-panel/floating-panel-control.js
var import_jsx_runtime190 = __toESM(require_jsx_runtime(), 1);
var import_react404 = __toESM(require_react(), 1);
var FloatingPanelControl = (0, import_react404.forwardRef)((props43, ref) => {
  const floatingPanel = useFloatingPanelContext();
  const mergedProps = mergeProps2(floatingPanel.getControlProps(), props43);
  return (0, import_jsx_runtime190.jsx)(ark.div, { ...mergedProps, ref });
});
FloatingPanelControl.displayName = "FloatingPanelControl";

// node_modules/@ark-ui/react/dist/components/focus-trap/focus-trap.js
var import_jsx_runtime191 = __toESM(require_jsx_runtime(), 1);
var import_react405 = __toESM(require_react(), 1);
var FocusTrap2 = (0, import_react405.forwardRef)((props43, ref) => {
  const localRef = (0, import_react405.useRef)(null);
  const [trapProps, localProps] = createSplitProps2()(props43, [
    "disabled",
    "onActivate",
    "onDeactivate",
    "initialFocus",
    "fallbackFocus",
    "returnFocusOnDeactivate",
    "setReturnFocus"
  ]);
  useSafeLayoutEffect2(() => {
    const node = localRef.current;
    if (!node || trapProps.disabled) return;
    return trapFocus(node, trapProps);
  }, [ref, trapProps]);
  return (0, import_jsx_runtime191.jsx)(ark.div, { ref: composeRefs(localRef, ref), ...localProps });
});
FocusTrap2.displayName = "FocusTrap";

// node_modules/@ark-ui/react/dist/components/frame/frame.js
var import_jsx_runtime193 = __toESM(require_jsx_runtime(), 1);
var import_react408 = __toESM(require_react(), 1);
var import_react_dom2 = __toESM(require_react_dom(), 1);

// node_modules/@ark-ui/react/dist/providers/environment/environment-provider.js
var import_jsx_runtime192 = __toESM(require_jsx_runtime(), 1);
var import_react406 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/utils/run-if-fn.js
var isFunction3 = (value) => typeof value === "function";
var runIfFn2 = (valueOrFn, ...args) => isFunction3(valueOrFn) ? valueOrFn(...args) : valueOrFn;

// node_modules/@ark-ui/react/dist/providers/environment/environment-provider.js
var EnvironmentProvider = (props43) => {
  const { value, children } = props43;
  const [spanRef, setSpanRef] = (0, import_react406.useState)();
  const getRootNode = (0, import_react406.useMemo)(() => {
    return () => runIfFn2(value) ?? (spanRef == null ? void 0 : spanRef.getRootNode()) ?? document;
  }, [value, spanRef]);
  const environment = (0, import_react406.useMemo)(
    () => ({
      getRootNode,
      getWindow: () => getWindow(getRootNode()),
      getDocument: () => getDocument(getRootNode())
    }),
    [getRootNode]
  );
  return (0, import_jsx_runtime192.jsxs)(EnvironmentContextProvider, { value: environment, children: [
    children,
    !value && (0, import_jsx_runtime192.jsx)("span", { hidden: true, ref: setSpanRef })
  ] });
};

// node_modules/@ark-ui/react/dist/components/frame/frame-content.js
var import_react407 = __toESM(require_react(), 1);
var FrameContent = (props43) => {
  const { onMount, onUnmount, children } = props43;
  const mountedRef = (0, import_react407.useRef)(false);
  const calledRef = (0, import_react407.useRef)(false);
  (0, import_react407.useEffect)(() => {
    if (!mountedRef.current && !calledRef.current) {
      onMount == null ? void 0 : onMount();
      mountedRef.current = true;
      calledRef.current = true;
    }
    return () => {
      if (mountedRef.current) {
        onUnmount == null ? void 0 : onUnmount();
        mountedRef.current = false;
      }
    };
  }, []);
  return children;
};

// node_modules/@ark-ui/react/dist/components/frame/frame.js
var resetStyle = "<style>*,*::before,*::after { margin: 0; padding: 0; box-sizing: border-box; }</style>";
var initialSrcDoc = `<html><head>${resetStyle}</head><body><div class="frame-root"></div></body></html>`;
function getMountNode(frame) {
  var _a8;
  const doc = (_a8 = frame.contentWindow) == null ? void 0 : _a8.document;
  if (!doc) return null;
  const mountNode = doc.body.querySelector(".frame-root") || doc.body;
  return mountNode;
}
var Frame = (0, import_react408.forwardRef)((props43, ref) => {
  const { children, head, onMount, onUnmount, srcDoc = initialSrcDoc, ...rest } = props43;
  const [frameRef, setFrameRef] = (0, import_react408.useState)(null);
  const [mountNode, setMountNode] = (0, import_react408.useState)(null);
  useSafeLayoutEffect2(() => {
    var _a8;
    if (!frameRef) return;
    const doc = (_a8 = frameRef.contentWindow) == null ? void 0 : _a8.document;
    if (!doc) return;
    doc.open();
    doc.write(srcDoc);
    doc.close();
    setMountNode(getMountNode(frameRef));
  }, [frameRef, srcDoc]);
  (0, import_react408.useEffect)(() => {
    if (!frameRef || !frameRef.contentDocument) return;
    const win = frameRef.contentWindow;
    if (!win) return;
    const mountNode2 = getMountNode(frameRef);
    if (!mountNode2) return;
    const exec = () => {
      var _a8;
      const rootEl = (_a8 = frameRef.contentDocument) == null ? void 0 : _a8.documentElement;
      if (!rootEl) return;
      frameRef.style.setProperty("--width", `${mountNode2.scrollWidth}px`);
      frameRef.style.setProperty("--height", `${mountNode2.scrollHeight}px`);
    };
    const resizeObserver = new win.ResizeObserver(exec);
    exec();
    if (frameRef.contentDocument) {
      resizeObserver.observe(mountNode2);
    }
    return () => {
      resizeObserver.disconnect();
    };
  }, [frameRef]);
  return (0, import_jsx_runtime193.jsx)(EnvironmentProvider, { value: () => (frameRef == null ? void 0 : frameRef.contentDocument) ?? document, children: (0, import_jsx_runtime193.jsxs)("iframe", { title: `frame:${(0, import_react408.useId)()}`, ref: composeRefs(ref, setFrameRef), ...rest, children: [
    mountNode ? (0, import_react_dom2.createPortal)(
      (0, import_jsx_runtime193.jsx)(FrameContent, { onMount, onUnmount, children }),
      mountNode
    ) : null,
    head && frameRef ? (0, import_react_dom2.createPortal)(head, frameRef.contentDocument.head) : null
  ] }) });
});

// node_modules/@ark-ui/react/dist/components/highlight/highlight.js
var import_jsx_runtime194 = __toESM(require_jsx_runtime(), 1);
var import_react410 = __toESM(require_react(), 1);

// node_modules/@zag-js/highlight-word/dist/index.mjs
var normalizeSpan = (spans, len) => {
  const result = [];
  const append = (start, end, match4) => {
    if (end - start > 0) result.push({ start, end, match: match4 });
  };
  if (spans.length === 0) {
    append(0, len, false);
  } else {
    let lastIndex = 0;
    for (const chunk2 of spans) {
      append(lastIndex, chunk2.start, false);
      append(chunk2.start, chunk2.end, true);
      lastIndex = chunk2.end;
    }
    append(lastIndex, len, false);
  }
  return result;
};
function highlightFirst(props43) {
  const { text, query: query2, ignoreCase } = props43;
  const searchText = ignoreCase ? text.toLowerCase() : text;
  const searchQuery = ignoreCase ? typeof query2 === "string" ? query2.toLowerCase() : query2 : query2;
  const start = typeof searchText === "string" ? searchText.indexOf(searchQuery) : -1;
  if (start === -1) {
    return [{ text, match: false }];
  }
  const end = start + searchQuery.length;
  const spans = [{ start, end }];
  return normalizeSpan(spans, text.length).map((chunk2) => ({
    text: text.slice(chunk2.start, chunk2.end),
    match: !!chunk2.match
  }));
}
var escapeRegexp = (term) => term.replace(/[|\\{}()[\]^$+*?.-]/g, (char) => `\\${char}`);
var buildRegex = (queryProp, flags) => {
  const query2 = queryProp.filter(Boolean).map((text) => escapeRegexp(text));
  return new RegExp(`(${query2.join("|")})`, flags);
};
var getRegexFlags = (ignoreCase, matchAll = true) => `${ignoreCase ? "i" : ""}${matchAll ? "g" : ""}`;
function highlightMultiple(props43) {
  const { text, query: query2, ignoreCase, matchAll } = props43;
  if (query2.length === 0) {
    return [{ text, match: false }];
  }
  const flags = getRegexFlags(ignoreCase, matchAll);
  const regex = buildRegex(Array.isArray(query2) ? query2 : [query2], flags);
  const spans = [...text.matchAll(regex)].map((match4) => ({
    start: match4.index || 0,
    end: (match4.index || 0) + match4[0].length
  }));
  return normalizeSpan(spans, props43.text.length).map((chunk2) => ({
    text: props43.text.slice(chunk2.start, chunk2.end),
    match: !!chunk2.match
  }));
}
var highlightWord = (props43) => {
  if (props43.matchAll == null) {
    props43.matchAll = Array.isArray(props43.query);
  }
  if (!props43.matchAll && Array.isArray(props43.query)) {
    throw new Error("matchAll must be true when using multiple queries");
  }
  return props43.matchAll ? highlightMultiple(props43) : highlightFirst(props43);
};

// node_modules/@ark-ui/react/dist/components/highlight/use-highlight.js
var import_react409 = __toESM(require_react(), 1);
var useHighlight = (props43) => {
  return (0, import_react409.useMemo)(() => highlightWord(props43), [props43]);
};

// node_modules/@ark-ui/react/dist/components/hover-card/hover-card-arrow.js
var import_jsx_runtime195 = __toESM(require_jsx_runtime(), 1);
var import_react412 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/hover-card/use-hover-card-context.js
var [HoverCardProvider, useHoverCardContext] = createContext3({
  name: "HoverCardContext",
  hookName: "useHoverCardContext",
  providerName: "<HoverCardProvider />"
});

// node_modules/@ark-ui/react/dist/components/hover-card/hover-card-arrow.js
var HoverCardArrow = (0, import_react412.forwardRef)((props43, ref) => {
  const hoverCard = useHoverCardContext();
  const mergedProps = mergeProps2(hoverCard.getArrowProps(), props43);
  return (0, import_jsx_runtime195.jsx)(ark.div, { ...mergedProps, ref });
});
HoverCardArrow.displayName = "HoverCardArrow";

// node_modules/@ark-ui/react/dist/components/hover-card/hover-card-arrow-tip.js
var import_jsx_runtime196 = __toESM(require_jsx_runtime(), 1);
var import_react414 = __toESM(require_react(), 1);
var HoverCardArrowTip = (0, import_react414.forwardRef)((props43, ref) => {
  const hoverCard = useHoverCardContext();
  const mergedProps = mergeProps2(hoverCard.getArrowTipProps(), props43);
  return (0, import_jsx_runtime196.jsx)(ark.div, { ...mergedProps, ref });
});
HoverCardArrowTip.displayName = "HoverCardArrowTip";

// node_modules/@ark-ui/react/dist/components/hover-card/hover-card-content.js
var import_jsx_runtime197 = __toESM(require_jsx_runtime(), 1);
var import_react416 = __toESM(require_react(), 1);
var HoverCardContent = (0, import_react416.forwardRef)((props43, ref) => {
  const hoverCard = useHoverCardContext();
  const presence = usePresenceContext();
  const mergedProps = mergeProps2(hoverCard.getContentProps(), presence.getPresenceProps(), props43);
  if (presence.unmounted) {
    return null;
  }
  return (0, import_jsx_runtime197.jsx)(ark.div, { ...mergedProps, ref: composeRefs(presence.ref, ref) });
});
HoverCardContent.displayName = "HoverCardContent";

// node_modules/@ark-ui/react/dist/components/hover-card/hover-card-context.js
var HoverCardContext = (props43) => props43.children(useHoverCardContext());

// node_modules/@ark-ui/react/dist/components/hover-card/hover-card-positioner.js
var import_jsx_runtime198 = __toESM(require_jsx_runtime(), 1);
var import_react418 = __toESM(require_react(), 1);
var HoverCardPositioner = (0, import_react418.forwardRef)((props43, ref) => {
  const hoverCard = useHoverCardContext();
  const mergedProps = mergeProps2(hoverCard.getPositionerProps(), props43);
  const presence = usePresenceContext();
  if (presence.unmounted) {
    return null;
  }
  return (0, import_jsx_runtime198.jsx)(ark.div, { ...mergedProps, ref });
});
HoverCardPositioner.displayName = "HoverCardPositioner";

// node_modules/@ark-ui/react/dist/components/hover-card/hover-card-root.js
var import_jsx_runtime199 = __toESM(require_jsx_runtime(), 1);

// node_modules/@zag-js/hover-card/dist/index.mjs
var anatomy15 = createAnatomy("hoverCard").parts("arrow", "arrowTip", "trigger", "positioner", "content");
var parts17 = anatomy15.build();
var getTriggerId8 = (ctx) => {
  var _a8;
  return ((_a8 = ctx.ids) == null ? void 0 : _a8.trigger) ?? `hover-card:${ctx.id}:trigger`;
};
var getContentId7 = (ctx) => {
  var _a8;
  return ((_a8 = ctx.ids) == null ? void 0 : _a8.content) ?? `hover-card:${ctx.id}:content`;
};
var getPositionerId6 = (ctx) => {
  var _a8;
  return ((_a8 = ctx.ids) == null ? void 0 : _a8.positioner) ?? `hover-card:${ctx.id}:popper`;
};
var getArrowId = (ctx) => {
  var _a8;
  return ((_a8 = ctx.ids) == null ? void 0 : _a8.arrow) ?? `hover-card:${ctx.id}:arrow`;
};
var getTriggerEl6 = (ctx) => ctx.getById(getTriggerId8(ctx));
var getContentEl7 = (ctx) => ctx.getById(getContentId7(ctx));
var getPositionerEl6 = (ctx) => ctx.getById(getPositionerId6(ctx));
function connect16(service, normalize4) {
  const { state: state2, send, prop, context, scope } = service;
  const open = state2.hasTag("open");
  const popperStyles = getPlacementStyles({
    ...prop("positioning"),
    placement: context.get("currentPlacement")
  });
  return {
    open,
    setOpen(nextOpen) {
      const open2 = state2.hasTag("open");
      if (open2 === nextOpen) return;
      send({ type: nextOpen ? "OPEN" : "CLOSE" });
    },
    reposition(options = {}) {
      send({ type: "POSITIONING.SET", options });
    },
    getArrowProps() {
      return normalize4.element({
        id: getArrowId(scope),
        ...parts17.arrow.attrs,
        dir: prop("dir"),
        style: popperStyles.arrow
      });
    },
    getArrowTipProps() {
      return normalize4.element({
        ...parts17.arrowTip.attrs,
        dir: prop("dir"),
        style: popperStyles.arrowTip
      });
    },
    getTriggerProps() {
      return normalize4.element({
        ...parts17.trigger.attrs,
        dir: prop("dir"),
        "data-placement": context.get("currentPlacement"),
        id: getTriggerId8(scope),
        "data-state": open ? "open" : "closed",
        onPointerEnter(event) {
          if (event.pointerType === "touch") return;
          send({ type: "POINTER_ENTER", src: "trigger" });
        },
        onPointerLeave(event) {
          if (event.pointerType === "touch") return;
          send({ type: "POINTER_LEAVE", src: "trigger" });
        },
        onFocus() {
          send({ type: "TRIGGER_FOCUS" });
        },
        onBlur() {
          send({ type: "TRIGGER_BLUR" });
        }
      });
    },
    getPositionerProps() {
      return normalize4.element({
        id: getPositionerId6(scope),
        ...parts17.positioner.attrs,
        dir: prop("dir"),
        style: popperStyles.floating
      });
    },
    getContentProps() {
      return normalize4.element({
        ...parts17.content.attrs,
        dir: prop("dir"),
        id: getContentId7(scope),
        hidden: !open,
        tabIndex: -1,
        "data-state": open ? "open" : "closed",
        "data-placement": context.get("currentPlacement"),
        onPointerEnter(event) {
          if (event.pointerType === "touch") return;
          send({ type: "POINTER_ENTER", src: "content" });
        },
        onPointerLeave(event) {
          if (event.pointerType === "touch") return;
          send({ type: "POINTER_LEAVE", src: "content" });
        }
      });
    }
  };
}
var { not: not5, and: and6 } = createGuards();
var machine16 = createMachine({
  props({ props: props210 }) {
    return {
      openDelay: 700,
      closeDelay: 300,
      ...props210,
      positioning: {
        placement: "bottom",
        ...props210.positioning
      }
    };
  },
  initialState({ prop }) {
    const open = prop("open") || prop("defaultOpen");
    return open ? "open" : "closed";
  },
  context({ prop, bindable }) {
    return {
      open: bindable(() => ({
        defaultValue: prop("defaultOpen"),
        value: prop("open"),
        onChange(value) {
          var _a8;
          (_a8 = prop("onOpenChange")) == null ? void 0 : _a8({ open: value });
        }
      })),
      currentPlacement: bindable(() => ({
        defaultValue: void 0
      })),
      isPointer: bindable(() => ({
        defaultValue: false
      }))
    };
  },
  watch({ track, context, action }) {
    track([() => context.get("open")], () => {
      action(["toggleVisibility"]);
    });
  },
  states: {
    closed: {
      tags: ["closed"],
      entry: ["clearIsPointer"],
      on: {
        "CONTROLLED.OPEN": {
          target: "open"
        },
        POINTER_ENTER: {
          target: "opening",
          actions: ["setIsPointer"]
        },
        TRIGGER_FOCUS: {
          target: "opening"
        },
        OPEN: {
          target: "opening"
        }
      }
    },
    opening: {
      tags: ["closed"],
      effects: ["waitForOpenDelay"],
      on: {
        OPEN_DELAY: [
          {
            guard: "isOpenControlled",
            actions: ["invokeOnOpen"]
          },
          {
            target: "open",
            actions: ["invokeOnOpen"]
          }
        ],
        "CONTROLLED.OPEN": {
          target: "open"
        },
        "CONTROLLED.CLOSE": {
          target: "closed"
        },
        POINTER_LEAVE: [
          {
            guard: "isOpenControlled",
            // We trigger toggleVisibility manually since the `ctx.open` has not changed yet (at this point)
            actions: ["invokeOnClose", "toggleVisibility"]
          },
          {
            target: "closed",
            actions: ["invokeOnClose"]
          }
        ],
        TRIGGER_BLUR: [
          {
            guard: and6("isOpenControlled", not5("isPointer")),
            // We trigger toggleVisibility manually since the `ctx.open` has not changed yet (at this point)
            actions: ["invokeOnClose", "toggleVisibility"]
          },
          {
            guard: not5("isPointer"),
            target: "closed",
            actions: ["invokeOnClose"]
          }
        ],
        CLOSE: [
          {
            guard: "isOpenControlled",
            // We trigger toggleVisibility manually since the `ctx.open` has not changed yet (at this point)
            actions: ["invokeOnClose", "toggleVisibility"]
          },
          {
            target: "closed",
            actions: ["invokeOnClose"]
          }
        ]
      }
    },
    open: {
      tags: ["open"],
      effects: ["trackDismissableElement", "trackPositioning"],
      on: {
        "CONTROLLED.CLOSE": {
          target: "closed"
        },
        POINTER_ENTER: {
          actions: ["setIsPointer"]
        },
        POINTER_LEAVE: {
          target: "closing"
        },
        CLOSE: [
          {
            guard: "isOpenControlled",
            actions: ["invokeOnClose"]
          },
          {
            target: "closed",
            actions: ["invokeOnClose"]
          }
        ],
        TRIGGER_BLUR: [
          {
            guard: and6("isOpenControlled", not5("isPointer")),
            actions: ["invokeOnClose"]
          },
          {
            guard: not5("isPointer"),
            target: "closed",
            actions: ["invokeOnClose"]
          }
        ],
        "POSITIONING.SET": {
          actions: ["reposition"]
        }
      }
    },
    closing: {
      tags: ["open"],
      effects: ["trackPositioning", "waitForCloseDelay"],
      on: {
        CLOSE_DELAY: [
          {
            guard: "isOpenControlled",
            actions: ["invokeOnClose"]
          },
          {
            target: "closed",
            actions: ["invokeOnClose"]
          }
        ],
        "CONTROLLED.CLOSE": {
          target: "closed"
        },
        "CONTROLLED.OPEN": {
          target: "open"
        },
        POINTER_ENTER: {
          target: "open",
          // no need to invokeOnOpen here because it's still open (but about to close)
          actions: ["setIsPointer"]
        }
      }
    }
  },
  implementations: {
    guards: {
      isPointer: ({ context }) => !!context.get("isPointer"),
      isOpenControlled: ({ prop }) => prop("open") != null
    },
    effects: {
      waitForOpenDelay({ send, prop }) {
        const id = setTimeout(() => {
          send({ type: "OPEN_DELAY" });
        }, prop("openDelay"));
        return () => clearTimeout(id);
      },
      waitForCloseDelay({ send, prop }) {
        const id = setTimeout(() => {
          send({ type: "CLOSE_DELAY" });
        }, prop("closeDelay"));
        return () => clearTimeout(id);
      },
      trackPositioning({ context, prop, scope }) {
        if (!context.get("currentPlacement")) {
          context.set("currentPlacement", prop("positioning").placement);
        }
        const getPositionerEl22 = () => getPositionerEl6(scope);
        return getPlacement(getTriggerEl6(scope), getPositionerEl22, {
          ...prop("positioning"),
          defer: true,
          onComplete(data) {
            context.set("currentPlacement", data.placement);
          }
        });
      },
      trackDismissableElement({ send, scope, prop }) {
        const getContentEl22 = () => getContentEl7(scope);
        return trackDismissableElement(getContentEl22, {
          defer: true,
          exclude: [getTriggerEl6(scope)],
          onDismiss() {
            send({ type: "CLOSE", src: "interact-outside" });
          },
          onInteractOutside: prop("onInteractOutside"),
          onPointerDownOutside: prop("onPointerDownOutside"),
          onFocusOutside(event) {
            var _a8;
            event.preventDefault();
            (_a8 = prop("onFocusOutside")) == null ? void 0 : _a8(event);
          }
        });
      }
    },
    actions: {
      invokeOnClose({ prop }) {
        var _a8;
        (_a8 = prop("onOpenChange")) == null ? void 0 : _a8({ open: false });
      },
      invokeOnOpen({ prop }) {
        var _a8;
        (_a8 = prop("onOpenChange")) == null ? void 0 : _a8({ open: true });
      },
      setIsPointer({ context }) {
        context.set("isPointer", true);
      },
      clearIsPointer({ context }) {
        context.set("isPointer", false);
      },
      reposition({ context, prop, scope, event }) {
        const getPositionerEl22 = () => getPositionerEl6(scope);
        getPlacement(getTriggerEl6(scope), getPositionerEl22, {
          ...prop("positioning"),
          ...event.options,
          defer: true,
          listeners: false,
          onComplete(data) {
            context.set("currentPlacement", data.placement);
          }
        });
      },
      toggleVisibility({ prop, event, send }) {
        queueMicrotask(() => {
          send({ type: prop("open") ? "CONTROLLED.OPEN" : "CONTROLLED.CLOSE", previousEvent: event });
        });
      }
    }
  }
});
var props16 = createProps()([
  "closeDelay",
  "dir",
  "getRootNode",
  "id",
  "ids",
  "onOpenChange",
  "defaultOpen",
  "open",
  "openDelay",
  "positioning",
  "onInteractOutside",
  "onPointerDownOutside",
  "onFocusOutside"
]);
var splitProps16 = createSplitProps(props16);

// node_modules/@ark-ui/react/dist/components/hover-card/use-hover-card.js
var import_react420 = __toESM(require_react(), 1);
var useHoverCard = (props43) => {
  const id = (0, import_react420.useId)();
  const { getRootNode } = useEnvironmentContext();
  const { dir } = useLocaleContext();
  const machineProps = {
    id,
    dir,
    getRootNode,
    ...props43
  };
  const service = useMachine(machine16, machineProps);
  return connect16(service, normalizeProps);
};

// node_modules/@ark-ui/react/dist/components/hover-card/hover-card-root.js
var HoverCardRoot = (props43) => {
  const [presenceProps, { children, ...localProps }] = splitPresenceProps(props43);
  const hoverCard = useHoverCard(localProps);
  const presence = usePresence(mergeProps2({ present: hoverCard.open }, presenceProps));
  return (0, import_jsx_runtime199.jsx)(HoverCardProvider, { value: hoverCard, children: (0, import_jsx_runtime199.jsx)(PresenceProvider, { value: presence, children }) });
};

// node_modules/@ark-ui/react/dist/components/hover-card/hover-card-root-provider.js
var import_jsx_runtime200 = __toESM(require_jsx_runtime(), 1);
var HoverCardRootProvider = (props43) => {
  const [presenceProps, { value: hoverCard, children }] = splitPresenceProps(props43);
  const presence = usePresence(mergeProps2({ present: hoverCard.open }, presenceProps));
  return (0, import_jsx_runtime200.jsx)(HoverCardProvider, { value: hoverCard, children: (0, import_jsx_runtime200.jsx)(PresenceProvider, { value: presence, children }) });
};

// node_modules/@ark-ui/react/dist/components/hover-card/hover-card-trigger.js
var import_jsx_runtime201 = __toESM(require_jsx_runtime(), 1);
var import_react424 = __toESM(require_react(), 1);
var HoverCardTrigger = (0, import_react424.forwardRef)((props43, ref) => {
  const hoverCard = useHoverCardContext();
  const mergedProps = mergeProps2(hoverCard.getTriggerProps(), props43);
  return (0, import_jsx_runtime201.jsx)(ark.button, { ...mergedProps, ref });
});
HoverCardTrigger.displayName = "HoverCardTrigger";

// node_modules/@ark-ui/react/dist/components/hover-card/hover-card.js
var hover_card_exports = {};
__export(hover_card_exports, {
  Arrow: () => HoverCardArrow,
  ArrowTip: () => HoverCardArrowTip,
  Content: () => HoverCardContent,
  Context: () => HoverCardContext,
  Positioner: () => HoverCardPositioner,
  Root: () => HoverCardRoot,
  RootProvider: () => HoverCardRootProvider,
  Trigger: () => HoverCardTrigger
});

// node_modules/@ark-ui/react/dist/components/listbox/listbox-content.js
var import_jsx_runtime202 = __toESM(require_jsx_runtime(), 1);
var import_react426 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/listbox/use-listbox-context.js
var [ListboxProvider, useListboxContext] = createContext3({
  name: "ListboxContext",
  hookName: "useListboxContext",
  providerName: "<ListboxProvider />"
});

// node_modules/@ark-ui/react/dist/components/listbox/listbox-content.js
var ListboxContent = (0, import_react426.forwardRef)((props43, ref) => {
  const listbox = useListboxContext();
  const mergedProps = mergeProps2(listbox.getContentProps(), props43);
  return (0, import_jsx_runtime202.jsx)(ark.div, { ...mergedProps, ref });
});
ListboxContent.displayName = "ListboxContent";

// node_modules/@ark-ui/react/dist/components/listbox/listbox-input.js
var import_jsx_runtime203 = __toESM(require_jsx_runtime(), 1);
var import_react428 = __toESM(require_react(), 1);
var ListboxInput = (0, import_react428.forwardRef)((props43, ref) => {
  const [inputProps2, localProps] = createSplitProps2()(props43, ["autoHighlight"]);
  const listbox = useListboxContext();
  const mergedProps = mergeProps2(listbox.getInputProps(inputProps2), localProps);
  return (0, import_jsx_runtime203.jsx)(ark.input, { ...mergedProps, ref });
});
ListboxInput.displayName = "ListboxInput";

// node_modules/@ark-ui/react/dist/components/listbox/listbox-item.js
var import_jsx_runtime204 = __toESM(require_jsx_runtime(), 1);
var import_react430 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/listbox/use-listbox-item-context.js
var [ListboxItemProvider, useListboxItemContext] = createContext3({
  name: "ListboxItemContext",
  hookName: "useListboxItemContext",
  providerName: "<ListboxItemProvider />"
});

// node_modules/@ark-ui/react/dist/components/listbox/use-listbox-item-props-context.js
var [ListboxItemPropsProvider, useListboxItemPropsContext] = createContext3({
  name: "ListboxItemPropsContext",
  hookName: "useListboxItemPropsContext",
  providerName: "<ListboxItemPropsProvider />"
});

// node_modules/@ark-ui/react/dist/components/listbox/listbox-item.js
var ListboxItem = (0, import_react430.forwardRef)((props43, ref) => {
  const [itemProps14, localProps] = createSplitProps2()(props43, ["item", "highlightOnHover"]);
  const listbox = useListboxContext();
  const mergedProps = mergeProps2(listbox.getItemProps(itemProps14), localProps);
  const itemState = listbox.getItemState(itemProps14);
  return (0, import_jsx_runtime204.jsx)(ListboxItemPropsProvider, { value: itemProps14, children: (0, import_jsx_runtime204.jsx)(ListboxItemProvider, { value: itemState, children: (0, import_jsx_runtime204.jsx)(ark.div, { ...mergedProps, ref }) }) });
});
ListboxItem.displayName = "ListboxItem";

// node_modules/@ark-ui/react/dist/components/listbox/listbox-item-group.js
var import_jsx_runtime205 = __toESM(require_jsx_runtime(), 1);
var import_react432 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/listbox/use-listbox-item-group-props.js
var [ListboxItemGroupPropsProvider, useListboxItemGroupPropsContext] = createContext3({
  name: "ListboxItemGroupPropsContext",
  hookName: "useListboxItemGroupPropsContext",
  providerName: "<ListboxItemGroupPropsProvider />"
});

// node_modules/@ark-ui/react/dist/components/listbox/listbox-item-group.js
var ListboxItemGroup = (0, import_react432.forwardRef)((props43, ref) => {
  const id = (0, import_react432.useId)();
  const [_itemGroupProps, localProps] = createSplitProps2()(props43, ["id"]);
  const itemGroupProps5 = { id, ..._itemGroupProps };
  const listbox = useListboxContext();
  const mergedProps = mergeProps2(listbox.getItemGroupProps(itemGroupProps5), localProps);
  return (0, import_jsx_runtime205.jsx)(ListboxItemGroupPropsProvider, { value: itemGroupProps5, children: (0, import_jsx_runtime205.jsx)(ark.div, { ...mergedProps, ref }) });
});
ListboxItemGroup.displayName = "ListboxItemGroup";

// node_modules/@ark-ui/react/dist/components/listbox/listbox-item-group-label.js
var import_jsx_runtime206 = __toESM(require_jsx_runtime(), 1);
var import_react434 = __toESM(require_react(), 1);
var ListboxItemGroupLabel = (0, import_react434.forwardRef)((props43, ref) => {
  const listbox = useListboxContext();
  const itemGroupProps5 = useListboxItemGroupPropsContext();
  const mergedProps = mergeProps2(listbox.getItemGroupLabelProps({ htmlFor: itemGroupProps5.id }), props43);
  return (0, import_jsx_runtime206.jsx)(ark.div, { ...mergedProps, ref });
});
ListboxItemGroupLabel.displayName = "ListboxItemGroupLabel";

// node_modules/@ark-ui/react/dist/components/listbox/listbox-item-indicator.js
var import_jsx_runtime207 = __toESM(require_jsx_runtime(), 1);
var import_react436 = __toESM(require_react(), 1);
var ListboxItemIndicator = (0, import_react436.forwardRef)((props43, ref) => {
  const listbox = useListboxContext();
  const itemProps14 = useListboxItemPropsContext();
  const mergedProps = mergeProps2(listbox.getItemIndicatorProps(itemProps14), props43);
  return (0, import_jsx_runtime207.jsx)(ark.div, { ...mergedProps, ref });
});
ListboxItemIndicator.displayName = "ListboxItemIndicator";

// node_modules/@ark-ui/react/dist/components/listbox/listbox-item-text.js
var import_jsx_runtime208 = __toESM(require_jsx_runtime(), 1);
var import_react438 = __toESM(require_react(), 1);
var ListboxItemText = (0, import_react438.forwardRef)((props43, ref) => {
  const listbox = useListboxContext();
  const itemProps14 = useListboxItemPropsContext();
  const mergedProps = mergeProps2(listbox.getItemTextProps(itemProps14), props43);
  return (0, import_jsx_runtime208.jsx)(ark.div, { ...mergedProps, ref });
});
ListboxItemText.displayName = "ListboxItemText";

// node_modules/@ark-ui/react/dist/components/listbox/listbox-label.js
var import_jsx_runtime209 = __toESM(require_jsx_runtime(), 1);
var import_react440 = __toESM(require_react(), 1);
var ListboxLabel = (0, import_react440.forwardRef)((props43, ref) => {
  const listbox = useListboxContext();
  const mergedProps = mergeProps2(listbox.getLabelProps(), props43);
  return (0, import_jsx_runtime209.jsx)(ark.label, { ...mergedProps, ref });
});
ListboxLabel.displayName = "ListboxLabel";

// node_modules/@ark-ui/react/dist/components/listbox/listbox-root.js
var import_jsx_runtime210 = __toESM(require_jsx_runtime(), 1);
var import_react444 = __toESM(require_react(), 1);

// node_modules/@zag-js/listbox/dist/index.mjs
var anatomy16 = createAnatomy("listbox").parts(
  "label",
  "input",
  "item",
  "itemText",
  "itemIndicator",
  "itemGroup",
  "itemGroupLabel",
  "content",
  "root",
  "valueText"
);
var parts18 = anatomy16.build();
var collection2 = (options) => {
  return new ListCollection(options);
};
collection2.empty = () => {
  return new ListCollection({ items: [] });
};
var gridCollection = (options) => {
  return new GridCollection(options);
};
gridCollection.empty = () => {
  return new GridCollection({ items: [], columnCount: 0 });
};
var getRootId13 = (ctx) => {
  var _a8;
  return ((_a8 = ctx.ids) == null ? void 0 : _a8.root) ?? `select:${ctx.id}`;
};
var getContentId8 = (ctx) => {
  var _a8;
  return ((_a8 = ctx.ids) == null ? void 0 : _a8.content) ?? `select:${ctx.id}:content`;
};
var getLabelId8 = (ctx) => {
  var _a8;
  return ((_a8 = ctx.ids) == null ? void 0 : _a8.label) ?? `select:${ctx.id}:label`;
};
var getItemId5 = (ctx, id) => {
  var _a8, _b7;
  return ((_b7 = (_a8 = ctx.ids) == null ? void 0 : _a8.item) == null ? void 0 : _b7.call(_a8, id)) ?? `select:${ctx.id}:option:${id}`;
};
var getItemGroupId3 = (ctx, id) => {
  var _a8, _b7;
  return ((_b7 = (_a8 = ctx.ids) == null ? void 0 : _a8.itemGroup) == null ? void 0 : _b7.call(_a8, id)) ?? `select:${ctx.id}:optgroup:${id}`;
};
var getItemGroupLabelId2 = (ctx, id) => {
  var _a8, _b7;
  return ((_b7 = (_a8 = ctx.ids) == null ? void 0 : _a8.itemGroupLabel) == null ? void 0 : _b7.call(_a8, id)) ?? `select:${ctx.id}:optgroup-label:${id}`;
};
var getContentEl8 = (ctx) => ctx.getById(getContentId8(ctx));
var getItemEl2 = (ctx, id) => ctx.getById(getItemId5(ctx, id));
function connect17(service, normalize4) {
  const { context, prop, scope, computed, send } = service;
  const disabled = prop("disabled");
  const collection22 = prop("collection");
  const layout = isGridCollection(collection22) ? "grid" : "list";
  const value = context.get("value");
  const highlightedValue = context.get("highlightedValue");
  const highlightedItem = context.get("highlightedItem");
  const selectedItems = context.get("selectedItems");
  const isTypingAhead = computed("isTypingAhead");
  const interactive = computed("isInteractive");
  const ariaActiveDescendant = highlightedValue ? getItemId5(scope, highlightedValue) : void 0;
  function getItemState(props210) {
    const itemDisabled = collection22.getItemDisabled(props210.item);
    const value2 = collection22.getItemValue(props210.item);
    ensure(value2, () => `[zag-js] No value found for item ${JSON.stringify(props210.item)}`);
    return {
      value: value2,
      disabled: Boolean(disabled || itemDisabled),
      highlighted: highlightedValue === value2 && context.get("focused"),
      selected: context.get("value").includes(value2)
    };
  }
  return {
    empty: value.length === 0,
    highlightedItem,
    highlightedValue,
    clearHighlightedValue() {
      send({ type: "HIGHLIGHTED_VALUE.SET", value: null });
    },
    selectedItems,
    hasSelectedItems: computed("hasSelectedItems"),
    value,
    valueAsString: context.get("valueAsString"),
    collection: collection22,
    disabled: !!disabled,
    selectValue(value2) {
      send({ type: "ITEM.SELECT", value: value2 });
    },
    setValue(value2) {
      send({ type: "VALUE.SET", value: value2 });
    },
    selectAll() {
      if (!computed("multiple")) {
        throw new Error("[zag-js] Cannot select all items in a single-select listbox");
      }
      send({ type: "VALUE.SET", value: collection22.getValues() });
    },
    highlightValue(value2) {
      send({ type: "HIGHLIGHTED_VALUE.SET", value: value2 });
    },
    clearValue(value2) {
      if (value2) {
        send({ type: "ITEM.CLEAR", value: value2 });
      } else {
        send({ type: "VALUE.CLEAR" });
      }
    },
    getItemState,
    getRootProps() {
      return normalize4.element({
        ...parts18.root.attrs,
        dir: prop("dir"),
        id: getRootId13(scope),
        "data-orientation": prop("orientation"),
        "data-disabled": dataAttr(disabled)
      });
    },
    getInputProps(props210 = {}) {
      return normalize4.input({
        ...parts18.input.attrs,
        dir: prop("dir"),
        disabled,
        "data-disabled": dataAttr(disabled),
        autoComplete: "off",
        autoCorrect: "off",
        "aria-haspopup": "listbox",
        "aria-controls": getContentId8(scope),
        "aria-autocomplete": "list",
        "aria-activedescendant": ariaActiveDescendant,
        spellCheck: false,
        enterKeyHint: "go",
        onFocus() {
          queueMicrotask(() => {
            const contentEl = getContentEl8(scope);
            const win = getWindow(contentEl);
            const focusInEvt = new win.FocusEvent("focusin", { bubbles: true, cancelable: true });
            contentEl == null ? void 0 : contentEl.dispatchEvent(focusInEvt);
          });
        },
        onBlur(event) {
          if (event.defaultPrevented) return;
          const contentEl = getContentEl8(scope);
          const win = getWindow(contentEl);
          const focusOutEvt = new win.FocusEvent("focusout", { bubbles: true, cancelable: true });
          contentEl == null ? void 0 : contentEl.dispatchEvent(focusOutEvt);
        },
        onInput(event) {
          if (!props210.autoHighlight) return;
          const node = event.currentTarget;
          queueMicrotask(() => {
            if (!node.isConnected) return;
            send({
              type: "HIGHLIGHTED_VALUE.SET",
              value: node.value ? prop("collection").firstValue : null
            });
          });
        },
        onKeyDown(event) {
          var _a8;
          if (event.defaultPrevented) return;
          if (isComposingEvent(event)) return;
          const nativeEvent = getNativeEvent(event);
          switch (nativeEvent.key) {
            case "ArrowDown":
            case "ArrowUp":
            case "Home":
            case "End": {
              if ((event.key === "Home" || event.key === "End") && !highlightedValue && event.shiftKey) {
                return;
              }
              event.preventDefault();
              const win = scope.getWin();
              const keyboardEvent = new win.KeyboardEvent(nativeEvent.type, nativeEvent);
              (_a8 = getContentEl8(scope)) == null ? void 0 : _a8.dispatchEvent(keyboardEvent);
              break;
            }
            case "Enter":
              event.preventDefault();
              send({ type: "ITEM.CLICK", value: highlightedValue });
              break;
          }
        }
      });
    },
    getLabelProps() {
      return normalize4.element({
        dir: prop("dir"),
        id: getLabelId8(scope),
        ...parts18.label.attrs,
        "data-disabled": dataAttr(disabled)
      });
    },
    getValueTextProps() {
      return normalize4.element({
        ...parts18.valueText.attrs,
        dir: prop("dir"),
        "data-disabled": dataAttr(disabled)
      });
    },
    getItemProps(props210) {
      const itemState = getItemState(props210);
      return normalize4.element({
        id: getItemId5(scope, itemState.value),
        role: "option",
        ...parts18.item.attrs,
        dir: prop("dir"),
        "data-value": itemState.value,
        "aria-selected": itemState.selected,
        "data-selected": dataAttr(itemState.selected),
        "data-layout": layout,
        "data-state": itemState.selected ? "checked" : "unchecked",
        "data-orientation": prop("orientation"),
        "data-highlighted": dataAttr(itemState.highlighted),
        "data-disabled": dataAttr(itemState.disabled),
        "aria-disabled": ariaAttr(itemState.disabled),
        onPointerMove(event) {
          if (!props210.highlightOnHover) return;
          if (itemState.disabled || event.pointerType !== "mouse") return;
          if (itemState.highlighted) return;
          send({ type: "ITEM.POINTER_MOVE", value: itemState.value });
        },
        onMouseDown(event) {
          var _a8;
          event.preventDefault();
          (_a8 = getContentEl8(scope)) == null ? void 0 : _a8.focus();
        },
        onClick(event) {
          if (event.defaultPrevented) return;
          if (itemState.disabled) return;
          send({
            type: "ITEM.CLICK",
            value: itemState.value,
            shiftKey: event.shiftKey,
            anchorValue: highlightedValue,
            metaKey: isCtrlOrMetaKey(event)
          });
        }
      });
    },
    getItemTextProps(props210) {
      const itemState = getItemState(props210);
      return normalize4.element({
        ...parts18.itemText.attrs,
        "data-state": itemState.selected ? "checked" : "unchecked",
        "data-disabled": dataAttr(itemState.disabled),
        "data-highlighted": dataAttr(itemState.highlighted)
      });
    },
    getItemIndicatorProps(props210) {
      const itemState = getItemState(props210);
      return normalize4.element({
        ...parts18.itemIndicator.attrs,
        "aria-hidden": true,
        "data-state": itemState.selected ? "checked" : "unchecked",
        hidden: !itemState.selected
      });
    },
    getItemGroupLabelProps(props210) {
      const { htmlFor } = props210;
      return normalize4.element({
        ...parts18.itemGroupLabel.attrs,
        id: getItemGroupLabelId2(scope, htmlFor),
        dir: prop("dir"),
        role: "presentation"
      });
    },
    getItemGroupProps(props210) {
      const { id } = props210;
      return normalize4.element({
        ...parts18.itemGroup.attrs,
        "data-disabled": dataAttr(disabled),
        "data-orientation": prop("orientation"),
        "data-empty": dataAttr(collection22.size === 0),
        id: getItemGroupId3(scope, id),
        "aria-labelledby": getItemGroupLabelId2(scope, id),
        role: "group",
        dir: prop("dir")
      });
    },
    getContentProps() {
      return normalize4.element({
        dir: prop("dir"),
        id: getContentId8(scope),
        role: "listbox",
        ...parts18.content.attrs,
        "data-activedescendant": ariaActiveDescendant,
        "aria-activedescendant": ariaActiveDescendant,
        "data-orientation": prop("orientation"),
        "aria-multiselectable": computed("multiple") ? true : void 0,
        "aria-labelledby": getLabelId8(scope),
        tabIndex: 0,
        "data-layout": layout,
        "data-empty": dataAttr(collection22.size === 0),
        style: {
          "--column-count": isGridCollection(collection22) ? collection22.columnCount : 1
        },
        onFocus() {
          send({ type: "CONTENT.FOCUS" });
        },
        onBlur() {
          send({ type: "CONTENT.BLUR" });
        },
        onKeyDown(event) {
          if (!interactive) return;
          if (!isSelfTarget(event)) return;
          const shiftKey = event.shiftKey;
          const keyMap2 = {
            ArrowUp(event2) {
              let nextValue = null;
              if (isGridCollection(collection22) && highlightedValue) {
                nextValue = collection22.getPreviousRowValue(highlightedValue);
              } else if (highlightedValue) {
                nextValue = collection22.getPreviousValue(highlightedValue);
              }
              if (!nextValue && (prop("loopFocus") || !highlightedValue)) {
                nextValue = collection22.lastValue;
              }
              if (!nextValue) return;
              event2.preventDefault();
              send({ type: "NAVIGATE", value: nextValue, shiftKey, anchorValue: highlightedValue });
            },
            ArrowDown(event2) {
              let nextValue = null;
              if (isGridCollection(collection22) && highlightedValue) {
                nextValue = collection22.getNextRowValue(highlightedValue);
              } else if (highlightedValue) {
                nextValue = collection22.getNextValue(highlightedValue);
              }
              if (!nextValue && (prop("loopFocus") || !highlightedValue)) {
                nextValue = collection22.firstValue;
              }
              if (!nextValue) return;
              event2.preventDefault();
              send({ type: "NAVIGATE", value: nextValue, shiftKey, anchorValue: highlightedValue });
            },
            ArrowLeft() {
              if (!isGridCollection(collection22) && prop("orientation") === "vertical") return;
              let nextValue = highlightedValue ? collection22.getPreviousValue(highlightedValue) : null;
              if (!nextValue && prop("loopFocus")) {
                nextValue = collection22.lastValue;
              }
              if (!nextValue) return;
              event.preventDefault();
              send({ type: "NAVIGATE", value: nextValue, shiftKey, anchorValue: highlightedValue });
            },
            ArrowRight() {
              if (!isGridCollection(collection22) && prop("orientation") === "vertical") return;
              let nextValue = highlightedValue ? collection22.getNextValue(highlightedValue) : null;
              if (!nextValue && prop("loopFocus")) {
                nextValue = collection22.firstValue;
              }
              if (!nextValue) return;
              event.preventDefault();
              send({ type: "NAVIGATE", value: nextValue, shiftKey, anchorValue: highlightedValue });
            },
            Home(event2) {
              event2.preventDefault();
              let nextValue = collection22.firstValue;
              send({ type: "NAVIGATE", value: nextValue, shiftKey, anchorValue: highlightedValue });
            },
            End(event2) {
              event2.preventDefault();
              let nextValue = collection22.lastValue;
              send({ type: "NAVIGATE", value: nextValue, shiftKey, anchorValue: highlightedValue });
            },
            Enter() {
              send({ type: "ITEM.CLICK", value: highlightedValue });
            },
            a(event2) {
              if (isCtrlOrMetaKey(event2) && computed("multiple") && !prop("disallowSelectAll")) {
                event2.preventDefault();
                send({ type: "VALUE.SET", value: collection22.getValues() });
              }
            },
            Space(event2) {
              var _a8;
              if (isTypingAhead && prop("typeahead")) {
                send({ type: "CONTENT.TYPEAHEAD", key: event2.key });
              } else {
                (_a8 = keyMap2.Enter) == null ? void 0 : _a8.call(keyMap2, event2);
              }
            },
            Escape(event2) {
              if (prop("deselectable") && value.length > 0) {
                event2.preventDefault();
                event2.stopPropagation();
                send({ type: "VALUE.CLEAR" });
              }
            }
          };
          const exec = keyMap2[getEventKey(event)];
          if (exec) {
            exec(event);
            return;
          }
          const target = getEventTarget(event);
          if (isEditableElement(target)) {
            return;
          }
          if (getByTypeahead.isValidEvent(event) && prop("typeahead")) {
            send({ type: "CONTENT.TYPEAHEAD", key: event.key });
            event.preventDefault();
          }
        }
      });
    }
  };
}
var machine17 = createMachine({
  props({ props: props210 }) {
    return {
      loopFocus: false,
      composite: true,
      defaultValue: [],
      multiple: false,
      typeahead: true,
      collection: collection2.empty(),
      orientation: "vertical",
      selectionMode: "single",
      ...props210
    };
  },
  context({ prop, bindable }) {
    return {
      value: bindable(() => ({
        defaultValue: prop("defaultValue"),
        value: prop("value"),
        isEqual,
        onChange(value) {
          var _a8;
          const items = prop("collection").findMany(value);
          return (_a8 = prop("onValueChange")) == null ? void 0 : _a8({ value, items });
        }
      })),
      highlightedValue: bindable(() => ({
        defaultValue: prop("defaultHighlightedValue") || null,
        value: prop("highlightedValue"),
        sync: true,
        onChange(value) {
          var _a8;
          (_a8 = prop("onHighlightChange")) == null ? void 0 : _a8({
            highlightedValue: value,
            highlightedItem: prop("collection").find(value),
            highlightedIndex: prop("collection").indexOf(value)
          });
        }
      })),
      highlightedItem: bindable(() => ({
        defaultValue: null
      })),
      selectedItems: bindable(() => {
        const value = prop("value") ?? prop("defaultValue") ?? [];
        const items = prop("collection").findMany(value);
        return { defaultValue: items };
      }),
      valueAsString: bindable(() => {
        const value = prop("value") ?? prop("defaultValue") ?? [];
        return { defaultValue: prop("collection").stringifyMany(value) };
      }),
      focused: bindable(() => ({
        defaultValue: false
      }))
    };
  },
  refs({ prop }) {
    return {
      typeahead: { ...getByTypeahead.defaultOptions },
      prevCollection: prop("collection")
    };
  },
  computed: {
    hasSelectedItems: ({ context }) => context.get("value").length > 0,
    isTypingAhead: ({ refs }) => refs.get("typeahead").keysSoFar !== "",
    isInteractive: ({ prop }) => !prop("disabled"),
    selection: ({ context, prop }) => {
      const selection = new Selection(context.get("value"));
      selection.selectionMode = prop("selectionMode");
      selection.deselectable = !!prop("deselectable");
      return selection;
    },
    multiple: ({ prop }) => prop("selectionMode") === "multiple" || prop("selectionMode") === "extended"
  },
  initialState() {
    return "idle";
  },
  watch({ context, prop, track, action }) {
    track([() => context.get("value").toString()], () => {
      action(["syncSelectedItems"]);
    });
    track([() => context.get("highlightedValue")], () => {
      action(["syncHighlightedItem"]);
    });
    track([() => prop("collection").toString()], () => {
      action(["syncCollection"]);
    });
  },
  effects: ["trackFocusVisible"],
  on: {
    "HIGHLIGHTED_VALUE.SET": {
      actions: ["setHighlightedItem"]
    },
    "ITEM.SELECT": {
      actions: ["selectItem"]
    },
    "ITEM.CLEAR": {
      actions: ["clearItem"]
    },
    "VALUE.SET": {
      actions: ["setSelectedItems"]
    },
    "VALUE.CLEAR": {
      actions: ["clearSelectedItems"]
    },
    "CLEAR.CLICK": {
      actions: ["clearSelectedItems"]
    }
  },
  states: {
    idle: {
      effects: ["scrollToHighlightedItem"],
      on: {
        "CONTENT.FOCUS": {
          actions: ["setFocused"]
        },
        "CONTENT.BLUR": {
          actions: ["clearFocused"]
        },
        "ITEM.CLICK": {
          actions: ["setHighlightedItem", "selectHighlightedItem"]
        },
        "CONTENT.TYPEAHEAD": {
          actions: ["highlightMatchingItem"]
        },
        "ITEM.POINTER_MOVE": {
          actions: ["highlightItem"]
        },
        "ITEM.POINTER_LEAVE": {
          actions: ["clearHighlightedItem"]
        },
        NAVIGATE: {
          actions: ["setHighlightedItem", "selectWithKeyboard"]
        }
      }
    }
  },
  implementations: {
    effects: {
      trackFocusVisible: ({ scope }) => {
        var _a8;
        return trackFocusVisible({ root: (_a8 = scope.getRootNode) == null ? void 0 : _a8.call(scope) });
      },
      scrollToHighlightedItem({ context, prop, scope }) {
        const exec = (immediate) => {
          const highlightedValue = context.get("highlightedValue");
          if (highlightedValue == null) return;
          const modality = getInteractionModality();
          if (modality !== "keyboard") return;
          const itemEl = getItemEl2(scope, highlightedValue);
          const contentEl2 = getContentEl8(scope);
          const scrollToIndexFn = prop("scrollToIndexFn");
          if (scrollToIndexFn) {
            const highlightedIndex = prop("collection").indexOf(highlightedValue);
            scrollToIndexFn == null ? void 0 : scrollToIndexFn({ index: highlightedIndex, immediate });
            return;
          }
          scrollIntoView(itemEl, { rootEl: contentEl2, block: "nearest" });
        };
        raf(() => exec(true));
        const contentEl = () => getContentEl8(scope);
        return observeAttributes(contentEl, {
          defer: true,
          attributes: ["data-activedescendant"],
          callback() {
            exec(false);
          }
        });
      }
    },
    actions: {
      selectHighlightedItem({ context, prop, event, computed }) {
        const value = event.value ?? context.get("highlightedValue");
        if (value == null) return;
        const selection = computed("selection");
        const collection22 = prop("collection");
        if (event.shiftKey && computed("multiple") && event.anchorValue) {
          const next2 = selection.extendSelection(collection22, event.anchorValue, value);
          invokeOnSelect(selection, next2, prop("onSelect"));
          context.set("value", Array.from(next2));
        } else {
          const next2 = selection.select(collection22, value, event.metaKey);
          invokeOnSelect(selection, next2, prop("onSelect"));
          context.set("value", Array.from(next2));
        }
      },
      selectWithKeyboard({ context, prop, event, computed }) {
        const selection = computed("selection");
        const collection22 = prop("collection");
        if (event.shiftKey && computed("multiple") && event.anchorValue) {
          const next2 = selection.extendSelection(collection22, event.anchorValue, event.value);
          invokeOnSelect(selection, next2, prop("onSelect"));
          context.set("value", Array.from(next2));
          return;
        }
        if (prop("selectOnHighlight")) {
          const next2 = selection.replaceSelection(collection22, event.value);
          invokeOnSelect(selection, next2, prop("onSelect"));
          context.set("value", Array.from(next2));
        }
      },
      highlightItem({ context, event }) {
        context.set("highlightedValue", event.value);
      },
      highlightMatchingItem({ context, prop, event, refs }) {
        const value = prop("collection").search(event.key, {
          state: refs.get("typeahead"),
          currentValue: context.get("highlightedValue")
        });
        if (value == null) return;
        context.set("highlightedValue", value);
      },
      setHighlightedItem({ context, event }) {
        context.set("highlightedValue", event.value);
      },
      clearHighlightedItem({ context }) {
        context.set("highlightedValue", null);
      },
      selectItem({ context, prop, event, computed }) {
        const collection22 = prop("collection");
        const selection = computed("selection");
        const next2 = selection.select(collection22, event.value);
        invokeOnSelect(selection, next2, prop("onSelect"));
        context.set("value", Array.from(next2));
      },
      clearItem({ context, event, computed }) {
        const selection = computed("selection");
        const value = selection.deselect(event.value);
        context.set("value", Array.from(value));
      },
      setSelectedItems({ context, event }) {
        context.set("value", event.value);
      },
      clearSelectedItems({ context }) {
        context.set("value", []);
      },
      syncCollection({ context, prop, refs }) {
        const collection22 = prop("collection");
        const highlightedItem = collection22.find(context.get("highlightedValue"));
        if (highlightedItem) context.set("highlightedItem", highlightedItem);
        const selectedItems = collection22.findMany(context.get("value"));
        context.set("selectedItems", selectedItems);
        const valueAsString = collection22.stringifyItems(selectedItems);
        context.set("valueAsString", valueAsString);
        const highlightedValue = syncHighlightedValue(
          collection22,
          refs.get("prevCollection"),
          context.get("highlightedValue")
        );
        queueMicrotask(() => {
          context.set("highlightedValue", highlightedValue);
          refs.set("prevCollection", collection22);
        });
      },
      syncSelectedItems({ context, prop }) {
        const collection22 = prop("collection");
        const prevSelectedItems = context.get("selectedItems");
        const value = context.get("value");
        const selectedItems = value.map((value2) => {
          const item = prevSelectedItems.find((item2) => collection22.getItemValue(item2) === value2);
          return item || collection22.find(value2);
        });
        context.set("selectedItems", selectedItems);
        context.set("valueAsString", collection22.stringifyItems(selectedItems));
      },
      syncHighlightedItem({ context, prop }) {
        const collection22 = prop("collection");
        const highlightedValue = context.get("highlightedValue");
        const highlightedItem = highlightedValue ? collection22.find(highlightedValue) : null;
        context.set("highlightedItem", highlightedItem);
      },
      setFocused({ context }) {
        context.set("focused", true);
      },
      clearFocused({ context }) {
        context.set("focused", false);
      }
    }
  }
});
var diff2 = (a2, b2) => {
  const result = new Set(a2);
  for (const item of b2) result.delete(item);
  return result;
};
function invokeOnSelect(current, next2, onSelect) {
  const added = diff2(next2, current);
  for (const item of added) {
    onSelect == null ? void 0 : onSelect({ value: item });
  }
}
function syncHighlightedValue(collection22, prevCollection, highlightedValue) {
  if (highlightedValue != null && !collection22.find(highlightedValue) && prevCollection) {
    const startIndex = prevCollection.indexOf(highlightedValue);
    const prevItems = [...prevCollection.items];
    const items = [...collection22.items];
    const diff22 = ((prevItems == null ? void 0 : prevItems.length) ?? 0) - ((items == null ? void 0 : items.length) ?? 0);
    let index = Math.min(
      diff22 > 1 ? Math.max((startIndex ?? 0) - diff22 + 1, 0) : startIndex ?? 0,
      ((items == null ? void 0 : items.length) ?? 0) - 1
    );
    let newValue = null;
    let isReverseSearching = false;
    while (index >= 0) {
      if (!collection22.getItemDisabled(items[index])) {
        newValue = collection22.getItemValue(items[index]);
        break;
      }
      if (index < items.length - 1 && !isReverseSearching) {
        index++;
      } else {
        isReverseSearching = true;
        if (index > (startIndex ?? 0)) {
          index = startIndex ?? 0;
        }
        index--;
      }
    }
    return newValue;
  }
  return null;
}
var props17 = createProps()([
  "collection",
  "defaultHighlightedValue",
  "defaultValue",
  "dir",
  "disabled",
  "deselectable",
  "disallowSelectAll",
  "getRootNode",
  "highlightedValue",
  "id",
  "ids",
  "loopFocus",
  "onHighlightChange",
  "onSelect",
  "onValueChange",
  "orientation",
  "scrollToIndexFn",
  "selectionMode",
  "selectOnHighlight",
  "typeahead",
  "value"
]);
var splitProps17 = createSplitProps(props17);
var itemProps5 = createProps()(["item", "highlightOnHover"]);
var splitItemProps5 = createSplitProps(itemProps5);
var itemGroupProps2 = createProps()(["id"]);
var splitItemGroupProps2 = createSplitProps(itemGroupProps2);
var itemGroupLabelProps2 = createProps()(["htmlFor"]);
var splitItemGroupLabelProps2 = createSplitProps(itemGroupLabelProps2);

// node_modules/@ark-ui/react/dist/components/listbox/use-listbox.js
var import_react442 = __toESM(require_react(), 1);
var useListbox = (props43) => {
  const id = (0, import_react442.useId)();
  const { dir } = useLocaleContext();
  const { getRootNode } = useEnvironmentContext();
  const machineProps = {
    id,
    dir,
    getRootNode,
    ...props43
  };
  const service = useMachine(machine17, machineProps);
  return connect17(service, normalizeProps);
};

// node_modules/@ark-ui/react/dist/components/listbox/listbox-root.js
var ListboxImpl = (props43, ref) => {
  const [useListboxProps, localProps] = createSplitProps2()(props43, [
    "collection",
    "defaultHighlightedValue",
    "defaultValue",
    "deselectable",
    "disabled",
    "disallowSelectAll",
    "highlightedValue",
    "id",
    "ids",
    "loopFocus",
    "onHighlightChange",
    "onSelect",
    "onValueChange",
    "orientation",
    "scrollToIndexFn",
    "selectionMode",
    "selectOnHighlight",
    "typeahead",
    "value"
  ]);
  const listbox = useListbox(useListboxProps);
  const mergedProps = mergeProps2(listbox.getRootProps(), localProps);
  return (0, import_jsx_runtime210.jsx)(ListboxProvider, { value: listbox, children: (0, import_jsx_runtime210.jsx)(ark.div, { ...mergedProps, ref }) });
};
var ListboxRoot = (0, import_react444.forwardRef)(ListboxImpl);

// node_modules/@ark-ui/react/dist/components/listbox/listbox-root-provider.js
var import_jsx_runtime211 = __toESM(require_jsx_runtime(), 1);
var import_react446 = __toESM(require_react(), 1);
var ListboxImpl2 = (props43, ref) => {
  const [{ value: listbox }, localProps] = createSplitProps2()(props43, ["value"]);
  const mergedProps = mergeProps2(listbox.getRootProps(), localProps);
  return (0, import_jsx_runtime211.jsx)(ListboxProvider, { value: listbox, children: (0, import_jsx_runtime211.jsx)(ark.div, { ...mergedProps, ref }) });
};
var ListboxRootProvider = (0, import_react446.forwardRef)(ListboxImpl2);

// node_modules/@ark-ui/react/dist/components/listbox/listbox-value-text.js
var import_jsx_runtime212 = __toESM(require_jsx_runtime(), 1);
var import_react448 = __toESM(require_react(), 1);
var ListboxValueText = (0, import_react448.forwardRef)((props43, ref) => {
  const { children, placeholder, ...localprops } = props43;
  const listbox = useListboxContext();
  const mergedProps = mergeProps2(listbox.getValueTextProps(), localprops);
  return (0, import_jsx_runtime212.jsx)(ark.span, { ...mergedProps, ref, children: children || listbox.valueAsString || placeholder });
});
ListboxValueText.displayName = "ListboxValueText";

// node_modules/@ark-ui/react/dist/components/menu/menu-arrow.js
var import_jsx_runtime213 = __toESM(require_jsx_runtime(), 1);
var import_react450 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/menu/use-menu-context.js
var [MenuProvider, useMenuContext] = createContext3({
  name: "MenuContext",
  hookName: "useMenuContext",
  providerName: "<MenuProvider />",
  strict: false
});

// node_modules/@ark-ui/react/dist/components/menu/menu-arrow.js
var MenuArrow = (0, import_react450.forwardRef)((props43, ref) => {
  const menu = useMenuContext();
  const mergedProps = mergeProps2(menu.getArrowProps(), props43);
  return (0, import_jsx_runtime213.jsx)(ark.div, { ...mergedProps, ref });
});
MenuArrow.displayName = "MenuArrow";

// node_modules/@ark-ui/react/dist/components/menu/menu-arrow-tip.js
var import_jsx_runtime214 = __toESM(require_jsx_runtime(), 1);
var import_react452 = __toESM(require_react(), 1);
var MenuArrowTip = (0, import_react452.forwardRef)((props43, ref) => {
  const menu = useMenuContext();
  const mergedProps = mergeProps2(menu.getArrowTipProps(), props43);
  return (0, import_jsx_runtime214.jsx)(ark.div, { ...mergedProps, ref });
});
MenuArrowTip.displayName = "MenuArrowTip";

// node_modules/@ark-ui/react/dist/components/menu/menu-checkbox-item.js
var import_jsx_runtime215 = __toESM(require_jsx_runtime(), 1);
var import_react454 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/menu/use-menu-item-context.js
var [MenuItemProvider, useMenuItemContext] = createContext3({
  name: "MenuItemContext",
  hookName: "useMenuItemContext",
  providerName: "<MenuItemProvider />"
});

// node_modules/@ark-ui/react/dist/components/menu/use-menu-option-item-props-context.js
var [MenuItemPropsProvider, useMenuItemPropsContext] = createContext3({
  name: "MenuItemPropsContext",
  hookName: "useMenuItemPropsContext",
  providerName: "<MenuItemPropsProvider />"
});

// node_modules/@ark-ui/react/dist/components/menu/menu-checkbox-item.js
var MenuCheckboxItem = (0, import_react454.forwardRef)((props43, ref) => {
  const [partialOptionItemProps, localProps] = createSplitProps2()(props43, [
    "checked",
    "closeOnSelect",
    "disabled",
    "onCheckedChange",
    "value",
    "valueText"
  ]);
  const optionItemProps2 = {
    ...partialOptionItemProps,
    type: "checkbox"
  };
  const menu = useMenuContext();
  const mergedProps = mergeProps2(menu.getOptionItemProps(optionItemProps2), localProps);
  const optionItemState = menu.getOptionItemState(optionItemProps2);
  return (0, import_jsx_runtime215.jsx)(MenuItemPropsProvider, { value: optionItemProps2, children: (0, import_jsx_runtime215.jsx)(MenuItemProvider, { value: optionItemState, children: (0, import_jsx_runtime215.jsx)(ark.div, { ...mergedProps, ref }) }) });
});
MenuCheckboxItem.displayName = "MenuCheckboxItem";

// node_modules/@ark-ui/react/dist/components/menu/menu-content.js
var import_jsx_runtime216 = __toESM(require_jsx_runtime(), 1);
var import_react456 = __toESM(require_react(), 1);
var MenuContent = (0, import_react456.forwardRef)((props43, ref) => {
  const menu = useMenuContext();
  const presence = usePresenceContext();
  const mergedProps = mergeProps2(menu.getContentProps(), presence.getPresenceProps(), props43);
  if (presence.unmounted) {
    return null;
  }
  return (0, import_jsx_runtime216.jsx)(ark.div, { ...mergedProps, ref: composeRefs(presence.ref, ref) });
});
MenuContent.displayName = "MenuContent";

// node_modules/@ark-ui/react/dist/components/menu/menu-context.js
var MenuContext = (props43) => props43.children(useMenuContext());

// node_modules/@ark-ui/react/dist/components/menu/menu-context-trigger.js
var import_jsx_runtime217 = __toESM(require_jsx_runtime(), 1);
var import_react458 = __toESM(require_react(), 1);
var MenuContextTrigger = (0, import_react458.forwardRef)((props43, ref) => {
  const menu = useMenuContext();
  const mergedProps = mergeProps2(menu.getContextTriggerProps(), props43);
  return (0, import_jsx_runtime217.jsx)(ark.button, { ...mergedProps, ref });
});
MenuContextTrigger.displayName = "MenuContextTrigger";

// node_modules/@ark-ui/react/dist/components/menu/menu-indicator.js
var import_jsx_runtime218 = __toESM(require_jsx_runtime(), 1);
var import_react460 = __toESM(require_react(), 1);
var MenuIndicator = (0, import_react460.forwardRef)((props43, ref) => {
  const menu = useMenuContext();
  const mergedProps = mergeProps2(menu.getIndicatorProps(), props43);
  return (0, import_jsx_runtime218.jsx)(ark.div, { ...mergedProps, ref });
});
MenuIndicator.displayName = "MenuIndicator";

// node_modules/@ark-ui/react/dist/components/menu/menu-item.js
var import_jsx_runtime219 = __toESM(require_jsx_runtime(), 1);
var import_react462 = __toESM(require_react(), 1);
var MenuItem = (0, import_react462.forwardRef)((props43, ref) => {
  const [itemProps14, localProps] = createSplitProps2()(props43, [
    "closeOnSelect",
    "disabled",
    "value",
    "valueText",
    "onSelect"
  ]);
  const menu = useMenuContext();
  const mergedProps = mergeProps2(menu.getItemProps(itemProps14), localProps);
  const itemState = menu.getItemState(itemProps14);
  (0, import_react462.useEffect)(() => {
    return menu.addItemListener({ id: itemState.id, onSelect: itemProps14.onSelect });
  }, [itemState.id, itemProps14.onSelect]);
  return (0, import_jsx_runtime219.jsx)(MenuItemPropsProvider, { value: itemProps14, children: (0, import_jsx_runtime219.jsx)(MenuItemProvider, { value: itemState, children: (0, import_jsx_runtime219.jsx)(ark.div, { ...mergedProps, ref }) }) });
});
MenuItem.displayName = "MenuItem";

// node_modules/@ark-ui/react/dist/components/menu/menu-item-context.js
var MenuItemContext = (props43) => props43.children(useMenuItemContext());

// node_modules/@ark-ui/react/dist/components/menu/menu-item-group.js
var import_jsx_runtime220 = __toESM(require_jsx_runtime(), 1);
var import_react464 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/menu/use-menu-item-group-context.js
var [MenuItemGroupProvider, useMenuItemGroupContext] = createContext3({
  name: "MenuItemGroupContext",
  hookName: "useMenuItemGroupContext",
  providerName: "<MenuItemGroupProvider />"
});

// node_modules/@ark-ui/react/dist/components/menu/menu-item-group.js
var MenuItemGroup = (0, import_react464.forwardRef)((props43, ref) => {
  const [optionalItemGroupProps, localProps] = createSplitProps2()(props43, ["id"]);
  const menu = useMenuContext();
  const id = (0, import_react464.useId)();
  const itemGroupProps5 = { id, ...optionalItemGroupProps };
  const mergedProps = mergeProps2(menu.getItemGroupProps(itemGroupProps5), localProps);
  return (0, import_jsx_runtime220.jsx)(MenuItemGroupProvider, { value: itemGroupProps5, children: (0, import_jsx_runtime220.jsx)(ark.div, { ...mergedProps, ref }) });
});
MenuItemGroup.displayName = "MenuItemGroup";

// node_modules/@ark-ui/react/dist/components/menu/menu-item-group-label.js
var import_jsx_runtime221 = __toESM(require_jsx_runtime(), 1);
var import_react466 = __toESM(require_react(), 1);
var MenuItemGroupLabel = (0, import_react466.forwardRef)((props43, ref) => {
  const menu = useMenuContext();
  const itemGroup = useMenuItemGroupContext();
  const mergedProps = mergeProps2(menu.getItemGroupLabelProps({ htmlFor: itemGroup.id }), props43);
  return (0, import_jsx_runtime221.jsx)(ark.div, { ...mergedProps, ref });
});
MenuItemGroupLabel.displayName = "MenuItemGroupLabel";

// node_modules/@ark-ui/react/dist/components/menu/menu-item-indicator.js
var import_jsx_runtime222 = __toESM(require_jsx_runtime(), 1);
var import_react468 = __toESM(require_react(), 1);
var MenuItemIndicator = (0, import_react468.forwardRef)((props43, ref) => {
  const menu = useMenuContext();
  const itemProps14 = useMenuItemPropsContext();
  const mergedProps = mergeProps2(menu.getItemIndicatorProps(itemProps14), props43);
  return (0, import_jsx_runtime222.jsx)(ark.div, { ...mergedProps, ref });
});
MenuItemIndicator.displayName = "MenuItemIndicator";

// node_modules/@ark-ui/react/dist/components/menu/menu-item-text.js
var import_jsx_runtime223 = __toESM(require_jsx_runtime(), 1);
var import_react470 = __toESM(require_react(), 1);
var MenuItemText = (0, import_react470.forwardRef)((props43, ref) => {
  const menu = useMenuContext();
  const itemProps14 = useMenuItemPropsContext();
  const mergedProps = mergeProps2(menu.getItemTextProps(itemProps14), props43);
  return (0, import_jsx_runtime223.jsx)(ark.div, { ...mergedProps, ref });
});
MenuItemText.displayName = "MenuItemText";

// node_modules/@ark-ui/react/dist/components/menu/menu-positioner.js
var import_jsx_runtime224 = __toESM(require_jsx_runtime(), 1);
var import_react472 = __toESM(require_react(), 1);
var MenuPositioner = (0, import_react472.forwardRef)((props43, ref) => {
  const menu = useMenuContext();
  const mergedProps = mergeProps2(menu.getPositionerProps(), props43);
  const presence = usePresenceContext();
  if (presence.unmounted) {
    return null;
  }
  return (0, import_jsx_runtime224.jsx)(ark.div, { ...mergedProps, ref });
});
MenuPositioner.displayName = "MenuPositioner";

// node_modules/@ark-ui/react/dist/components/menu/menu-radio-item.js
var import_jsx_runtime225 = __toESM(require_jsx_runtime(), 1);
var import_react474 = __toESM(require_react(), 1);
var MenuRadioItem = (0, import_react474.forwardRef)((props43, ref) => {
  const [partialItemProps, localProps] = createSplitProps2()(props43, [
    "closeOnSelect",
    "disabled",
    "value",
    "valueText"
  ]);
  const menu = useMenuContext();
  const itemGroup = useMenuItemGroupContext();
  const optionItemProps2 = {
    ...partialItemProps,
    checked: itemGroup.value === partialItemProps.value,
    type: "radio",
    onCheckedChange: () => {
      var _a8;
      return (_a8 = itemGroup.onValueChange) == null ? void 0 : _a8.call(itemGroup, { value: partialItemProps.value });
    }
  };
  const mergedProps = mergeProps2(menu.getOptionItemProps(optionItemProps2), localProps);
  const optionItemState = menu.getOptionItemState(optionItemProps2);
  return (0, import_jsx_runtime225.jsx)(MenuItemPropsProvider, { value: optionItemProps2, children: (0, import_jsx_runtime225.jsx)(MenuItemProvider, { value: optionItemState, children: (0, import_jsx_runtime225.jsx)(ark.div, { ...mergedProps, ref }) }) });
});
MenuRadioItem.displayName = "MenuRadioItem";

// node_modules/@ark-ui/react/dist/components/menu/menu-radio-item-group.js
var import_jsx_runtime226 = __toESM(require_jsx_runtime(), 1);
var import_react476 = __toESM(require_react(), 1);
var MenuRadioItemGroup = (0, import_react476.forwardRef)((props43, ref) => {
  const [optionalItemGroupProps, localProps] = createSplitProps2()(props43, [
    "id",
    "onValueChange",
    "value"
  ]);
  const menu = useMenuContext();
  const id = (0, import_react476.useId)();
  const itemGroupProps5 = { id, ...optionalItemGroupProps };
  const mergedProps = mergeProps2(menu.getItemGroupProps({ id: itemGroupProps5.id }), localProps);
  return (0, import_jsx_runtime226.jsx)(MenuItemGroupProvider, { value: itemGroupProps5, children: (0, import_jsx_runtime226.jsx)(ark.div, { ...mergedProps, ref }) });
});
MenuRadioItemGroup.displayName = "MenuRadioItemGroup";

// node_modules/@ark-ui/react/dist/components/menu/menu-root.js
var import_jsx_runtime227 = __toESM(require_jsx_runtime(), 1);
var import_react481 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/utils/use-effect-once.js
var import_react477 = __toESM(require_react(), 1);
var useEffectOnce = (cb) => {
  const savedCallback = (0, import_react477.useRef)(cb);
  const effectGuard = (0, import_react477.useRef)(false);
  (0, import_react477.useEffect)(() => {
    savedCallback.current = cb;
  });
  (0, import_react477.useEffect)(() => {
    if (effectGuard.current !== true) {
      effectGuard.current = true;
      savedCallback.current();
    }
  }, []);
};

// node_modules/@zag-js/menu/dist/index.mjs
var anatomy17 = createAnatomy("menu").parts(
  "arrow",
  "arrowTip",
  "content",
  "contextTrigger",
  "indicator",
  "item",
  "itemGroup",
  "itemGroupLabel",
  "itemIndicator",
  "itemText",
  "positioner",
  "separator",
  "trigger",
  "triggerItem"
);
var parts19 = anatomy17.build();
var getTriggerId9 = (ctx) => {
  var _a8;
  return ((_a8 = ctx.ids) == null ? void 0 : _a8.trigger) ?? `menu:${ctx.id}:trigger`;
};
var getContextTriggerId = (ctx) => {
  var _a8;
  return ((_a8 = ctx.ids) == null ? void 0 : _a8.contextTrigger) ?? `menu:${ctx.id}:ctx-trigger`;
};
var getContentId9 = (ctx) => {
  var _a8;
  return ((_a8 = ctx.ids) == null ? void 0 : _a8.content) ?? `menu:${ctx.id}:content`;
};
var getArrowId2 = (ctx) => {
  var _a8;
  return ((_a8 = ctx.ids) == null ? void 0 : _a8.arrow) ?? `menu:${ctx.id}:arrow`;
};
var getPositionerId7 = (ctx) => {
  var _a8;
  return ((_a8 = ctx.ids) == null ? void 0 : _a8.positioner) ?? `menu:${ctx.id}:popper`;
};
var getGroupId = (ctx, id) => {
  var _a8, _b7;
  return ((_b7 = (_a8 = ctx.ids) == null ? void 0 : _a8.group) == null ? void 0 : _b7.call(_a8, id)) ?? `menu:${ctx.id}:group:${id}`;
};
var getItemId6 = (ctx, id) => `${ctx.id}/${id}`;
var getItemValue = (el) => (el == null ? void 0 : el.dataset.value) ?? null;
var getGroupLabelId = (ctx, id) => {
  var _a8, _b7;
  return ((_b7 = (_a8 = ctx.ids) == null ? void 0 : _a8.groupLabel) == null ? void 0 : _b7.call(_a8, id)) ?? `menu:${ctx.id}:group-label:${id}`;
};
var getContentEl9 = (ctx) => ctx.getById(getContentId9(ctx));
var getPositionerEl7 = (ctx) => ctx.getById(getPositionerId7(ctx));
var getTriggerEl7 = (ctx) => ctx.getById(getTriggerId9(ctx));
var getItemEl3 = (ctx, value) => value ? ctx.getById(getItemId6(ctx, value)) : null;
var getContextTriggerEl = (ctx) => ctx.getById(getContextTriggerId(ctx));
var getElements = (ctx) => {
  const ownerId = CSS.escape(getContentId9(ctx));
  const selector = `[role^="menuitem"][data-ownedby=${ownerId}]:not([data-disabled])`;
  return queryAll(getContentEl9(ctx), selector);
};
var getFirstEl = (ctx) => first(getElements(ctx));
var getLastEl = (ctx) => last(getElements(ctx));
var isMatch = (el, value) => {
  if (!value) return false;
  return el.id === value || el.dataset.value === value;
};
var getNextEl = (ctx, opts) => {
  const items = getElements(ctx);
  const index = items.findIndex((el) => isMatch(el, opts.value));
  return next(items, index, { loop: opts.loop ?? opts.loopFocus });
};
var getPrevEl = (ctx, opts) => {
  const items = getElements(ctx);
  const index = items.findIndex((el) => isMatch(el, opts.value));
  return prev(items, index, { loop: opts.loop ?? opts.loopFocus });
};
var getElemByKey = (ctx, opts) => {
  const items = getElements(ctx);
  const item = items.find((el) => isMatch(el, opts.value));
  return getByTypeahead(items, { state: opts.typeaheadState, key: opts.key, activeId: (item == null ? void 0 : item.id) ?? null });
};
var isTargetDisabled = (v) => {
  return isHTMLElement(v) && (v.dataset.disabled === "" || v.hasAttribute("disabled"));
};
var isTriggerItem = (el) => {
  var _a8;
  return !!((_a8 = el == null ? void 0 : el.getAttribute("role")) == null ? void 0 : _a8.startsWith("menuitem")) && !!(el == null ? void 0 : el.hasAttribute("aria-controls"));
};
var itemSelectEvent = "menu:select";
function dispatchSelectionEvent(el, value) {
  if (!el) return;
  const win = getWindow(el);
  const event = new win.CustomEvent(itemSelectEvent, { detail: { value } });
  el.dispatchEvent(event);
}
function connect18(service, normalize4) {
  const { context, send, state: state2, computed, prop, scope } = service;
  const open = state2.hasTag("open");
  const isSubmenu = computed("isSubmenu");
  const isTypingAhead = computed("isTypingAhead");
  const composite = prop("composite");
  const currentPlacement = context.get("currentPlacement");
  const anchorPoint = context.get("anchorPoint");
  const highlightedValue = context.get("highlightedValue");
  const popperStyles = getPlacementStyles({
    ...prop("positioning"),
    placement: anchorPoint ? "bottom" : currentPlacement
  });
  function getItemState(props210) {
    return {
      id: getItemId6(scope, props210.value),
      disabled: !!props210.disabled,
      highlighted: highlightedValue === props210.value
    };
  }
  function getOptionItemProps(props210) {
    const valueText = props210.valueText ?? props210.value;
    return { ...props210, id: props210.value, valueText };
  }
  function getOptionItemState(props210) {
    const itemState = getItemState(getOptionItemProps(props210));
    return {
      ...itemState,
      checked: !!props210.checked
    };
  }
  function getItemProps(props210) {
    const { closeOnSelect, valueText, value } = props210;
    const itemState = getItemState(props210);
    const id = getItemId6(scope, value);
    return normalize4.element({
      ...parts19.item.attrs,
      id,
      role: "menuitem",
      "aria-disabled": ariaAttr(itemState.disabled),
      "data-disabled": dataAttr(itemState.disabled),
      "data-ownedby": getContentId9(scope),
      "data-highlighted": dataAttr(itemState.highlighted),
      "data-value": value,
      "data-valuetext": valueText,
      onDragStart(event) {
        const isLink = event.currentTarget.matches("a[href]");
        if (isLink) event.preventDefault();
      },
      onPointerMove(event) {
        if (itemState.disabled) return;
        if (event.pointerType !== "mouse") return;
        const target = event.currentTarget;
        if (itemState.highlighted) return;
        send({ type: "ITEM_POINTERMOVE", id, target, closeOnSelect });
      },
      onPointerLeave(event) {
        var _a8;
        if (itemState.disabled) return;
        if (event.pointerType !== "mouse") return;
        const pointerMoved = (_a8 = service.event.previous()) == null ? void 0 : _a8.type.includes("POINTER");
        if (!pointerMoved) return;
        const target = event.currentTarget;
        send({ type: "ITEM_POINTERLEAVE", id, target, closeOnSelect });
      },
      onPointerDown(event) {
        if (itemState.disabled) return;
        const target = event.currentTarget;
        send({ type: "ITEM_POINTERDOWN", target, id, closeOnSelect });
      },
      onClick(event) {
        if (isDownloadingEvent(event)) return;
        if (isOpeningInNewTab(event)) return;
        if (itemState.disabled) return;
        const target = event.currentTarget;
        send({ type: "ITEM_CLICK", target, id, closeOnSelect });
      }
    });
  }
  return {
    highlightedValue,
    open,
    setOpen(nextOpen) {
      const open2 = state2.hasTag("open");
      if (open2 === nextOpen) return;
      send({ type: nextOpen ? "OPEN" : "CLOSE" });
    },
    setHighlightedValue(value) {
      send({ type: "HIGHLIGHTED.SET", value });
    },
    setParent(parent) {
      send({ type: "PARENT.SET", value: parent, id: parent.prop("id") });
    },
    setChild(child) {
      send({ type: "CHILD.SET", value: child, id: child.prop("id") });
    },
    reposition(options = {}) {
      send({ type: "POSITIONING.SET", options });
    },
    addItemListener(props210) {
      const node = scope.getById(props210.id);
      if (!node) return;
      const listener = () => {
        var _a8;
        return (_a8 = props210.onSelect) == null ? void 0 : _a8.call(props210);
      };
      node.addEventListener(itemSelectEvent, listener);
      return () => node.removeEventListener(itemSelectEvent, listener);
    },
    getContextTriggerProps() {
      return normalize4.element({
        ...parts19.contextTrigger.attrs,
        dir: prop("dir"),
        id: getContextTriggerId(scope),
        onPointerDown(event) {
          if (event.pointerType === "mouse") return;
          const point = getEventPoint(event);
          send({ type: "CONTEXT_MENU_START", point });
        },
        onPointerCancel(event) {
          if (event.pointerType === "mouse") return;
          send({ type: "CONTEXT_MENU_CANCEL" });
        },
        onPointerMove(event) {
          if (event.pointerType === "mouse") return;
          send({ type: "CONTEXT_MENU_CANCEL" });
        },
        onPointerUp(event) {
          if (event.pointerType === "mouse") return;
          send({ type: "CONTEXT_MENU_CANCEL" });
        },
        onContextMenu(event) {
          const point = getEventPoint(event);
          send({ type: "CONTEXT_MENU", point });
          event.preventDefault();
        },
        style: {
          WebkitTouchCallout: "none",
          WebkitUserSelect: "none",
          userSelect: "none"
        }
      });
    },
    getTriggerItemProps(childApi) {
      const triggerProps2 = childApi.getTriggerProps();
      return mergeProps2(getItemProps({ value: triggerProps2.id }), triggerProps2);
    },
    getTriggerProps() {
      return normalize4.button({
        ...isSubmenu ? parts19.triggerItem.attrs : parts19.trigger.attrs,
        "data-placement": context.get("currentPlacement"),
        type: "button",
        dir: prop("dir"),
        id: getTriggerId9(scope),
        "data-uid": prop("id"),
        "aria-haspopup": composite ? "menu" : "dialog",
        "aria-controls": getContentId9(scope),
        "aria-expanded": open || void 0,
        "data-state": open ? "open" : "closed",
        onPointerMove(event) {
          if (event.pointerType !== "mouse") return;
          const disabled = isTargetDisabled(event.currentTarget);
          if (disabled || !isSubmenu) return;
          const point = getEventPoint(event);
          send({ type: "TRIGGER_POINTERMOVE", target: event.currentTarget, point });
        },
        onPointerLeave(event) {
          if (isTargetDisabled(event.currentTarget)) return;
          if (event.pointerType !== "mouse") return;
          if (!isSubmenu) return;
          const point = getEventPoint(event);
          send({
            type: "TRIGGER_POINTERLEAVE",
            target: event.currentTarget,
            point
          });
        },
        onPointerDown(event) {
          if (isTargetDisabled(event.currentTarget)) return;
          if (isContextMenuEvent(event)) return;
          event.preventDefault();
        },
        onClick(event) {
          if (event.defaultPrevented) return;
          if (isTargetDisabled(event.currentTarget)) return;
          send({ type: "TRIGGER_CLICK", target: event.currentTarget });
        },
        onBlur() {
          send({ type: "TRIGGER_BLUR" });
        },
        onFocus() {
          send({ type: "TRIGGER_FOCUS" });
        },
        onKeyDown(event) {
          if (event.defaultPrevented) return;
          const keyMap2 = {
            ArrowDown() {
              send({ type: "ARROW_DOWN" });
            },
            ArrowUp() {
              send({ type: "ARROW_UP" });
            },
            Enter() {
              send({ type: "ARROW_DOWN", src: "enter" });
            },
            Space() {
              send({ type: "ARROW_DOWN", src: "space" });
            }
          };
          const key = getEventKey(event, {
            orientation: "vertical",
            dir: prop("dir")
          });
          const exec = keyMap2[key];
          if (exec) {
            event.preventDefault();
            exec(event);
          }
        }
      });
    },
    getIndicatorProps() {
      return normalize4.element({
        ...parts19.indicator.attrs,
        dir: prop("dir"),
        "data-state": open ? "open" : "closed"
      });
    },
    getPositionerProps() {
      return normalize4.element({
        ...parts19.positioner.attrs,
        dir: prop("dir"),
        id: getPositionerId7(scope),
        style: popperStyles.floating
      });
    },
    getArrowProps() {
      return normalize4.element({
        id: getArrowId2(scope),
        ...parts19.arrow.attrs,
        dir: prop("dir"),
        style: popperStyles.arrow
      });
    },
    getArrowTipProps() {
      return normalize4.element({
        ...parts19.arrowTip.attrs,
        dir: prop("dir"),
        style: popperStyles.arrowTip
      });
    },
    getContentProps() {
      return normalize4.element({
        ...parts19.content.attrs,
        id: getContentId9(scope),
        "aria-label": prop("aria-label"),
        hidden: !open,
        "data-state": open ? "open" : "closed",
        role: composite ? "menu" : "dialog",
        tabIndex: 0,
        dir: prop("dir"),
        "aria-activedescendant": computed("highlightedId") || void 0,
        "aria-labelledby": getTriggerId9(scope),
        "data-placement": currentPlacement,
        onPointerEnter(event) {
          if (event.pointerType !== "mouse") return;
          send({ type: "MENU_POINTERENTER" });
        },
        onKeyDown(event) {
          if (event.defaultPrevented) return;
          if (!isSelfTarget(event)) return;
          const target = getEventTarget(event);
          const sameMenu = (target == null ? void 0 : target.closest("[role=menu]")) === event.currentTarget || target === event.currentTarget;
          if (!sameMenu) return;
          if (event.key === "Tab") {
            const valid = isValidTabEvent(event);
            if (!valid) {
              event.preventDefault();
              return;
            }
          }
          const item = getItemEl3(scope, highlightedValue);
          const keyMap2 = {
            ArrowDown() {
              send({ type: "ARROW_DOWN" });
            },
            ArrowUp() {
              send({ type: "ARROW_UP" });
            },
            ArrowLeft() {
              send({ type: "ARROW_LEFT" });
            },
            ArrowRight() {
              send({ type: "ARROW_RIGHT" });
            },
            Enter() {
              var _a8;
              send({ type: "ENTER" });
              if (highlightedValue == null) return;
              if (isAnchorElement(item)) {
                (_a8 = prop("navigate")) == null ? void 0 : _a8({ value: highlightedValue, node: item, href: item.href });
              }
            },
            Space(event2) {
              var _a8;
              if (isTypingAhead) {
                send({ type: "TYPEAHEAD", key: event2.key });
              } else {
                (_a8 = keyMap2.Enter) == null ? void 0 : _a8.call(keyMap2, event2);
              }
            },
            Home() {
              send({ type: "HOME" });
            },
            End() {
              send({ type: "END" });
            }
          };
          const key = getEventKey(event, { dir: prop("dir") });
          const exec = keyMap2[key];
          if (exec) {
            exec(event);
            event.stopPropagation();
            event.preventDefault();
            return;
          }
          if (!prop("typeahead")) return;
          if (!isPrintableKey(event)) return;
          if (isModifierKey(event)) return;
          if (isEditableElement(target)) return;
          send({ type: "TYPEAHEAD", key: event.key });
          event.preventDefault();
        }
      });
    },
    getSeparatorProps() {
      return normalize4.element({
        ...parts19.separator.attrs,
        role: "separator",
        dir: prop("dir"),
        "aria-orientation": "horizontal"
      });
    },
    getItemState,
    getItemProps,
    getOptionItemState,
    getOptionItemProps(props210) {
      const { type, disabled, onCheckedChange, closeOnSelect } = props210;
      const option = getOptionItemProps(props210);
      const itemState = getOptionItemState(props210);
      return {
        ...getItemProps(option),
        ...normalize4.element({
          "data-type": type,
          ...parts19.item.attrs,
          dir: prop("dir"),
          "data-value": option.value,
          role: `menuitem${type}`,
          "aria-checked": !!itemState.checked,
          "data-state": itemState.checked ? "checked" : "unchecked",
          onClick(event) {
            if (disabled) return;
            if (isDownloadingEvent(event)) return;
            if (isOpeningInNewTab(event)) return;
            const target = event.currentTarget;
            send({ type: "ITEM_CLICK", target, option, closeOnSelect });
            onCheckedChange == null ? void 0 : onCheckedChange(!itemState.checked);
          }
        })
      };
    },
    getItemIndicatorProps(props210) {
      const itemState = getOptionItemState(cast(props210));
      const dataState = itemState.checked ? "checked" : "unchecked";
      return normalize4.element({
        ...parts19.itemIndicator.attrs,
        dir: prop("dir"),
        "data-disabled": dataAttr(itemState.disabled),
        "data-highlighted": dataAttr(itemState.highlighted),
        "data-state": hasProp2(props210, "checked") ? dataState : void 0,
        hidden: hasProp2(props210, "checked") ? !itemState.checked : void 0
      });
    },
    getItemTextProps(props210) {
      const itemState = getOptionItemState(cast(props210));
      const dataState = itemState.checked ? "checked" : "unchecked";
      return normalize4.element({
        ...parts19.itemText.attrs,
        dir: prop("dir"),
        "data-disabled": dataAttr(itemState.disabled),
        "data-highlighted": dataAttr(itemState.highlighted),
        "data-state": hasProp2(props210, "checked") ? dataState : void 0
      });
    },
    getItemGroupLabelProps(props210) {
      return normalize4.element({
        ...parts19.itemGroupLabel.attrs,
        id: getGroupLabelId(scope, props210.htmlFor),
        dir: prop("dir")
      });
    },
    getItemGroupProps(props210) {
      return normalize4.element({
        id: getGroupId(scope, props210.id),
        ...parts19.itemGroup.attrs,
        dir: prop("dir"),
        "aria-labelledby": getGroupLabelId(scope, props210.id),
        role: "group"
      });
    }
  };
}
var { not: not6, and: and7, or } = createGuards();
var machine18 = createMachine({
  props({ props: props210 }) {
    return {
      closeOnSelect: true,
      typeahead: true,
      composite: true,
      loopFocus: false,
      navigate(details) {
        clickIfLink(details.node);
      },
      ...props210,
      positioning: {
        placement: "bottom-start",
        gutter: 8,
        ...props210.positioning
      }
    };
  },
  initialState({ prop }) {
    const open = prop("open") || prop("defaultOpen");
    return open ? "open" : "idle";
  },
  context({ bindable, prop }) {
    return {
      suspendPointer: bindable(() => ({
        defaultValue: false
      })),
      highlightedValue: bindable(() => ({
        defaultValue: prop("defaultHighlightedValue") || null,
        value: prop("highlightedValue"),
        onChange(value) {
          var _a8;
          (_a8 = prop("onHighlightChange")) == null ? void 0 : _a8({ highlightedValue: value });
        }
      })),
      lastHighlightedValue: bindable(() => ({
        defaultValue: null
      })),
      currentPlacement: bindable(() => ({
        defaultValue: void 0
      })),
      intentPolygon: bindable(() => ({
        defaultValue: null
      })),
      anchorPoint: bindable(() => ({
        defaultValue: null,
        hash(value) {
          return `x: ${value == null ? void 0 : value.x}, y: ${value == null ? void 0 : value.y}`;
        }
      }))
    };
  },
  refs() {
    return {
      parent: null,
      children: {},
      typeaheadState: { ...getByTypeahead.defaultOptions },
      positioningOverride: {}
    };
  },
  computed: {
    isSubmenu: ({ refs }) => refs.get("parent") != null,
    isRtl: ({ prop }) => prop("dir") === "rtl",
    isTypingAhead: ({ refs }) => refs.get("typeaheadState").keysSoFar !== "",
    highlightedId: ({ context, scope, refs }) => resolveItemId(refs.get("children"), context.get("highlightedValue"), scope)
  },
  watch({ track, action, context, computed, prop }) {
    track([() => computed("isSubmenu")], () => {
      action(["setSubmenuPlacement"]);
    });
    track([() => context.hash("anchorPoint")], () => {
      action(["reposition"]);
    });
    track([() => prop("open")], () => {
      action(["toggleVisibility"]);
    });
  },
  on: {
    "PARENT.SET": {
      actions: ["setParentMenu"]
    },
    "CHILD.SET": {
      actions: ["setChildMenu"]
    },
    OPEN: [
      {
        guard: "isOpenControlled",
        actions: ["invokeOnOpen"]
      },
      {
        target: "open",
        actions: ["invokeOnOpen"]
      }
    ],
    OPEN_AUTOFOCUS: [
      {
        guard: "isOpenControlled",
        actions: ["invokeOnOpen"]
      },
      {
        // internal: true,
        target: "open",
        actions: ["highlightFirstItem", "invokeOnOpen"]
      }
    ],
    CLOSE: [
      {
        guard: "isOpenControlled",
        actions: ["invokeOnClose"]
      },
      {
        target: "closed",
        actions: ["invokeOnClose"]
      }
    ],
    "HIGHLIGHTED.RESTORE": {
      actions: ["restoreHighlightedItem"]
    },
    "HIGHLIGHTED.SET": {
      actions: ["setHighlightedItem"]
    }
  },
  states: {
    idle: {
      tags: ["closed"],
      on: {
        "CONTROLLED.OPEN": {
          target: "open"
        },
        "CONTROLLED.CLOSE": {
          target: "closed"
        },
        CONTEXT_MENU_START: {
          target: "opening:contextmenu",
          actions: ["setAnchorPoint"]
        },
        CONTEXT_MENU: [
          {
            guard: "isOpenControlled",
            actions: ["setAnchorPoint", "invokeOnOpen"]
          },
          {
            target: "open",
            actions: ["setAnchorPoint", "invokeOnOpen"]
          }
        ],
        TRIGGER_CLICK: [
          {
            guard: "isOpenControlled",
            actions: ["invokeOnOpen"]
          },
          {
            target: "open",
            actions: ["invokeOnOpen"]
          }
        ],
        TRIGGER_FOCUS: {
          guard: not6("isSubmenu"),
          target: "closed"
        },
        TRIGGER_POINTERMOVE: {
          guard: "isSubmenu",
          target: "opening"
        }
      }
    },
    "opening:contextmenu": {
      tags: ["closed"],
      effects: ["waitForLongPress"],
      on: {
        "CONTROLLED.OPEN": { target: "open" },
        "CONTROLLED.CLOSE": { target: "closed" },
        CONTEXT_MENU_CANCEL: [
          {
            guard: "isOpenControlled",
            actions: ["invokeOnClose"]
          },
          {
            target: "closed",
            actions: ["invokeOnClose"]
          }
        ],
        "LONG_PRESS.OPEN": [
          {
            guard: "isOpenControlled",
            actions: ["invokeOnOpen"]
          },
          {
            target: "open",
            actions: ["invokeOnOpen"]
          }
        ]
      }
    },
    opening: {
      tags: ["closed"],
      effects: ["waitForOpenDelay"],
      on: {
        "CONTROLLED.OPEN": {
          target: "open"
        },
        "CONTROLLED.CLOSE": {
          target: "closed"
        },
        BLUR: [
          {
            guard: "isOpenControlled",
            actions: ["invokeOnClose"]
          },
          {
            target: "closed",
            actions: ["invokeOnClose"]
          }
        ],
        TRIGGER_POINTERLEAVE: [
          {
            guard: "isOpenControlled",
            actions: ["invokeOnClose"]
          },
          {
            target: "closed",
            actions: ["invokeOnClose"]
          }
        ],
        "DELAY.OPEN": [
          {
            guard: "isOpenControlled",
            actions: ["invokeOnOpen"]
          },
          {
            target: "open",
            actions: ["invokeOnOpen"]
          }
        ]
      }
    },
    closing: {
      tags: ["open"],
      effects: ["trackPointerMove", "trackInteractOutside", "waitForCloseDelay"],
      on: {
        "CONTROLLED.OPEN": {
          target: "open"
        },
        "CONTROLLED.CLOSE": {
          target: "closed",
          actions: ["focusParentMenu", "restoreParentHighlightedItem"]
        },
        // don't invoke on open here since the menu is still open (we're only keeping it open)
        MENU_POINTERENTER: {
          target: "open",
          actions: ["clearIntentPolygon"]
        },
        POINTER_MOVED_AWAY_FROM_SUBMENU: [
          {
            guard: "isOpenControlled",
            actions: ["invokeOnClose"]
          },
          {
            target: "closed",
            actions: ["focusParentMenu", "restoreParentHighlightedItem"]
          }
        ],
        "DELAY.CLOSE": [
          {
            guard: "isOpenControlled",
            actions: ["invokeOnClose"]
          },
          {
            target: "closed",
            actions: ["focusParentMenu", "restoreParentHighlightedItem", "invokeOnClose"]
          }
        ]
      }
    },
    closed: {
      tags: ["closed"],
      entry: ["clearHighlightedItem", "focusTrigger", "resumePointer"],
      on: {
        "CONTROLLED.OPEN": [
          {
            guard: or("isOpenAutoFocusEvent", "isArrowDownEvent"),
            target: "open",
            actions: ["highlightFirstItem"]
          },
          {
            guard: "isArrowUpEvent",
            target: "open",
            actions: ["highlightLastItem"]
          },
          {
            target: "open"
          }
        ],
        CONTEXT_MENU_START: {
          target: "opening:contextmenu",
          actions: ["setAnchorPoint"]
        },
        CONTEXT_MENU: [
          {
            guard: "isOpenControlled",
            actions: ["setAnchorPoint", "invokeOnOpen"]
          },
          {
            target: "open",
            actions: ["setAnchorPoint", "invokeOnOpen"]
          }
        ],
        TRIGGER_CLICK: [
          {
            guard: "isOpenControlled",
            actions: ["invokeOnOpen"]
          },
          {
            target: "open",
            actions: ["invokeOnOpen"]
          }
        ],
        TRIGGER_POINTERMOVE: {
          guard: "isTriggerItem",
          target: "opening"
        },
        TRIGGER_BLUR: { target: "idle" },
        ARROW_DOWN: [
          {
            guard: "isOpenControlled",
            actions: ["invokeOnOpen"]
          },
          {
            target: "open",
            actions: ["highlightFirstItem", "invokeOnOpen"]
          }
        ],
        ARROW_UP: [
          {
            guard: "isOpenControlled",
            actions: ["invokeOnOpen"]
          },
          {
            target: "open",
            actions: ["highlightLastItem", "invokeOnOpen"]
          }
        ]
      }
    },
    open: {
      tags: ["open"],
      effects: ["trackInteractOutside", "trackPositioning", "scrollToHighlightedItem"],
      entry: ["focusMenu", "resumePointer"],
      on: {
        "CONTROLLED.CLOSE": [
          {
            target: "closed",
            guard: "isArrowLeftEvent",
            actions: ["focusParentMenu"]
          },
          {
            target: "closed"
          }
        ],
        TRIGGER_CLICK: [
          {
            guard: and7(not6("isTriggerItem"), "isOpenControlled"),
            actions: ["invokeOnClose"]
          },
          {
            guard: not6("isTriggerItem"),
            target: "closed",
            actions: ["invokeOnClose"]
          }
        ],
        CONTEXT_MENU: {
          actions: ["setAnchorPoint", "focusMenu"]
        },
        ARROW_UP: {
          actions: ["highlightPrevItem", "focusMenu"]
        },
        ARROW_DOWN: {
          actions: ["highlightNextItem", "focusMenu"]
        },
        ARROW_LEFT: [
          {
            guard: and7("isSubmenu", "isOpenControlled"),
            actions: ["invokeOnClose"]
          },
          {
            guard: "isSubmenu",
            target: "closed",
            actions: ["focusParentMenu", "invokeOnClose"]
          }
        ],
        HOME: {
          actions: ["highlightFirstItem", "focusMenu"]
        },
        END: {
          actions: ["highlightLastItem", "focusMenu"]
        },
        ARROW_RIGHT: {
          guard: "isTriggerItemHighlighted",
          actions: ["openSubmenu"]
        },
        ENTER: [
          {
            guard: "isTriggerItemHighlighted",
            actions: ["openSubmenu"]
          },
          {
            actions: ["clickHighlightedItem"]
          }
        ],
        ITEM_POINTERMOVE: [
          {
            guard: not6("isPointerSuspended"),
            actions: ["setHighlightedItem", "focusMenu"]
          },
          {
            actions: ["setLastHighlightedItem"]
          }
        ],
        ITEM_POINTERLEAVE: {
          guard: and7(not6("isPointerSuspended"), not6("isTriggerItem")),
          actions: ["clearHighlightedItem"]
        },
        ITEM_CLICK: [
          // == grouped ==
          {
            guard: and7(
              not6("isTriggerItemHighlighted"),
              not6("isHighlightedItemEditable"),
              "closeOnSelect",
              "isOpenControlled"
            ),
            actions: ["invokeOnSelect", "setOptionState", "closeRootMenu", "invokeOnClose"]
          },
          {
            guard: and7(not6("isTriggerItemHighlighted"), not6("isHighlightedItemEditable"), "closeOnSelect"),
            target: "closed",
            actions: ["invokeOnSelect", "setOptionState", "closeRootMenu", "invokeOnClose"]
          },
          //
          {
            guard: and7(not6("isTriggerItemHighlighted"), not6("isHighlightedItemEditable")),
            actions: ["invokeOnSelect", "setOptionState"]
          },
          { actions: ["setHighlightedItem"] }
        ],
        TRIGGER_POINTERMOVE: {
          guard: "isTriggerItem",
          actions: ["setIntentPolygon"]
        },
        TRIGGER_POINTERLEAVE: {
          target: "closing"
        },
        ITEM_POINTERDOWN: {
          actions: ["setHighlightedItem"]
        },
        TYPEAHEAD: {
          actions: ["highlightMatchedItem"]
        },
        FOCUS_MENU: {
          actions: ["focusMenu"]
        },
        "POSITIONING.SET": {
          actions: ["reposition"]
        }
      }
    }
  },
  implementations: {
    guards: {
      closeOnSelect: ({ prop, event }) => !!((event == null ? void 0 : event.closeOnSelect) ?? prop("closeOnSelect")),
      // whether the trigger is also a menu item
      isTriggerItem: ({ event }) => isTriggerItem(event.target),
      // whether the trigger item is the active item
      isTriggerItemHighlighted: ({ event, scope, computed }) => {
        const target = event.target ?? scope.getById(computed("highlightedId"));
        return !!(target == null ? void 0 : target.hasAttribute("aria-controls"));
      },
      isSubmenu: ({ computed }) => computed("isSubmenu"),
      isPointerSuspended: ({ context }) => context.get("suspendPointer"),
      isHighlightedItemEditable: ({ scope, computed }) => isEditableElement(scope.getById(computed("highlightedId"))),
      // guard assertions (for controlled mode)
      isOpenControlled: ({ prop }) => prop("open") !== void 0,
      isArrowLeftEvent: ({ event }) => {
        var _a8;
        return ((_a8 = event.previousEvent) == null ? void 0 : _a8.type) === "ARROW_LEFT";
      },
      isArrowUpEvent: ({ event }) => {
        var _a8;
        return ((_a8 = event.previousEvent) == null ? void 0 : _a8.type) === "ARROW_UP";
      },
      isArrowDownEvent: ({ event }) => {
        var _a8;
        return ((_a8 = event.previousEvent) == null ? void 0 : _a8.type) === "ARROW_DOWN";
      },
      isOpenAutoFocusEvent: ({ event }) => {
        var _a8;
        return ((_a8 = event.previousEvent) == null ? void 0 : _a8.type) === "OPEN_AUTOFOCUS";
      }
    },
    effects: {
      waitForOpenDelay({ send }) {
        const timer = setTimeout(() => {
          send({ type: "DELAY.OPEN" });
        }, 100);
        return () => clearTimeout(timer);
      },
      waitForCloseDelay({ send }) {
        const timer = setTimeout(() => {
          send({ type: "DELAY.CLOSE" });
        }, 300);
        return () => clearTimeout(timer);
      },
      waitForLongPress({ send }) {
        const timer = setTimeout(() => {
          send({ type: "LONG_PRESS.OPEN" });
        }, 700);
        return () => clearTimeout(timer);
      },
      trackPositioning({ context, prop, scope, refs }) {
        if (!!getContextTriggerEl(scope)) return;
        const positioning = {
          ...prop("positioning"),
          ...refs.get("positioningOverride")
        };
        context.set("currentPlacement", positioning.placement);
        const getPositionerEl22 = () => getPositionerEl7(scope);
        return getPlacement(getTriggerEl7(scope), getPositionerEl22, {
          ...positioning,
          defer: true,
          onComplete(data) {
            context.set("currentPlacement", data.placement);
          }
        });
      },
      trackInteractOutside({ refs, scope, prop, computed, send }) {
        const getContentEl22 = () => getContentEl9(scope);
        let restoreFocus = true;
        return trackDismissableElement(getContentEl22, {
          defer: true,
          exclude: [getTriggerEl7(scope)],
          onInteractOutside: prop("onInteractOutside"),
          onFocusOutside: prop("onFocusOutside"),
          onEscapeKeyDown(event) {
            var _a8;
            (_a8 = prop("onEscapeKeyDown")) == null ? void 0 : _a8(event);
            if (computed("isSubmenu")) event.preventDefault();
            closeRootMenu({ parent: refs.get("parent") });
          },
          onPointerDownOutside(event) {
            var _a8;
            const target = getEventTarget(event.detail.originalEvent);
            const isWithinContextTrigger = contains(getContextTriggerEl(scope), target);
            if (isWithinContextTrigger && event.detail.contextmenu) {
              event.preventDefault();
              return;
            }
            restoreFocus = !event.detail.focusable;
            (_a8 = prop("onPointerDownOutside")) == null ? void 0 : _a8(event);
          },
          onDismiss() {
            send({ type: "CLOSE", src: "interact-outside", restoreFocus });
          }
        });
      },
      trackPointerMove({ context, scope, send, refs, flush: flush2 }) {
        const parent = refs.get("parent");
        flush2(() => {
          parent.context.set("suspendPointer", true);
        });
        const doc = scope.getDoc();
        return addDomEvent(doc, "pointermove", (e) => {
          const isMovingToSubmenu = isWithinPolygon(context.get("intentPolygon"), {
            x: e.clientX,
            y: e.clientY
          });
          if (!isMovingToSubmenu) {
            send({ type: "POINTER_MOVED_AWAY_FROM_SUBMENU" });
            parent.context.set("suspendPointer", false);
          }
        });
      },
      scrollToHighlightedItem({ event, scope, computed }) {
        const exec = () => {
          if (event.type.startsWith("ITEM_POINTER")) return;
          const itemEl = scope.getById(computed("highlightedId"));
          const contentEl2 = getContentEl9(scope);
          scrollIntoView(itemEl, { rootEl: contentEl2, block: "nearest" });
        };
        raf(() => exec());
        const contentEl = () => getContentEl9(scope);
        return observeAttributes(contentEl, {
          defer: true,
          attributes: ["aria-activedescendant"],
          callback: exec
        });
      }
    },
    actions: {
      setAnchorPoint({ context, event }) {
        context.set("anchorPoint", event.point);
      },
      setSubmenuPlacement({ computed, refs }) {
        if (!computed("isSubmenu")) return;
        const placement = computed("isRtl") ? "left-start" : "right-start";
        refs.set("positioningOverride", { placement, gutter: 0 });
      },
      reposition({ context, scope, prop, event, refs }) {
        const getPositionerEl22 = () => getPositionerEl7(scope);
        const anchorPoint = context.get("anchorPoint");
        const getAnchorRect = anchorPoint ? () => ({ width: 0, height: 0, ...anchorPoint }) : void 0;
        const positioning = {
          ...prop("positioning"),
          ...refs.get("positioningOverride")
        };
        getPlacement(getTriggerEl7(scope), getPositionerEl22, {
          ...positioning,
          defer: true,
          getAnchorRect,
          ...event.options ?? {},
          listeners: false,
          onComplete(data) {
            context.set("currentPlacement", data.placement);
          }
        });
      },
      setOptionState({ event }) {
        if (!event.option) return;
        const { checked, onCheckedChange, type } = event.option;
        if (type === "radio") {
          onCheckedChange == null ? void 0 : onCheckedChange(true);
        } else if (type === "checkbox") {
          onCheckedChange == null ? void 0 : onCheckedChange(!checked);
        }
      },
      clickHighlightedItem({ scope, computed }) {
        const itemEl = scope.getById(computed("highlightedId"));
        if (!itemEl || itemEl.dataset.disabled) return;
        queueMicrotask(() => itemEl.click());
      },
      setIntentPolygon({ context, scope, event }) {
        const menu = getContentEl9(scope);
        const placement = context.get("currentPlacement");
        if (!menu || !placement) return;
        const rect = menu.getBoundingClientRect();
        const polygon = getElementPolygon(rect, placement);
        if (!polygon) return;
        const rightSide = getPlacementSide(placement) === "right";
        const bleed = rightSide ? -5 : 5;
        context.set("intentPolygon", [{ ...event.point, x: event.point.x + bleed }, ...polygon]);
      },
      clearIntentPolygon({ context }) {
        context.set("intentPolygon", null);
      },
      resumePointer({ refs, flush: flush2 }) {
        const parent = refs.get("parent");
        if (!parent) return;
        flush2(() => {
          parent.context.set("suspendPointer", false);
        });
      },
      setHighlightedItem({ context, event }) {
        const value = event.value || getItemValue(event.target);
        context.set("highlightedValue", value);
      },
      clearHighlightedItem({ context }) {
        context.set("highlightedValue", null);
      },
      focusMenu({ scope }) {
        raf(() => {
          const contentEl = getContentEl9(scope);
          const initialFocusEl = getInitialFocus({
            root: contentEl,
            enabled: !contains(contentEl, scope.getActiveElement()),
            filter(node) {
              var _a8;
              return !((_a8 = node.role) == null ? void 0 : _a8.startsWith("menuitem"));
            }
          });
          initialFocusEl == null ? void 0 : initialFocusEl.focus({ preventScroll: true });
        });
      },
      highlightFirstItem({ context, scope }) {
        const fn = getContentEl9(scope) ? queueMicrotask : raf;
        fn(() => {
          const first2 = getFirstEl(scope);
          if (!first2) return;
          context.set("highlightedValue", getItemValue(first2));
        });
      },
      highlightLastItem({ context, scope }) {
        const fn = getContentEl9(scope) ? queueMicrotask : raf;
        fn(() => {
          const last2 = getLastEl(scope);
          if (!last2) return;
          context.set("highlightedValue", getItemValue(last2));
        });
      },
      highlightNextItem({ context, scope, event, prop }) {
        const next2 = getNextEl(scope, {
          loop: event.loop,
          value: context.get("highlightedValue"),
          loopFocus: prop("loopFocus")
        });
        context.set("highlightedValue", getItemValue(next2));
      },
      highlightPrevItem({ context, scope, event, prop }) {
        const prev2 = getPrevEl(scope, {
          loop: event.loop,
          value: context.get("highlightedValue"),
          loopFocus: prop("loopFocus")
        });
        context.set("highlightedValue", getItemValue(prev2));
      },
      invokeOnSelect({ context, prop, scope }) {
        var _a8;
        const value = context.get("highlightedValue");
        if (value == null) return;
        const node = getItemEl3(scope, value);
        dispatchSelectionEvent(node, value);
        (_a8 = prop("onSelect")) == null ? void 0 : _a8({ value });
      },
      focusTrigger({ scope, context, event, computed }) {
        if (computed("isSubmenu") || context.get("anchorPoint") || event.restoreFocus === false) return;
        queueMicrotask(() => {
          var _a8;
          return (_a8 = getTriggerEl7(scope)) == null ? void 0 : _a8.focus({ preventScroll: true });
        });
      },
      highlightMatchedItem({ scope, context, event, refs }) {
        const node = getElemByKey(scope, {
          key: event.key,
          value: context.get("highlightedValue"),
          typeaheadState: refs.get("typeaheadState")
        });
        if (!node) return;
        context.set("highlightedValue", getItemValue(node));
      },
      setParentMenu({ refs, event }) {
        refs.set("parent", event.value);
      },
      setChildMenu({ refs, event }) {
        const children = refs.get("children");
        children[event.id] = event.value;
        refs.set("children", children);
      },
      closeRootMenu({ refs }) {
        closeRootMenu({ parent: refs.get("parent") });
      },
      openSubmenu({ refs, scope, computed }) {
        const item = scope.getById(computed("highlightedId"));
        const id = item == null ? void 0 : item.getAttribute("data-uid");
        const children = refs.get("children");
        const child = id ? children[id] : null;
        child == null ? void 0 : child.send({ type: "OPEN_AUTOFOCUS" });
      },
      focusParentMenu({ refs }) {
        var _a8;
        (_a8 = refs.get("parent")) == null ? void 0 : _a8.send({ type: "FOCUS_MENU" });
      },
      setLastHighlightedItem({ context, event }) {
        context.set("lastHighlightedValue", getItemValue(event.target));
      },
      restoreHighlightedItem({ context }) {
        if (!context.get("lastHighlightedValue")) return;
        context.set("highlightedValue", context.get("lastHighlightedValue"));
        context.set("lastHighlightedValue", null);
      },
      restoreParentHighlightedItem({ refs }) {
        var _a8;
        (_a8 = refs.get("parent")) == null ? void 0 : _a8.send({ type: "HIGHLIGHTED.RESTORE" });
      },
      invokeOnOpen({ prop }) {
        var _a8;
        (_a8 = prop("onOpenChange")) == null ? void 0 : _a8({ open: true });
      },
      invokeOnClose({ prop }) {
        var _a8;
        (_a8 = prop("onOpenChange")) == null ? void 0 : _a8({ open: false });
      },
      toggleVisibility({ prop, event, send }) {
        send({
          type: prop("open") ? "CONTROLLED.OPEN" : "CONTROLLED.CLOSE",
          previousEvent: event
        });
      }
    }
  }
});
function closeRootMenu(ctx) {
  let parent = ctx.parent;
  while (parent && parent.computed("isSubmenu")) {
    parent = parent.refs.get("parent");
  }
  parent == null ? void 0 : parent.send({ type: "CLOSE" });
}
function isWithinPolygon(polygon, point) {
  if (!polygon) return false;
  return isPointInPolygon(polygon, point);
}
function resolveItemId(children, value, scope) {
  const hasChildren = Object.keys(children).length > 0;
  if (!value) return null;
  if (!hasChildren) {
    return getItemId6(scope, value);
  }
  for (const id in children) {
    const childMenu = children[id];
    const childTriggerId = getTriggerId9(childMenu.scope);
    if (childTriggerId === value) {
      return childTriggerId;
    }
  }
  return getItemId6(scope, value);
}
var props18 = createProps()([
  "anchorPoint",
  "aria-label",
  "closeOnSelect",
  "composite",
  "defaultHighlightedValue",
  "defaultOpen",
  "dir",
  "getRootNode",
  "highlightedValue",
  "id",
  "ids",
  "loopFocus",
  "navigate",
  "onEscapeKeyDown",
  "onFocusOutside",
  "onHighlightChange",
  "onInteractOutside",
  "onOpenChange",
  "onPointerDownOutside",
  "onSelect",
  "open",
  "positioning",
  "typeahead"
]);
var splitProps18 = createSplitProps(props18);
var itemProps6 = createProps()(["closeOnSelect", "disabled", "value", "valueText"]);
var splitItemProps6 = createSplitProps(itemProps6);
var itemGroupLabelProps3 = createProps()(["htmlFor"]);
var splitItemGroupLabelProps3 = createSplitProps(itemGroupLabelProps3);
var itemGroupProps3 = createProps()(["id"]);
var splitItemGroupProps3 = createSplitProps(itemGroupProps3);
var optionItemProps = createProps()([
  "checked",
  "closeOnSelect",
  "disabled",
  "onCheckedChange",
  "type",
  "value",
  "valueText"
]);
var splitOptionItemProps = createSplitProps(optionItemProps);

// node_modules/@ark-ui/react/dist/components/menu/use-menu.js
var import_react479 = __toESM(require_react(), 1);
var useMenu = (props43) => {
  const id = (0, import_react479.useId)();
  const { getRootNode } = useEnvironmentContext();
  const { dir } = useLocaleContext();
  const machineProps = {
    id,
    dir,
    getRootNode,
    ...props43
  };
  const service = useMachine(machine18, machineProps);
  const api = connect18(service, normalizeProps);
  return { api, service };
};

// node_modules/@ark-ui/react/dist/components/menu/use-menu-machine-context.js
var [MenuMachineProvider, useMenuMachineContext] = createContext3({
  name: "MenuMachineContext",
  hookName: "useMenuMachineContext",
  providerName: "<MenuMachineProvider />",
  strict: false
});

// node_modules/@ark-ui/react/dist/components/menu/use-menu-trigger-item-context.js
var [MenuTriggerItemProvider, useMenuTriggerItemContext] = createContext3({
  name: "MenuMachineContext",
  hookName: "useMenuMachineContext",
  providerName: "<MenuMachineProvider />",
  strict: false
});

// node_modules/@ark-ui/react/dist/components/menu/menu-root.js
var MenuRoot = (props43) => {
  const [presenceProps, menuProps] = splitPresenceProps(props43);
  const [useMenuProps, localProps] = createSplitProps2()(menuProps, [
    "anchorPoint",
    "aria-label",
    "closeOnSelect",
    "composite",
    "defaultHighlightedValue",
    "defaultOpen",
    "highlightedValue",
    "id",
    "ids",
    "loopFocus",
    "navigate",
    "onEscapeKeyDown",
    "onFocusOutside",
    "onHighlightChange",
    "onInteractOutside",
    "onOpenChange",
    "onPointerDownOutside",
    "onSelect",
    "open",
    "positioning",
    "typeahead"
  ]);
  const parentApi = useMenuContext();
  const parentMachine = useMenuMachineContext();
  const { api, service } = useMenu(useMenuProps);
  const presence = usePresence(mergeProps2({ present: api.open }, presenceProps));
  useEffectOnce(() => {
    if (!parentMachine) return;
    if (!parentApi) return;
    parentApi.setChild(service);
    api.setParent(parentMachine);
  });
  const triggerItemContext = (0, import_react481.useCallback)(() => parentApi == null ? void 0 : parentApi.getTriggerItemProps(api), [api, parentApi]);
  return (0, import_jsx_runtime227.jsx)(MenuTriggerItemProvider, { value: triggerItemContext, children: (0, import_jsx_runtime227.jsx)(MenuMachineProvider, { value: service, children: (0, import_jsx_runtime227.jsx)(MenuProvider, { value: api, children: (0, import_jsx_runtime227.jsx)(PresenceProvider, { value: presence, ...localProps }) }) }) });
};

// node_modules/@ark-ui/react/dist/components/menu/menu-root-provider.js
var import_jsx_runtime228 = __toESM(require_jsx_runtime(), 1);
var import_react483 = __toESM(require_react(), 1);
var MenuRootProvider = (props43) => {
  const parentApi = useMenuContext();
  const parentMachine = useMenuMachineContext();
  const [presenceProps, { value: menu, children }] = splitPresenceProps(props43);
  const { api, service } = menu;
  const presence = usePresence(mergeProps2({ present: api.open }, presenceProps));
  useEffectOnce(() => {
    if (!parentMachine) return;
    if (!parentApi) return;
    parentApi.setChild(service);
    api.setParent(parentMachine);
  });
  const triggerItemContext = (0, import_react483.useCallback)(() => parentApi == null ? void 0 : parentApi.getTriggerItemProps(api), [api, parentApi]);
  return (0, import_jsx_runtime228.jsx)(MenuTriggerItemProvider, { value: triggerItemContext, children: (0, import_jsx_runtime228.jsx)(MenuMachineProvider, { value: service, children: (0, import_jsx_runtime228.jsx)(MenuProvider, { value: api, children: (0, import_jsx_runtime228.jsx)(PresenceProvider, { value: presence, children }) }) }) });
};

// node_modules/@ark-ui/react/dist/components/menu/menu-separator.js
var import_jsx_runtime229 = __toESM(require_jsx_runtime(), 1);
var import_react485 = __toESM(require_react(), 1);
var MenuSeparator = (0, import_react485.forwardRef)((props43, ref) => {
  const menu = useMenuContext();
  const mergedProps = mergeProps2(menu.getSeparatorProps(), props43);
  return (0, import_jsx_runtime229.jsx)(ark.hr, { ...mergedProps, ref });
});
MenuSeparator.displayName = "MenuSeparator";

// node_modules/@ark-ui/react/dist/components/menu/menu-trigger.js
var import_jsx_runtime230 = __toESM(require_jsx_runtime(), 1);
var import_react487 = __toESM(require_react(), 1);
var MenuTrigger = (0, import_react487.forwardRef)((props43, ref) => {
  const menu = useMenuContext();
  const presence = usePresenceContext();
  const mergedProps = mergeProps2(
    {
      ...menu.getTriggerProps(),
      "aria-controls": presence.unmounted ? void 0 : menu.getTriggerProps()["aria-controls"]
    },
    props43
  );
  return (0, import_jsx_runtime230.jsx)(ark.button, { ...mergedProps, ref });
});
MenuTrigger.displayName = "MenuTrigger";

// node_modules/@ark-ui/react/dist/components/menu/menu-trigger-item.js
var import_jsx_runtime231 = __toESM(require_jsx_runtime(), 1);
var import_react489 = __toESM(require_react(), 1);
var MenuTriggerItem = (0, import_react489.forwardRef)((props43, ref) => {
  const getTriggerItemProps = useMenuTriggerItemContext();
  const mergedProps = mergeProps2((getTriggerItemProps == null ? void 0 : getTriggerItemProps()) ?? {}, props43);
  return (0, import_jsx_runtime231.jsx)(ark.div, { ...mergedProps, ref });
});
MenuTriggerItem.displayName = "MenuTriggerItem";

// node_modules/@ark-ui/react/dist/components/menu/menu.js
var menu_exports = {};
__export(menu_exports, {
  Arrow: () => MenuArrow,
  ArrowTip: () => MenuArrowTip,
  CheckboxItem: () => MenuCheckboxItem,
  Content: () => MenuContent,
  Context: () => MenuContext,
  ContextTrigger: () => MenuContextTrigger,
  Indicator: () => MenuIndicator,
  Item: () => MenuItem,
  ItemContext: () => MenuItemContext,
  ItemGroup: () => MenuItemGroup,
  ItemGroupLabel: () => MenuItemGroupLabel,
  ItemIndicator: () => MenuItemIndicator,
  ItemText: () => MenuItemText,
  Positioner: () => MenuPositioner,
  RadioItem: () => MenuRadioItem,
  RadioItemGroup: () => MenuRadioItemGroup,
  Root: () => MenuRoot,
  RootProvider: () => MenuRootProvider,
  Separator: () => MenuSeparator,
  Trigger: () => MenuTrigger,
  TriggerItem: () => MenuTriggerItem
});

// node_modules/@ark-ui/react/dist/components/number-input/use-number-input-context.js
var [NumberInputProvider, useNumberInputContext] = createContext3({
  name: "NumberInputContext",
  hookName: "useNumberInputContext",
  providerName: "<NumberInputProvider />"
});

// node_modules/@ark-ui/react/dist/components/number-input/number-input-context.js
var NumberInputContext = (props43) => props43.children(useNumberInputContext());

// node_modules/@ark-ui/react/dist/components/number-input/number-input-control.js
var import_jsx_runtime232 = __toESM(require_jsx_runtime(), 1);
var import_react491 = __toESM(require_react(), 1);
var NumberInputControl = (0, import_react491.forwardRef)((props43, ref) => {
  const numberInput = useNumberInputContext();
  const mergedProps = mergeProps2(numberInput.getControlProps(), props43);
  return (0, import_jsx_runtime232.jsx)(ark.div, { ...mergedProps, ref });
});
NumberInputControl.displayName = "NumberInputControl";

// node_modules/@ark-ui/react/dist/components/number-input/number-input-decrement-trigger.js
var import_jsx_runtime233 = __toESM(require_jsx_runtime(), 1);
var import_react493 = __toESM(require_react(), 1);
var NumberInputDecrementTrigger = (0, import_react493.forwardRef)(
  (props43, ref) => {
    const numberInput = useNumberInputContext();
    const mergedProps = mergeProps2(numberInput.getDecrementTriggerProps(), props43);
    return (0, import_jsx_runtime233.jsx)(ark.button, { ...mergedProps, ref });
  }
);
NumberInputDecrementTrigger.displayName = "NumberInputDecrementTrigger";

// node_modules/@ark-ui/react/dist/components/number-input/number-input-increment-trigger.js
var import_jsx_runtime234 = __toESM(require_jsx_runtime(), 1);
var import_react495 = __toESM(require_react(), 1);
var NumberInputIncrementTrigger = (0, import_react495.forwardRef)(
  (props43, ref) => {
    const numberInput = useNumberInputContext();
    const mergedProps = mergeProps2(numberInput.getIncrementTriggerProps(), props43);
    return (0, import_jsx_runtime234.jsx)(ark.button, { ...mergedProps, ref });
  }
);
NumberInputIncrementTrigger.displayName = "NumberInputIncrementTrigger";

// node_modules/@ark-ui/react/dist/components/number-input/number-input-input.js
var import_jsx_runtime235 = __toESM(require_jsx_runtime(), 1);
var import_react497 = __toESM(require_react(), 1);
var NumberInputInput = (0, import_react497.forwardRef)((props43, ref) => {
  const numberInput = useNumberInputContext();
  const mergedProps = mergeProps2(numberInput.getInputProps(), props43);
  const field = useFieldContext();
  return (0, import_jsx_runtime235.jsx)(ark.input, { "aria-describedby": field == null ? void 0 : field.ariaDescribedby, ...mergedProps, ref });
});
NumberInputInput.displayName = "NumberInputInput";

// node_modules/@ark-ui/react/dist/components/number-input/number-input-label.js
var import_jsx_runtime236 = __toESM(require_jsx_runtime(), 1);
var import_react499 = __toESM(require_react(), 1);
var NumberInputLabel = (0, import_react499.forwardRef)((props43, ref) => {
  const numberInput = useNumberInputContext();
  const mergedProps = mergeProps2(numberInput.getLabelProps(), props43);
  return (0, import_jsx_runtime236.jsx)(ark.label, { ...mergedProps, ref });
});
NumberInputLabel.displayName = "NumberInputLabel";

// node_modules/@ark-ui/react/dist/components/number-input/number-input-root.js
var import_jsx_runtime237 = __toESM(require_jsx_runtime(), 1);
var import_react503 = __toESM(require_react(), 1);

// node_modules/@internationalized/number/dist/NumberFormatter.mjs
var $488c6ddbf4ef74c2$var$formatterCache = /* @__PURE__ */ new Map();
var $488c6ddbf4ef74c2$var$supportsSignDisplay = false;
try {
  $488c6ddbf4ef74c2$var$supportsSignDisplay = new Intl.NumberFormat("de-DE", {
    signDisplay: "exceptZero"
  }).resolvedOptions().signDisplay === "exceptZero";
} catch {
}
var $488c6ddbf4ef74c2$var$supportsUnit = false;
try {
  $488c6ddbf4ef74c2$var$supportsUnit = new Intl.NumberFormat("de-DE", {
    style: "unit",
    unit: "degree"
  }).resolvedOptions().style === "unit";
} catch {
}
var $488c6ddbf4ef74c2$var$UNITS = {
  degree: {
    narrow: {
      default: "",
      "ja-JP": " ",
      "zh-TW": "",
      "sl-SI": " "
    }
  }
};
var $488c6ddbf4ef74c2$export$cc77c4ff7e8673c5 = class {
  /** Formats a number value as a string, according to the locale and options provided to the constructor. */
  format(value) {
    let res = "";
    if (!$488c6ddbf4ef74c2$var$supportsSignDisplay && this.options.signDisplay != null) res = $488c6ddbf4ef74c2$export$711b50b3c525e0f2(this.numberFormatter, this.options.signDisplay, value);
    else res = this.numberFormatter.format(value);
    if (this.options.style === "unit" && !$488c6ddbf4ef74c2$var$supportsUnit) {
      var _UNITS_unit;
      let { unit, unitDisplay = "short", locale } = this.resolvedOptions();
      if (!unit) return res;
      let values = (_UNITS_unit = $488c6ddbf4ef74c2$var$UNITS[unit]) === null || _UNITS_unit === void 0 ? void 0 : _UNITS_unit[unitDisplay];
      res += values[locale] || values.default;
    }
    return res;
  }
  /** Formats a number to an array of parts such as separators, digits, punctuation, and more. */
  formatToParts(value) {
    return this.numberFormatter.formatToParts(value);
  }
  /** Formats a number range as a string. */
  formatRange(start, end) {
    if (typeof this.numberFormatter.formatRange === "function") return this.numberFormatter.formatRange(start, end);
    if (end < start) throw new RangeError("End date must be >= start date");
    return `${this.format(start)}  ${this.format(end)}`;
  }
  /** Formats a number range as an array of parts. */
  formatRangeToParts(start, end) {
    if (typeof this.numberFormatter.formatRangeToParts === "function") return this.numberFormatter.formatRangeToParts(start, end);
    if (end < start) throw new RangeError("End date must be >= start date");
    let startParts = this.numberFormatter.formatToParts(start);
    let endParts = this.numberFormatter.formatToParts(end);
    return [
      ...startParts.map((p) => ({
        ...p,
        source: "startRange"
      })),
      {
        type: "literal",
        value: "  ",
        source: "shared"
      },
      ...endParts.map((p) => ({
        ...p,
        source: "endRange"
      }))
    ];
  }
  /** Returns the resolved formatting options based on the values passed to the constructor. */
  resolvedOptions() {
    let options = this.numberFormatter.resolvedOptions();
    if (!$488c6ddbf4ef74c2$var$supportsSignDisplay && this.options.signDisplay != null) options = {
      ...options,
      signDisplay: this.options.signDisplay
    };
    if (!$488c6ddbf4ef74c2$var$supportsUnit && this.options.style === "unit") options = {
      ...options,
      style: "unit",
      unit: this.options.unit,
      unitDisplay: this.options.unitDisplay
    };
    return options;
  }
  constructor(locale, options = {}) {
    this.numberFormatter = $488c6ddbf4ef74c2$var$getCachedNumberFormatter(locale, options);
    this.options = options;
  }
};
function $488c6ddbf4ef74c2$var$getCachedNumberFormatter(locale, options = {}) {
  let { numberingSystem } = options;
  if (numberingSystem && locale.includes("-nu-")) {
    if (!locale.includes("-u-")) locale += "-u-";
    locale += `-nu-${numberingSystem}`;
  }
  if (options.style === "unit" && !$488c6ddbf4ef74c2$var$supportsUnit) {
    var _UNITS_unit;
    let { unit, unitDisplay = "short" } = options;
    if (!unit) throw new Error('unit option must be provided with style: "unit"');
    if (!((_UNITS_unit = $488c6ddbf4ef74c2$var$UNITS[unit]) === null || _UNITS_unit === void 0 ? void 0 : _UNITS_unit[unitDisplay])) throw new Error(`Unsupported unit ${unit} with unitDisplay = ${unitDisplay}`);
    options = {
      ...options,
      style: "decimal"
    };
  }
  let cacheKey = locale + (options ? Object.entries(options).sort((a2, b2) => a2[0] < b2[0] ? -1 : 1).join() : "");
  if ($488c6ddbf4ef74c2$var$formatterCache.has(cacheKey)) return $488c6ddbf4ef74c2$var$formatterCache.get(cacheKey);
  let numberFormatter = new Intl.NumberFormat(locale, options);
  $488c6ddbf4ef74c2$var$formatterCache.set(cacheKey, numberFormatter);
  return numberFormatter;
}
function $488c6ddbf4ef74c2$export$711b50b3c525e0f2(numberFormat, signDisplay, num) {
  if (signDisplay === "auto") return numberFormat.format(num);
  else if (signDisplay === "never") return numberFormat.format(Math.abs(num));
  else {
    let needsPositiveSign = false;
    if (signDisplay === "always") needsPositiveSign = num > 0 || Object.is(num, 0);
    else if (signDisplay === "exceptZero") {
      if (Object.is(num, -0) || Object.is(num, 0)) num = Math.abs(num);
      else needsPositiveSign = num > 0;
    }
    if (needsPositiveSign) {
      let negative = numberFormat.format(-num);
      let noSign = numberFormat.format(num);
      let minus = negative.replace(noSign, "").replace(/\u200e|\u061C/, "");
      if ([
        ...minus
      ].length !== 1) console.warn("@react-aria/i18n polyfill for NumberFormat signDisplay: Unsupported case");
      let positive = negative.replace(noSign, "!!!").replace(minus, "+").replace("!!!", noSign);
      return positive;
    } else return numberFormat.format(num);
  }
}

// node_modules/@internationalized/number/dist/NumberParser.mjs
var $6c7bd7858deea686$var$CURRENCY_SIGN_REGEX = new RegExp("^.*\\(.*\\).*$");
var $6c7bd7858deea686$var$NUMBERING_SYSTEMS = [
  "latn",
  "arab",
  "hanidec",
  "deva",
  "beng"
];
var $6c7bd7858deea686$export$cd11ab140839f11d = class {
  /**
  * Parses the given string to a number. Returns NaN if a valid number could not be parsed.
  */
  parse(value) {
    return $6c7bd7858deea686$var$getNumberParserImpl(this.locale, this.options, value).parse(value);
  }
  /**
  * Returns whether the given string could potentially be a valid number. This should be used to
  * validate user input as the user types. If a `minValue` or `maxValue` is provided, the validity
  * of the minus/plus sign characters can be checked.
  */
  isValidPartialNumber(value, minValue, maxValue2) {
    return $6c7bd7858deea686$var$getNumberParserImpl(this.locale, this.options, value).isValidPartialNumber(value, minValue, maxValue2);
  }
  /**
  * Returns a numbering system for which the given string is valid in the current locale.
  * If no numbering system could be detected, the default numbering system for the current
  * locale is returned.
  */
  getNumberingSystem(value) {
    return $6c7bd7858deea686$var$getNumberParserImpl(this.locale, this.options, value).options.numberingSystem;
  }
  constructor(locale, options = {}) {
    this.locale = locale;
    this.options = options;
  }
};
var $6c7bd7858deea686$var$numberParserCache = /* @__PURE__ */ new Map();
function $6c7bd7858deea686$var$getNumberParserImpl(locale, options, value) {
  let defaultParser = $6c7bd7858deea686$var$getCachedNumberParser(locale, options);
  if (!locale.includes("-nu-") && !defaultParser.isValidPartialNumber(value)) {
    for (let numberingSystem of $6c7bd7858deea686$var$NUMBERING_SYSTEMS) if (numberingSystem !== defaultParser.options.numberingSystem) {
      let parser = $6c7bd7858deea686$var$getCachedNumberParser(locale + (locale.includes("-u-") ? "-nu-" : "-u-nu-") + numberingSystem, options);
      if (parser.isValidPartialNumber(value)) return parser;
    }
  }
  return defaultParser;
}
function $6c7bd7858deea686$var$getCachedNumberParser(locale, options) {
  let cacheKey = locale + (options ? Object.entries(options).sort((a2, b2) => a2[0] < b2[0] ? -1 : 1).join() : "");
  let parser = $6c7bd7858deea686$var$numberParserCache.get(cacheKey);
  if (!parser) {
    parser = new $6c7bd7858deea686$var$NumberParserImpl(locale, options);
    $6c7bd7858deea686$var$numberParserCache.set(cacheKey, parser);
  }
  return parser;
}
var $6c7bd7858deea686$var$NumberParserImpl = class {
  parse(value) {
    let fullySanitizedValue = this.sanitize(value);
    if (this.symbols.group)
      fullySanitizedValue = $6c7bd7858deea686$var$replaceAll(fullySanitizedValue, this.symbols.group, "");
    if (this.symbols.decimal) fullySanitizedValue = fullySanitizedValue.replace(this.symbols.decimal, ".");
    if (this.symbols.minusSign) fullySanitizedValue = fullySanitizedValue.replace(this.symbols.minusSign, "-");
    fullySanitizedValue = fullySanitizedValue.replace(this.symbols.numeral, this.symbols.index);
    if (this.options.style === "percent") {
      let isNegative = fullySanitizedValue.indexOf("-");
      fullySanitizedValue = fullySanitizedValue.replace("-", "");
      fullySanitizedValue = fullySanitizedValue.replace("+", "");
      let index = fullySanitizedValue.indexOf(".");
      if (index === -1) index = fullySanitizedValue.length;
      fullySanitizedValue = fullySanitizedValue.replace(".", "");
      if (index - 2 === 0) fullySanitizedValue = `0.${fullySanitizedValue}`;
      else if (index - 2 === -1) fullySanitizedValue = `0.0${fullySanitizedValue}`;
      else if (index - 2 === -2) fullySanitizedValue = "0.00";
      else fullySanitizedValue = `${fullySanitizedValue.slice(0, index - 2)}.${fullySanitizedValue.slice(index - 2)}`;
      if (isNegative > -1) fullySanitizedValue = `-${fullySanitizedValue}`;
    }
    let newValue = fullySanitizedValue ? +fullySanitizedValue : NaN;
    if (isNaN(newValue)) return NaN;
    if (this.options.style === "percent") {
      var _this_options_minimumFractionDigits, _this_options_maximumFractionDigits;
      let options = {
        ...this.options,
        style: "decimal",
        minimumFractionDigits: Math.min(((_this_options_minimumFractionDigits = this.options.minimumFractionDigits) !== null && _this_options_minimumFractionDigits !== void 0 ? _this_options_minimumFractionDigits : 0) + 2, 20),
        maximumFractionDigits: Math.min(((_this_options_maximumFractionDigits = this.options.maximumFractionDigits) !== null && _this_options_maximumFractionDigits !== void 0 ? _this_options_maximumFractionDigits : 0) + 2, 20)
      };
      return new $6c7bd7858deea686$export$cd11ab140839f11d(this.locale, options).parse(new (0, $488c6ddbf4ef74c2$export$cc77c4ff7e8673c5)(this.locale, options).format(newValue));
    }
    if (this.options.currencySign === "accounting" && $6c7bd7858deea686$var$CURRENCY_SIGN_REGEX.test(value)) newValue = -1 * newValue;
    return newValue;
  }
  sanitize(value) {
    value = value.replace(this.symbols.literals, "");
    if (this.symbols.minusSign) value = value.replace("-", this.symbols.minusSign);
    if (this.options.numberingSystem === "arab") {
      if (this.symbols.decimal) {
        value = value.replace(",", this.symbols.decimal);
        value = value.replace(String.fromCharCode(1548), this.symbols.decimal);
      }
      if (this.symbols.group) value = $6c7bd7858deea686$var$replaceAll(value, ".", this.symbols.group);
    }
    if (this.options.locale === "fr-FR" && this.symbols.group) {
      value = $6c7bd7858deea686$var$replaceAll(value, " ", this.symbols.group);
      value = $6c7bd7858deea686$var$replaceAll(value, /\u00A0/g, this.symbols.group);
    }
    return value;
  }
  isValidPartialNumber(value, minValue = -Infinity, maxValue2 = Infinity) {
    value = this.sanitize(value);
    if (this.symbols.minusSign && value.startsWith(this.symbols.minusSign) && minValue < 0) value = value.slice(this.symbols.minusSign.length);
    else if (this.symbols.plusSign && value.startsWith(this.symbols.plusSign) && maxValue2 > 0) value = value.slice(this.symbols.plusSign.length);
    if (this.symbols.group && value.startsWith(this.symbols.group)) return false;
    if (this.symbols.decimal && value.indexOf(this.symbols.decimal) > -1 && this.options.maximumFractionDigits === 0) return false;
    if (this.symbols.group) value = $6c7bd7858deea686$var$replaceAll(value, this.symbols.group, "");
    value = value.replace(this.symbols.numeral, "");
    if (this.symbols.decimal) value = value.replace(this.symbols.decimal, "");
    return value.length === 0;
  }
  constructor(locale, options = {}) {
    this.locale = locale;
    if (options.roundingIncrement !== 1 && options.roundingIncrement != null) {
      if (options.maximumFractionDigits == null && options.minimumFractionDigits == null) {
        options.maximumFractionDigits = 0;
        options.minimumFractionDigits = 0;
      } else if (options.maximumFractionDigits == null) options.maximumFractionDigits = options.minimumFractionDigits;
      else if (options.minimumFractionDigits == null) options.minimumFractionDigits = options.maximumFractionDigits;
    }
    this.formatter = new Intl.NumberFormat(locale, options);
    this.options = this.formatter.resolvedOptions();
    this.symbols = $6c7bd7858deea686$var$getSymbols(locale, this.formatter, this.options, options);
    var _this_options_minimumFractionDigits, _this_options_maximumFractionDigits;
    if (this.options.style === "percent" && (((_this_options_minimumFractionDigits = this.options.minimumFractionDigits) !== null && _this_options_minimumFractionDigits !== void 0 ? _this_options_minimumFractionDigits : 0) > 18 || ((_this_options_maximumFractionDigits = this.options.maximumFractionDigits) !== null && _this_options_maximumFractionDigits !== void 0 ? _this_options_maximumFractionDigits : 0) > 18)) console.warn("NumberParser cannot handle percentages with greater than 18 decimal places, please reduce the number in your options.");
  }
};
var $6c7bd7858deea686$var$nonLiteralParts = /* @__PURE__ */ new Set([
  "decimal",
  "fraction",
  "integer",
  "minusSign",
  "plusSign",
  "group"
]);
var $6c7bd7858deea686$var$pluralNumbers = [
  0,
  4,
  2,
  1,
  11,
  20,
  3,
  7,
  100,
  21,
  0.1,
  1.1
];
function $6c7bd7858deea686$var$getSymbols(locale, formatter, intlOptions, originalOptions) {
  var _allParts_find, _posAllParts_find, _decimalParts_find, _allParts_find1;
  let symbolFormatter = new Intl.NumberFormat(locale, {
    ...intlOptions,
    // Resets so we get the full range of symbols
    minimumSignificantDigits: 1,
    maximumSignificantDigits: 21,
    roundingIncrement: 1,
    roundingPriority: "auto",
    roundingMode: "halfExpand"
  });
  let allParts = symbolFormatter.formatToParts(-10000.111);
  let posAllParts = symbolFormatter.formatToParts(10000.111);
  let pluralParts = $6c7bd7858deea686$var$pluralNumbers.map((n) => symbolFormatter.formatToParts(n));
  var _allParts_find_value;
  let minusSign = (_allParts_find_value = (_allParts_find = allParts.find((p) => p.type === "minusSign")) === null || _allParts_find === void 0 ? void 0 : _allParts_find.value) !== null && _allParts_find_value !== void 0 ? _allParts_find_value : "-";
  let plusSign = (_posAllParts_find = posAllParts.find((p) => p.type === "plusSign")) === null || _posAllParts_find === void 0 ? void 0 : _posAllParts_find.value;
  if (!plusSign && ((originalOptions === null || originalOptions === void 0 ? void 0 : originalOptions.signDisplay) === "exceptZero" || (originalOptions === null || originalOptions === void 0 ? void 0 : originalOptions.signDisplay) === "always")) plusSign = "+";
  let decimalParts = new Intl.NumberFormat(locale, {
    ...intlOptions,
    minimumFractionDigits: 2,
    maximumFractionDigits: 2
  }).formatToParts(1e-3);
  let decimal = (_decimalParts_find = decimalParts.find((p) => p.type === "decimal")) === null || _decimalParts_find === void 0 ? void 0 : _decimalParts_find.value;
  let group2 = (_allParts_find1 = allParts.find((p) => p.type === "group")) === null || _allParts_find1 === void 0 ? void 0 : _allParts_find1.value;
  let allPartsLiterals = allParts.filter((p) => !$6c7bd7858deea686$var$nonLiteralParts.has(p.type)).map((p) => $6c7bd7858deea686$var$escapeRegex(p.value));
  let pluralPartsLiterals = pluralParts.flatMap((p) => p.filter((p2) => !$6c7bd7858deea686$var$nonLiteralParts.has(p2.type)).map((p2) => $6c7bd7858deea686$var$escapeRegex(p2.value)));
  let sortedLiterals = [
    .../* @__PURE__ */ new Set([
      ...allPartsLiterals,
      ...pluralPartsLiterals
    ])
  ].sort((a2, b2) => b2.length - a2.length);
  let literals = sortedLiterals.length === 0 ? new RegExp("[\\p{White_Space}]", "gu") : new RegExp(`${sortedLiterals.join("|")}|[\\p{White_Space}]`, "gu");
  let numerals = [
    ...new Intl.NumberFormat(intlOptions.locale, {
      useGrouping: false
    }).format(9876543210)
  ].reverse();
  let indexes = new Map(numerals.map((d, i) => [
    d,
    i
  ]));
  let numeral = new RegExp(`[${numerals.join("")}]`, "g");
  let index = (d) => String(indexes.get(d));
  return {
    minusSign,
    plusSign,
    decimal,
    group: group2,
    literals,
    numeral,
    index
  };
}
function $6c7bd7858deea686$var$replaceAll(str, find2, replace2) {
  if (str.replaceAll) return str.replaceAll(find2, replace2);
  return str.split(find2).join(replace2);
}
function $6c7bd7858deea686$var$escapeRegex(string) {
  return string.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}

// node_modules/@zag-js/number-input/dist/index.mjs
var anatomy18 = createAnatomy("numberInput").parts(
  "root",
  "label",
  "input",
  "control",
  "valueText",
  "incrementTrigger",
  "decrementTrigger",
  "scrubber"
);
var parts20 = anatomy18.build();
var getRootId14 = (ctx) => {
  var _a8;
  return ((_a8 = ctx.ids) == null ? void 0 : _a8.root) ?? `number-input:${ctx.id}`;
};
var getInputId5 = (ctx) => {
  var _a8;
  return ((_a8 = ctx.ids) == null ? void 0 : _a8.input) ?? `number-input:${ctx.id}:input`;
};
var getIncrementTriggerId = (ctx) => {
  var _a8;
  return ((_a8 = ctx.ids) == null ? void 0 : _a8.incrementTrigger) ?? `number-input:${ctx.id}:inc`;
};
var getDecrementTriggerId = (ctx) => {
  var _a8;
  return ((_a8 = ctx.ids) == null ? void 0 : _a8.decrementTrigger) ?? `number-input:${ctx.id}:dec`;
};
var getScrubberId = (ctx) => {
  var _a8;
  return ((_a8 = ctx.ids) == null ? void 0 : _a8.scrubber) ?? `number-input:${ctx.id}:scrubber`;
};
var getCursorId = (ctx) => `number-input:${ctx.id}:cursor`;
var getLabelId9 = (ctx) => {
  var _a8;
  return ((_a8 = ctx.ids) == null ? void 0 : _a8.label) ?? `number-input:${ctx.id}:label`;
};
var getInputEl4 = (ctx) => ctx.getById(getInputId5(ctx));
var getIncrementTriggerEl = (ctx) => ctx.getById(getIncrementTriggerId(ctx));
var getDecrementTriggerEl = (ctx) => ctx.getById(getDecrementTriggerId(ctx));
var getCursorEl = (ctx) => ctx.getDoc().getElementById(getCursorId(ctx));
var getPressedTriggerEl = (ctx, hint) => {
  let btnEl = null;
  if (hint === "increment") {
    btnEl = getIncrementTriggerEl(ctx);
  }
  if (hint === "decrement") {
    btnEl = getDecrementTriggerEl(ctx);
  }
  return btnEl;
};
var setupVirtualCursor = (ctx, point) => {
  if (isSafari()) return;
  createVirtualCursor(ctx, point);
  return () => {
    var _a8;
    (_a8 = getCursorEl(ctx)) == null ? void 0 : _a8.remove();
  };
};
var preventTextSelection = (ctx) => {
  const doc = ctx.getDoc();
  const html = doc.documentElement;
  const body = doc.body;
  body.style.pointerEvents = "none";
  html.style.userSelect = "none";
  html.style.cursor = "ew-resize";
  return () => {
    body.style.pointerEvents = "";
    html.style.userSelect = "";
    html.style.cursor = "";
    if (!html.style.length) {
      html.removeAttribute("style");
    }
    if (!body.style.length) {
      body.removeAttribute("style");
    }
  };
};
var getMousemoveValue = (ctx, opts) => {
  const { point, isRtl, event } = opts;
  const win = ctx.getWin();
  const x = roundToDpr(event.movementX, win.devicePixelRatio);
  const y = roundToDpr(event.movementY, win.devicePixelRatio);
  let hint = x > 0 ? "increment" : x < 0 ? "decrement" : null;
  if (isRtl && hint === "increment") hint = "decrement";
  if (isRtl && hint === "decrement") hint = "increment";
  const newPoint = { x: point.x + x, y: point.y + y };
  const width = win.innerWidth;
  const half = roundToDpr(7.5, win.devicePixelRatio);
  newPoint.x = wrap(newPoint.x + half, width) - half;
  return { hint, point: newPoint };
};
var createVirtualCursor = (ctx, point) => {
  const doc = ctx.getDoc();
  const el = doc.createElement("div");
  el.className = "scrubber--cursor";
  el.id = getCursorId(ctx);
  Object.assign(el.style, {
    width: "15px",
    height: "15px",
    position: "fixed",
    pointerEvents: "none",
    left: "0px",
    top: "0px",
    zIndex: MAX_Z_INDEX,
    transform: point ? `translate3d(${point.x}px, ${point.y}px, 0px)` : void 0,
    willChange: "transform"
  });
  el.innerHTML = `
      <svg width="46" height="15" style="left: -15.5px; position: absolute; top: 0; filter: drop-shadow(rgba(0, 0, 0, 0.4) 0px 1px 1.1px);">
        <g transform="translate(2 3)">
          <path fill-rule="evenodd" d="M 15 4.5L 15 2L 11.5 5.5L 15 9L 15 6.5L 31 6.5L 31 9L 34.5 5.5L 31 2L 31 4.5Z" style="stroke-width: 2px; stroke: white;"></path>
          <path fill-rule="evenodd" d="M 15 4.5L 15 2L 11.5 5.5L 15 9L 15 6.5L 31 6.5L 31 9L 34.5 5.5L 31 2L 31 4.5Z"></path>
        </g>
      </svg>`;
  doc.body.appendChild(el);
};
function connect19(service, normalize4) {
  const { state: state2, send, prop, scope, computed } = service;
  const focused = state2.hasTag("focus");
  const disabled = computed("isDisabled");
  const readOnly = prop("readOnly");
  const empty2 = computed("isValueEmpty");
  const invalid = computed("isOutOfRange") || !!prop("invalid");
  const isIncrementDisabled = disabled || !computed("canIncrement") || readOnly;
  const isDecrementDisabled = disabled || !computed("canDecrement") || readOnly;
  const translations = prop("translations");
  return {
    focused,
    invalid,
    empty: empty2,
    value: computed("formattedValue"),
    valueAsNumber: computed("valueAsNumber"),
    setValue(value) {
      send({ type: "VALUE.SET", value });
    },
    clearValue() {
      send({ type: "VALUE.CLEAR" });
    },
    increment() {
      send({ type: "VALUE.INCREMENT" });
    },
    decrement() {
      send({ type: "VALUE.DECREMENT" });
    },
    setToMax() {
      send({ type: "VALUE.SET", value: prop("max") });
    },
    setToMin() {
      send({ type: "VALUE.SET", value: prop("min") });
    },
    focus() {
      var _a8;
      (_a8 = getInputEl4(scope)) == null ? void 0 : _a8.focus();
    },
    getRootProps() {
      return normalize4.element({
        id: getRootId14(scope),
        ...parts20.root.attrs,
        dir: prop("dir"),
        "data-disabled": dataAttr(disabled),
        "data-focus": dataAttr(focused),
        "data-invalid": dataAttr(invalid)
      });
    },
    getLabelProps() {
      return normalize4.label({
        ...parts20.label.attrs,
        dir: prop("dir"),
        "data-disabled": dataAttr(disabled),
        "data-focus": dataAttr(focused),
        "data-invalid": dataAttr(invalid),
        id: getLabelId9(scope),
        htmlFor: getInputId5(scope)
      });
    },
    getControlProps() {
      return normalize4.element({
        ...parts20.control.attrs,
        dir: prop("dir"),
        role: "group",
        "aria-disabled": disabled,
        "data-focus": dataAttr(focused),
        "data-disabled": dataAttr(disabled),
        "data-invalid": dataAttr(invalid),
        "aria-invalid": ariaAttr(invalid)
      });
    },
    getValueTextProps() {
      return normalize4.element({
        ...parts20.valueText.attrs,
        dir: prop("dir"),
        "data-disabled": dataAttr(disabled),
        "data-invalid": dataAttr(invalid),
        "data-focus": dataAttr(focused)
      });
    },
    getInputProps() {
      return normalize4.input({
        ...parts20.input.attrs,
        dir: prop("dir"),
        name: prop("name"),
        form: prop("form"),
        id: getInputId5(scope),
        role: "spinbutton",
        defaultValue: computed("formattedValue"),
        pattern: prop("pattern"),
        inputMode: prop("inputMode"),
        "aria-invalid": ariaAttr(invalid),
        "data-invalid": dataAttr(invalid),
        disabled,
        "data-disabled": dataAttr(disabled),
        readOnly,
        required: prop("required"),
        autoComplete: "off",
        autoCorrect: "off",
        spellCheck: "false",
        type: "text",
        "aria-roledescription": "numberfield",
        "aria-valuemin": prop("min"),
        "aria-valuemax": prop("max"),
        "aria-valuenow": Number.isNaN(computed("valueAsNumber")) ? void 0 : computed("valueAsNumber"),
        "aria-valuetext": computed("valueText"),
        onFocus() {
          send({ type: "INPUT.FOCUS" });
        },
        onBlur() {
          send({ type: "INPUT.BLUR" });
        },
        onInput(event) {
          send({ type: "INPUT.CHANGE", target: event.currentTarget, hint: "set" });
        },
        onBeforeInput(event) {
          try {
            const { selectionStart, selectionEnd, value } = event.currentTarget;
            const nextValue = value.slice(0, selectionStart) + (event.data ?? "") + value.slice(selectionEnd);
            const isValid = computed("parser").isValidPartialNumber(nextValue);
            if (!isValid) {
              event.preventDefault();
            }
          } catch {
          }
        },
        onKeyDown(event) {
          if (event.defaultPrevented) return;
          if (readOnly) return;
          if (isComposingEvent(event)) return;
          const step = getEventStep(event) * prop("step");
          const keyMap2 = {
            ArrowUp() {
              send({ type: "INPUT.ARROW_UP", step });
              event.preventDefault();
            },
            ArrowDown() {
              send({ type: "INPUT.ARROW_DOWN", step });
              event.preventDefault();
            },
            Home() {
              if (isModifierKey(event)) return;
              send({ type: "INPUT.HOME" });
              event.preventDefault();
            },
            End() {
              if (isModifierKey(event)) return;
              send({ type: "INPUT.END" });
              event.preventDefault();
            },
            Enter() {
              send({ type: "INPUT.ENTER" });
            }
          };
          const exec = keyMap2[event.key];
          exec == null ? void 0 : exec(event);
        }
      });
    },
    getDecrementTriggerProps() {
      return normalize4.button({
        ...parts20.decrementTrigger.attrs,
        dir: prop("dir"),
        id: getDecrementTriggerId(scope),
        disabled: isDecrementDisabled,
        "data-disabled": dataAttr(isDecrementDisabled),
        "aria-label": translations.decrementLabel,
        type: "button",
        tabIndex: -1,
        "aria-controls": getInputId5(scope),
        onPointerDown(event) {
          var _a8;
          if (isDecrementDisabled || !isLeftClick(event)) return;
          send({ type: "TRIGGER.PRESS_DOWN", hint: "decrement", pointerType: event.pointerType });
          if (event.pointerType === "mouse") {
            event.preventDefault();
          }
          if (event.pointerType === "touch") {
            (_a8 = event.currentTarget) == null ? void 0 : _a8.focus({ preventScroll: true });
          }
        },
        onPointerUp(event) {
          send({ type: "TRIGGER.PRESS_UP", hint: "decrement", pointerType: event.pointerType });
        },
        onPointerLeave() {
          if (isDecrementDisabled) return;
          send({ type: "TRIGGER.PRESS_UP", hint: "decrement" });
        }
      });
    },
    getIncrementTriggerProps() {
      return normalize4.button({
        ...parts20.incrementTrigger.attrs,
        dir: prop("dir"),
        id: getIncrementTriggerId(scope),
        disabled: isIncrementDisabled,
        "data-disabled": dataAttr(isIncrementDisabled),
        "aria-label": translations.incrementLabel,
        type: "button",
        tabIndex: -1,
        "aria-controls": getInputId5(scope),
        onPointerDown(event) {
          var _a8;
          if (isIncrementDisabled || !isLeftClick(event)) return;
          send({ type: "TRIGGER.PRESS_DOWN", hint: "increment", pointerType: event.pointerType });
          if (event.pointerType === "mouse") {
            event.preventDefault();
          }
          if (event.pointerType === "touch") {
            (_a8 = event.currentTarget) == null ? void 0 : _a8.focus({ preventScroll: true });
          }
        },
        onPointerUp(event) {
          send({ type: "TRIGGER.PRESS_UP", hint: "increment", pointerType: event.pointerType });
        },
        onPointerLeave(event) {
          send({ type: "TRIGGER.PRESS_UP", hint: "increment", pointerType: event.pointerType });
        }
      });
    },
    getScrubberProps() {
      return normalize4.element({
        ...parts20.scrubber.attrs,
        dir: prop("dir"),
        "data-disabled": dataAttr(disabled),
        id: getScrubberId(scope),
        role: "presentation",
        onMouseDown(event) {
          if (disabled) return;
          const point = getEventPoint(event);
          const win = getWindow(event.currentTarget);
          const dpr = win.devicePixelRatio;
          point.x = point.x - roundToDpr(7.5, dpr);
          point.y = point.y - roundToDpr(7.5, dpr);
          send({ type: "SCRUBBER.PRESS_DOWN", point });
          event.preventDefault();
        },
        style: {
          cursor: disabled ? void 0 : "ew-resize"
        }
      });
    }
  };
}
function recordCursor(inputEl) {
  if (!inputEl || inputEl.ownerDocument.activeElement !== inputEl) return;
  try {
    const { selectionStart: start, selectionEnd: end, value } = inputEl;
    const beforeTxt = value.substring(0, start);
    const afterTxt = value.substring(end);
    return {
      start,
      end,
      value,
      beforeTxt,
      afterTxt
    };
  } catch {
  }
}
function restoreCursor(inputEl, selection) {
  if (!inputEl || inputEl.ownerDocument.activeElement !== inputEl) return;
  if (!selection) {
    inputEl.setSelectionRange(inputEl.value.length, inputEl.value.length);
    return;
  }
  try {
    const { value } = inputEl;
    const { beforeTxt = "", afterTxt = "", start } = selection;
    let startPos = value.length;
    if (value.endsWith(afterTxt)) {
      startPos = value.length - afterTxt.length;
    } else if (value.startsWith(beforeTxt)) {
      startPos = beforeTxt.length;
    } else if (start != null) {
      const beforeLastChar = beforeTxt[start - 1];
      const newIndex = value.indexOf(beforeLastChar, start - 1);
      if (newIndex !== -1) {
        startPos = newIndex + 1;
      }
    }
    inputEl.setSelectionRange(startPos, startPos);
  } catch {
  }
}
var createFormatter = (locale, options = {}) => {
  return new Intl.NumberFormat(locale, options);
};
var createParser = (locale, options = {}) => {
  return new $6c7bd7858deea686$export$cd11ab140839f11d(locale, options);
};
var parseValue = (value, params) => {
  const { prop, computed } = params;
  if (!prop("formatOptions")) return parseFloat(value);
  return computed("parser").parse(String(value));
};
var formatValue = (value, params) => {
  const { prop, computed } = params;
  if (Number.isNaN(value)) return "";
  if (!prop("formatOptions")) return value.toString();
  return computed("formatter").format(value);
};
var getDefaultStep = (step, formatOptions) => {
  let defaultStep = step !== void 0 && !Number.isNaN(step) ? step : 1;
  if ((formatOptions == null ? void 0 : formatOptions.style) === "percent" && (step === void 0 || Number.isNaN(step))) {
    defaultStep = 0.01;
  }
  return defaultStep;
};
var { choose: choose2, guards: guards2, createMachine: createMachine3 } = setup();
var { not: not7, and: and8 } = guards2;
var machine19 = createMachine3({
  props({ props: props210 }) {
    const step = getDefaultStep(props210.step, props210.formatOptions);
    return {
      dir: "ltr",
      locale: "en-US",
      focusInputOnChange: true,
      clampValueOnBlur: !props210.allowOverflow,
      allowOverflow: false,
      inputMode: "decimal",
      pattern: "[0-9]*(.[0-9]+)?",
      defaultValue: "",
      step,
      min: Number.MIN_SAFE_INTEGER,
      max: Number.MAX_SAFE_INTEGER,
      spinOnPress: true,
      ...props210,
      translations: {
        incrementLabel: "increment value",
        decrementLabel: "decrease value",
        ...props210.translations
      }
    };
  },
  initialState() {
    return "idle";
  },
  context({ prop, bindable, getComputed }) {
    return {
      value: bindable(() => ({
        defaultValue: prop("defaultValue"),
        value: prop("value"),
        onChange(value) {
          var _a8;
          const computed = getComputed();
          const valueAsNumber = parseValue(value, { computed, prop });
          (_a8 = prop("onValueChange")) == null ? void 0 : _a8({ value, valueAsNumber });
        }
      })),
      hint: bindable(() => ({ defaultValue: null })),
      scrubberCursorPoint: bindable(() => ({
        defaultValue: null,
        hash(value) {
          return value ? `x:${value.x}, y:${value.y}` : "";
        }
      })),
      fieldsetDisabled: bindable(() => ({ defaultValue: false }))
    };
  },
  computed: {
    isRtl: ({ prop }) => prop("dir") === "rtl",
    valueAsNumber: ({ context, computed, prop }) => parseValue(context.get("value"), { computed, prop }),
    formattedValue: ({ computed, prop }) => formatValue(computed("valueAsNumber"), { computed, prop }),
    isAtMin: ({ computed, prop }) => isValueAtMin(computed("valueAsNumber"), prop("min")),
    isAtMax: ({ computed, prop }) => isValueAtMax(computed("valueAsNumber"), prop("max")),
    isOutOfRange: ({ computed, prop }) => !isValueWithinRange(computed("valueAsNumber"), prop("min"), prop("max")),
    isValueEmpty: ({ context }) => context.get("value") === "",
    isDisabled: ({ prop, context }) => !!prop("disabled") || context.get("fieldsetDisabled"),
    canIncrement: ({ prop, computed }) => prop("allowOverflow") || !computed("isAtMax"),
    canDecrement: ({ prop, computed }) => prop("allowOverflow") || !computed("isAtMin"),
    valueText: ({ prop, context }) => {
      var _a8, _b7;
      return (_b7 = (_a8 = prop("translations")).valueText) == null ? void 0 : _b7.call(_a8, context.get("value"));
    },
    formatter: memo(
      ({ prop }) => [prop("locale"), prop("formatOptions")],
      (locale, formatOptions) => createFormatter(locale, formatOptions)
    ),
    parser: memo(
      ({ prop }) => [prop("locale"), prop("formatOptions")],
      (locale, formatOptions) => createParser(locale, formatOptions)
    )
  },
  watch({ track, action, context, computed, prop }) {
    track([() => context.get("value"), () => prop("locale")], () => {
      action(["syncInputElement"]);
    });
    track([() => computed("isOutOfRange")], () => {
      action(["invokeOnInvalid"]);
    });
    track([() => context.hash("scrubberCursorPoint")], () => {
      action(["setVirtualCursorPosition"]);
    });
  },
  effects: ["trackFormControl"],
  on: {
    "VALUE.SET": {
      actions: ["setRawValue"]
    },
    "VALUE.CLEAR": {
      actions: ["clearValue"]
    },
    "VALUE.INCREMENT": {
      actions: ["increment"]
    },
    "VALUE.DECREMENT": {
      actions: ["decrement"]
    }
  },
  states: {
    idle: {
      on: {
        "TRIGGER.PRESS_DOWN": [
          { guard: "isTouchPointer", target: "before:spin", actions: ["setHint"] },
          {
            target: "before:spin",
            actions: ["focusInput", "invokeOnFocus", "setHint"]
          }
        ],
        "SCRUBBER.PRESS_DOWN": {
          target: "scrubbing",
          actions: ["focusInput", "invokeOnFocus", "setHint", "setCursorPoint"]
        },
        "INPUT.FOCUS": {
          target: "focused",
          actions: ["focusInput", "invokeOnFocus"]
        }
      }
    },
    focused: {
      tags: ["focus"],
      effects: ["attachWheelListener"],
      on: {
        "TRIGGER.PRESS_DOWN": [
          { guard: "isTouchPointer", target: "before:spin", actions: ["setHint"] },
          { target: "before:spin", actions: ["focusInput", "setHint"] }
        ],
        "SCRUBBER.PRESS_DOWN": {
          target: "scrubbing",
          actions: ["focusInput", "setHint", "setCursorPoint"]
        },
        "INPUT.ARROW_UP": {
          actions: ["increment"]
        },
        "INPUT.ARROW_DOWN": {
          actions: ["decrement"]
        },
        "INPUT.HOME": {
          actions: ["decrementToMin"]
        },
        "INPUT.END": {
          actions: ["incrementToMax"]
        },
        "INPUT.CHANGE": {
          actions: ["setValue", "setHint"]
        },
        "INPUT.BLUR": [
          {
            guard: and8("clampValueOnBlur", not7("isInRange")),
            target: "idle",
            actions: ["setClampedValue", "clearHint", "invokeOnBlur"]
          },
          {
            guard: not7("isInRange"),
            target: "idle",
            actions: ["setFormattedValue", "clearHint", "invokeOnBlur", "invokeOnInvalid"]
          },
          {
            target: "idle",
            actions: ["setFormattedValue", "clearHint", "invokeOnBlur"]
          }
        ],
        "INPUT.ENTER": {
          actions: ["setFormattedValue", "clearHint", "invokeOnBlur"]
        }
      }
    },
    "before:spin": {
      tags: ["focus"],
      effects: ["trackButtonDisabled", "waitForChangeDelay"],
      entry: choose2([
        { guard: "isIncrementHint", actions: ["increment"] },
        { guard: "isDecrementHint", actions: ["decrement"] }
      ]),
      on: {
        CHANGE_DELAY: {
          target: "spinning",
          guard: and8("isInRange", "spinOnPress")
        },
        "TRIGGER.PRESS_UP": [
          { guard: "isTouchPointer", target: "focused", actions: ["clearHint"] },
          { target: "focused", actions: ["focusInput", "clearHint"] }
        ]
      }
    },
    spinning: {
      tags: ["focus"],
      effects: ["trackButtonDisabled", "spinValue"],
      on: {
        SPIN: [
          {
            guard: "isIncrementHint",
            actions: ["increment"]
          },
          {
            guard: "isDecrementHint",
            actions: ["decrement"]
          }
        ],
        "TRIGGER.PRESS_UP": {
          target: "focused",
          actions: ["focusInput", "clearHint"]
        }
      }
    },
    scrubbing: {
      tags: ["focus"],
      effects: ["activatePointerLock", "trackMousemove", "setupVirtualCursor", "preventTextSelection"],
      on: {
        "SCRUBBER.POINTER_UP": {
          target: "focused",
          actions: ["focusInput", "clearCursorPoint"]
        },
        "SCRUBBER.POINTER_MOVE": [
          {
            guard: "isIncrementHint",
            actions: ["increment", "setCursorPoint"]
          },
          {
            guard: "isDecrementHint",
            actions: ["decrement", "setCursorPoint"]
          }
        ]
      }
    }
  },
  implementations: {
    guards: {
      clampValueOnBlur: ({ prop }) => prop("clampValueOnBlur"),
      spinOnPress: ({ prop }) => !!prop("spinOnPress"),
      isInRange: ({ computed }) => !computed("isOutOfRange"),
      isDecrementHint: ({ context, event }) => (event.hint ?? context.get("hint")) === "decrement",
      isIncrementHint: ({ context, event }) => (event.hint ?? context.get("hint")) === "increment",
      isTouchPointer: ({ event }) => event.pointerType === "touch"
    },
    effects: {
      waitForChangeDelay({ send }) {
        const id = setTimeout(() => {
          send({ type: "CHANGE_DELAY" });
        }, 300);
        return () => clearTimeout(id);
      },
      spinValue({ send }) {
        const id = setInterval(() => {
          send({ type: "SPIN" });
        }, 50);
        return () => clearInterval(id);
      },
      trackFormControl({ context, scope }) {
        const inputEl = getInputEl4(scope);
        return trackFormControl(inputEl, {
          onFieldsetDisabledChange(disabled) {
            context.set("fieldsetDisabled", disabled);
          },
          onFormReset() {
            context.set("value", context.initial("value"));
          }
        });
      },
      setupVirtualCursor({ context, scope }) {
        const point = context.get("scrubberCursorPoint");
        return setupVirtualCursor(scope, point);
      },
      preventTextSelection({ scope }) {
        return preventTextSelection(scope);
      },
      trackButtonDisabled({ context, scope, send }) {
        const hint = context.get("hint");
        const btn = getPressedTriggerEl(scope, hint);
        return observeAttributes(btn, {
          attributes: ["disabled"],
          callback() {
            send({ type: "TRIGGER.PRESS_UP", src: "attr" });
          }
        });
      },
      attachWheelListener({ scope, send, prop }) {
        const inputEl = getInputEl4(scope);
        if (!inputEl || !scope.isActiveElement(inputEl) || !prop("allowMouseWheel")) return;
        function onWheel(event) {
          event.preventDefault();
          const dir = Math.sign(event.deltaY) * -1;
          if (dir === 1) {
            send({ type: "VALUE.INCREMENT" });
          } else if (dir === -1) {
            send({ type: "VALUE.DECREMENT" });
          }
        }
        return addDomEvent(inputEl, "wheel", onWheel, { passive: false });
      },
      activatePointerLock({ scope }) {
        if (isSafari()) return;
        return requestPointerLock(scope.getDoc());
      },
      trackMousemove({ scope, send, context, computed }) {
        const doc = scope.getDoc();
        function onMousemove(event) {
          const point = context.get("scrubberCursorPoint");
          const isRtl = computed("isRtl");
          const value = getMousemoveValue(scope, { point, isRtl, event });
          if (!value.hint) return;
          send({
            type: "SCRUBBER.POINTER_MOVE",
            hint: value.hint,
            point: value.point
          });
        }
        function onMouseup() {
          send({ type: "SCRUBBER.POINTER_UP" });
        }
        return callAll2(addDomEvent(doc, "mousemove", onMousemove, false), addDomEvent(doc, "mouseup", onMouseup, false));
      }
    },
    actions: {
      focusInput({ scope, prop }) {
        if (!prop("focusInputOnChange")) return;
        const inputEl = getInputEl4(scope);
        if (scope.isActiveElement(inputEl)) return;
        raf(() => inputEl == null ? void 0 : inputEl.focus({ preventScroll: true }));
      },
      increment({ context, event, prop, computed }) {
        let nextValue = incrementValue(computed("valueAsNumber"), event.step ?? prop("step"));
        if (!prop("allowOverflow")) nextValue = clampValue(nextValue, prop("min"), prop("max"));
        context.set("value", formatValue(nextValue, { computed, prop }));
      },
      decrement({ context, event, prop, computed }) {
        let nextValue = decrementValue(computed("valueAsNumber"), event.step ?? prop("step"));
        if (!prop("allowOverflow")) nextValue = clampValue(nextValue, prop("min"), prop("max"));
        context.set("value", formatValue(nextValue, { computed, prop }));
      },
      setClampedValue({ context, prop, computed }) {
        const nextValue = clampValue(computed("valueAsNumber"), prop("min"), prop("max"));
        context.set("value", formatValue(nextValue, { computed, prop }));
      },
      setRawValue({ context, event, prop, computed }) {
        let nextValue = parseValue(event.value, { computed, prop });
        if (!prop("allowOverflow")) nextValue = clampValue(nextValue, prop("min"), prop("max"));
        context.set("value", formatValue(nextValue, { computed, prop }));
      },
      setValue({ context, event }) {
        var _a8;
        const value = ((_a8 = event.target) == null ? void 0 : _a8.value) ?? event.value;
        context.set("value", value);
      },
      clearValue({ context }) {
        context.set("value", "");
      },
      incrementToMax({ context, prop, computed }) {
        const value = formatValue(prop("max"), { computed, prop });
        context.set("value", value);
      },
      decrementToMin({ context, prop, computed }) {
        const value = formatValue(prop("min"), { computed, prop });
        context.set("value", value);
      },
      setHint({ context, event }) {
        context.set("hint", event.hint);
      },
      clearHint({ context }) {
        context.set("hint", null);
      },
      invokeOnFocus({ computed, prop }) {
        var _a8;
        (_a8 = prop("onFocusChange")) == null ? void 0 : _a8({
          focused: true,
          value: computed("formattedValue"),
          valueAsNumber: computed("valueAsNumber")
        });
      },
      invokeOnBlur({ computed, prop }) {
        var _a8;
        (_a8 = prop("onFocusChange")) == null ? void 0 : _a8({
          focused: false,
          value: computed("formattedValue"),
          valueAsNumber: computed("valueAsNumber")
        });
      },
      invokeOnInvalid({ computed, prop, event }) {
        var _a8;
        if (event.type === "INPUT.CHANGE") return;
        const reason = computed("valueAsNumber") > prop("max") ? "rangeOverflow" : "rangeUnderflow";
        (_a8 = prop("onValueInvalid")) == null ? void 0 : _a8({
          reason,
          value: computed("formattedValue"),
          valueAsNumber: computed("valueAsNumber")
        });
      },
      syncInputElement({ context, event, computed, scope }) {
        const value = event.type.endsWith("CHANGE") ? context.get("value") : computed("formattedValue");
        const inputEl = getInputEl4(scope);
        const sel = recordCursor(inputEl);
        raf(() => {
          setElementValue(inputEl, value);
          restoreCursor(inputEl, sel);
        });
      },
      setFormattedValue({ context, computed }) {
        context.set("value", computed("formattedValue"));
      },
      setCursorPoint({ context, event }) {
        context.set("scrubberCursorPoint", event.point);
      },
      clearCursorPoint({ context }) {
        context.set("scrubberCursorPoint", null);
      },
      setVirtualCursorPosition({ context, scope }) {
        const cursorEl = getCursorEl(scope);
        const point = context.get("scrubberCursorPoint");
        if (!cursorEl || !point) return;
        cursorEl.style.transform = `translate3d(${point.x}px, ${point.y}px, 0px)`;
      }
    }
  }
});
var props19 = createProps()([
  "allowMouseWheel",
  "allowOverflow",
  "clampValueOnBlur",
  "dir",
  "disabled",
  "focusInputOnChange",
  "form",
  "formatOptions",
  "getRootNode",
  "id",
  "ids",
  "inputMode",
  "invalid",
  "locale",
  "max",
  "min",
  "name",
  "onFocusChange",
  "onValueChange",
  "onValueInvalid",
  "pattern",
  "required",
  "readOnly",
  "spinOnPress",
  "step",
  "translations",
  "value",
  "defaultValue"
]);
var splitProps19 = createSplitProps(props19);

// node_modules/@ark-ui/react/dist/components/number-input/use-number-input.js
var import_react501 = __toESM(require_react(), 1);
var useNumberInput = (props43) => {
  const id = (0, import_react501.useId)();
  const { getRootNode } = useEnvironmentContext();
  const { dir, locale } = useLocaleContext();
  const field = useFieldContext();
  const machineProps = {
    id,
    ids: {
      label: field == null ? void 0 : field.ids.label,
      input: field == null ? void 0 : field.ids.control
    },
    disabled: field == null ? void 0 : field.disabled,
    readOnly: field == null ? void 0 : field.readOnly,
    required: field == null ? void 0 : field.required,
    invalid: field == null ? void 0 : field.invalid,
    dir,
    locale,
    getRootNode,
    ...props43
  };
  const service = useMachine(machine19, machineProps);
  return connect19(service, normalizeProps);
};

// node_modules/@ark-ui/react/dist/components/number-input/number-input-root.js
var NumberInputRoot = (0, import_react503.forwardRef)((props43, ref) => {
  const [useNumberInputProps, localProps] = createSplitProps2()(props43, [
    "allowMouseWheel",
    "allowOverflow",
    "clampValueOnBlur",
    "defaultValue",
    "disabled",
    "focusInputOnChange",
    "form",
    "formatOptions",
    "id",
    "ids",
    "inputMode",
    "invalid",
    "locale",
    "max",
    "min",
    "name",
    "onFocusChange",
    "onValueChange",
    "onValueInvalid",
    "pattern",
    "readOnly",
    "required",
    "spinOnPress",
    "step",
    "translations",
    "value"
  ]);
  const numberInput = useNumberInput(useNumberInputProps);
  const mergedProps = mergeProps2(numberInput.getRootProps(), localProps);
  return (0, import_jsx_runtime237.jsx)(NumberInputProvider, { value: numberInput, children: (0, import_jsx_runtime237.jsx)(ark.div, { ...mergedProps, ref }) });
});
NumberInputRoot.displayName = "NumberInputRoot";

// node_modules/@ark-ui/react/dist/components/number-input/number-input-root-provider.js
var import_jsx_runtime238 = __toESM(require_jsx_runtime(), 1);
var import_react505 = __toESM(require_react(), 1);
var NumberInputRootProvider = (0, import_react505.forwardRef)((props43, ref) => {
  const [{ value: numberInput }, localProps] = createSplitProps2()(props43, ["value"]);
  const mergedProps = mergeProps2(numberInput.getRootProps(), localProps);
  return (0, import_jsx_runtime238.jsx)(NumberInputProvider, { value: numberInput, children: (0, import_jsx_runtime238.jsx)(ark.div, { ...mergedProps, ref }) });
});
NumberInputRootProvider.displayName = "NumberInputRootProvider";

// node_modules/@ark-ui/react/dist/components/number-input/number-input-scrubber.js
var import_jsx_runtime239 = __toESM(require_jsx_runtime(), 1);
var import_react507 = __toESM(require_react(), 1);
var NumberInputScrubber = (0, import_react507.forwardRef)((props43, ref) => {
  const numberInput = useNumberInputContext();
  const mergedProps = mergeProps2(numberInput.getScrubberProps(), props43);
  return (0, import_jsx_runtime239.jsx)(ark.div, { ...mergedProps, ref });
});
NumberInputScrubber.displayName = "NumberInputScrubber";

// node_modules/@ark-ui/react/dist/components/number-input/number-input-value-text.js
var import_jsx_runtime240 = __toESM(require_jsx_runtime(), 1);
var import_react509 = __toESM(require_react(), 1);
var NumberInputValueText = (0, import_react509.forwardRef)((props43, ref) => {
  const { children, ...localProps } = props43;
  const numberInput = useNumberInputContext();
  const mergedProps = mergeProps2(numberInput.getValueTextProps(), localProps);
  return (0, import_jsx_runtime240.jsx)(ark.span, { ...mergedProps, ref, children: children || numberInput.value });
});
NumberInputValueText.displayName = "NumberInputValueText";

// node_modules/@ark-ui/react/dist/components/number-input/number-input.js
var number_input_exports = {};
__export(number_input_exports, {
  Context: () => NumberInputContext,
  Control: () => NumberInputControl,
  DecrementTrigger: () => NumberInputDecrementTrigger,
  IncrementTrigger: () => NumberInputIncrementTrigger,
  Input: () => NumberInputInput,
  Label: () => NumberInputLabel,
  Root: () => NumberInputRoot,
  RootProvider: () => NumberInputRootProvider,
  Scrubber: () => NumberInputScrubber,
  ValueText: () => NumberInputValueText
});

// node_modules/@ark-ui/react/dist/components/pagination/use-pagination-context.js
var [PaginationProvider, usePaginationContext] = createContext3({
  name: "PaginationContext",
  hookName: "usePaginationContext",
  providerName: "<PaginationProvider />"
});

// node_modules/@ark-ui/react/dist/components/pagination/pagination-context.js
var PaginationContext = (props43) => props43.children(usePaginationContext());

// node_modules/@ark-ui/react/dist/components/pagination/pagination-ellipsis.js
var import_jsx_runtime241 = __toESM(require_jsx_runtime(), 1);
var import_react511 = __toESM(require_react(), 1);
var PaginationEllipsis = (0, import_react511.forwardRef)((props43, ref) => {
  const [ellipsisProps2, localProps] = createSplitProps2()(props43, ["index"]);
  const pagination = usePaginationContext();
  const mergedProps = mergeProps2(pagination.getEllipsisProps(ellipsisProps2), localProps);
  return (0, import_jsx_runtime241.jsx)(ark.div, { ...mergedProps, ref });
});
PaginationEllipsis.displayName = "PaginationEllipsis";

// node_modules/@ark-ui/react/dist/components/pagination/pagination-item.js
var import_jsx_runtime242 = __toESM(require_jsx_runtime(), 1);
var import_react513 = __toESM(require_react(), 1);
var PaginationItem = (0, import_react513.forwardRef)((props43, ref) => {
  const [itemProps14, localProps] = createSplitProps2()(props43, ["value", "type"]);
  const pagination = usePaginationContext();
  const mergedProps = mergeProps2(pagination.getItemProps(itemProps14), localProps);
  return (0, import_jsx_runtime242.jsx)(ark.button, { ...mergedProps, ref });
});
PaginationItem.displayName = "PaginationItem";

// node_modules/@ark-ui/react/dist/components/pagination/pagination-next-trigger.js
var import_jsx_runtime243 = __toESM(require_jsx_runtime(), 1);
var import_react515 = __toESM(require_react(), 1);
var PaginationNextTrigger = (0, import_react515.forwardRef)((props43, ref) => {
  const pagination = usePaginationContext();
  const mergedProps = mergeProps2(pagination.getNextTriggerProps(), props43);
  return (0, import_jsx_runtime243.jsx)(ark.button, { ...mergedProps, ref });
});
PaginationNextTrigger.displayName = "PaginationNextTrigger";

// node_modules/@ark-ui/react/dist/components/pagination/pagination-prev-trigger.js
var import_jsx_runtime244 = __toESM(require_jsx_runtime(), 1);
var import_react517 = __toESM(require_react(), 1);
var PaginationPrevTrigger = (0, import_react517.forwardRef)((props43, ref) => {
  const pagination = usePaginationContext();
  const mergedProps = mergeProps2(pagination.getPrevTriggerProps(), props43);
  return (0, import_jsx_runtime244.jsx)(ark.button, { ...mergedProps, ref });
});
PaginationPrevTrigger.displayName = "PaginationPrevTrigger";

// node_modules/@ark-ui/react/dist/components/pagination/pagination-root.js
var import_jsx_runtime245 = __toESM(require_jsx_runtime(), 1);
var import_react521 = __toESM(require_react(), 1);

// node_modules/@zag-js/pagination/dist/index.mjs
var anatomy19 = createAnatomy("pagination").parts("root", "item", "ellipsis", "prevTrigger", "nextTrigger");
var parts21 = anatomy19.build();
var getRootId15 = (ctx) => {
  var _a8;
  return ((_a8 = ctx.ids) == null ? void 0 : _a8.root) ?? `pagination:${ctx.id}`;
};
var getPrevTriggerId3 = (ctx) => {
  var _a8;
  return ((_a8 = ctx.ids) == null ? void 0 : _a8.prevTrigger) ?? `pagination:${ctx.id}:prev`;
};
var getNextTriggerId3 = (ctx) => {
  var _a8;
  return ((_a8 = ctx.ids) == null ? void 0 : _a8.nextTrigger) ?? `pagination:${ctx.id}:next`;
};
var getEllipsisId = (ctx, index) => {
  var _a8, _b7;
  return ((_b7 = (_a8 = ctx.ids) == null ? void 0 : _a8.ellipsis) == null ? void 0 : _b7.call(_a8, index)) ?? `pagination:${ctx.id}:ellipsis:${index}`;
};
var getItemId7 = (ctx, page) => {
  var _a8, _b7;
  return ((_b7 = (_a8 = ctx.ids) == null ? void 0 : _a8.item) == null ? void 0 : _b7.call(_a8, page)) ?? `pagination:${ctx.id}:item:${page}`;
};
var range = (start, end) => {
  let length = end - start + 1;
  return Array.from({ length }, (_, idx) => idx + start);
};
var transform = (items) => {
  return items.map((value) => {
    if (typeof value === "number") return { type: "page", value };
    return { type: "ellipsis" };
  });
};
var ELLIPSIS = "ellipsis";
var getRange = (ctx) => {
  const { page, totalPages, siblingCount } = ctx;
  const totalPageNumbers = Math.min(2 * siblingCount + 5, totalPages);
  const firstPageIndex = 1;
  const lastPageIndex = totalPages;
  const leftSiblingIndex = Math.max(page - siblingCount, firstPageIndex);
  const rightSiblingIndex = Math.min(page + siblingCount, lastPageIndex);
  const showLeftEllipsis = leftSiblingIndex > firstPageIndex + 1;
  const showRightEllipsis = rightSiblingIndex < lastPageIndex - 1;
  const itemCount = totalPageNumbers - 2;
  if (!showLeftEllipsis && showRightEllipsis) {
    const leftRange = range(1, itemCount);
    return [...leftRange, ELLIPSIS, lastPageIndex];
  }
  if (showLeftEllipsis && !showRightEllipsis) {
    const rightRange = range(lastPageIndex - itemCount + 1, lastPageIndex);
    return [firstPageIndex, ELLIPSIS, ...rightRange];
  }
  if (showLeftEllipsis && showRightEllipsis) {
    const middleRange = range(leftSiblingIndex, rightSiblingIndex);
    return [firstPageIndex, ELLIPSIS, ...middleRange, ELLIPSIS, lastPageIndex];
  }
  const fullRange = range(firstPageIndex, lastPageIndex);
  return fullRange;
};
var getTransformedRange = (ctx) => transform(getRange(ctx));
function connect20(service, normalize4) {
  const { send, scope, prop, computed, context } = service;
  const totalPages = computed("totalPages");
  const page = context.get("page");
  const translations = prop("translations");
  const count = prop("count");
  const previousPage = computed("previousPage");
  const nextPage = computed("nextPage");
  const pageRange = computed("pageRange");
  const type = prop("type");
  const isButton = type === "button";
  const isFirstPage = page === 1;
  const isLastPage = page === totalPages;
  const pages = getTransformedRange({
    page,
    totalPages,
    siblingCount: prop("siblingCount")
  });
  return {
    count,
    page,
    pageSize: context.get("pageSize"),
    totalPages,
    pages,
    previousPage,
    nextPage,
    pageRange,
    slice(data) {
      return data.slice(pageRange.start, pageRange.end);
    },
    setPageSize(size3) {
      send({ type: "SET_PAGE_SIZE", size: size3 });
    },
    setPage(page2) {
      send({ type: "SET_PAGE", page: page2 });
    },
    goToNextPage() {
      send({ type: "NEXT_PAGE" });
    },
    goToPrevPage() {
      send({ type: "PREVIOUS_PAGE" });
    },
    goToFirstPage() {
      send({ type: "FIRST_PAGE" });
    },
    goToLastPage() {
      send({ type: "LAST_PAGE" });
    },
    getRootProps() {
      return normalize4.element({
        id: getRootId15(scope),
        ...parts21.root.attrs,
        dir: prop("dir"),
        "aria-label": translations.rootLabel
      });
    },
    getEllipsisProps(props210) {
      return normalize4.element({
        id: getEllipsisId(scope, props210.index),
        ...parts21.ellipsis.attrs,
        dir: prop("dir")
      });
    },
    getItemProps(props210) {
      var _a8;
      const index = props210.value;
      const isCurrentPage = index === page;
      return normalize4.element({
        id: getItemId7(scope, index),
        ...parts21.item.attrs,
        dir: prop("dir"),
        "data-index": index,
        "data-selected": dataAttr(isCurrentPage),
        "aria-current": isCurrentPage ? "page" : void 0,
        "aria-label": (_a8 = translations.itemLabel) == null ? void 0 : _a8.call(translations, { page: index, totalPages }),
        onClick() {
          send({ type: "SET_PAGE", page: index });
        },
        ...isButton && { type: "button" }
      });
    },
    getPrevTriggerProps() {
      return normalize4.element({
        id: getPrevTriggerId3(scope),
        ...parts21.prevTrigger.attrs,
        dir: prop("dir"),
        "data-disabled": dataAttr(isFirstPage),
        "aria-label": translations.prevTriggerLabel,
        onClick() {
          send({ type: "PREVIOUS_PAGE" });
        },
        ...isButton && { disabled: isFirstPage, type: "button" }
      });
    },
    getNextTriggerProps() {
      return normalize4.element({
        id: getNextTriggerId3(scope),
        ...parts21.nextTrigger.attrs,
        dir: prop("dir"),
        "data-disabled": dataAttr(isLastPage),
        "aria-label": translations.nextTriggerLabel,
        onClick() {
          send({ type: "NEXT_PAGE" });
        },
        ...isButton && { disabled: isLastPage, type: "button" }
      });
    }
  };
}
var machine20 = createMachine({
  props({ props: props210 }) {
    return {
      defaultPageSize: 10,
      siblingCount: 1,
      defaultPage: 1,
      type: "button",
      count: 1,
      ...props210,
      translations: {
        rootLabel: "pagination",
        prevTriggerLabel: "previous page",
        nextTriggerLabel: "next page",
        itemLabel({ page, totalPages }) {
          const isLastPage = totalPages > 1 && page === totalPages;
          return `${isLastPage ? "last page, " : ""}page ${page}`;
        },
        ...props210.translations
      }
    };
  },
  initialState() {
    return "idle";
  },
  context({ prop, bindable, getContext }) {
    return {
      page: bindable(() => ({
        value: prop("page"),
        defaultValue: prop("defaultPage"),
        onChange(value) {
          var _a8;
          const context = getContext();
          (_a8 = prop("onPageChange")) == null ? void 0 : _a8({ page: value, pageSize: context.get("pageSize") });
        }
      })),
      pageSize: bindable(() => ({
        value: prop("pageSize"),
        defaultValue: prop("defaultPageSize"),
        onChange(value) {
          var _a8;
          (_a8 = prop("onPageSizeChange")) == null ? void 0 : _a8({ pageSize: value });
        }
      }))
    };
  },
  watch({ track, context, action }) {
    track([() => context.get("pageSize")], () => {
      action(["setPageIfNeeded"]);
    });
  },
  computed: {
    totalPages: ({ context, prop }) => Math.ceil(prop("count") / context.get("pageSize")),
    previousPage: ({ context }) => context.get("page") === 1 ? null : context.get("page") - 1,
    nextPage: ({ context, computed }) => context.get("page") === computed("totalPages") ? null : context.get("page") + 1,
    pageRange: ({ context, prop }) => {
      const start = (context.get("page") - 1) * context.get("pageSize");
      const end = Math.min(start + context.get("pageSize"), prop("count"));
      return { start, end };
    },
    isValidPage: ({ context, computed }) => context.get("page") >= 1 && context.get("page") <= computed("totalPages")
  },
  on: {
    SET_PAGE: {
      guard: "isValidPage",
      actions: ["setPage"]
    },
    SET_PAGE_SIZE: {
      actions: ["setPageSize"]
    },
    FIRST_PAGE: {
      actions: ["goToFirstPage"]
    },
    LAST_PAGE: {
      actions: ["goToLastPage"]
    },
    PREVIOUS_PAGE: {
      guard: "canGoToPrevPage",
      actions: ["goToPrevPage"]
    },
    NEXT_PAGE: {
      guard: "canGoToNextPage",
      actions: ["goToNextPage"]
    }
  },
  states: {
    idle: {}
  },
  implementations: {
    guards: {
      isValidPage: ({ event, computed }) => event.page >= 1 && event.page <= computed("totalPages"),
      isValidCount: ({ context, event }) => context.get("page") > event.count,
      canGoToNextPage: ({ context, computed }) => context.get("page") < computed("totalPages"),
      canGoToPrevPage: ({ context }) => context.get("page") > 1
    },
    actions: {
      setPage({ context, event, computed }) {
        const page = clampPage(event.page, computed("totalPages"));
        context.set("page", page);
      },
      setPageSize({ context, event }) {
        context.set("pageSize", event.size);
      },
      goToFirstPage({ context }) {
        context.set("page", 1);
      },
      goToLastPage({ context, computed }) {
        context.set("page", computed("totalPages"));
      },
      goToPrevPage({ context, computed }) {
        context.set("page", (prev2) => clampPage(prev2 - 1, computed("totalPages")));
      },
      goToNextPage({ context, computed }) {
        context.set("page", (prev2) => clampPage(prev2 + 1, computed("totalPages")));
      },
      setPageIfNeeded({ context, computed }) {
        if (computed("isValidPage")) return;
        context.set("page", 1);
      }
    }
  }
});
var clampPage = (page, totalPages) => Math.min(Math.max(page, 1), totalPages);
var props20 = createProps()([
  "count",
  "dir",
  "getRootNode",
  "id",
  "ids",
  "onPageChange",
  "onPageSizeChange",
  "page",
  "defaultPage",
  "pageSize",
  "defaultPageSize",
  "siblingCount",
  "translations",
  "type"
]);
var splitProps20 = createSplitProps(props20);
var itemProps7 = createProps()(["value", "type"]);
var splitItemProps7 = createSplitProps(itemProps7);
var ellipsisProps = createProps()(["index"]);
var splitEllipsisProps = createSplitProps(ellipsisProps);

// node_modules/@ark-ui/react/dist/components/pagination/use-pagination.js
var import_react519 = __toESM(require_react(), 1);
var usePagination = (props43) => {
  const id = (0, import_react519.useId)();
  const { getRootNode } = useEnvironmentContext();
  const { dir } = useLocaleContext();
  const machineProps = {
    id,
    dir,
    getRootNode,
    ...props43
  };
  const service = useMachine(machine20, machineProps);
  return connect20(service, normalizeProps);
};

// node_modules/@ark-ui/react/dist/components/pagination/pagination-root.js
var PaginationRoot = (0, import_react521.forwardRef)((props43, ref) => {
  const [paginationProps, localProps] = createSplitProps2()(props43, [
    "count",
    "defaultPage",
    "defaultPageSize",
    "id",
    "ids",
    "onPageChange",
    "onPageSizeChange",
    "page",
    "pageSize",
    "siblingCount",
    "translations",
    "type"
  ]);
  const pagination = usePagination(paginationProps);
  const mergedProps = mergeProps2(pagination.getRootProps(), localProps);
  return (0, import_jsx_runtime245.jsx)(PaginationProvider, { value: pagination, children: (0, import_jsx_runtime245.jsx)(ark.nav, { ...mergedProps, ref }) });
});
PaginationRoot.displayName = "PaginationRoot";

// node_modules/@ark-ui/react/dist/components/pagination/pagination-root-provider.js
var import_jsx_runtime246 = __toESM(require_jsx_runtime(), 1);
var import_react523 = __toESM(require_react(), 1);
var PaginationRootProvider = (0, import_react523.forwardRef)((props43, ref) => {
  const [{ value: pagination }, localProps] = createSplitProps2()(props43, ["value"]);
  const mergedProps = mergeProps2(pagination.getRootProps(), localProps);
  return (0, import_jsx_runtime246.jsx)(PaginationProvider, { value: pagination, children: (0, import_jsx_runtime246.jsx)(ark.nav, { ...mergedProps, ref }) });
});
PaginationRootProvider.displayName = "PaginationRootProvider";

// node_modules/@ark-ui/react/dist/components/pagination/pagination.js
var pagination_exports = {};
__export(pagination_exports, {
  Context: () => PaginationContext,
  Ellipsis: () => PaginationEllipsis,
  Item: () => PaginationItem,
  NextTrigger: () => PaginationNextTrigger,
  PrevTrigger: () => PaginationPrevTrigger,
  Root: () => PaginationRoot,
  RootProvider: () => PaginationRootProvider
});

// node_modules/@ark-ui/react/dist/components/password-input/use-password-input-context.js
var [PasswordInputProvider, usePasswordInputContext] = createContext3({
  name: "PasswordInputContext",
  hookName: "usePasswordInputContext",
  providerName: "<PasswordInputProvider />"
});

// node_modules/@ark-ui/react/dist/components/password-input/password-input-control.js
var import_jsx_runtime247 = __toESM(require_jsx_runtime(), 1);
var import_react525 = __toESM(require_react(), 1);
var PasswordInputControl = (0, import_react525.forwardRef)((props43, ref) => {
  const passwordInput = usePasswordInputContext();
  const mergedProps = mergeProps2(passwordInput.getControlProps(), props43);
  return (0, import_jsx_runtime247.jsx)(ark.div, { ...mergedProps, ref });
});
PasswordInputControl.displayName = "PasswordInputControl";

// node_modules/@ark-ui/react/dist/components/password-input/password-input-indicator.js
var import_jsx_runtime248 = __toESM(require_jsx_runtime(), 1);
var import_react527 = __toESM(require_react(), 1);
var PasswordInputIndicator = (0, import_react527.forwardRef)((props43, ref) => {
  const passwordInput = usePasswordInputContext();
  const mergedProps = mergeProps2(passwordInput.getIndicatorProps(), props43);
  return (0, import_jsx_runtime248.jsx)(ark.span, { ...mergedProps, ref, children: passwordInput.visible ? props43.children : props43.fallback });
});
PasswordInputIndicator.displayName = "PasswordInputIndicator";

// node_modules/@ark-ui/react/dist/components/password-input/password-input-input.js
var import_jsx_runtime249 = __toESM(require_jsx_runtime(), 1);
var import_react529 = __toESM(require_react(), 1);
var PasswordInputInput = (0, import_react529.forwardRef)((props43, ref) => {
  const passwordInput = usePasswordInputContext();
  const mergedProps = mergeProps2(passwordInput.getInputProps(), props43);
  const field = useFieldContext();
  return (0, import_jsx_runtime249.jsx)(ark.input, { "aria-describedby": field == null ? void 0 : field.ariaDescribedby, ...mergedProps, ref });
});
PasswordInputInput.displayName = "PasswordInputInput";

// node_modules/@ark-ui/react/dist/components/password-input/password-input-label.js
var import_jsx_runtime250 = __toESM(require_jsx_runtime(), 1);
var import_react531 = __toESM(require_react(), 1);
var PasswordInputLabel = (0, import_react531.forwardRef)((props43, ref) => {
  const passwordInput = usePasswordInputContext();
  const mergedProps = mergeProps2(passwordInput.getLabelProps(), props43);
  return (0, import_jsx_runtime250.jsx)(ark.label, { ...mergedProps, ref });
});
PasswordInputLabel.displayName = "PasswordInputLabel";

// node_modules/@ark-ui/react/dist/components/password-input/password-input-root.js
var import_jsx_runtime251 = __toESM(require_jsx_runtime(), 1);
var import_react535 = __toESM(require_react(), 1);

// node_modules/@zag-js/password-input/dist/index.mjs
var anatomy20 = createAnatomy("password-input").parts(
  "root",
  "input",
  "label",
  "control",
  "indicator",
  "visibilityTrigger"
);
var parts22 = anatomy20.build();
var getInputId6 = (ctx) => {
  var _a8;
  return ((_a8 = ctx.ids) == null ? void 0 : _a8.input) ?? `p-input-${ctx.id}-input`;
};
var getInputEl5 = (ctx) => ctx.getById(getInputId6(ctx));
function connect21(service, normalize4) {
  const { scope, prop, context } = service;
  const visible = context.get("visible");
  const disabled = !!prop("disabled");
  const invalid = !!prop("invalid");
  const readOnly = !!prop("readOnly");
  const interactive = !(readOnly || disabled);
  const translations = prop("translations");
  return {
    visible,
    disabled,
    invalid,
    focus() {
      var _a8;
      (_a8 = getInputEl5(scope)) == null ? void 0 : _a8.focus();
    },
    setVisible(value) {
      service.send({ type: "VISIBILITY.SET", value });
    },
    toggleVisible() {
      service.send({ type: "VISIBILITY.SET", value: !visible });
    },
    getRootProps() {
      return normalize4.element({
        ...parts22.root.attrs,
        dir: prop("dir"),
        "data-disabled": dataAttr(disabled),
        "data-invalid": dataAttr(invalid),
        "data-readonly": dataAttr(readOnly)
      });
    },
    getLabelProps() {
      return normalize4.label({
        ...parts22.label.attrs,
        htmlFor: getInputId6(scope),
        "data-disabled": dataAttr(disabled),
        "data-invalid": dataAttr(invalid),
        "data-readonly": dataAttr(readOnly)
      });
    },
    getInputProps() {
      return normalize4.input({
        ...parts22.input.attrs,
        id: getInputId6(scope),
        autoCapitalize: "off",
        name: prop("name"),
        required: prop("required"),
        autoComplete: prop("autoComplete"),
        spellCheck: false,
        readOnly,
        disabled,
        type: visible ? "text" : "password",
        "data-state": visible ? "visible" : "hidden",
        "aria-invalid": ariaAttr(invalid),
        "data-disabled": dataAttr(disabled),
        "data-invalid": dataAttr(invalid),
        "data-readonly": dataAttr(readOnly),
        ...prop("ignorePasswordManagers") ? passwordManagerProps : {}
      });
    },
    getVisibilityTriggerProps() {
      var _a8;
      return normalize4.button({
        ...parts22.visibilityTrigger.attrs,
        type: "button",
        tabIndex: -1,
        "aria-controls": getInputId6(scope),
        "aria-expanded": visible,
        "data-readonly": dataAttr(readOnly),
        disabled,
        "data-disabled": dataAttr(disabled),
        "data-state": visible ? "visible" : "hidden",
        "aria-label": (_a8 = translations == null ? void 0 : translations.visibilityTrigger) == null ? void 0 : _a8.call(translations, visible),
        onPointerDown(event) {
          if (!isLeftClick(event)) return;
          if (!interactive) return;
          event.preventDefault();
          service.send({ type: "TRIGGER.CLICK" });
        }
      });
    },
    getIndicatorProps() {
      return normalize4.element({
        ...parts22.indicator.attrs,
        "aria-hidden": true,
        "data-state": visible ? "visible" : "hidden",
        "data-disabled": dataAttr(disabled),
        "data-invalid": dataAttr(invalid),
        "data-readonly": dataAttr(readOnly)
      });
    },
    getControlProps() {
      return normalize4.element({
        ...parts22.control.attrs,
        "data-disabled": dataAttr(disabled),
        "data-invalid": dataAttr(invalid),
        "data-readonly": dataAttr(readOnly)
      });
    }
  };
}
var passwordManagerProps = {
  // 1Password
  "data-1p-ignore": "",
  // LastPass
  "data-lpignore": "true",
  // Bitwarden
  "data-bwignore": "true",
  // Dashlane
  "data-form-type": "other",
  // Proton Pass
  "data-protonpass-ignore": "true"
};
var machine21 = createMachine({
  props({ props: props210 }) {
    return {
      id: uuid(),
      defaultVisible: false,
      autoComplete: "current-password",
      ignorePasswordManagers: false,
      ...props210,
      translations: {
        visibilityTrigger(visible) {
          return visible ? "Hide password" : "Show password";
        },
        ...props210.translations
      }
    };
  },
  context({ prop, bindable }) {
    return {
      visible: bindable(() => ({
        value: prop("visible"),
        defaultValue: prop("defaultVisible"),
        onChange(value) {
          var _a8;
          (_a8 = prop("onVisibilityChange")) == null ? void 0 : _a8({ visible: value });
        }
      }))
    };
  },
  initialState() {
    return "idle";
  },
  effects: ["trackFormEvents"],
  states: {
    idle: {
      on: {
        "VISIBILITY.SET": {
          actions: ["setVisibility"]
        },
        "TRIGGER.CLICK": {
          actions: ["toggleVisibility", "focusInputEl"]
        }
      }
    }
  },
  implementations: {
    actions: {
      setVisibility({ context, event }) {
        context.set("visible", event.value);
      },
      toggleVisibility({ context }) {
        context.set("visible", (c) => !c);
      },
      focusInputEl({ scope }) {
        const inputEl = getInputEl5(scope);
        inputEl == null ? void 0 : inputEl.focus();
      }
    },
    effects: {
      trackFormEvents({ scope, send }) {
        const inputEl = getInputEl5(scope);
        const form = inputEl == null ? void 0 : inputEl.form;
        if (!form) return;
        const win = scope.getWin();
        const controller = new win.AbortController();
        form.addEventListener(
          "reset",
          (event) => {
            if (event.defaultPrevented) return;
            send({ type: "VISIBILITY.SET", value: false });
          },
          { signal: controller.signal }
        );
        form.addEventListener(
          "submit",
          () => {
            send({ type: "VISIBILITY.SET", value: false });
          },
          { signal: controller.signal }
        );
        return () => controller.abort();
      }
    }
  }
});
var props21 = createProps()([
  "defaultVisible",
  "dir",
  "id",
  "onVisibilityChange",
  "visible",
  "ids",
  "getRootNode",
  "disabled",
  "invalid",
  "required",
  "readOnly",
  "translations",
  "ignorePasswordManagers",
  "autoComplete",
  "name"
]);
var splitProps21 = createSplitProps(props21);

// node_modules/@ark-ui/react/dist/components/password-input/use-password-input.js
var import_react533 = __toESM(require_react(), 1);
var usePasswordInput = (props43) => {
  const id = (0, import_react533.useId)();
  const { getRootNode } = useEnvironmentContext();
  const { dir } = useLocaleContext();
  const field = useFieldContext();
  const machineProps = {
    id,
    ids: {
      input: field == null ? void 0 : field.ids.control
    },
    disabled: field == null ? void 0 : field.disabled,
    readOnly: field == null ? void 0 : field.readOnly,
    required: field == null ? void 0 : field.required,
    invalid: field == null ? void 0 : field.invalid,
    dir,
    getRootNode,
    ...props43
  };
  const service = useMachine(machine21, machineProps);
  return connect21(service, normalizeProps);
};

// node_modules/@ark-ui/react/dist/components/password-input/password-input-root.js
var PasswordInputRoot = (0, import_react535.forwardRef)((props43, ref) => {
  const [usePasswordInputProps, localProps] = createSplitProps2()(props43, [
    "autoComplete",
    "defaultVisible",
    "disabled",
    "id",
    "ids",
    "ignorePasswordManagers",
    "invalid",
    "name",
    "onVisibilityChange",
    "readOnly",
    "required",
    "translations",
    "visible"
  ]);
  const passwordInput = usePasswordInput(usePasswordInputProps);
  const mergedProps = mergeProps2(passwordInput.getRootProps(), localProps);
  return (0, import_jsx_runtime251.jsx)(PasswordInputProvider, { value: passwordInput, children: (0, import_jsx_runtime251.jsx)(ark.div, { ...mergedProps, ref }) });
});
PasswordInputRoot.displayName = "PasswordInputRoot";

// node_modules/@ark-ui/react/dist/components/password-input/password-input-root-provider.js
var import_jsx_runtime252 = __toESM(require_jsx_runtime(), 1);
var import_react537 = __toESM(require_react(), 1);
var PasswordInputRootProvider = (0, import_react537.forwardRef)((props43, ref) => {
  const { value: passwordInput, ...localProps } = props43;
  const mergedProps = mergeProps2(passwordInput.getRootProps(), localProps);
  return (0, import_jsx_runtime252.jsx)(PasswordInputProvider, { value: passwordInput, children: (0, import_jsx_runtime252.jsx)(ark.div, { ...mergedProps, ref }) });
});
PasswordInputRootProvider.displayName = "PasswordInputRootProvider";

// node_modules/@ark-ui/react/dist/components/password-input/password-input-visibility-trigger.js
var import_jsx_runtime253 = __toESM(require_jsx_runtime(), 1);
var import_react539 = __toESM(require_react(), 1);
var PasswordInputVisibilityTrigger = (0, import_react539.forwardRef)(
  (props43, ref) => {
    const passwordInput = usePasswordInputContext();
    const mergedProps = mergeProps2(passwordInput.getVisibilityTriggerProps(), props43);
    return (0, import_jsx_runtime253.jsx)(ark.button, { ...mergedProps, ref });
  }
);
PasswordInputVisibilityTrigger.displayName = "PasswordInputVisibilityTrigger";

// node_modules/@ark-ui/react/dist/components/pin-input/use-pin-input-context.js
var [PinInputProvider, usePinInputContext] = createContext3({
  name: "PinInputContext",
  hookName: "usePinInputContext",
  providerName: "<PinInputProvider />"
});

// node_modules/@ark-ui/react/dist/components/pin-input/pin-input-context.js
var PinInputContext = (props43) => props43.children(usePinInputContext());

// node_modules/@ark-ui/react/dist/components/pin-input/pin-input-control.js
var import_jsx_runtime254 = __toESM(require_jsx_runtime(), 1);
var import_react541 = __toESM(require_react(), 1);
var PinInputControl = (0, import_react541.forwardRef)((props43, ref) => {
  const pinInput = usePinInputContext();
  const mergedProps = mergeProps2(pinInput.getControlProps(), props43);
  return (0, import_jsx_runtime254.jsx)(ark.div, { ...mergedProps, ref });
});
PinInputControl.displayName = "PinInputControl";

// node_modules/@ark-ui/react/dist/components/pin-input/pin-input-hidden-input.js
var import_jsx_runtime255 = __toESM(require_jsx_runtime(), 1);
var import_react543 = __toESM(require_react(), 1);
var PinInputHiddenInput = (0, import_react543.forwardRef)((props43, ref) => {
  const pinInput = usePinInputContext();
  const mergedProps = mergeProps2(pinInput.getHiddenInputProps(), props43);
  const field = useFieldContext();
  return (0, import_jsx_runtime255.jsx)(ark.input, { "aria-describedby": field == null ? void 0 : field.ariaDescribedby, ...mergedProps, ref });
});
PinInputHiddenInput.displayName = "PinInputHiddenInput";

// node_modules/@ark-ui/react/dist/components/pin-input/pin-input-input.js
var import_jsx_runtime256 = __toESM(require_jsx_runtime(), 1);
var import_react545 = __toESM(require_react(), 1);
var PinInputInput = (0, import_react545.forwardRef)((props43, ref) => {
  const [inputProps2, localProps] = createSplitProps2()(props43, ["index"]);
  const pinInput = usePinInputContext();
  const mergedProps = mergeProps2(pinInput.getInputProps(inputProps2), localProps);
  return (0, import_jsx_runtime256.jsx)(ark.input, { ...mergedProps, ref });
});
PinInputInput.displayName = "PinInputInput";

// node_modules/@ark-ui/react/dist/components/pin-input/pin-input-label.js
var import_jsx_runtime257 = __toESM(require_jsx_runtime(), 1);
var import_react547 = __toESM(require_react(), 1);
var PinInputLabel = (0, import_react547.forwardRef)((props43, ref) => {
  const pinInput = usePinInputContext();
  const mergedProps = mergeProps2(pinInput.getLabelProps(), props43);
  return (0, import_jsx_runtime257.jsx)(ark.label, { ...mergedProps, ref });
});
PinInputLabel.displayName = "PinInputLabel";

// node_modules/@ark-ui/react/dist/components/pin-input/pin-input-root.js
var import_jsx_runtime258 = __toESM(require_jsx_runtime(), 1);
var import_react551 = __toESM(require_react(), 1);

// node_modules/@zag-js/pin-input/dist/index.mjs
var anatomy21 = createAnatomy("pinInput").parts("root", "label", "input", "control");
var parts23 = anatomy21.build();
var getRootId16 = (ctx) => {
  var _a8;
  return ((_a8 = ctx.ids) == null ? void 0 : _a8.root) ?? `pin-input:${ctx.id}`;
};
var getInputId7 = (ctx, id) => {
  var _a8, _b7;
  return ((_b7 = (_a8 = ctx.ids) == null ? void 0 : _a8.input) == null ? void 0 : _b7.call(_a8, id)) ?? `pin-input:${ctx.id}:${id}`;
};
var getHiddenInputId5 = (ctx) => {
  var _a8;
  return ((_a8 = ctx.ids) == null ? void 0 : _a8.hiddenInput) ?? `pin-input:${ctx.id}:hidden`;
};
var getLabelId10 = (ctx) => {
  var _a8;
  return ((_a8 = ctx.ids) == null ? void 0 : _a8.label) ?? `pin-input:${ctx.id}:label`;
};
var getControlId7 = (ctx) => {
  var _a8;
  return ((_a8 = ctx.ids) == null ? void 0 : _a8.control) ?? `pin-input:${ctx.id}:control`;
};
var getRootEl5 = (ctx) => ctx.getById(getRootId16(ctx));
var getInputEls2 = (ctx) => {
  const ownerId = CSS.escape(getRootId16(ctx));
  const selector = `input[data-ownedby=${ownerId}]`;
  return queryAll(getRootEl5(ctx), selector);
};
var getInputElAtIndex = (ctx, index) => getInputEls2(ctx)[index];
var getFirstInputEl = (ctx) => getInputEls2(ctx)[0];
var getHiddenInputEl5 = (ctx) => ctx.getById(getHiddenInputId5(ctx));
var setInputValue = (inputEl, value) => {
  inputEl.value = value;
  inputEl.setAttribute("value", value);
};
var REGEX = {
  numeric: /^[0-9]+$/,
  alphabetic: /^[A-Za-z]+$/,
  alphanumeric: /^[a-zA-Z0-9]+$/i
};
function isValidType(type, value) {
  var _a8;
  if (!type) return true;
  return !!((_a8 = REGEX[type]) == null ? void 0 : _a8.test(value));
}
function isValidValue(value, type, pattern) {
  if (!pattern) return isValidType(type, value);
  const regex = new RegExp(pattern, "g");
  return regex.test(value);
}
function connect22(service, normalize4) {
  const { send, context, computed, prop, scope } = service;
  const complete = computed("isValueComplete");
  const invalid = prop("invalid");
  const translations = prop("translations");
  const focusedIndex = context.get("focusedIndex");
  function focus() {
    var _a8;
    (_a8 = getFirstInputEl(scope)) == null ? void 0 : _a8.focus();
  }
  return {
    focus,
    count: context.get("count"),
    items: Array.from({ length: context.get("count") }).map((_, i) => i),
    value: context.get("value"),
    valueAsString: computed("valueAsString"),
    complete,
    setValue(value) {
      if (!Array.isArray(value)) {
        invariant("[pin-input/setValue] value must be an array");
      }
      send({ type: "VALUE.SET", value });
    },
    clearValue() {
      send({ type: "VALUE.CLEAR" });
    },
    setValueAtIndex(index, value) {
      send({ type: "VALUE.SET", value, index });
    },
    getRootProps() {
      return normalize4.element({
        dir: prop("dir"),
        ...parts23.root.attrs,
        id: getRootId16(scope),
        "data-invalid": dataAttr(invalid),
        "data-disabled": dataAttr(prop("disabled")),
        "data-complete": dataAttr(complete),
        "data-readonly": dataAttr(prop("readOnly"))
      });
    },
    getLabelProps() {
      return normalize4.label({
        ...parts23.label.attrs,
        dir: prop("dir"),
        htmlFor: getHiddenInputId5(scope),
        id: getLabelId10(scope),
        "data-invalid": dataAttr(invalid),
        "data-disabled": dataAttr(prop("disabled")),
        "data-complete": dataAttr(complete),
        "data-readonly": dataAttr(prop("readOnly")),
        onClick(event) {
          event.preventDefault();
          focus();
        }
      });
    },
    getHiddenInputProps() {
      return normalize4.input({
        "aria-hidden": true,
        type: "text",
        tabIndex: -1,
        id: getHiddenInputId5(scope),
        readOnly: prop("readOnly"),
        disabled: prop("disabled"),
        required: prop("required"),
        name: prop("name"),
        form: prop("form"),
        style: visuallyHiddenStyle,
        maxLength: computed("valueLength"),
        defaultValue: computed("valueAsString")
      });
    },
    getControlProps() {
      return normalize4.element({
        ...parts23.control.attrs,
        dir: prop("dir"),
        id: getControlId7(scope)
      });
    },
    getInputProps(props210) {
      var _a8;
      const { index } = props210;
      const inputType = prop("type") === "numeric" ? "tel" : "text";
      return normalize4.input({
        ...parts23.input.attrs,
        dir: prop("dir"),
        disabled: prop("disabled"),
        "data-disabled": dataAttr(prop("disabled")),
        "data-complete": dataAttr(complete),
        id: getInputId7(scope, index.toString()),
        "data-index": index,
        "data-ownedby": getRootId16(scope),
        "aria-label": (_a8 = translations == null ? void 0 : translations.inputLabel) == null ? void 0 : _a8.call(translations, index, computed("valueLength")),
        inputMode: prop("otp") || prop("type") === "numeric" ? "numeric" : "text",
        "aria-invalid": ariaAttr(invalid),
        "data-invalid": dataAttr(invalid),
        type: prop("mask") ? "password" : inputType,
        defaultValue: context.get("value")[index] || "",
        readOnly: prop("readOnly"),
        autoCapitalize: "none",
        autoComplete: prop("otp") ? "one-time-code" : "off",
        placeholder: focusedIndex === index ? "" : prop("placeholder"),
        onBeforeInput(event) {
          try {
            const value = getBeforeInputValue(event);
            const isValid = isValidValue(value, prop("type"), prop("pattern"));
            if (!isValid) {
              send({ type: "VALUE.INVALID", value });
              event.preventDefault();
            }
            if (value.length > 2) {
              event.currentTarget.setSelectionRange(0, 1, "forward");
            }
          } catch {
          }
        },
        onChange(event) {
          const evt = getNativeEvent(event);
          const { value } = event.currentTarget;
          if (evt.inputType === "insertFromPaste" || value.length > 2) {
            send({ type: "INPUT.PASTE", value });
            event.currentTarget.value = value[0];
            event.preventDefault();
            return;
          }
          if (evt.inputType === "deleteContentBackward") {
            send({ type: "INPUT.BACKSPACE" });
            return;
          }
          send({ type: "INPUT.CHANGE", value, index });
        },
        onKeyDown(event) {
          if (event.defaultPrevented) return;
          if (isComposingEvent(event)) return;
          if (isModifierKey(event)) return;
          const keyMap2 = {
            Backspace() {
              send({ type: "INPUT.BACKSPACE" });
            },
            Delete() {
              send({ type: "INPUT.DELETE" });
            },
            ArrowLeft() {
              send({ type: "INPUT.ARROW_LEFT" });
            },
            ArrowRight() {
              send({ type: "INPUT.ARROW_RIGHT" });
            },
            Enter() {
              send({ type: "INPUT.ENTER" });
            }
          };
          const exec = keyMap2[getEventKey(event, {
            dir: prop("dir"),
            orientation: "horizontal"
          })];
          if (exec) {
            exec(event);
            event.preventDefault();
          }
        },
        onFocus() {
          send({ type: "INPUT.FOCUS", index });
        },
        onBlur(event) {
          const target = event.relatedTarget;
          if (isHTMLElement(target) && target.dataset.ownedby === getRootId16(scope)) return;
          send({ type: "INPUT.BLUR", index });
        }
      });
    }
  };
}
var { choose: choose3, createMachine: createMachine4 } = setup();
var machine22 = createMachine4({
  props({ props: props210 }) {
    return {
      placeholder: "",
      otp: false,
      type: "numeric",
      defaultValue: props210.count ? fill([], props210.count) : [],
      ...props210,
      translations: {
        inputLabel: (index, length) => `pin code ${index + 1} of ${length}`,
        ...props210.translations
      }
    };
  },
  initialState() {
    return "idle";
  },
  context({ prop, bindable }) {
    return {
      value: bindable(() => ({
        value: prop("value"),
        defaultValue: prop("defaultValue"),
        isEqual,
        onChange(value) {
          var _a8;
          (_a8 = prop("onValueChange")) == null ? void 0 : _a8({ value, valueAsString: value.join("") });
        }
      })),
      focusedIndex: bindable(() => ({
        sync: true,
        defaultValue: -1
      })),
      // TODO: Move this to `props` in next major version
      count: bindable(() => ({
        defaultValue: prop("count")
      }))
    };
  },
  computed: {
    _value: ({ context }) => fill(context.get("value"), context.get("count")),
    valueLength: ({ computed }) => computed("_value").length,
    filledValueLength: ({ computed }) => computed("_value").filter((v) => (v == null ? void 0 : v.trim()) !== "").length,
    isValueComplete: ({ computed }) => computed("valueLength") === computed("filledValueLength"),
    valueAsString: ({ computed }) => computed("_value").join(""),
    focusedValue: ({ computed, context }) => computed("_value")[context.get("focusedIndex")] || ""
  },
  entry: choose3([
    {
      guard: "autoFocus",
      actions: ["setInputCount", "setFocusIndexToFirst"]
    },
    { actions: ["setInputCount"] }
  ]),
  watch({ action, track, context, computed }) {
    track([() => context.get("focusedIndex")], () => {
      action(["focusInput", "selectInputIfNeeded"]);
    });
    track([() => context.get("value").join(",")], () => {
      action(["syncInputElements", "dispatchInputEvent"]);
    });
    track([() => computed("isValueComplete")], () => {
      action(["invokeOnComplete", "blurFocusedInputIfNeeded"]);
    });
  },
  on: {
    "VALUE.SET": [
      {
        guard: "hasIndex",
        actions: ["setValueAtIndex"]
      },
      { actions: ["setValue"] }
    ],
    "VALUE.CLEAR": {
      actions: ["clearValue", "setFocusIndexToFirst"]
    }
  },
  states: {
    idle: {
      on: {
        "INPUT.FOCUS": {
          target: "focused",
          actions: ["setFocusedIndex"]
        }
      }
    },
    focused: {
      on: {
        "INPUT.CHANGE": {
          actions: ["setFocusedValue", "syncInputValue", "setNextFocusedIndex"]
        },
        "INPUT.PASTE": {
          actions: ["setPastedValue", "setLastValueFocusIndex"]
        },
        "INPUT.FOCUS": {
          actions: ["setFocusedIndex"]
        },
        "INPUT.BLUR": {
          target: "idle",
          actions: ["clearFocusedIndex"]
        },
        "INPUT.DELETE": {
          guard: "hasValue",
          actions: ["clearFocusedValue"]
        },
        "INPUT.ARROW_LEFT": {
          actions: ["setPrevFocusedIndex"]
        },
        "INPUT.ARROW_RIGHT": {
          actions: ["setNextFocusedIndex"]
        },
        "INPUT.BACKSPACE": [
          {
            guard: "hasValue",
            actions: ["clearFocusedValue"]
          },
          {
            actions: ["setPrevFocusedIndex", "clearFocusedValue"]
          }
        ],
        "INPUT.ENTER": {
          guard: "isValueComplete",
          actions: ["requestFormSubmit"]
        },
        "VALUE.INVALID": {
          actions: ["invokeOnInvalid"]
        }
      }
    }
  },
  implementations: {
    guards: {
      autoFocus: ({ prop }) => !!prop("autoFocus"),
      hasValue: ({ context }) => context.get("value")[context.get("focusedIndex")] !== "",
      isValueComplete: ({ computed }) => computed("isValueComplete"),
      hasIndex: ({ event }) => event.index !== void 0
    },
    actions: {
      dispatchInputEvent({ computed, scope }) {
        const inputEl = getHiddenInputEl5(scope);
        dispatchInputValueEvent(inputEl, { value: computed("valueAsString") });
      },
      setInputCount({ scope, context, prop }) {
        if (prop("count")) return;
        const inputEls = getInputEls2(scope);
        context.set("count", inputEls.length);
      },
      focusInput({ context, scope }) {
        var _a8;
        const focusedIndex = context.get("focusedIndex");
        if (focusedIndex === -1) return;
        (_a8 = getInputElAtIndex(scope, focusedIndex)) == null ? void 0 : _a8.focus({ preventScroll: true });
      },
      selectInputIfNeeded({ context, prop, scope }) {
        const focusedIndex = context.get("focusedIndex");
        if (!prop("selectOnFocus") || focusedIndex === -1) return;
        raf(() => {
          var _a8;
          (_a8 = getInputElAtIndex(scope, focusedIndex)) == null ? void 0 : _a8.select();
        });
      },
      invokeOnComplete({ computed, prop }) {
        var _a8;
        if (!computed("isValueComplete")) return;
        (_a8 = prop("onValueComplete")) == null ? void 0 : _a8({
          value: computed("_value"),
          valueAsString: computed("valueAsString")
        });
      },
      invokeOnInvalid({ context, event, prop }) {
        var _a8;
        (_a8 = prop("onValueInvalid")) == null ? void 0 : _a8({
          value: event.value,
          index: context.get("focusedIndex")
        });
      },
      clearFocusedIndex({ context }) {
        context.set("focusedIndex", -1);
      },
      setFocusedIndex({ context, event }) {
        context.set("focusedIndex", event.index);
      },
      setValue({ context, event }) {
        const value = fill(event.value, context.get("count"));
        context.set("value", value);
      },
      setFocusedValue({ context, event, computed, flush: flush2 }) {
        const focusedValue = computed("focusedValue");
        const focusedIndex = context.get("focusedIndex");
        const value = getNextValue(focusedValue, event.value);
        flush2(() => {
          context.set("value", setValueAtIndex(computed("_value"), focusedIndex, value));
        });
      },
      revertInputValue({ context, computed, scope }) {
        const inputEl = getInputElAtIndex(scope, context.get("focusedIndex"));
        setInputValue(inputEl, computed("focusedValue"));
      },
      syncInputValue({ context, event, scope }) {
        const value = context.get("value");
        const inputEl = getInputElAtIndex(scope, event.index);
        setInputValue(inputEl, value[event.index]);
      },
      syncInputElements({ context, scope }) {
        const inputEls = getInputEls2(scope);
        const value = context.get("value");
        inputEls.forEach((inputEl, index) => {
          setInputValue(inputEl, value[index]);
        });
      },
      setPastedValue({ context, event, computed, flush: flush2 }) {
        raf(() => {
          const valueAsString = computed("valueAsString");
          const focusedIndex = context.get("focusedIndex");
          const valueLength = computed("valueLength");
          const filledValueLength = computed("filledValueLength");
          const startIndex = Math.min(focusedIndex, filledValueLength);
          const left = startIndex > 0 ? valueAsString.substring(0, focusedIndex) : "";
          const right = event.value.substring(0, valueLength - startIndex);
          const value = fill(`${left}${right}`.split(""), valueLength);
          flush2(() => {
            context.set("value", value);
          });
        });
      },
      setValueAtIndex({ context, event, computed }) {
        const nextValue = getNextValue(computed("focusedValue"), event.value);
        context.set("value", setValueAtIndex(computed("_value"), event.index, nextValue));
      },
      clearValue({ context }) {
        const nextValue = Array.from({ length: context.get("count") }).fill("");
        context.set("value", nextValue);
      },
      clearFocusedValue({ context, computed }) {
        const focusedIndex = context.get("focusedIndex");
        if (focusedIndex === -1) return;
        context.set("value", setValueAtIndex(computed("_value"), focusedIndex, ""));
      },
      setFocusIndexToFirst({ context }) {
        context.set("focusedIndex", 0);
      },
      setNextFocusedIndex({ context, computed }) {
        context.set("focusedIndex", Math.min(context.get("focusedIndex") + 1, computed("valueLength") - 1));
      },
      setPrevFocusedIndex({ context }) {
        context.set("focusedIndex", Math.max(context.get("focusedIndex") - 1, 0));
      },
      setLastValueFocusIndex({ context, computed }) {
        raf(() => {
          context.set("focusedIndex", Math.min(computed("filledValueLength"), computed("valueLength") - 1));
        });
      },
      blurFocusedInputIfNeeded({ context, prop, scope }) {
        if (!prop("blurOnComplete")) return;
        raf(() => {
          var _a8;
          (_a8 = getInputElAtIndex(scope, context.get("focusedIndex"))) == null ? void 0 : _a8.blur();
        });
      },
      requestFormSubmit({ computed, prop, scope }) {
        var _a8;
        if (!prop("name") || !computed("isValueComplete")) return;
        const inputEl = getHiddenInputEl5(scope);
        (_a8 = inputEl == null ? void 0 : inputEl.form) == null ? void 0 : _a8.requestSubmit();
      }
    }
  }
});
function getNextValue(current, next2) {
  let nextValue = next2;
  if (current[0] === next2[0]) nextValue = next2[1];
  else if (current[0] === next2[1]) nextValue = next2[0];
  return nextValue.split("")[nextValue.length - 1];
}
function fill(value, count) {
  return Array.from({ length: count }).fill("").map((v, i) => value[i] || v);
}
var props22 = createProps()([
  "autoFocus",
  "blurOnComplete",
  "count",
  "defaultValue",
  "dir",
  "disabled",
  "form",
  "getRootNode",
  "id",
  "ids",
  "invalid",
  "mask",
  "name",
  "onValueChange",
  "onValueComplete",
  "onValueInvalid",
  "otp",
  "pattern",
  "placeholder",
  "readOnly",
  "required",
  "selectOnFocus",
  "translations",
  "type",
  "value"
]);
var splitProps22 = createSplitProps(props22);

// node_modules/@ark-ui/react/dist/components/pin-input/use-pin-input.js
var import_react549 = __toESM(require_react(), 1);
var usePinInput = (props43) => {
  const id = (0, import_react549.useId)();
  const { getRootNode } = useEnvironmentContext();
  const { dir } = useLocaleContext();
  const field = useFieldContext();
  const machineProps = {
    id,
    ids: {
      label: field == null ? void 0 : field.ids.label,
      hiddenInput: field == null ? void 0 : field.ids.control
    },
    disabled: field == null ? void 0 : field.disabled,
    readOnly: field == null ? void 0 : field.readOnly,
    required: field == null ? void 0 : field.required,
    invalid: field == null ? void 0 : field.invalid,
    dir,
    getRootNode,
    ...props43
  };
  const service = useMachine(machine22, machineProps);
  return connect22(service, normalizeProps);
};

// node_modules/@ark-ui/react/dist/components/pin-input/pin-input-root.js
var PinInputRoot = (0, import_react551.forwardRef)((props43, ref) => {
  const [usePinInputProps, localProps] = createSplitProps2()(props43, [
    "autoFocus",
    "blurOnComplete",
    "count",
    "defaultValue",
    "disabled",
    "form",
    "id",
    "ids",
    "invalid",
    "mask",
    "name",
    "onValueChange",
    "onValueComplete",
    "onValueInvalid",
    "otp",
    "pattern",
    "placeholder",
    "readOnly",
    "required",
    "selectOnFocus",
    "translations",
    "type",
    "value"
  ]);
  const pinInput = usePinInput(usePinInputProps);
  const mergedProps = mergeProps2(pinInput.getRootProps(), localProps);
  return (0, import_jsx_runtime258.jsx)(PinInputProvider, { value: pinInput, children: (0, import_jsx_runtime258.jsx)(ark.div, { ...mergedProps, ref }) });
});
PinInputRoot.displayName = "PinInputRoot";

// node_modules/@ark-ui/react/dist/components/pin-input/pin-input-root-provider.js
var import_jsx_runtime259 = __toESM(require_jsx_runtime(), 1);
var import_react553 = __toESM(require_react(), 1);
var PinInputRootProvider = (0, import_react553.forwardRef)((props43, ref) => {
  const [{ value: pinInput }, localProps] = createSplitProps2()(props43, ["value"]);
  const mergedProps = mergeProps2(pinInput.getRootProps(), localProps);
  return (0, import_jsx_runtime259.jsx)(PinInputProvider, { value: pinInput, children: (0, import_jsx_runtime259.jsx)(ark.div, { ...mergedProps, ref }) });
});
PinInputRootProvider.displayName = "PinInputRootProvider";

// node_modules/@ark-ui/react/dist/components/pin-input/pin-input.js
var pin_input_exports = {};
__export(pin_input_exports, {
  Context: () => PinInputContext,
  Control: () => PinInputControl,
  HiddenInput: () => PinInputHiddenInput,
  Input: () => PinInputInput,
  Label: () => PinInputLabel,
  Root: () => PinInputRoot,
  RootProvider: () => PinInputRootProvider
});

// node_modules/@ark-ui/react/dist/components/popover/popover-anchor.js
var import_jsx_runtime260 = __toESM(require_jsx_runtime(), 1);
var import_react555 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/popover/use-popover-context.js
var [PopoverProvider, usePopoverContext] = createContext3({
  name: "PopoverContext",
  hookName: "usePopoverContext",
  providerName: "<PopoverProvider />"
});

// node_modules/@ark-ui/react/dist/components/popover/popover-anchor.js
var PopoverAnchor = (0, import_react555.forwardRef)((props43, ref) => {
  const popover = usePopoverContext();
  const mergedProps = mergeProps2(popover.getAnchorProps(), props43);
  return (0, import_jsx_runtime260.jsx)(ark.div, { ...mergedProps, ref });
});
PopoverAnchor.displayName = "PopoverAnchor";

// node_modules/@ark-ui/react/dist/components/popover/popover-arrow.js
var import_jsx_runtime261 = __toESM(require_jsx_runtime(), 1);
var import_react557 = __toESM(require_react(), 1);
var PopoverArrow = (0, import_react557.forwardRef)((props43, ref) => {
  const popover = usePopoverContext();
  const mergedProps = mergeProps2(popover.getArrowProps(), props43);
  return (0, import_jsx_runtime261.jsx)(ark.div, { ...mergedProps, ref });
});
PopoverArrow.displayName = "PopoverArrow";

// node_modules/@ark-ui/react/dist/components/popover/popover-arrow-tip.js
var import_jsx_runtime262 = __toESM(require_jsx_runtime(), 1);
var import_react559 = __toESM(require_react(), 1);
var PopoverArrowTip = (0, import_react559.forwardRef)((props43, ref) => {
  const popover = usePopoverContext();
  const mergedProps = mergeProps2(popover.getArrowTipProps(), props43);
  return (0, import_jsx_runtime262.jsx)(ark.div, { ...mergedProps, ref });
});
PopoverArrowTip.displayName = "PopoverArrowTip";

// node_modules/@ark-ui/react/dist/components/popover/popover-close-trigger.js
var import_jsx_runtime263 = __toESM(require_jsx_runtime(), 1);
var import_react561 = __toESM(require_react(), 1);
var PopoverCloseTrigger = (0, import_react561.forwardRef)((props43, ref) => {
  const popover = usePopoverContext();
  const mergedProps = mergeProps2(popover.getCloseTriggerProps(), props43);
  return (0, import_jsx_runtime263.jsx)(ark.button, { ...mergedProps, ref });
});
PopoverCloseTrigger.displayName = "PopoverCloseTrigger";

// node_modules/@ark-ui/react/dist/components/popover/popover-content.js
var import_jsx_runtime264 = __toESM(require_jsx_runtime(), 1);
var import_react563 = __toESM(require_react(), 1);
var PopoverContent = (0, import_react563.forwardRef)((props43, ref) => {
  const popover = usePopoverContext();
  const presence = usePresenceContext();
  const mergedProps = mergeProps2(popover.getContentProps(), presence.getPresenceProps(), props43);
  if (presence.unmounted) {
    return null;
  }
  return (0, import_jsx_runtime264.jsx)(ark.div, { ...mergedProps, ref: composeRefs(presence.ref, ref) });
});
PopoverContent.displayName = "PopoverContent";

// node_modules/@ark-ui/react/dist/components/popover/popover-context.js
var PopoverContext = (props43) => props43.children(usePopoverContext());

// node_modules/@ark-ui/react/dist/components/popover/popover-description.js
var import_jsx_runtime265 = __toESM(require_jsx_runtime(), 1);
var import_react565 = __toESM(require_react(), 1);
var PopoverDescription = (0, import_react565.forwardRef)((props43, ref) => {
  const popover = usePopoverContext();
  const mergedProps = mergeProps2(popover.getDescriptionProps(), props43);
  return (0, import_jsx_runtime265.jsx)(ark.div, { ...mergedProps, ref });
});
PopoverDescription.displayName = "PopoverDescription";

// node_modules/@ark-ui/react/dist/components/popover/popover-indicator.js
var import_jsx_runtime266 = __toESM(require_jsx_runtime(), 1);
var import_react567 = __toESM(require_react(), 1);
var PopoverIndicator = (0, import_react567.forwardRef)((props43, ref) => {
  const popover = usePopoverContext();
  const mergedProps = mergeProps2(popover.getIndicatorProps(), props43);
  return (0, import_jsx_runtime266.jsx)(ark.div, { ...mergedProps, ref });
});
PopoverIndicator.displayName = "PopoverIndicator";

// node_modules/@ark-ui/react/dist/components/popover/popover-positioner.js
var import_jsx_runtime267 = __toESM(require_jsx_runtime(), 1);
var import_react569 = __toESM(require_react(), 1);
var PopoverPositioner = (0, import_react569.forwardRef)((props43, ref) => {
  const popover = usePopoverContext();
  const presence = usePresenceContext();
  const mergedProps = mergeProps2(popover.getPositionerProps(), props43);
  if (presence.unmounted) {
    return null;
  }
  return (0, import_jsx_runtime267.jsx)(ark.div, { ...mergedProps, ref });
});
PopoverPositioner.displayName = "PopoverPositioner";

// node_modules/@ark-ui/react/dist/components/popover/popover-root.js
var import_jsx_runtime268 = __toESM(require_jsx_runtime(), 1);

// node_modules/@zag-js/popover/dist/index.mjs
var anatomy22 = createAnatomy("popover").parts(
  "arrow",
  "arrowTip",
  "anchor",
  "trigger",
  "indicator",
  "positioner",
  "content",
  "title",
  "description",
  "closeTrigger"
);
var parts24 = anatomy22.build();
var getAnchorId = (scope) => {
  var _a8;
  return ((_a8 = scope.ids) == null ? void 0 : _a8.anchor) ?? `popover:${scope.id}:anchor`;
};
var getTriggerId10 = (scope) => {
  var _a8;
  return ((_a8 = scope.ids) == null ? void 0 : _a8.trigger) ?? `popover:${scope.id}:trigger`;
};
var getContentId10 = (scope) => {
  var _a8;
  return ((_a8 = scope.ids) == null ? void 0 : _a8.content) ?? `popover:${scope.id}:content`;
};
var getPositionerId8 = (scope) => {
  var _a8;
  return ((_a8 = scope.ids) == null ? void 0 : _a8.positioner) ?? `popover:${scope.id}:popper`;
};
var getArrowId3 = (scope) => {
  var _a8;
  return ((_a8 = scope.ids) == null ? void 0 : _a8.arrow) ?? `popover:${scope.id}:arrow`;
};
var getTitleId2 = (scope) => {
  var _a8;
  return ((_a8 = scope.ids) == null ? void 0 : _a8.title) ?? `popover:${scope.id}:title`;
};
var getDescriptionId2 = (scope) => {
  var _a8;
  return ((_a8 = scope.ids) == null ? void 0 : _a8.description) ?? `popover:${scope.id}:desc`;
};
var getCloseTriggerId2 = (scope) => {
  var _a8;
  return ((_a8 = scope.ids) == null ? void 0 : _a8.closeTrigger) ?? `popover:${scope.id}:close`;
};
var getAnchorEl = (scope) => scope.getById(getAnchorId(scope));
var getTriggerEl8 = (scope) => scope.getById(getTriggerId10(scope));
var getContentEl10 = (scope) => scope.getById(getContentId10(scope));
var getPositionerEl8 = (scope) => scope.getById(getPositionerId8(scope));
var getTitleEl2 = (scope) => scope.getById(getTitleId2(scope));
var getDescriptionEl2 = (scope) => scope.getById(getDescriptionId2(scope));
function connect23(service, normalize4) {
  const { state: state2, context, send, computed, prop, scope } = service;
  const open = state2.matches("open");
  const currentPlacement = context.get("currentPlacement");
  const portalled = computed("currentPortalled");
  const rendered = context.get("renderedElements");
  const popperStyles = getPlacementStyles({
    ...prop("positioning"),
    placement: currentPlacement
  });
  return {
    portalled,
    open,
    setOpen(nextOpen) {
      const open2 = state2.matches("open");
      if (open2 === nextOpen) return;
      send({ type: nextOpen ? "OPEN" : "CLOSE" });
    },
    reposition(options = {}) {
      send({ type: "POSITIONING.SET", options });
    },
    getArrowProps() {
      return normalize4.element({
        id: getArrowId3(scope),
        ...parts24.arrow.attrs,
        dir: prop("dir"),
        style: popperStyles.arrow
      });
    },
    getArrowTipProps() {
      return normalize4.element({
        ...parts24.arrowTip.attrs,
        dir: prop("dir"),
        style: popperStyles.arrowTip
      });
    },
    getAnchorProps() {
      return normalize4.element({
        ...parts24.anchor.attrs,
        dir: prop("dir"),
        id: getAnchorId(scope)
      });
    },
    getTriggerProps() {
      return normalize4.button({
        ...parts24.trigger.attrs,
        dir: prop("dir"),
        type: "button",
        "data-placement": currentPlacement,
        id: getTriggerId10(scope),
        "aria-haspopup": "dialog",
        "aria-expanded": open,
        "data-state": open ? "open" : "closed",
        "aria-controls": getContentId10(scope),
        onPointerDown(event) {
          if (isSafari()) {
            event.currentTarget.focus();
          }
        },
        onClick(event) {
          if (event.defaultPrevented) return;
          send({ type: "TOGGLE" });
        },
        onBlur(event) {
          send({ type: "TRIGGER_BLUR", target: event.relatedTarget });
        }
      });
    },
    getIndicatorProps() {
      return normalize4.element({
        ...parts24.indicator.attrs,
        dir: prop("dir"),
        "data-state": open ? "open" : "closed"
      });
    },
    getPositionerProps() {
      return normalize4.element({
        id: getPositionerId8(scope),
        ...parts24.positioner.attrs,
        dir: prop("dir"),
        style: popperStyles.floating
      });
    },
    getContentProps() {
      return normalize4.element({
        ...parts24.content.attrs,
        dir: prop("dir"),
        id: getContentId10(scope),
        tabIndex: -1,
        role: "dialog",
        hidden: !open,
        "data-state": open ? "open" : "closed",
        "data-expanded": dataAttr(open),
        "aria-labelledby": rendered.title ? getTitleId2(scope) : void 0,
        "aria-describedby": rendered.description ? getDescriptionId2(scope) : void 0,
        "data-placement": currentPlacement
      });
    },
    getTitleProps() {
      return normalize4.element({
        ...parts24.title.attrs,
        id: getTitleId2(scope),
        dir: prop("dir")
      });
    },
    getDescriptionProps() {
      return normalize4.element({
        ...parts24.description.attrs,
        id: getDescriptionId2(scope),
        dir: prop("dir")
      });
    },
    getCloseTriggerProps() {
      return normalize4.button({
        ...parts24.closeTrigger.attrs,
        dir: prop("dir"),
        id: getCloseTriggerId2(scope),
        type: "button",
        "aria-label": "close",
        onClick(event) {
          if (event.defaultPrevented) return;
          event.stopPropagation();
          send({ type: "CLOSE" });
        }
      });
    }
  };
}
var machine23 = createMachine({
  props({ props: props210 }) {
    return {
      closeOnInteractOutside: true,
      closeOnEscape: true,
      autoFocus: true,
      modal: false,
      portalled: true,
      ...props210,
      positioning: {
        placement: "bottom",
        ...props210.positioning
      }
    };
  },
  initialState({ prop }) {
    const open = prop("open") || prop("defaultOpen");
    return open ? "open" : "closed";
  },
  context({ bindable }) {
    return {
      currentPlacement: bindable(() => ({
        defaultValue: void 0
      })),
      renderedElements: bindable(() => ({
        defaultValue: { title: true, description: true }
      }))
    };
  },
  computed: {
    currentPortalled: ({ prop }) => !!prop("modal") || !!prop("portalled")
  },
  watch({ track, prop, action }) {
    track([() => prop("open")], () => {
      action(["toggleVisibility"]);
    });
  },
  entry: ["checkRenderedElements"],
  states: {
    closed: {
      on: {
        "CONTROLLED.OPEN": {
          target: "open",
          actions: ["setInitialFocus"]
        },
        TOGGLE: [
          {
            guard: "isOpenControlled",
            actions: ["invokeOnOpen"]
          },
          {
            target: "open",
            actions: ["invokeOnOpen", "setInitialFocus"]
          }
        ],
        OPEN: [
          {
            guard: "isOpenControlled",
            actions: ["invokeOnOpen"]
          },
          {
            target: "open",
            actions: ["invokeOnOpen", "setInitialFocus"]
          }
        ]
      }
    },
    open: {
      effects: [
        "trapFocus",
        "preventScroll",
        "hideContentBelow",
        "trackPositioning",
        "trackDismissableElement",
        "proxyTabFocus"
      ],
      on: {
        "CONTROLLED.CLOSE": {
          target: "closed",
          actions: ["setFinalFocus"]
        },
        CLOSE: [
          {
            guard: "isOpenControlled",
            actions: ["invokeOnClose"]
          },
          {
            target: "closed",
            actions: ["invokeOnClose", "setFinalFocus"]
          }
        ],
        TOGGLE: [
          {
            guard: "isOpenControlled",
            actions: ["invokeOnClose"]
          },
          {
            target: "closed",
            actions: ["invokeOnClose"]
          }
        ],
        "POSITIONING.SET": {
          actions: ["reposition"]
        }
      }
    }
  },
  implementations: {
    guards: {
      isOpenControlled: ({ prop }) => prop("open") != void 0
    },
    effects: {
      trackPositioning({ context, prop, scope }) {
        context.set("currentPlacement", prop("positioning").placement);
        const anchorEl = getAnchorEl(scope) ?? getTriggerEl8(scope);
        const getPositionerEl22 = () => getPositionerEl8(scope);
        return getPlacement(anchorEl, getPositionerEl22, {
          ...prop("positioning"),
          defer: true,
          onComplete(data) {
            context.set("currentPlacement", data.placement);
          }
        });
      },
      trackDismissableElement({ send, prop, scope }) {
        const getContentEl22 = () => getContentEl10(scope);
        let restoreFocus = true;
        return trackDismissableElement(getContentEl22, {
          pointerBlocking: prop("modal"),
          exclude: getTriggerEl8(scope),
          defer: true,
          onEscapeKeyDown(event) {
            var _a8;
            (_a8 = prop("onEscapeKeyDown")) == null ? void 0 : _a8(event);
            if (prop("closeOnEscape")) return;
            event.preventDefault();
          },
          onInteractOutside(event) {
            var _a8;
            (_a8 = prop("onInteractOutside")) == null ? void 0 : _a8(event);
            if (event.defaultPrevented) return;
            restoreFocus = !(event.detail.focusable || event.detail.contextmenu);
            if (!prop("closeOnInteractOutside")) {
              event.preventDefault();
            }
          },
          onPointerDownOutside: prop("onPointerDownOutside"),
          onFocusOutside: prop("onFocusOutside"),
          persistentElements: prop("persistentElements"),
          onDismiss() {
            send({ type: "CLOSE", src: "interact-outside", restoreFocus });
          }
        });
      },
      proxyTabFocus({ prop, scope }) {
        if (prop("modal") || !prop("portalled")) return;
        const getContentEl22 = () => getContentEl10(scope);
        return proxyTabFocus(getContentEl22, {
          triggerElement: getTriggerEl8(scope),
          defer: true,
          onFocus(el) {
            el.focus({ preventScroll: true });
          }
        });
      },
      hideContentBelow({ prop, scope }) {
        if (!prop("modal")) return;
        const getElements4 = () => [getContentEl10(scope), getTriggerEl8(scope)];
        return ariaHidden(getElements4, { defer: true });
      },
      preventScroll({ prop, scope }) {
        if (!prop("modal")) return;
        return preventBodyScroll(scope.getDoc());
      },
      trapFocus({ prop, scope }) {
        if (!prop("modal")) return;
        const contentEl = () => getContentEl10(scope);
        return trapFocus(contentEl, {
          initialFocus: () => getInitialFocus({
            root: getContentEl10(scope),
            getInitialEl: prop("initialFocusEl"),
            enabled: prop("autoFocus")
          })
        });
      }
    },
    actions: {
      reposition({ event, prop, scope, context }) {
        const anchorEl = getAnchorEl(scope) ?? getTriggerEl8(scope);
        const getPositionerEl22 = () => getPositionerEl8(scope);
        getPlacement(anchorEl, getPositionerEl22, {
          ...prop("positioning"),
          ...event.options,
          defer: true,
          listeners: false,
          onComplete(data) {
            context.set("currentPlacement", data.placement);
          }
        });
      },
      checkRenderedElements({ context, scope }) {
        raf(() => {
          Object.assign(context.get("renderedElements"), {
            title: !!getTitleEl2(scope),
            description: !!getDescriptionEl2(scope)
          });
        });
      },
      setInitialFocus({ prop, scope }) {
        if (prop("modal")) return;
        raf(() => {
          const element = getInitialFocus({
            root: getContentEl10(scope),
            getInitialEl: prop("initialFocusEl"),
            enabled: prop("autoFocus")
          });
          element == null ? void 0 : element.focus({ preventScroll: true });
        });
      },
      setFinalFocus({ event, scope }) {
        var _a8;
        const restoreFocus = event.restoreFocus ?? ((_a8 = event.previousEvent) == null ? void 0 : _a8.restoreFocus);
        if (restoreFocus != null && !restoreFocus) return;
        raf(() => {
          const element = getTriggerEl8(scope);
          element == null ? void 0 : element.focus({ preventScroll: true });
        });
      },
      invokeOnOpen({ prop }) {
        var _a8;
        (_a8 = prop("onOpenChange")) == null ? void 0 : _a8({ open: true });
      },
      invokeOnClose({ prop }) {
        var _a8;
        (_a8 = prop("onOpenChange")) == null ? void 0 : _a8({ open: false });
      },
      toggleVisibility({ event, send, prop }) {
        send({ type: prop("open") ? "CONTROLLED.OPEN" : "CONTROLLED.CLOSE", previousEvent: event });
      }
    }
  }
});
var props23 = createProps()([
  "autoFocus",
  "closeOnEscape",
  "closeOnInteractOutside",
  "dir",
  "getRootNode",
  "id",
  "ids",
  "initialFocusEl",
  "modal",
  "onEscapeKeyDown",
  "onFocusOutside",
  "onInteractOutside",
  "onOpenChange",
  "onPointerDownOutside",
  "defaultOpen",
  "open",
  "persistentElements",
  "portalled",
  "positioning"
]);
var splitProps23 = createSplitProps(props23);

// node_modules/@ark-ui/react/dist/components/popover/use-popover.js
var import_react571 = __toESM(require_react(), 1);
var usePopover = (props43) => {
  const id = (0, import_react571.useId)();
  const { getRootNode } = useEnvironmentContext();
  const { dir } = useLocaleContext();
  const machineProps = {
    id,
    dir,
    getRootNode,
    ...props43
  };
  const service = useMachine(machine23, machineProps);
  return connect23(service, normalizeProps);
};

// node_modules/@ark-ui/react/dist/components/popover/popover-root.js
var PopoverRoot = (props43) => {
  const [presenceProps, { children, ...localProps }] = splitPresenceProps(props43);
  const popover = usePopover(localProps);
  const presence = usePresence(mergeProps2({ present: popover.open }, presenceProps));
  return (0, import_jsx_runtime268.jsx)(PopoverProvider, { value: popover, children: (0, import_jsx_runtime268.jsx)(PresenceProvider, { value: presence, children }) });
};

// node_modules/@ark-ui/react/dist/components/popover/popover-root-provider.js
var import_jsx_runtime269 = __toESM(require_jsx_runtime(), 1);
var PopoverRootProvider = (props43) => {
  const [presenceProps, { value: popover, children }] = splitPresenceProps(props43);
  const presence = usePresence(mergeProps2({ present: popover.open }, presenceProps));
  return (0, import_jsx_runtime269.jsx)(PopoverProvider, { value: popover, children: (0, import_jsx_runtime269.jsx)(PresenceProvider, { value: presence, children }) });
};

// node_modules/@ark-ui/react/dist/components/popover/popover-title.js
var import_jsx_runtime270 = __toESM(require_jsx_runtime(), 1);
var import_react575 = __toESM(require_react(), 1);
var PopoverTitle = (0, import_react575.forwardRef)((props43, ref) => {
  const popover = usePopoverContext();
  const mergedProps = mergeProps2(popover.getTitleProps(), props43);
  return (0, import_jsx_runtime270.jsx)(ark.div, { ...mergedProps, ref });
});
PopoverTitle.displayName = "PopoverTitle";

// node_modules/@ark-ui/react/dist/components/popover/popover-trigger.js
var import_jsx_runtime271 = __toESM(require_jsx_runtime(), 1);
var import_react577 = __toESM(require_react(), 1);
var PopoverTrigger = (0, import_react577.forwardRef)((props43, ref) => {
  const popover = usePopoverContext();
  const presence = usePresenceContext();
  const mergedProps = mergeProps2(
    {
      ...popover.getTriggerProps(),
      "aria-controls": presence.unmounted ? void 0 : popover.getTriggerProps()["aria-controls"]
    },
    props43
  );
  return (0, import_jsx_runtime271.jsx)(ark.button, { ...mergedProps, ref });
});
PopoverTrigger.displayName = "PopoverTrigger";

// node_modules/@ark-ui/react/dist/components/popover/popover.js
var popover_exports = {};
__export(popover_exports, {
  Anchor: () => PopoverAnchor,
  Arrow: () => PopoverArrow,
  ArrowTip: () => PopoverArrowTip,
  CloseTrigger: () => PopoverCloseTrigger,
  Content: () => PopoverContent,
  Context: () => PopoverContext,
  Description: () => PopoverDescription,
  Indicator: () => PopoverIndicator,
  Positioner: () => PopoverPositioner,
  Root: () => PopoverRoot,
  RootProvider: () => PopoverRootProvider,
  Title: () => PopoverTitle,
  Trigger: () => PopoverTrigger
});

// node_modules/@ark-ui/react/dist/components/portal/portal.js
var import_jsx_runtime272 = __toESM(require_jsx_runtime(), 1);
var import_react578 = __toESM(require_react(), 1);
var import_react_dom3 = __toESM(require_react_dom(), 1);
var Portal = (props43) => {
  var _a8;
  const { children, disabled } = props43;
  const [container, setContainer] = (0, import_react578.useState)((_a8 = props43.container) == null ? void 0 : _a8.current);
  const isServer = (0, import_react578.useSyncExternalStore)(
    subscribe2,
    () => false,
    () => true
  );
  const { getRootNode } = useEnvironmentContext();
  (0, import_react578.useEffect)(() => {
    setContainer(() => {
      var _a9;
      return (_a9 = props43.container) == null ? void 0 : _a9.current;
    });
  }, [props43.container]);
  if (isServer || disabled) return (0, import_jsx_runtime272.jsx)(import_jsx_runtime272.Fragment, { children });
  const mountNode = container ?? getPortalNode(getRootNode);
  return (0, import_jsx_runtime272.jsx)(import_jsx_runtime272.Fragment, { children: import_react578.Children.map(children, (child) => (0, import_react_dom3.createPortal)(child, mountNode)) });
};
var getPortalNode = (cb) => {
  const node = cb == null ? void 0 : cb();
  const rootNode = node.getRootNode();
  if (isShadowRoot(rootNode)) return rootNode;
  return getDocument(node).body;
};
var subscribe2 = () => () => {
};

// node_modules/@ark-ui/react/dist/components/progress/progress-circle.js
var import_jsx_runtime273 = __toESM(require_jsx_runtime(), 1);
var import_react580 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/progress/use-progress-context.js
var [ProgressProvider, useProgressContext] = createContext3({
  name: "ProgressContext",
  hookName: "useProgressContext",
  providerName: "<ProgressProvider />"
});

// node_modules/@ark-ui/react/dist/components/progress/progress-circle.js
var ProgressCircle = (0, import_react580.forwardRef)((props43, ref) => {
  const progress = useProgressContext();
  const mergedProps = mergeProps2(progress.getCircleProps(), props43);
  return (0, import_jsx_runtime273.jsx)(ark.svg, { ref, ...mergedProps });
});
ProgressCircle.displayName = "ProgressCircle";

// node_modules/@ark-ui/react/dist/components/progress/progress-circle-range.js
var import_jsx_runtime274 = __toESM(require_jsx_runtime(), 1);
var import_react582 = __toESM(require_react(), 1);
var ProgressCircleRange = (0, import_react582.forwardRef)((props43, ref) => {
  const progress = useProgressContext();
  const mergedProps = mergeProps2(progress.getCircleRangeProps(), props43);
  return (0, import_jsx_runtime274.jsx)(ark.circle, { ref, ...mergedProps });
});
ProgressCircleRange.displayName = "ProgressCircleRange";

// node_modules/@ark-ui/react/dist/components/progress/progress-circle-track.js
var import_jsx_runtime275 = __toESM(require_jsx_runtime(), 1);
var import_react584 = __toESM(require_react(), 1);
var ProgressCircleTrack = (0, import_react584.forwardRef)((props43, ref) => {
  const progress = useProgressContext();
  const mergedProps = mergeProps2(progress.getCircleTrackProps(), props43);
  return (0, import_jsx_runtime275.jsx)(ark.circle, { ref, ...mergedProps });
});
ProgressCircleTrack.displayName = "ProgressCircleTrack";

// node_modules/@ark-ui/react/dist/components/progress/progress-context.js
var ProgressContext = (props43) => props43.children(useProgressContext());

// node_modules/@ark-ui/react/dist/components/progress/progress-label.js
var import_jsx_runtime276 = __toESM(require_jsx_runtime(), 1);
var import_react586 = __toESM(require_react(), 1);
var ProgressLabel = (0, import_react586.forwardRef)((props43, ref) => {
  const progress = useProgressContext();
  const mergedProps = mergeProps2(progress.getLabelProps(), props43);
  return (0, import_jsx_runtime276.jsx)(ark.label, { ...mergedProps, ref });
});
ProgressLabel.displayName = "ProgressLabel";

// node_modules/@ark-ui/react/dist/components/progress/progress-range.js
var import_jsx_runtime277 = __toESM(require_jsx_runtime(), 1);
var import_react588 = __toESM(require_react(), 1);
var ProgressRange = (0, import_react588.forwardRef)((props43, ref) => {
  const progress = useProgressContext();
  const mergedProps = mergeProps2(progress.getRangeProps(), props43);
  return (0, import_jsx_runtime277.jsx)(ark.div, { ...mergedProps, ref });
});
ProgressRange.displayName = "ProgressRange";

// node_modules/@ark-ui/react/dist/components/progress/progress-root.js
var import_jsx_runtime278 = __toESM(require_jsx_runtime(), 1);
var import_react592 = __toESM(require_react(), 1);

// node_modules/@zag-js/progress/dist/index.mjs
var anatomy23 = createAnatomy("progress").parts(
  "root",
  "label",
  "track",
  "range",
  "valueText",
  "view",
  "circle",
  "circleTrack",
  "circleRange"
);
var parts25 = anatomy23.build();
var getRootId17 = (ctx) => {
  var _a8;
  return ((_a8 = ctx.ids) == null ? void 0 : _a8.root) ?? `progress-${ctx.id}`;
};
var getTrackId = (ctx) => {
  var _a8;
  return ((_a8 = ctx.ids) == null ? void 0 : _a8.track) ?? `progress-${ctx.id}-track`;
};
var getLabelId11 = (ctx) => {
  var _a8;
  return ((_a8 = ctx.ids) == null ? void 0 : _a8.label) ?? `progress-${ctx.id}-label`;
};
var getCircleId = (ctx) => {
  var _a8;
  return ((_a8 = ctx.ids) == null ? void 0 : _a8.circle) ?? `progress-${ctx.id}-circle`;
};
function connect24(service, normalize4) {
  const { context, computed, prop, send, scope } = service;
  const percent = computed("percent");
  const percentAsString = computed("isIndeterminate") ? "" : computed("formatter").format(computed("percent") / 100);
  const max4 = prop("max");
  const min4 = prop("min");
  const orientation = prop("orientation");
  const translations = prop("translations");
  const indeterminate = computed("isIndeterminate");
  const value = context.get("value");
  const valueAsString = (translations == null ? void 0 : translations.value({ value, max: max4, percent, min: min4 })) ?? "";
  const progressState = getProgressState(value, max4);
  const progressbarProps = {
    role: "progressbar",
    "aria-label": valueAsString,
    "data-max": max4,
    "aria-valuemin": min4,
    "aria-valuemax": max4,
    "aria-valuenow": value ?? void 0,
    "data-orientation": orientation,
    "data-state": progressState
  };
  const circleProps2 = getCircleProps(service);
  return {
    value,
    valueAsString,
    min: min4,
    max: max4,
    percent,
    percentAsString,
    indeterminate,
    setValue(value2) {
      send({ type: "VALUE.SET", value: value2 });
    },
    setToMax() {
      send({ type: "VALUE.SET", value: max4 });
    },
    setToMin() {
      send({ type: "VALUE.SET", value: min4 });
    },
    getRootProps() {
      return normalize4.element({
        dir: prop("dir"),
        ...parts25.root.attrs,
        id: getRootId17(scope),
        "data-max": max4,
        "data-value": value ?? void 0,
        "data-state": progressState,
        "data-orientation": orientation,
        style: {
          "--percent": indeterminate ? void 0 : percent
        }
      });
    },
    getLabelProps() {
      return normalize4.element({
        dir: prop("dir"),
        id: getLabelId11(scope),
        ...parts25.label.attrs,
        "data-orientation": orientation
      });
    },
    getValueTextProps() {
      return normalize4.element({
        dir: prop("dir"),
        "aria-live": "polite",
        ...parts25.valueText.attrs
      });
    },
    getTrackProps() {
      return normalize4.element({
        dir: prop("dir"),
        id: getTrackId(scope),
        ...parts25.track.attrs,
        ...progressbarProps
      });
    },
    getRangeProps() {
      return normalize4.element({
        dir: prop("dir"),
        ...parts25.range.attrs,
        "data-orientation": orientation,
        "data-state": progressState,
        style: {
          [computed("isHorizontal") ? "width" : "height"]: indeterminate ? void 0 : `${percent}%`
        }
      });
    },
    getCircleProps() {
      return normalize4.element({
        dir: prop("dir"),
        id: getCircleId(scope),
        ...parts25.circle.attrs,
        ...progressbarProps,
        ...circleProps2.root
      });
    },
    getCircleTrackProps() {
      return normalize4.element({
        dir: prop("dir"),
        "data-orientation": orientation,
        ...parts25.circleTrack.attrs,
        ...circleProps2.track
      });
    },
    getCircleRangeProps() {
      return normalize4.element({
        dir: prop("dir"),
        ...parts25.circleRange.attrs,
        ...circleProps2.range,
        "data-state": progressState
      });
    },
    getViewProps(props210) {
      return normalize4.element({
        dir: prop("dir"),
        ...parts25.view.attrs,
        "data-state": props210.state,
        hidden: props210.state !== progressState
      });
    }
  };
}
function getProgressState(value, maxValue2) {
  return value == null ? "indeterminate" : value === maxValue2 ? "complete" : "loading";
}
var circleProps = {
  style: {
    "--radius": "calc(var(--size) / 2 - var(--thickness) / 2)",
    cx: "calc(var(--size) / 2)",
    cy: "calc(var(--size) / 2)",
    r: "var(--radius)",
    fill: "transparent",
    strokeWidth: "var(--thickness)"
  }
};
var rootProps = {
  style: {
    width: "var(--size)",
    height: "var(--size)"
  }
};
function getCircleProps(service) {
  const { context, computed } = service;
  return {
    root: rootProps,
    track: circleProps,
    range: {
      opacity: context.get("value") === 0 ? 0 : void 0,
      style: {
        ...circleProps.style,
        "--percent": computed("percent"),
        "--circumference": `calc(2 * 3.14159 * var(--radius))`,
        "--offset": `calc(var(--circumference) * (100 - var(--percent)) / 100)`,
        strokeDashoffset: `calc(var(--circumference) * ((100 - var(--percent)) / 100))`,
        strokeDasharray: computed("isIndeterminate") ? void 0 : `var(--circumference)`,
        transformOrigin: "center",
        transform: "rotate(-90deg)"
      }
    }
  };
}
var machine24 = createMachine({
  props({ props: props210 }) {
    const min4 = props210.min ?? 0;
    const max4 = props210.max ?? 100;
    return {
      ...props210,
      max: max4,
      min: min4,
      defaultValue: props210.defaultValue ?? midValue(min4, max4),
      orientation: "horizontal",
      formatOptions: {
        style: "percent",
        ...props210.formatOptions
      },
      translations: {
        value: ({ percent }) => percent === -1 ? "loading..." : `${percent} percent`,
        ...props210.translations
      }
    };
  },
  initialState() {
    return "idle";
  },
  entry: ["validateContext"],
  context({ bindable, prop }) {
    return {
      value: bindable(() => ({
        defaultValue: prop("defaultValue"),
        value: prop("value"),
        onChange(value) {
          var _a8;
          (_a8 = prop("onValueChange")) == null ? void 0 : _a8({ value });
        }
      }))
    };
  },
  computed: {
    isIndeterminate: ({ context }) => context.get("value") === null,
    percent({ context, prop }) {
      const value = context.get("value");
      if (!isNumber(value)) return -1;
      return getValuePercent(value, prop("min"), prop("max")) * 100;
    },
    formatter: memo(
      ({ prop }) => [prop("locale"), prop("formatOptions")],
      (locale, formatOptions) => new Intl.NumberFormat(locale, formatOptions)
    ),
    isHorizontal: ({ prop }) => prop("orientation") === "horizontal"
  },
  states: {
    idle: {
      on: {
        "VALUE.SET": {
          actions: ["setValue"]
        }
      }
    }
  },
  implementations: {
    actions: {
      setValue: ({ context, event, prop }) => {
        const value = event.value === null ? null : Math.max(0, Math.min(event.value, prop("max")));
        context.set("value", value);
      },
      validateContext: ({ context, prop }) => {
        const max4 = prop("max");
        const min4 = prop("min");
        const value = context.get("value");
        if (value == null) return;
        if (!isValidNumber(max4)) {
          throw new Error(`[progress] The max value passed \`${max4}\` is not a valid number`);
        }
        if (!isValidMax(value, max4)) {
          throw new Error(`[progress] The value passed \`${value}\` exceeds the max value \`${max4}\``);
        }
        if (!isValidMin(value, min4)) {
          throw new Error(`[progress] The value passed \`${value}\` exceeds the min value \`${min4}\``);
        }
      }
    }
  }
});
var isValidNumber = (max4) => isNumber(max4) && !isNaN(max4);
var isValidMax = (value, max4) => isValidNumber(value) && value <= max4;
var isValidMin = (value, min4) => isValidNumber(value) && value >= min4;
var midValue = (min4, max4) => min4 + (max4 - min4) / 2;
var props24 = createProps()([
  "dir",
  "getRootNode",
  "id",
  "ids",
  "max",
  "min",
  "orientation",
  "translations",
  "value",
  "onValueChange",
  "defaultValue",
  "formatOptions",
  "locale"
]);
var splitProps24 = createSplitProps(props24);

// node_modules/@ark-ui/react/dist/components/progress/use-progress.js
var import_react590 = __toESM(require_react(), 1);
var useProgress = (props43) => {
  const id = (0, import_react590.useId)();
  const { getRootNode } = useEnvironmentContext();
  const { dir, locale } = useLocaleContext();
  const machineProps = {
    id,
    dir,
    locale,
    getRootNode,
    ...props43
  };
  const service = useMachine(machine24, machineProps);
  return connect24(service, normalizeProps);
};

// node_modules/@ark-ui/react/dist/components/progress/progress-root.js
var ProgressRoot = (0, import_react592.forwardRef)((props43, ref) => {
  const [progressProps, localProps] = createSplitProps2()(props43, [
    "defaultValue",
    "formatOptions",
    "id",
    "ids",
    "locale",
    "max",
    "min",
    "onValueChange",
    "orientation",
    "translations",
    "value"
  ]);
  const progress = useProgress(progressProps);
  const mergedProps = mergeProps2(progress.getRootProps(), localProps);
  return (0, import_jsx_runtime278.jsx)(ProgressProvider, { value: progress, children: (0, import_jsx_runtime278.jsx)(ark.div, { ...mergedProps, ref }) });
});
ProgressRoot.displayName = "ProgressRoot";

// node_modules/@ark-ui/react/dist/components/progress/progress-root-provider.js
var import_jsx_runtime279 = __toESM(require_jsx_runtime(), 1);
var import_react594 = __toESM(require_react(), 1);
var ProgressRootProvider = (0, import_react594.forwardRef)((props43, ref) => {
  const [{ value: progress }, localProps] = createSplitProps2()(props43, ["value"]);
  const mergedProps = mergeProps2(progress.getRootProps(), localProps);
  return (0, import_jsx_runtime279.jsx)(ProgressProvider, { value: progress, children: (0, import_jsx_runtime279.jsx)(ark.div, { ...mergedProps, ref }) });
});
ProgressRootProvider.displayName = "ProgressRootProvider";

// node_modules/@ark-ui/react/dist/components/progress/progress-track.js
var import_jsx_runtime280 = __toESM(require_jsx_runtime(), 1);
var import_react596 = __toESM(require_react(), 1);
var ProgressTrack = (0, import_react596.forwardRef)((props43, ref) => {
  const progress = useProgressContext();
  const mergedProps = mergeProps2(progress.getTrackProps(), props43);
  return (0, import_jsx_runtime280.jsx)(ark.div, { ...mergedProps, ref });
});
ProgressTrack.displayName = "ProgressTrack";

// node_modules/@ark-ui/react/dist/components/progress/progress-value-text.js
var import_jsx_runtime281 = __toESM(require_jsx_runtime(), 1);
var import_react598 = __toESM(require_react(), 1);
var ProgressValueText = (0, import_react598.forwardRef)((props43, ref) => {
  const { children, ...rest } = props43;
  const progress = useProgressContext();
  const mergedProps = mergeProps2(progress.getValueTextProps(), rest);
  return (0, import_jsx_runtime281.jsx)(ark.span, { ...mergedProps, ref, children: children || progress.percentAsString });
});
ProgressValueText.displayName = "ProgressValueText";

// node_modules/@ark-ui/react/dist/components/progress/progress-view.js
var import_jsx_runtime282 = __toESM(require_jsx_runtime(), 1);
var import_react600 = __toESM(require_react(), 1);
var ProgressView = (0, import_react600.forwardRef)((props43, ref) => {
  const [viewProps2, localProps] = createSplitProps2()(props43, ["state"]);
  const progress = useProgressContext();
  const mergedProps = mergeProps2(progress.getViewProps(viewProps2), localProps);
  return (0, import_jsx_runtime282.jsx)(ark.span, { ...mergedProps, ref });
});
ProgressView.displayName = "ProgressView";

// node_modules/@ark-ui/react/dist/components/progress/progress.js
var progress_exports = {};
__export(progress_exports, {
  Circle: () => ProgressCircle,
  CircleRange: () => ProgressCircleRange,
  CircleTrack: () => ProgressCircleTrack,
  Context: () => ProgressContext,
  Label: () => ProgressLabel,
  Range: () => ProgressRange,
  Root: () => ProgressRoot,
  RootProvider: () => ProgressRootProvider,
  Track: () => ProgressTrack,
  ValueText: () => ProgressValueText,
  View: () => ProgressView
});

// node_modules/@ark-ui/react/dist/components/qr-code/use-qr-code-context.js
var [QrCodeProvider, useQrCodeContext] = createContext3({
  name: "QrCodeContext",
  hookName: "useQrCodeContext",
  providerName: "<QrCodeProvider />"
});

// node_modules/@ark-ui/react/dist/components/qr-code/qr-code-context.js
var QrCodeContext = (props43) => props43.children(useQrCodeContext());

// node_modules/@ark-ui/react/dist/components/qr-code/qr-code-download-trigger.js
var import_jsx_runtime283 = __toESM(require_jsx_runtime(), 1);
var import_react602 = __toESM(require_react(), 1);
var QrCodeDownloadTrigger = (0, import_react602.forwardRef)((props43, ref) => {
  const [downloadTriggerProps, localProps] = createSplitProps2()(props43, [
    "fileName",
    "mimeType",
    "quality"
  ]);
  const qrCode = useQrCodeContext();
  const mergedProps = mergeProps2(qrCode.getDownloadTriggerProps(downloadTriggerProps), localProps);
  return (0, import_jsx_runtime283.jsx)(ark.button, { ...mergedProps, ref });
});
QrCodeDownloadTrigger.displayName = "QrCodeDownloadTrigger";

// node_modules/@ark-ui/react/dist/components/qr-code/qr-code-frame.js
var import_jsx_runtime284 = __toESM(require_jsx_runtime(), 1);
var import_react604 = __toESM(require_react(), 1);
var QrCodeFrame = (0, import_react604.forwardRef)((props43, ref) => {
  const qrCode = useQrCodeContext();
  const mergedProps = mergeProps2(qrCode.getFrameProps(), props43);
  return (0, import_jsx_runtime284.jsx)(ark.svg, { ...mergedProps, ref });
});
QrCodeFrame.displayName = "QrCodeFrame";

// node_modules/@ark-ui/react/dist/components/qr-code/qr-code-overlay.js
var import_jsx_runtime285 = __toESM(require_jsx_runtime(), 1);
var import_react606 = __toESM(require_react(), 1);
var QrCodeOverlay = (0, import_react606.forwardRef)((props43, ref) => {
  const qrCode = useQrCodeContext();
  const mergedProps = mergeProps2(qrCode.getOverlayProps(), props43);
  return (0, import_jsx_runtime285.jsx)(ark.div, { ...mergedProps, ref });
});
QrCodeOverlay.displayName = "QrCodeOverlay";

// node_modules/@ark-ui/react/dist/components/qr-code/qr-code-pattern.js
var import_jsx_runtime286 = __toESM(require_jsx_runtime(), 1);
var import_react608 = __toESM(require_react(), 1);
var QrCodePattern = (0, import_react608.forwardRef)((props43, ref) => {
  const qrCode = useQrCodeContext();
  const mergedProps = mergeProps2(qrCode.getPatternProps(), props43);
  return (0, import_jsx_runtime286.jsx)(ark.path, { ...mergedProps, ref });
});
QrCodePattern.displayName = "QrCodePattern";

// node_modules/@ark-ui/react/dist/components/qr-code/qr-code-root.js
var import_jsx_runtime287 = __toESM(require_jsx_runtime(), 1);
var import_react612 = __toESM(require_react(), 1);

// node_modules/uqr/dist/index.mjs
var QrCodeDataType = ((QrCodeDataType2) => {
  QrCodeDataType2[QrCodeDataType2["Border"] = -1] = "Border";
  QrCodeDataType2[QrCodeDataType2["Data"] = 0] = "Data";
  QrCodeDataType2[QrCodeDataType2["Function"] = 1] = "Function";
  QrCodeDataType2[QrCodeDataType2["Position"] = 2] = "Position";
  QrCodeDataType2[QrCodeDataType2["Timing"] = 3] = "Timing";
  QrCodeDataType2[QrCodeDataType2["Alignment"] = 4] = "Alignment";
  return QrCodeDataType2;
})(QrCodeDataType || {});
var __defProp5 = Object.defineProperty;
var __defNormalProp5 = (obj, key, value) => key in obj ? __defProp5(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField5 = (obj, key, value) => {
  __defNormalProp5(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var LOW = [0, 1];
var MEDIUM = [1, 0];
var QUARTILE = [2, 3];
var HIGH = [3, 2];
var EccMap = {
  L: LOW,
  M: MEDIUM,
  Q: QUARTILE,
  H: HIGH
};
var NUMERIC_REGEX = /^[0-9]*$/;
var ALPHANUMERIC_REGEX = /^[A-Z0-9 $%*+.\/:-]*$/;
var ALPHANUMERIC_CHARSET = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ $%*+-./:";
var MIN_VERSION = 1;
var MAX_VERSION = 40;
var PENALTY_N1 = 3;
var PENALTY_N2 = 3;
var PENALTY_N3 = 40;
var PENALTY_N4 = 10;
var ECC_CODEWORDS_PER_BLOCK = [
  // Version: (note that index 0 is for padding, and is set to an illegal value)
  // 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40    Error correction level
  [-1, 7, 10, 15, 20, 26, 18, 20, 24, 30, 18, 20, 24, 26, 30, 22, 24, 28, 30, 28, 28, 28, 28, 30, 30, 26, 28, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30],
  // Low
  [-1, 10, 16, 26, 18, 24, 16, 18, 22, 22, 26, 30, 22, 22, 24, 24, 28, 28, 26, 26, 26, 26, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28],
  // Medium
  [-1, 13, 22, 18, 26, 18, 24, 18, 22, 20, 24, 28, 26, 24, 20, 30, 24, 28, 28, 26, 30, 28, 30, 30, 30, 30, 28, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30],
  // Quartile
  [-1, 17, 28, 22, 16, 22, 28, 26, 26, 24, 28, 24, 28, 22, 24, 24, 30, 28, 28, 26, 28, 30, 24, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30]
  // High
];
var NUM_ERROR_CORRECTION_BLOCKS = [
  // Version: (note that index 0 is for padding, and is set to an illegal value)
  // 0, 1, 2, 3, 4, 5, 6, 7, 8, 9,10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40    Error correction level
  [-1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 4, 4, 4, 4, 4, 6, 6, 6, 6, 7, 8, 8, 9, 9, 10, 12, 12, 12, 13, 14, 15, 16, 17, 18, 19, 19, 20, 21, 22, 24, 25],
  // Low
  [-1, 1, 1, 1, 2, 2, 4, 4, 4, 5, 5, 5, 8, 9, 9, 10, 10, 11, 13, 14, 16, 17, 17, 18, 20, 21, 23, 25, 26, 28, 29, 31, 33, 35, 37, 38, 40, 43, 45, 47, 49],
  // Medium
  [-1, 1, 1, 2, 2, 4, 4, 6, 6, 8, 8, 8, 10, 12, 16, 12, 17, 16, 18, 21, 20, 23, 23, 25, 27, 29, 34, 34, 35, 38, 40, 43, 45, 48, 51, 53, 56, 59, 62, 65, 68],
  // Quartile
  [-1, 1, 1, 2, 4, 4, 4, 5, 6, 8, 8, 11, 11, 16, 16, 18, 16, 19, 21, 25, 25, 25, 34, 30, 32, 35, 37, 40, 42, 45, 48, 51, 54, 57, 60, 63, 66, 70, 74, 77, 81]
  // High
];
var QrCode = class {
  /* -- Constructor (low level) and fields -- */
  // Creates a new QR Code with the given version number,
  // error correction level, data codeword bytes, and mask number.
  // This is a low-level API that most users should not use directly.
  // A mid-level API is the encodeSegments() function.
  constructor(version2, ecc, dataCodewords, msk) {
    this.version = version2;
    this.ecc = ecc;
    __publicField5(this, "size");
    __publicField5(this, "mask");
    __publicField5(this, "modules", []);
    __publicField5(this, "types", []);
    if (version2 < MIN_VERSION || version2 > MAX_VERSION)
      throw new RangeError("Version value out of range");
    if (msk < -1 || msk > 7)
      throw new RangeError("Mask value out of range");
    this.size = version2 * 4 + 17;
    const row = Array.from({ length: this.size }, () => false);
    for (let i = 0; i < this.size; i++) {
      this.modules.push(row.slice());
      this.types.push(row.map(() => 0));
    }
    this.drawFunctionPatterns();
    const allCodewords = this.addEccAndInterleave(dataCodewords);
    this.drawCodewords(allCodewords);
    if (msk === -1) {
      let minPenalty = 1e9;
      for (let i = 0; i < 8; i++) {
        this.applyMask(i);
        this.drawFormatBits(i);
        const penalty = this.getPenaltyScore();
        if (penalty < minPenalty) {
          msk = i;
          minPenalty = penalty;
        }
        this.applyMask(i);
      }
    }
    this.mask = msk;
    this.applyMask(msk);
    this.drawFormatBits(msk);
  }
  /* -- Accessor methods -- */
  // Returns the color of the module (pixel) at the given coordinates, which is false
  // for light or true for dark. The top left corner has the coordinates (x=0, y=0).
  // If the given coordinates are out of bounds, then false (light) is returned.
  getModule(x, y) {
    return x >= 0 && x < this.size && y >= 0 && y < this.size && this.modules[y][x];
  }
  /* -- Private helper methods for constructor: Drawing function modules -- */
  // Reads this object's version field, and draws and marks all function modules.
  drawFunctionPatterns() {
    for (let i = 0; i < this.size; i++) {
      this.setFunctionModule(6, i, i % 2 === 0, QrCodeDataType.Timing);
      this.setFunctionModule(i, 6, i % 2 === 0, QrCodeDataType.Timing);
    }
    this.drawFinderPattern(3, 3);
    this.drawFinderPattern(this.size - 4, 3);
    this.drawFinderPattern(3, this.size - 4);
    const alignPatPos = this.getAlignmentPatternPositions();
    const numAlign = alignPatPos.length;
    for (let i = 0; i < numAlign; i++) {
      for (let j = 0; j < numAlign; j++) {
        if (!(i === 0 && j === 0 || i === 0 && j === numAlign - 1 || i === numAlign - 1 && j === 0))
          this.drawAlignmentPattern(alignPatPos[i], alignPatPos[j]);
      }
    }
    this.drawFormatBits(0);
    this.drawVersion();
  }
  // Draws two copies of the format bits (with its own error correction code)
  // based on the given mask and this object's error correction level field.
  drawFormatBits(mask) {
    const data = this.ecc[1] << 3 | mask;
    let rem = data;
    for (let i = 0; i < 10; i++)
      rem = rem << 1 ^ (rem >>> 9) * 1335;
    const bits = (data << 10 | rem) ^ 21522;
    for (let i = 0; i <= 5; i++)
      this.setFunctionModule(8, i, getBit(bits, i));
    this.setFunctionModule(8, 7, getBit(bits, 6));
    this.setFunctionModule(8, 8, getBit(bits, 7));
    this.setFunctionModule(7, 8, getBit(bits, 8));
    for (let i = 9; i < 15; i++)
      this.setFunctionModule(14 - i, 8, getBit(bits, i));
    for (let i = 0; i < 8; i++)
      this.setFunctionModule(this.size - 1 - i, 8, getBit(bits, i));
    for (let i = 8; i < 15; i++)
      this.setFunctionModule(8, this.size - 15 + i, getBit(bits, i));
    this.setFunctionModule(8, this.size - 8, true);
  }
  // Draws two copies of the version bits (with its own error correction code),
  // based on this object's version field, iff 7 <= version <= 40.
  drawVersion() {
    if (this.version < 7)
      return;
    let rem = this.version;
    for (let i = 0; i < 12; i++)
      rem = rem << 1 ^ (rem >>> 11) * 7973;
    const bits = this.version << 12 | rem;
    for (let i = 0; i < 18; i++) {
      const color = getBit(bits, i);
      const a2 = this.size - 11 + i % 3;
      const b2 = Math.floor(i / 3);
      this.setFunctionModule(a2, b2, color);
      this.setFunctionModule(b2, a2, color);
    }
  }
  // Draws a 9*9 finder pattern including the border separator,
  // with the center module at (x, y). Modules can be out of bounds.
  drawFinderPattern(x, y) {
    for (let dy = -4; dy <= 4; dy++) {
      for (let dx = -4; dx <= 4; dx++) {
        const dist = Math.max(Math.abs(dx), Math.abs(dy));
        const xx = x + dx;
        const yy = y + dy;
        if (xx >= 0 && xx < this.size && yy >= 0 && yy < this.size)
          this.setFunctionModule(xx, yy, dist !== 2 && dist !== 4, QrCodeDataType.Position);
      }
    }
  }
  // Draws a 5*5 alignment pattern, with the center module
  // at (x, y). All modules must be in bounds.
  drawAlignmentPattern(x, y) {
    for (let dy = -2; dy <= 2; dy++) {
      for (let dx = -2; dx <= 2; dx++) {
        this.setFunctionModule(
          x + dx,
          y + dy,
          Math.max(Math.abs(dx), Math.abs(dy)) !== 1,
          QrCodeDataType.Alignment
        );
      }
    }
  }
  // Sets the color of a module and marks it as a function module.
  // Only used by the constructor. Coordinates must be in bounds.
  setFunctionModule(x, y, isDark, type = QrCodeDataType.Function) {
    this.modules[y][x] = isDark;
    this.types[y][x] = type;
  }
  /* -- Private helper methods for constructor: Codewords and masking -- */
  // Returns a new byte string representing the given data with the appropriate error correction
  // codewords appended to it, based on this object's version and error correction level.
  addEccAndInterleave(data) {
    const ver = this.version;
    const ecl = this.ecc;
    if (data.length !== getNumDataCodewords(ver, ecl))
      throw new RangeError("Invalid argument");
    const numBlocks = NUM_ERROR_CORRECTION_BLOCKS[ecl[0]][ver];
    const blockEccLen = ECC_CODEWORDS_PER_BLOCK[ecl[0]][ver];
    const rawCodewords = Math.floor(getNumRawDataModules(ver) / 8);
    const numShortBlocks = numBlocks - rawCodewords % numBlocks;
    const shortBlockLen = Math.floor(rawCodewords / numBlocks);
    const blocks = [];
    const rsDiv = reedSolomonComputeDivisor(blockEccLen);
    for (let i = 0, k = 0; i < numBlocks; i++) {
      const dat = data.slice(k, k + shortBlockLen - blockEccLen + (i < numShortBlocks ? 0 : 1));
      k += dat.length;
      const ecc = reedSolomonComputeRemainder(dat, rsDiv);
      if (i < numShortBlocks)
        dat.push(0);
      blocks.push(dat.concat(ecc));
    }
    const result = [];
    for (let i = 0; i < blocks[0].length; i++) {
      blocks.forEach((block, j) => {
        if (i !== shortBlockLen - blockEccLen || j >= numShortBlocks)
          result.push(block[i]);
      });
    }
    return result;
  }
  // Draws the given sequence of 8-bit codewords (data and error correction) onto the entire
  // data area of this QR Code. Function modules need to be marked off before this is called.
  drawCodewords(data) {
    if (data.length !== Math.floor(getNumRawDataModules(this.version) / 8))
      throw new RangeError("Invalid argument");
    let i = 0;
    for (let right = this.size - 1; right >= 1; right -= 2) {
      if (right === 6)
        right = 5;
      for (let vert = 0; vert < this.size; vert++) {
        for (let j = 0; j < 2; j++) {
          const x = right - j;
          const upward = (right + 1 & 2) === 0;
          const y = upward ? this.size - 1 - vert : vert;
          if (!this.types[y][x] && i < data.length * 8) {
            this.modules[y][x] = getBit(data[i >>> 3], 7 - (i & 7));
            i++;
          }
        }
      }
    }
  }
  // XORs the codeword modules in this QR Code with the given mask pattern.
  // The function modules must be marked and the codeword bits must be drawn
  // before masking. Due to the arithmetic of XOR, calling applyMask() with
  // the same mask value a second time will undo the mask. A final well-formed
  // QR Code needs exactly one (not zero, two, etc.) mask applied.
  applyMask(mask) {
    if (mask < 0 || mask > 7)
      throw new RangeError("Mask value out of range");
    for (let y = 0; y < this.size; y++) {
      for (let x = 0; x < this.size; x++) {
        let invert;
        switch (mask) {
          case 0:
            invert = (x + y) % 2 === 0;
            break;
          case 1:
            invert = y % 2 === 0;
            break;
          case 2:
            invert = x % 3 === 0;
            break;
          case 3:
            invert = (x + y) % 3 === 0;
            break;
          case 4:
            invert = (Math.floor(x / 3) + Math.floor(y / 2)) % 2 === 0;
            break;
          case 5:
            invert = x * y % 2 + x * y % 3 === 0;
            break;
          case 6:
            invert = (x * y % 2 + x * y % 3) % 2 === 0;
            break;
          case 7:
            invert = ((x + y) % 2 + x * y % 3) % 2 === 0;
            break;
          default:
            throw new Error("Unreachable");
        }
        if (!this.types[y][x] && invert)
          this.modules[y][x] = !this.modules[y][x];
      }
    }
  }
  // Calculates and returns the penalty score based on state of this QR Code's current modules.
  // This is used by the automatic mask choice algorithm to find the mask pattern that yields the lowest score.
  getPenaltyScore() {
    let result = 0;
    for (let y = 0; y < this.size; y++) {
      let runColor = false;
      let runX = 0;
      const runHistory = [0, 0, 0, 0, 0, 0, 0];
      for (let x = 0; x < this.size; x++) {
        if (this.modules[y][x] === runColor) {
          runX++;
          if (runX === 5)
            result += PENALTY_N1;
          else if (runX > 5)
            result++;
        } else {
          this.finderPenaltyAddHistory(runX, runHistory);
          if (!runColor)
            result += this.finderPenaltyCountPatterns(runHistory) * PENALTY_N3;
          runColor = this.modules[y][x];
          runX = 1;
        }
      }
      result += this.finderPenaltyTerminateAndCount(runColor, runX, runHistory) * PENALTY_N3;
    }
    for (let x = 0; x < this.size; x++) {
      let runColor = false;
      let runY = 0;
      const runHistory = [0, 0, 0, 0, 0, 0, 0];
      for (let y = 0; y < this.size; y++) {
        if (this.modules[y][x] === runColor) {
          runY++;
          if (runY === 5)
            result += PENALTY_N1;
          else if (runY > 5)
            result++;
        } else {
          this.finderPenaltyAddHistory(runY, runHistory);
          if (!runColor)
            result += this.finderPenaltyCountPatterns(runHistory) * PENALTY_N3;
          runColor = this.modules[y][x];
          runY = 1;
        }
      }
      result += this.finderPenaltyTerminateAndCount(runColor, runY, runHistory) * PENALTY_N3;
    }
    for (let y = 0; y < this.size - 1; y++) {
      for (let x = 0; x < this.size - 1; x++) {
        const color = this.modules[y][x];
        if (color === this.modules[y][x + 1] && color === this.modules[y + 1][x] && color === this.modules[y + 1][x + 1])
          result += PENALTY_N2;
      }
    }
    let dark = 0;
    for (const row of this.modules)
      dark = row.reduce((sum2, color) => sum2 + (color ? 1 : 0), dark);
    const total = this.size * this.size;
    const k = Math.ceil(Math.abs(dark * 20 - total * 10) / total) - 1;
    result += k * PENALTY_N4;
    return result;
  }
  /* -- Private helper functions -- */
  // Returns an ascending list of positions of alignment patterns for this version number.
  // Each position is in the range [0,177), and are used on both the x and y axes.
  // This could be implemented as lookup table of 40 variable-length lists of integers.
  getAlignmentPatternPositions() {
    if (this.version === 1) {
      return [];
    } else {
      const numAlign = Math.floor(this.version / 7) + 2;
      const step = this.version === 32 ? 26 : Math.ceil((this.version * 4 + 4) / (numAlign * 2 - 2)) * 2;
      const result = [6];
      for (let pos = this.size - 7; result.length < numAlign; pos -= step)
        result.splice(1, 0, pos);
      return result;
    }
  }
  // Can only be called immediately after a light run is added, and
  // returns either 0, 1, or 2. A helper function for getPenaltyScore().
  finderPenaltyCountPatterns(runHistory) {
    const n = runHistory[1];
    const core = n > 0 && runHistory[2] === n && runHistory[3] === n * 3 && runHistory[4] === n && runHistory[5] === n;
    return (core && runHistory[0] >= n * 4 && runHistory[6] >= n ? 1 : 0) + (core && runHistory[6] >= n * 4 && runHistory[0] >= n ? 1 : 0);
  }
  // Must be called at the end of a line (row or column) of modules. A helper function for getPenaltyScore().
  finderPenaltyTerminateAndCount(currentRunColor, currentRunLength, runHistory) {
    if (currentRunColor) {
      this.finderPenaltyAddHistory(currentRunLength, runHistory);
      currentRunLength = 0;
    }
    currentRunLength += this.size;
    this.finderPenaltyAddHistory(currentRunLength, runHistory);
    return this.finderPenaltyCountPatterns(runHistory);
  }
  // Pushes the given value to the front and drops the last value. A helper function for getPenaltyScore().
  finderPenaltyAddHistory(currentRunLength, runHistory) {
    if (runHistory[0] === 0)
      currentRunLength += this.size;
    runHistory.pop();
    runHistory.unshift(currentRunLength);
  }
};
function appendBits(val, len, bb) {
  if (len < 0 || len > 31 || val >>> len !== 0)
    throw new RangeError("Value out of range");
  for (let i = len - 1; i >= 0; i--)
    bb.push(val >>> i & 1);
}
function getBit(x, i) {
  return (x >>> i & 1) !== 0;
}
var QrSegment = class {
  // Creates a new QR Code segment with the given attributes and data.
  // The character count (numChars) must agree with the mode and the bit buffer length,
  // but the constraint isn't checked. The given bit buffer is cloned and stored.
  constructor(mode, numChars, bitData) {
    this.mode = mode;
    this.numChars = numChars;
    this.bitData = bitData;
    if (numChars < 0)
      throw new RangeError("Invalid argument");
    this.bitData = bitData.slice();
  }
  /* -- Methods -- */
  // Returns a new copy of the data bits of this segment.
  getData() {
    return this.bitData.slice();
  }
};
var MODE_NUMERIC = [1, 10, 12, 14];
var MODE_ALPHANUMERIC = [2, 9, 11, 13];
var MODE_BYTE = [4, 8, 16, 16];
function numCharCountBits(mode, ver) {
  return mode[Math.floor((ver + 7) / 17) + 1];
}
function makeBytes(data) {
  const bb = [];
  for (const b2 of data)
    appendBits(b2, 8, bb);
  return new QrSegment(MODE_BYTE, data.length, bb);
}
function makeNumeric(digits) {
  if (!isNumeric(digits))
    throw new RangeError("String contains non-numeric characters");
  const bb = [];
  for (let i = 0; i < digits.length; ) {
    const n = Math.min(digits.length - i, 3);
    appendBits(Number.parseInt(digits.substring(i, i + n), 10), n * 3 + 1, bb);
    i += n;
  }
  return new QrSegment(MODE_NUMERIC, digits.length, bb);
}
function makeAlphanumeric(text) {
  if (!isAlphanumeric(text))
    throw new RangeError("String contains unencodable characters in alphanumeric mode");
  const bb = [];
  let i;
  for (i = 0; i + 2 <= text.length; i += 2) {
    let temp = ALPHANUMERIC_CHARSET.indexOf(text.charAt(i)) * 45;
    temp += ALPHANUMERIC_CHARSET.indexOf(text.charAt(i + 1));
    appendBits(temp, 11, bb);
  }
  if (i < text.length)
    appendBits(ALPHANUMERIC_CHARSET.indexOf(text.charAt(i)), 6, bb);
  return new QrSegment(MODE_ALPHANUMERIC, text.length, bb);
}
function makeSegments(text) {
  if (text === "")
    return [];
  else if (isNumeric(text))
    return [makeNumeric(text)];
  else if (isAlphanumeric(text))
    return [makeAlphanumeric(text)];
  else
    return [makeBytes(toUtf8ByteArray(text))];
}
function isNumeric(text) {
  return NUMERIC_REGEX.test(text);
}
function isAlphanumeric(text) {
  return ALPHANUMERIC_REGEX.test(text);
}
function getTotalBits(segs, version2) {
  let result = 0;
  for (const seg of segs) {
    const ccbits = numCharCountBits(seg.mode, version2);
    if (seg.numChars >= 1 << ccbits)
      return Number.POSITIVE_INFINITY;
    result += 4 + ccbits + seg.bitData.length;
  }
  return result;
}
function toUtf8ByteArray(str) {
  str = encodeURI(str);
  const result = [];
  for (let i = 0; i < str.length; i++) {
    if (str.charAt(i) !== "%") {
      result.push(str.charCodeAt(i));
    } else {
      result.push(Number.parseInt(str.substring(i + 1, i + 3), 16));
      i += 2;
    }
  }
  return result;
}
function getNumRawDataModules(ver) {
  if (ver < MIN_VERSION || ver > MAX_VERSION)
    throw new RangeError("Version number out of range");
  let result = (16 * ver + 128) * ver + 64;
  if (ver >= 2) {
    const numAlign = Math.floor(ver / 7) + 2;
    result -= (25 * numAlign - 10) * numAlign - 55;
    if (ver >= 7)
      result -= 36;
  }
  return result;
}
function getNumDataCodewords(ver, ecl) {
  return Math.floor(getNumRawDataModules(ver) / 8) - ECC_CODEWORDS_PER_BLOCK[ecl[0]][ver] * NUM_ERROR_CORRECTION_BLOCKS[ecl[0]][ver];
}
function reedSolomonComputeDivisor(degree) {
  if (degree < 1 || degree > 255)
    throw new RangeError("Degree out of range");
  const result = [];
  for (let i = 0; i < degree - 1; i++)
    result.push(0);
  result.push(1);
  let root = 1;
  for (let i = 0; i < degree; i++) {
    for (let j = 0; j < result.length; j++) {
      result[j] = reedSolomonMultiply(result[j], root);
      if (j + 1 < result.length)
        result[j] ^= result[j + 1];
    }
    root = reedSolomonMultiply(root, 2);
  }
  return result;
}
function reedSolomonComputeRemainder(data, divisor) {
  const result = divisor.map((_) => 0);
  for (const b2 of data) {
    const factor = b2 ^ result.shift();
    result.push(0);
    divisor.forEach((coef, i) => result[i] ^= reedSolomonMultiply(coef, factor));
  }
  return result;
}
function reedSolomonMultiply(x, y) {
  if (x >>> 8 !== 0 || y >>> 8 !== 0)
    throw new RangeError("Byte out of range");
  let z = 0;
  for (let i = 7; i >= 0; i--) {
    z = z << 1 ^ (z >>> 7) * 285;
    z ^= (y >>> i & 1) * x;
  }
  return z;
}
function encodeSegments(segs, ecl, minVersion = 1, maxVersion = 40, mask = -1, boostEcl = true) {
  if (!(MIN_VERSION <= minVersion && minVersion <= maxVersion && maxVersion <= MAX_VERSION) || mask < -1 || mask > 7)
    throw new RangeError("Invalid value");
  let version2;
  let dataUsedBits;
  for (version2 = minVersion; ; version2++) {
    const dataCapacityBits2 = getNumDataCodewords(version2, ecl) * 8;
    const usedBits = getTotalBits(segs, version2);
    if (usedBits <= dataCapacityBits2) {
      dataUsedBits = usedBits;
      break;
    }
    if (version2 >= maxVersion)
      throw new RangeError("Data too long");
  }
  for (const newEcl of [MEDIUM, QUARTILE, HIGH]) {
    if (boostEcl && dataUsedBits <= getNumDataCodewords(version2, newEcl) * 8)
      ecl = newEcl;
  }
  const bb = [];
  for (const seg of segs) {
    appendBits(seg.mode[0], 4, bb);
    appendBits(seg.numChars, numCharCountBits(seg.mode, version2), bb);
    for (const b2 of seg.getData())
      bb.push(b2);
  }
  const dataCapacityBits = getNumDataCodewords(version2, ecl) * 8;
  appendBits(0, Math.min(4, dataCapacityBits - bb.length), bb);
  appendBits(0, (8 - bb.length % 8) % 8, bb);
  for (let padByte = 236; bb.length < dataCapacityBits; padByte ^= 236 ^ 17)
    appendBits(padByte, 8, bb);
  const dataCodewords = Array.from({ length: Math.ceil(bb.length / 8) }, () => 0);
  bb.forEach((b2, i) => dataCodewords[i >>> 3] |= b2 << 7 - (i & 7));
  return new QrCode(version2, ecl, dataCodewords, mask);
}
function encode(data, options) {
  var _a8;
  const {
    ecc = "L",
    boostEcc = false,
    minVersion = 1,
    maxVersion = 40,
    maskPattern = -1,
    border = 1
  } = options || {};
  const segment = typeof data === "string" ? makeSegments(data) : Array.isArray(data) ? [makeBytes(data)] : void 0;
  if (!segment)
    throw new Error(`uqr only supports encoding string and binary data, but got: ${typeof data}`);
  const qr = encodeSegments(
    segment,
    EccMap[ecc],
    minVersion,
    maxVersion,
    maskPattern,
    boostEcc
  );
  const result = addBorder({
    version: qr.version,
    maskPattern: qr.mask,
    size: qr.size,
    data: qr.modules,
    types: qr.types
  }, border);
  if (options == null ? void 0 : options.invert)
    result.data = result.data.map((row) => row.map((mod2) => !mod2));
  (_a8 = options == null ? void 0 : options.onEncoded) == null ? void 0 : _a8.call(options, result);
  return result;
}
function addBorder(input, border = 1) {
  if (!border)
    return input;
  const { size: size3 } = input;
  const newSize = size3 + border * 2;
  input.size = newSize;
  input.data.forEach((row) => {
    for (let i = 0; i < border; i++) {
      row.unshift(false);
      row.push(false);
    }
  });
  for (let i = 0; i < border; i++) {
    input.data.unshift(Array.from({ length: newSize }, (_) => false));
    input.data.push(Array.from({ length: newSize }, (_) => false));
  }
  const b2 = QrCodeDataType.Border;
  input.types.forEach((row) => {
    for (let i = 0; i < border; i++) {
      row.unshift(b2);
      row.push(b2);
    }
  });
  for (let i = 0; i < border; i++) {
    input.types.unshift(Array.from({ length: newSize }, (_) => b2));
    input.types.push(Array.from({ length: newSize }, (_) => b2));
  }
  return input;
}

// node_modules/@zag-js/qr-code/dist/index.mjs
var anatomy24 = createAnatomy("qr-code").parts("root", "frame", "pattern", "overlay", "downloadTrigger");
var parts26 = anatomy24.build();
var getRootId18 = (scope) => {
  var _a8;
  return ((_a8 = scope.ids) == null ? void 0 : _a8.root) ?? `qrcode:${scope.id}:root`;
};
var getFrameId = (scope) => {
  var _a8;
  return ((_a8 = scope.ids) == null ? void 0 : _a8.frame) ?? `qrcode:${scope.id}:frame`;
};
var getFrameEl = (scope) => scope.getById(getFrameId(scope));
function connect25(service, normalize4) {
  const { context, computed, send, scope, prop } = service;
  const encoded = computed("encoded");
  const pixelSize = prop("pixelSize");
  const height = encoded.size * pixelSize;
  const width = encoded.size * pixelSize;
  const paths = [];
  for (let row = 0; row < encoded.size; row++) {
    for (let col = 0; col < encoded.size; col++) {
      const x = col * pixelSize;
      const y = row * pixelSize;
      if (encoded.data[row][col]) {
        paths.push(`M${x},${y}h${pixelSize}v${pixelSize}h-${pixelSize}z`);
      }
    }
  }
  return {
    value: context.get("value"),
    setValue(value) {
      send({ type: "VALUE.SET", value });
    },
    getDataUrl(type, quality) {
      const svgEl = getFrameEl(scope);
      return getDataUrl(svgEl, { type, quality });
    },
    getRootProps() {
      return normalize4.element({
        id: getRootId18(scope),
        ...parts26.root.attrs,
        style: {
          "--qrcode-pixel-size": `${pixelSize}px`,
          "--qrcode-width": `${width}px`,
          "--qrcode-height": `${height}px`,
          position: "relative"
        }
      });
    },
    getFrameProps() {
      return normalize4.svg({
        id: getFrameId(scope),
        ...parts26.frame.attrs,
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: `0 0 ${width} ${height}`
      });
    },
    getPatternProps() {
      return normalize4.path({
        d: paths.join(""),
        ...parts26.pattern.attrs
      });
    },
    getOverlayProps() {
      return normalize4.element({
        ...parts26.overlay.attrs,
        style: {
          position: "absolute",
          top: "50%",
          left: "50%",
          translate: "-50% -50%"
        }
      });
    },
    getDownloadTriggerProps(props210) {
      return normalize4.button({
        type: "button",
        ...parts26.downloadTrigger.attrs,
        onClick(event) {
          if (event.defaultPrevented) return;
          send({ type: "DOWNLOAD_TRIGGER.CLICK", ...props210 });
        }
      });
    }
  };
}
var machine25 = createMachine({
  props({ props: props210 }) {
    return {
      defaultValue: "",
      pixelSize: 10,
      ...props210
    };
  },
  initialState() {
    return "idle";
  },
  context({ prop, bindable }) {
    return {
      value: bindable(() => ({
        value: prop("value"),
        defaultValue: prop("defaultValue"),
        onChange(value) {
          var _a8;
          (_a8 = prop("onValueChange")) == null ? void 0 : _a8({ value });
        }
      }))
    };
  },
  computed: {
    encoded: memo(
      ({ context, prop }) => [context.get("value"), prop("encoding")],
      (value, encoding) => encode(value, encoding)
    )
  },
  states: {
    idle: {
      on: {
        "VALUE.SET": {
          actions: ["setValue"]
        },
        "DOWNLOAD_TRIGGER.CLICK": {
          actions: ["downloadQrCode"]
        }
      }
    }
  },
  implementations: {
    actions: {
      setValue({ context, event }) {
        context.set("value", event.value);
      },
      downloadQrCode({ event, scope }) {
        const { mimeType, quality, fileName } = event;
        const svgEl = getFrameEl(scope);
        const doc = scope.getDoc();
        getDataUrl(svgEl, { type: mimeType, quality }).then((dataUri) => {
          const a2 = doc.createElement("a");
          a2.href = dataUri;
          a2.rel = "noopener";
          a2.download = fileName;
          a2.click();
          setTimeout(() => {
            a2.remove();
          }, 0);
        });
      }
    }
  }
});
var props25 = createProps()([
  "ids",
  "defaultValue",
  "value",
  "id",
  "encoding",
  "dir",
  "getRootNode",
  "onValueChange",
  "pixelSize"
]);
var splitProps25 = createSplitProps(props25);

// node_modules/@ark-ui/react/dist/components/qr-code/use-qr-code.js
var import_react610 = __toESM(require_react(), 1);
var useQrCode = (props43) => {
  const id = (0, import_react610.useId)();
  const { getRootNode } = useEnvironmentContext();
  const { dir } = useLocaleContext();
  const machineProps = {
    id,
    dir,
    getRootNode,
    ...props43
  };
  const service = useMachine(machine25, machineProps);
  return connect25(service, normalizeProps);
};

// node_modules/@ark-ui/react/dist/components/qr-code/qr-code-root.js
var QrCodeRoot = (0, import_react612.forwardRef)((props43, ref) => {
  const [qrcodeProps, localProps] = createSplitProps2()(props43, [
    "defaultValue",
    "encoding",
    "id",
    "ids",
    "onValueChange",
    "pixelSize",
    "value"
  ]);
  const qrCode = useQrCode(qrcodeProps);
  const mergedProps = mergeProps2(qrCode.getRootProps(), localProps);
  return (0, import_jsx_runtime287.jsx)(QrCodeProvider, { value: qrCode, children: (0, import_jsx_runtime287.jsx)(ark.div, { ...mergedProps, ref }) });
});
QrCodeRoot.displayName = "QrcodeRoot";

// node_modules/@ark-ui/react/dist/components/qr-code/qr-code-root-provider.js
var import_jsx_runtime288 = __toESM(require_jsx_runtime(), 1);
var import_react614 = __toESM(require_react(), 1);
var QrCodeRootProvider = (0, import_react614.forwardRef)((props43, ref) => {
  const [{ value: qrCode }, localProps] = createSplitProps2()(props43, ["value"]);
  const mergedProps = mergeProps2(qrCode.getRootProps(), localProps);
  return (0, import_jsx_runtime288.jsx)(QrCodeProvider, { value: qrCode, children: (0, import_jsx_runtime288.jsx)(ark.div, { ...mergedProps, ref }) });
});
QrCodeRootProvider.displayName = "QrCodeRootProvider";

// node_modules/@ark-ui/react/dist/components/qr-code/qr-code.js
var qr_code_exports = {};
__export(qr_code_exports, {
  Context: () => QrCodeContext,
  DownloadTrigger: () => QrCodeDownloadTrigger,
  Frame: () => QrCodeFrame,
  Overlay: () => QrCodeOverlay,
  Pattern: () => QrCodePattern,
  Root: () => QrCodeRoot,
  RootProvider: () => QrCodeRootProvider
});

// node_modules/@ark-ui/react/dist/components/radio-group/use-radio-group-context.js
var [RadioGroupProvider, useRadioGroupContext] = createContext3({
  name: "RadioGroupContext",
  hookName: "useRadioGroupContext",
  providerName: "<RadioGroupProvider />"
});

// node_modules/@ark-ui/react/dist/components/radio-group/radio-group-context.js
var RadioGroupContext = (props43) => props43.children(useRadioGroupContext());

// node_modules/@ark-ui/react/dist/components/radio-group/radio-group-indicator.js
var import_jsx_runtime289 = __toESM(require_jsx_runtime(), 1);
var import_react616 = __toESM(require_react(), 1);
var RadioGroupIndicator = (0, import_react616.forwardRef)((props43, ref) => {
  const radioGroup = useRadioGroupContext();
  const mergedProps = mergeProps2(radioGroup.getIndicatorProps(), props43);
  return (0, import_jsx_runtime289.jsx)(ark.div, { ...mergedProps, ref });
});
RadioGroupIndicator.displayName = "RadioGroupIndicator";

// node_modules/@ark-ui/react/dist/components/radio-group/radio-group-item.js
var import_jsx_runtime290 = __toESM(require_jsx_runtime(), 1);
var import_react618 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/radio-group/use-radio-group-item-context.js
var [RadioGroupItemProvider, useRadioGroupItemContext] = createContext3({
  name: "RadioGroupItemContext",
  hookName: "useRadioGroupItemContext",
  providerName: "<RadioGroupItemProvider />"
});

// node_modules/@ark-ui/react/dist/components/radio-group/use-radio-group-item-props-context.js
var [RadioGroupItemPropsProvider, useRadioGroupItemPropsContext] = createContext3({
  name: "RadioGroupItemPropsContext",
  hookName: "useRadioGroupItemPropsContext",
  providerName: "<RadioGroupItemPropsProvider />"
});

// node_modules/@ark-ui/react/dist/components/radio-group/radio-group-item.js
var RadioGroupItem = (0, import_react618.forwardRef)((props43, ref) => {
  const [itemProps14, localProps] = createSplitProps2()(props43, ["value", "disabled", "invalid"]);
  const radioGroup = useRadioGroupContext();
  const mergedProps = mergeProps2(radioGroup.getItemProps(itemProps14), localProps);
  const itemState = radioGroup.getItemState(itemProps14);
  return (0, import_jsx_runtime290.jsx)(RadioGroupItemProvider, { value: itemState, children: (0, import_jsx_runtime290.jsx)(RadioGroupItemPropsProvider, { value: itemProps14, children: (0, import_jsx_runtime290.jsx)(ark.label, { ...mergedProps, ref }) }) });
});
RadioGroupItem.displayName = "RadioGroupItem";

// node_modules/@ark-ui/react/dist/components/radio-group/radio-group-item-context.js
var RadioGroupItemContext = (props43) => props43.children(useRadioGroupItemContext());

// node_modules/@ark-ui/react/dist/components/radio-group/radio-group-item-control.js
var import_jsx_runtime291 = __toESM(require_jsx_runtime(), 1);
var import_react620 = __toESM(require_react(), 1);
var RadioGroupItemControl = (0, import_react620.forwardRef)((props43, ref) => {
  const radioGroup = useRadioGroupContext();
  const itemProps14 = useRadioGroupItemPropsContext();
  const mergedProps = mergeProps2(radioGroup.getItemControlProps(itemProps14), props43);
  return (0, import_jsx_runtime291.jsx)(ark.div, { ...mergedProps, ref });
});
RadioGroupItemControl.displayName = "RadioGroupItemControl";

// node_modules/@ark-ui/react/dist/components/radio-group/radio-group-item-hidden-input.js
var import_jsx_runtime292 = __toESM(require_jsx_runtime(), 1);
var import_react622 = __toESM(require_react(), 1);
var RadioGroupItemHiddenInput = (0, import_react622.forwardRef)((props43, ref) => {
  const radioGroup = useRadioGroupContext();
  const itemProps14 = useRadioGroupItemPropsContext();
  const mergedProps = mergeProps2(radioGroup.getItemHiddenInputProps(itemProps14), props43);
  return (0, import_jsx_runtime292.jsx)(ark.input, { ...mergedProps, ref });
});
RadioGroupItemHiddenInput.displayName = "RadioGroupItemHiddenInput";

// node_modules/@ark-ui/react/dist/components/radio-group/radio-group-item-text.js
var import_jsx_runtime293 = __toESM(require_jsx_runtime(), 1);
var import_react624 = __toESM(require_react(), 1);
var RadioGroupItemText = (0, import_react624.forwardRef)((props43, ref) => {
  const radioGroup = useRadioGroupContext();
  const itemProps14 = useRadioGroupItemPropsContext();
  const mergedProps = mergeProps2(radioGroup.getItemTextProps(itemProps14), props43);
  return (0, import_jsx_runtime293.jsx)(ark.span, { ...mergedProps, ref });
});
RadioGroupItemText.displayName = "RadioGroupItemText";

// node_modules/@ark-ui/react/dist/components/radio-group/radio-group-label.js
var import_jsx_runtime294 = __toESM(require_jsx_runtime(), 1);
var import_react626 = __toESM(require_react(), 1);
var RadioGroupLabel = (0, import_react626.forwardRef)((props43, ref) => {
  const radioGroup = useRadioGroupContext();
  const mergedProps = mergeProps2(radioGroup.getLabelProps(), props43);
  return (0, import_jsx_runtime294.jsx)(ark.label, { ...mergedProps, ref });
});
RadioGroupLabel.displayName = "RadioGroupLabel";

// node_modules/@ark-ui/react/dist/components/radio-group/radio-group-root.js
var import_jsx_runtime295 = __toESM(require_jsx_runtime(), 1);
var import_react630 = __toESM(require_react(), 1);

// node_modules/@zag-js/radio-group/dist/index.mjs
var anatomy25 = createAnatomy("radio-group").parts(
  "root",
  "label",
  "item",
  "itemText",
  "itemControl",
  "indicator"
);
var parts27 = anatomy25.build();
var getRootId19 = (ctx) => {
  var _a8;
  return ((_a8 = ctx.ids) == null ? void 0 : _a8.root) ?? `radio-group:${ctx.id}`;
};
var getLabelId12 = (ctx) => {
  var _a8;
  return ((_a8 = ctx.ids) == null ? void 0 : _a8.label) ?? `radio-group:${ctx.id}:label`;
};
var getItemId8 = (ctx, value) => {
  var _a8, _b7;
  return ((_b7 = (_a8 = ctx.ids) == null ? void 0 : _a8.item) == null ? void 0 : _b7.call(_a8, value)) ?? `radio-group:${ctx.id}:radio:${value}`;
};
var getItemHiddenInputId = (ctx, value) => {
  var _a8, _b7;
  return ((_b7 = (_a8 = ctx.ids) == null ? void 0 : _a8.itemHiddenInput) == null ? void 0 : _b7.call(_a8, value)) ?? `radio-group:${ctx.id}:radio:input:${value}`;
};
var getItemControlId = (ctx, value) => {
  var _a8, _b7;
  return ((_b7 = (_a8 = ctx.ids) == null ? void 0 : _a8.itemControl) == null ? void 0 : _b7.call(_a8, value)) ?? `radio-group:${ctx.id}:radio:control:${value}`;
};
var getItemLabelId = (ctx, value) => {
  var _a8, _b7;
  return ((_b7 = (_a8 = ctx.ids) == null ? void 0 : _a8.itemLabel) == null ? void 0 : _b7.call(_a8, value)) ?? `radio-group:${ctx.id}:radio:label:${value}`;
};
var getIndicatorId2 = (ctx) => {
  var _a8;
  return ((_a8 = ctx.ids) == null ? void 0 : _a8.indicator) ?? `radio-group:${ctx.id}:indicator`;
};
var getRootEl6 = (ctx) => ctx.getById(getRootId19(ctx));
var getItemHiddenInputEl = (ctx, value) => ctx.getById(getItemHiddenInputId(ctx, value));
var getIndicatorEl2 = (ctx) => ctx.getById(getIndicatorId2(ctx));
var getFirstEnabledInputEl = (ctx) => {
  var _a8;
  return (_a8 = getRootEl6(ctx)) == null ? void 0 : _a8.querySelector("input:not(:disabled)");
};
var getFirstEnabledAndCheckedInputEl = (ctx) => {
  var _a8;
  return (_a8 = getRootEl6(ctx)) == null ? void 0 : _a8.querySelector("input:not(:disabled):checked");
};
var getInputEls3 = (ctx) => {
  const ownerId = CSS.escape(getRootId19(ctx));
  const selector = `input[type=radio][data-ownedby='${ownerId}']:not([disabled])`;
  return queryAll(getRootEl6(ctx), selector);
};
var getRadioEl = (ctx, value) => {
  if (!value) return;
  return ctx.getById(getItemId8(ctx, value));
};
var getOffsetRect = (el) => ({
  left: (el == null ? void 0 : el.offsetLeft) ?? 0,
  top: (el == null ? void 0 : el.offsetTop) ?? 0,
  width: (el == null ? void 0 : el.offsetWidth) ?? 0,
  height: (el == null ? void 0 : el.offsetHeight) ?? 0
});
var resolveRect = (rect) => ({
  width: `${rect.width}px`,
  height: `${rect.height}px`,
  left: `${rect.left}px`,
  top: `${rect.top}px`
});
function connect26(service, normalize4) {
  const { context, send, computed, prop, scope } = service;
  const groupDisabled = computed("isDisabled");
  const readOnly = prop("readOnly");
  function getItemState(props210) {
    const focused = context.get("focusedValue") === props210.value;
    const focusVisible = focused && isFocusVisible();
    return {
      value: props210.value,
      invalid: !!props210.invalid,
      disabled: !!props210.disabled || groupDisabled,
      checked: context.get("value") === props210.value,
      focused,
      focusVisible,
      hovered: context.get("hoveredValue") === props210.value,
      active: context.get("activeValue") === props210.value
    };
  }
  function getItemDataAttrs(props210) {
    const itemState = getItemState(props210);
    return {
      "data-focus": dataAttr(itemState.focused),
      "data-focus-visible": dataAttr(itemState.focusVisible),
      "data-disabled": dataAttr(itemState.disabled),
      "data-readonly": dataAttr(readOnly),
      "data-state": itemState.checked ? "checked" : "unchecked",
      "data-hover": dataAttr(itemState.hovered),
      "data-invalid": dataAttr(itemState.invalid),
      "data-orientation": prop("orientation"),
      "data-ssr": dataAttr(context.get("ssr"))
    };
  }
  const focus = () => {
    const nodeToFocus = getFirstEnabledAndCheckedInputEl(scope) ?? getFirstEnabledInputEl(scope);
    nodeToFocus == null ? void 0 : nodeToFocus.focus();
  };
  return {
    focus,
    value: context.get("value"),
    setValue(value) {
      send({ type: "SET_VALUE", value, isTrusted: false });
    },
    clearValue() {
      send({ type: "SET_VALUE", value: null, isTrusted: false });
    },
    getRootProps() {
      return normalize4.element({
        ...parts27.root.attrs,
        role: "radiogroup",
        id: getRootId19(scope),
        "aria-labelledby": getLabelId12(scope),
        "data-orientation": prop("orientation"),
        "data-disabled": dataAttr(groupDisabled),
        "aria-orientation": prop("orientation"),
        dir: prop("dir"),
        style: {
          position: "relative"
        }
      });
    },
    getLabelProps() {
      return normalize4.element({
        ...parts27.label.attrs,
        dir: prop("dir"),
        "data-orientation": prop("orientation"),
        "data-disabled": dataAttr(groupDisabled),
        id: getLabelId12(scope),
        onClick: focus
      });
    },
    getItemState,
    getItemProps(props210) {
      const itemState = getItemState(props210);
      return normalize4.label({
        ...parts27.item.attrs,
        dir: prop("dir"),
        id: getItemId8(scope, props210.value),
        htmlFor: getItemHiddenInputId(scope, props210.value),
        ...getItemDataAttrs(props210),
        onPointerMove() {
          if (itemState.disabled) return;
          if (itemState.hovered) return;
          send({ type: "SET_HOVERED", value: props210.value, hovered: true });
        },
        onPointerLeave() {
          if (itemState.disabled) return;
          send({ type: "SET_HOVERED", value: null });
        },
        onPointerDown(event) {
          if (itemState.disabled) return;
          if (itemState.focused && event.pointerType === "mouse") {
            event.preventDefault();
          }
          send({ type: "SET_ACTIVE", value: props210.value, active: true });
        },
        onPointerUp() {
          if (itemState.disabled) return;
          send({ type: "SET_ACTIVE", value: null });
        },
        onClick() {
          var _a8;
          if (!itemState.disabled && isSafari()) {
            (_a8 = getItemHiddenInputEl(scope, props210.value)) == null ? void 0 : _a8.focus();
          }
        }
      });
    },
    getItemTextProps(props210) {
      return normalize4.element({
        ...parts27.itemText.attrs,
        dir: prop("dir"),
        id: getItemLabelId(scope, props210.value),
        ...getItemDataAttrs(props210)
      });
    },
    getItemControlProps(props210) {
      const itemState = getItemState(props210);
      return normalize4.element({
        ...parts27.itemControl.attrs,
        dir: prop("dir"),
        id: getItemControlId(scope, props210.value),
        "data-active": dataAttr(itemState.active),
        "aria-hidden": true,
        ...getItemDataAttrs(props210)
      });
    },
    getItemHiddenInputProps(props210) {
      const itemState = getItemState(props210);
      return normalize4.input({
        "data-ownedby": getRootId19(scope),
        id: getItemHiddenInputId(scope, props210.value),
        type: "radio",
        name: prop("name") || prop("id"),
        form: prop("form"),
        value: props210.value,
        onClick(event) {
          if (readOnly) {
            event.preventDefault();
            return;
          }
          if (event.currentTarget.checked) {
            send({ type: "SET_VALUE", value: props210.value, isTrusted: true });
          }
        },
        onBlur() {
          send({ type: "SET_FOCUSED", value: null, focused: false });
        },
        onFocus() {
          send({ type: "SET_FOCUSED", value: props210.value, focused: true });
        },
        onKeyDown(event) {
          if (event.defaultPrevented) return;
          if (event.key === " ") {
            send({ type: "SET_ACTIVE", value: props210.value, active: true });
          }
        },
        onKeyUp(event) {
          if (event.defaultPrevented) return;
          if (event.key === " ") {
            send({ type: "SET_ACTIVE", value: null });
          }
        },
        disabled: itemState.disabled,
        defaultChecked: itemState.checked,
        style: visuallyHiddenStyle
      });
    },
    getIndicatorProps() {
      const rect = context.get("indicatorRect");
      return normalize4.element({
        id: getIndicatorId2(scope),
        ...parts27.indicator.attrs,
        dir: prop("dir"),
        hidden: context.get("value") == null,
        "data-disabled": dataAttr(groupDisabled),
        "data-orientation": prop("orientation"),
        style: {
          "--transition-property": "left, top, width, height",
          "--left": rect == null ? void 0 : rect.left,
          "--top": rect == null ? void 0 : rect.top,
          "--width": rect == null ? void 0 : rect.width,
          "--height": rect == null ? void 0 : rect.height,
          position: "absolute",
          willChange: "var(--transition-property)",
          transitionProperty: "var(--transition-property)",
          transitionDuration: context.get("canIndicatorTransition") ? "var(--transition-duration, 150ms)" : "0ms",
          transitionTimingFunction: "var(--transition-timing-function)",
          [prop("orientation") === "horizontal" ? "left" : "top"]: prop("orientation") === "horizontal" ? "var(--left)" : "var(--top)"
        }
      });
    }
  };
}
var { not: not8 } = createGuards();
var machine26 = createMachine({
  props({ props: props210 }) {
    return {
      orientation: "vertical",
      ...props210
    };
  },
  initialState() {
    return "idle";
  },
  context({ prop, bindable }) {
    return {
      value: bindable(() => ({
        defaultValue: prop("defaultValue"),
        value: prop("value"),
        onChange(value) {
          var _a8;
          (_a8 = prop("onValueChange")) == null ? void 0 : _a8({ value });
        }
      })),
      activeValue: bindable(() => ({
        defaultValue: null
      })),
      focusedValue: bindable(() => ({
        defaultValue: null
      })),
      hoveredValue: bindable(() => ({
        defaultValue: null
      })),
      indicatorRect: bindable(() => ({
        defaultValue: {}
      })),
      canIndicatorTransition: bindable(() => ({
        defaultValue: false
      })),
      fieldsetDisabled: bindable(() => ({
        defaultValue: false
      })),
      ssr: bindable(() => ({
        defaultValue: true
      }))
    };
  },
  refs() {
    return {
      indicatorCleanup: null
    };
  },
  computed: {
    isDisabled: ({ prop, context }) => !!prop("disabled") || context.get("fieldsetDisabled")
  },
  entry: ["syncIndicatorRect", "syncSsr"],
  exit: ["cleanupObserver"],
  effects: ["trackFormControlState", "trackFocusVisible"],
  watch({ track, action, context }) {
    track([() => context.get("value")], () => {
      action(["setIndicatorTransition", "syncIndicatorRect", "syncInputElements"]);
    });
  },
  on: {
    SET_VALUE: [
      {
        guard: not8("isTrusted"),
        actions: ["setValue", "dispatchChangeEvent"]
      },
      {
        actions: ["setValue"]
      }
    ],
    SET_HOVERED: {
      actions: ["setHovered"]
    },
    SET_ACTIVE: {
      actions: ["setActive"]
    },
    SET_FOCUSED: {
      actions: ["setFocused"]
    }
  },
  states: {
    idle: {}
  },
  implementations: {
    guards: {
      isTrusted: ({ event }) => !!event.isTrusted
    },
    effects: {
      trackFormControlState({ context, scope }) {
        return trackFormControl(getRootEl6(scope), {
          onFieldsetDisabledChange(disabled) {
            context.set("fieldsetDisabled", disabled);
          },
          onFormReset() {
            context.set("value", context.initial("value"));
          }
        });
      },
      trackFocusVisible({ scope }) {
        var _a8;
        return trackFocusVisible({ root: (_a8 = scope.getRootNode) == null ? void 0 : _a8.call(scope) });
      }
    },
    actions: {
      setValue({ context, event }) {
        context.set("value", event.value);
      },
      setHovered({ context, event }) {
        context.set("hoveredValue", event.value);
      },
      setActive({ context, event }) {
        context.set("activeValue", event.value);
      },
      setFocused({ context, event }) {
        context.set("focusedValue", event.value);
      },
      syncInputElements({ context, scope }) {
        const inputs = getInputEls3(scope);
        inputs.forEach((input) => {
          input.checked = input.value === context.get("value");
        });
      },
      setIndicatorTransition({ context }) {
        context.set("canIndicatorTransition", isString2(context.get("value")));
      },
      cleanupObserver({ refs }) {
        var _a8;
        (_a8 = refs.get("indicatorCleanup")) == null ? void 0 : _a8();
      },
      syncSsr({ context }) {
        context.set("ssr", false);
      },
      syncIndicatorRect({ context, scope, refs }) {
        var _a8;
        (_a8 = refs.get("indicatorCleanup")) == null ? void 0 : _a8();
        if (!getIndicatorEl2(scope)) return;
        const value = context.get("value");
        const radioEl = getRadioEl(scope, value);
        if (value == null || !radioEl) {
          context.set("canIndicatorTransition", false);
          context.set("indicatorRect", {});
          return;
        }
        const indicatorCleanup = trackElementRect([radioEl], {
          measure(el) {
            return getOffsetRect(el);
          },
          onEntry({ rects }) {
            context.set("indicatorRect", resolveRect(rects[0]));
          }
        });
        refs.set("indicatorCleanup", indicatorCleanup);
      },
      dispatchChangeEvent({ context, scope }) {
        const inputEls = getInputEls3(scope);
        inputEls.forEach((inputEl) => {
          const checked = inputEl.value === context.get("value");
          if (checked === inputEl.checked) return;
          dispatchInputCheckedEvent(inputEl, { checked });
        });
      }
    }
  }
});
var props26 = createProps()([
  "dir",
  "disabled",
  "form",
  "getRootNode",
  "id",
  "ids",
  "name",
  "onValueChange",
  "orientation",
  "readOnly",
  "value",
  "defaultValue"
]);
var splitProps26 = createSplitProps(props26);
var itemProps8 = createProps()(["value", "disabled", "invalid"]);
var splitItemProps8 = createSplitProps(itemProps8);

// node_modules/@ark-ui/react/dist/components/radio-group/use-radio-group.js
var import_react628 = __toESM(require_react(), 1);
var useRadioGroup = (props43) => {
  const id = (0, import_react628.useId)();
  const { getRootNode } = useEnvironmentContext();
  const { dir } = useLocaleContext();
  const machineProps = {
    id,
    dir,
    getRootNode,
    ...props43
  };
  const service = useMachine(machine26, machineProps);
  return connect26(service, normalizeProps);
};

// node_modules/@ark-ui/react/dist/components/radio-group/radio-group-root.js
var RadioGroupRoot = (0, import_react630.forwardRef)((props43, ref) => {
  const [useRadioGroupProps, localProps] = createSplitProps2()(props43, [
    "defaultValue",
    "disabled",
    "form",
    "id",
    "ids",
    "name",
    "onValueChange",
    "orientation",
    "readOnly",
    "value"
  ]);
  const radioGroup = useRadioGroup(useRadioGroupProps);
  const mergedProps = mergeProps2(radioGroup.getRootProps(), localProps);
  return (0, import_jsx_runtime295.jsx)(RadioGroupProvider, { value: radioGroup, children: (0, import_jsx_runtime295.jsx)(ark.div, { ...mergedProps, ref }) });
});
RadioGroupRoot.displayName = "RadioGroupRoot";

// node_modules/@ark-ui/react/dist/components/radio-group/radio-group-root-provider.js
var import_jsx_runtime296 = __toESM(require_jsx_runtime(), 1);
var import_react632 = __toESM(require_react(), 1);
var RadioGroupRootProvider = (0, import_react632.forwardRef)((props43, ref) => {
  const [{ value: radioGroup }, localProps] = createSplitProps2()(props43, ["value"]);
  const mergedProps = mergeProps2(radioGroup.getRootProps(), localProps);
  return (0, import_jsx_runtime296.jsx)(RadioGroupProvider, { value: radioGroup, children: (0, import_jsx_runtime296.jsx)(ark.div, { ...mergedProps, ref }) });
});
RadioGroupRootProvider.displayName = "RadioGroupRootProvider";

// node_modules/@ark-ui/react/dist/components/radio-group/radio-group.js
var radio_group_exports = {};
__export(radio_group_exports, {
  Context: () => RadioGroupContext,
  Indicator: () => RadioGroupIndicator,
  Item: () => RadioGroupItem,
  ItemContext: () => RadioGroupItemContext,
  ItemControl: () => RadioGroupItemControl,
  ItemHiddenInput: () => RadioGroupItemHiddenInput,
  ItemText: () => RadioGroupItemText,
  Label: () => RadioGroupLabel,
  Root: () => RadioGroupRoot,
  RootProvider: () => RadioGroupRootProvider
});

// node_modules/@ark-ui/react/dist/components/rating-group/use-rating-group-context.js
var [RatingGroupProvider, useRatingGroupContext] = createContext3({
  name: "RatingGroupContext",
  hookName: "useRatingGroupContext",
  providerName: "<RatingGroupProvider />"
});

// node_modules/@ark-ui/react/dist/components/rating-group/rating-group-context.js
var RatingGroupContext = (props43) => props43.children(useRatingGroupContext());

// node_modules/@ark-ui/react/dist/components/rating-group/rating-group-control.js
var import_jsx_runtime297 = __toESM(require_jsx_runtime(), 1);
var import_react634 = __toESM(require_react(), 1);
var RatingGroupControl = (0, import_react634.forwardRef)((props43, ref) => {
  const ratingGroup = useRatingGroupContext();
  const mergedProps = mergeProps2(ratingGroup.getControlProps(), props43);
  return (0, import_jsx_runtime297.jsx)(ark.div, { ...mergedProps, ref });
});
RatingGroupControl.displayName = "RatingGroupControl";

// node_modules/@ark-ui/react/dist/components/rating-group/rating-group-hidden-input.js
var import_jsx_runtime298 = __toESM(require_jsx_runtime(), 1);
var import_react636 = __toESM(require_react(), 1);
var RatingGroupHiddenInput = (0, import_react636.forwardRef)((props43, ref) => {
  const ratingGroup = useRatingGroupContext();
  const mergedProps = mergeProps2(ratingGroup.getHiddenInputProps(), props43);
  const field = useFieldContext();
  return (0, import_jsx_runtime298.jsx)(ark.input, { "aria-describedby": field == null ? void 0 : field.ariaDescribedby, ...mergedProps, ref });
});
RatingGroupHiddenInput.displayName = "RatingGroupHiddenInput";

// node_modules/@ark-ui/react/dist/components/rating-group/rating-group-item.js
var import_jsx_runtime299 = __toESM(require_jsx_runtime(), 1);
var import_react638 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/rating-group/use-rating-group-item-context.js
var [RatingGroupItemProvider, useRatingGroupItemContext] = createContext3({
  name: "RatingGroupItemContext",
  hookName: "useRatingGroupItemContext",
  providerName: "<RatingGroupItemProvider />"
});

// node_modules/@ark-ui/react/dist/components/rating-group/rating-group-item.js
var RatingGroupItem = (0, import_react638.forwardRef)((props43, ref) => {
  const [itemProps14, localProps] = createSplitProps2()(props43, ["index"]);
  const ratingGroup = useRatingGroupContext();
  const mergedProps = mergeProps2(ratingGroup.getItemProps(itemProps14), localProps);
  const itemState = ratingGroup.getItemState(itemProps14);
  return (0, import_jsx_runtime299.jsx)(RatingGroupItemProvider, { value: itemState, children: (0, import_jsx_runtime299.jsx)(ark.span, { ...mergedProps, ref }) });
});
RatingGroupItem.displayName = "RatingGroupItem";

// node_modules/@ark-ui/react/dist/components/rating-group/rating-group-item-context.js
var RatingGroupItemContext = (props43) => props43.children(useRatingGroupItemContext());

// node_modules/@ark-ui/react/dist/components/rating-group/rating-group-label.js
var import_jsx_runtime300 = __toESM(require_jsx_runtime(), 1);
var import_react640 = __toESM(require_react(), 1);
var RatingGroupLabel = (0, import_react640.forwardRef)((props43, ref) => {
  const ratingGroup = useRatingGroupContext();
  const mergedProps = mergeProps2(ratingGroup.getLabelProps(), props43);
  return (0, import_jsx_runtime300.jsx)(ark.label, { ...mergedProps, ref });
});
RatingGroupLabel.displayName = "RatingGroupLabel";

// node_modules/@ark-ui/react/dist/components/rating-group/rating-group-root.js
var import_jsx_runtime301 = __toESM(require_jsx_runtime(), 1);
var import_react644 = __toESM(require_react(), 1);

// node_modules/@zag-js/rating-group/dist/index.mjs
var anatomy26 = createAnatomy("rating-group").parts("root", "label", "item", "control");
var parts28 = anatomy26.build();
var getRootId20 = (ctx) => {
  var _a8;
  return ((_a8 = ctx.ids) == null ? void 0 : _a8.root) ?? `rating:${ctx.id}`;
};
var getLabelId13 = (ctx) => {
  var _a8;
  return ((_a8 = ctx.ids) == null ? void 0 : _a8.label) ?? `rating:${ctx.id}:label`;
};
var getHiddenInputId6 = (ctx) => {
  var _a8;
  return ((_a8 = ctx.ids) == null ? void 0 : _a8.hiddenInput) ?? `rating:${ctx.id}:input`;
};
var getControlId8 = (ctx) => {
  var _a8;
  return ((_a8 = ctx.ids) == null ? void 0 : _a8.control) ?? `rating:${ctx.id}:control`;
};
var getItemId9 = (ctx, id) => {
  var _a8, _b7;
  return ((_b7 = (_a8 = ctx.ids) == null ? void 0 : _a8.item) == null ? void 0 : _b7.call(_a8, id)) ?? `rating:${ctx.id}:item:${id}`;
};
var getControlEl5 = (ctx) => ctx.getById(getControlId8(ctx));
var getRadioEl2 = (ctx, value) => {
  const selector = `[role=radio][aria-posinset='${Math.ceil(value)}']`;
  return query(getControlEl5(ctx), selector);
};
var getHiddenInputEl6 = (ctx) => ctx.getById(getHiddenInputId6(ctx));
var dispatchChangeEvent = (ctx, value) => {
  const inputEl = getHiddenInputEl6(ctx);
  if (!inputEl) return;
  dispatchInputValueEvent(inputEl, { value });
};
function connect27(service, normalize4) {
  const { context, send, prop, scope, computed } = service;
  const interactive = computed("isInteractive");
  const disabled = computed("isDisabled");
  const readOnly = prop("readOnly");
  const value = context.get("value");
  const hoveredValue = context.get("hoveredValue");
  const translations = prop("translations");
  function getItemState(props210) {
    const currentValue = computed("isHovering") ? hoveredValue : value;
    const equal = Math.ceil(currentValue) === props210.index;
    const highlighted = props210.index <= currentValue || equal;
    const half = equal && Math.abs(currentValue - props210.index) === 0.5;
    return {
      highlighted,
      half,
      checked: equal || value === -1 && props210.index === 1
    };
  }
  return {
    hovering: computed("isHovering"),
    value,
    hoveredValue,
    count: prop("count"),
    items: Array.from({ length: prop("count") }).map((_, index) => index + 1),
    setValue(value2) {
      send({ type: "SET_VALUE", value: value2 });
    },
    clearValue() {
      send({ type: "CLEAR_VALUE" });
    },
    getRootProps() {
      return normalize4.element({
        ...parts28.root.attrs,
        dir: prop("dir"),
        id: getRootId20(scope)
      });
    },
    getHiddenInputProps() {
      return normalize4.input({
        name: prop("name"),
        form: prop("form"),
        type: "text",
        hidden: true,
        disabled,
        readOnly,
        required: prop("required"),
        id: getHiddenInputId6(scope),
        defaultValue: value
      });
    },
    getLabelProps() {
      return normalize4.label({
        ...parts28.label.attrs,
        dir: prop("dir"),
        id: getLabelId13(scope),
        "data-disabled": dataAttr(disabled),
        htmlFor: getHiddenInputId6(scope),
        onClick(event) {
          if (event.defaultPrevented) return;
          if (!interactive) return;
          event.preventDefault();
          const radioEl = getRadioEl2(scope, Math.max(1, context.get("value")));
          radioEl == null ? void 0 : radioEl.focus({ preventScroll: true });
        }
      });
    },
    getControlProps() {
      return normalize4.element({
        id: getControlId8(scope),
        ...parts28.control.attrs,
        dir: prop("dir"),
        role: "radiogroup",
        "aria-orientation": "horizontal",
        "aria-labelledby": getLabelId13(scope),
        "aria-readonly": ariaAttr(readOnly),
        "data-readonly": dataAttr(readOnly),
        "data-disabled": dataAttr(disabled),
        onPointerMove(event) {
          if (!interactive) return;
          if (event.pointerType === "touch") return;
          send({ type: "GROUP_POINTER_OVER" });
        },
        onPointerLeave(event) {
          if (!interactive) return;
          if (event.pointerType === "touch") return;
          send({ type: "GROUP_POINTER_LEAVE" });
        }
      });
    },
    getItemState,
    getItemProps(props210) {
      const { index } = props210;
      const itemState = getItemState(props210);
      const valueText = translations.ratingValueText(index);
      return normalize4.element({
        ...parts28.item.attrs,
        dir: prop("dir"),
        id: getItemId9(scope, index.toString()),
        role: "radio",
        tabIndex: (() => {
          if (readOnly) return itemState.checked ? 0 : void 0;
          if (disabled) return void 0;
          return itemState.checked ? 0 : -1;
        })(),
        "aria-roledescription": "rating",
        "aria-label": valueText,
        "aria-disabled": disabled,
        "data-disabled": dataAttr(disabled),
        "data-readonly": dataAttr(readOnly),
        "aria-setsize": prop("count"),
        "aria-checked": itemState.checked,
        "data-checked": dataAttr(itemState.checked),
        "aria-posinset": index,
        "data-highlighted": dataAttr(itemState.highlighted),
        "data-half": dataAttr(itemState.half),
        onPointerDown(event) {
          if (!interactive) return;
          if (!isLeftClick(event)) return;
          event.preventDefault();
        },
        onPointerMove(event) {
          if (!interactive) return;
          const point = getEventPoint(event);
          const relativePoint = getRelativePoint(point, event.currentTarget);
          const percentX = relativePoint.getPercentValue({
            orientation: "horizontal",
            dir: prop("dir")
          });
          const isMidway = percentX < 0.5;
          send({ type: "POINTER_OVER", index, isMidway });
        },
        onKeyDown(event) {
          if (event.defaultPrevented) return;
          if (!interactive) return;
          const keyMap2 = {
            ArrowLeft() {
              send({ type: "ARROW_LEFT" });
            },
            ArrowRight() {
              send({ type: "ARROW_RIGHT" });
            },
            ArrowUp() {
              send({ type: "ARROW_LEFT" });
            },
            ArrowDown() {
              send({ type: "ARROW_RIGHT" });
            },
            Space() {
              send({ type: "SPACE", value: index });
            },
            Home() {
              send({ type: "HOME" });
            },
            End() {
              send({ type: "END" });
            }
          };
          const key = getEventKey(event, { dir: prop("dir") });
          const exec = keyMap2[key];
          if (exec) {
            event.preventDefault();
            exec(event);
          }
        },
        onClick() {
          if (!interactive) return;
          send({ type: "CLICK", value: index });
        },
        onFocus() {
          if (!interactive) return;
          send({ type: "FOCUS" });
        },
        onBlur() {
          if (!interactive) return;
          send({ type: "BLUR" });
        }
      });
    }
  };
}
var machine27 = createMachine({
  props({ props: props210 }) {
    return {
      name: "rating",
      count: 5,
      dir: "ltr",
      defaultValue: -1,
      ...props210,
      translations: {
        ratingValueText: (index) => `${index} stars`,
        ...props210.translations
      }
    };
  },
  initialState() {
    return "idle";
  },
  context({ prop, bindable }) {
    return {
      value: bindable(() => ({
        defaultValue: prop("defaultValue"),
        value: prop("value"),
        onChange(value) {
          var _a8;
          (_a8 = prop("onValueChange")) == null ? void 0 : _a8({ value });
        }
      })),
      hoveredValue: bindable(() => ({
        defaultValue: -1,
        onChange(value) {
          var _a8;
          (_a8 = prop("onHoverChange")) == null ? void 0 : _a8({ hoveredValue: value });
        }
      })),
      fieldsetDisabled: bindable(() => ({
        defaultValue: false
      }))
    };
  },
  watch({ track, action, prop, context }) {
    track([() => prop("allowHalf")], () => {
      action(["roundValueIfNeeded"]);
    });
    track([() => context.get("value")], () => {
      action(["dispatchChangeEvent"]);
    });
  },
  computed: {
    isDisabled: ({ context, prop }) => !!prop("disabled") || context.get("fieldsetDisabled"),
    isInteractive: ({ computed, prop }) => !(computed("isDisabled") || prop("readOnly")),
    isHovering: ({ context }) => context.get("hoveredValue") > -1
  },
  effects: ["trackFormControlState"],
  on: {
    SET_VALUE: {
      actions: ["setValue"]
    },
    CLEAR_VALUE: {
      actions: ["clearValue"]
    }
  },
  states: {
    idle: {
      entry: ["clearHoveredValue"],
      on: {
        GROUP_POINTER_OVER: {
          target: "hover"
        },
        FOCUS: {
          target: "focus"
        },
        CLICK: {
          actions: ["setValue", "focusActiveRadio"]
        }
      }
    },
    focus: {
      on: {
        POINTER_OVER: {
          actions: ["setHoveredValue"]
        },
        GROUP_POINTER_LEAVE: {
          actions: ["clearHoveredValue"]
        },
        BLUR: {
          target: "idle"
        },
        SPACE: {
          guard: "isValueEmpty",
          actions: ["setValue"]
        },
        CLICK: {
          actions: ["setValue", "focusActiveRadio"]
        },
        ARROW_LEFT: {
          actions: ["setPrevValue", "focusActiveRadio"]
        },
        ARROW_RIGHT: {
          actions: ["setNextValue", "focusActiveRadio"]
        },
        HOME: {
          actions: ["setValueToMin", "focusActiveRadio"]
        },
        END: {
          actions: ["setValueToMax", "focusActiveRadio"]
        }
      }
    },
    hover: {
      on: {
        POINTER_OVER: {
          actions: ["setHoveredValue"]
        },
        GROUP_POINTER_LEAVE: [
          {
            guard: "isRadioFocused",
            target: "focus",
            actions: ["clearHoveredValue"]
          },
          {
            target: "idle",
            actions: ["clearHoveredValue"]
          }
        ],
        CLICK: {
          actions: ["setValue", "focusActiveRadio"]
        }
      }
    }
  },
  implementations: {
    guards: {
      isInteractive: ({ prop }) => !(prop("disabled") || prop("readOnly")),
      isHoveredValueEmpty: ({ context }) => context.get("hoveredValue") === -1,
      isValueEmpty: ({ context }) => context.get("value") <= 0,
      isRadioFocused: ({ scope }) => {
        var _a8;
        return !!((_a8 = getControlEl5(scope)) == null ? void 0 : _a8.contains(scope.getActiveElement()));
      }
    },
    effects: {
      trackFormControlState({ context, scope }) {
        return trackFormControl(getHiddenInputEl6(scope), {
          onFieldsetDisabledChange(disabled) {
            context.set("fieldsetDisabled", disabled);
          },
          onFormReset() {
            context.set("value", context.initial("value"));
          }
        });
      }
    },
    actions: {
      clearHoveredValue({ context }) {
        context.set("hoveredValue", -1);
      },
      focusActiveRadio({ scope, context }) {
        raf(() => {
          var _a8;
          return (_a8 = getRadioEl2(scope, context.get("value"))) == null ? void 0 : _a8.focus();
        });
      },
      setPrevValue({ context, prop }) {
        const factor = prop("allowHalf") ? 0.5 : 1;
        context.set("value", Math.max(0, context.get("value") - factor));
      },
      setNextValue({ context, prop }) {
        const factor = prop("allowHalf") ? 0.5 : 1;
        const value = context.get("value") === -1 ? 0 : context.get("value");
        context.set("value", Math.min(prop("count"), value + factor));
      },
      setValueToMin({ context }) {
        context.set("value", 1);
      },
      setValueToMax({ context, prop }) {
        context.set("value", prop("count"));
      },
      setValue({ context, event }) {
        const hoveredValue = context.get("hoveredValue");
        const value = hoveredValue === -1 ? event.value : hoveredValue;
        context.set("value", value);
      },
      clearValue({ context }) {
        context.set("value", -1);
      },
      setHoveredValue({ context, prop, event }) {
        const half = prop("allowHalf") && event.isMidway;
        const factor = half ? 0.5 : 0;
        context.set("hoveredValue", event.index - factor);
      },
      roundValueIfNeeded({ context, prop }) {
        if (prop("allowHalf")) return;
        context.set("value", Math.round(context.get("value")));
      },
      dispatchChangeEvent({ context, scope }) {
        dispatchChangeEvent(scope, context.get("value"));
      }
    }
  }
});
var props27 = createProps()([
  "allowHalf",
  "autoFocus",
  "count",
  "dir",
  "disabled",
  "form",
  "getRootNode",
  "id",
  "ids",
  "name",
  "onHoverChange",
  "onValueChange",
  "required",
  "readOnly",
  "translations",
  "value",
  "defaultValue"
]);
var splitProps27 = createSplitProps(props27);
var itemProps9 = createProps()(["index"]);
var splitItemProps9 = createSplitProps(itemProps9);

// node_modules/@ark-ui/react/dist/components/rating-group/use-rating-group.js
var import_react642 = __toESM(require_react(), 1);
var useRatingGroup = (props43) => {
  const id = (0, import_react642.useId)();
  const { getRootNode } = useEnvironmentContext();
  const { dir } = useLocaleContext();
  const field = useFieldContext();
  const machineProps = {
    id,
    ids: {
      label: field == null ? void 0 : field.ids.label,
      hiddenInput: field == null ? void 0 : field.ids.control
    },
    dir,
    disabled: field == null ? void 0 : field.disabled,
    readOnly: field == null ? void 0 : field.readOnly,
    required: field == null ? void 0 : field.required,
    getRootNode,
    ...props43
  };
  const service = useMachine(machine27, machineProps);
  return connect27(service, normalizeProps);
};

// node_modules/@ark-ui/react/dist/components/rating-group/rating-group-root.js
var RatingGroupRoot = (0, import_react644.forwardRef)((props43, ref) => {
  const [useRatingProps, localProps] = createSplitProps2()(props43, [
    "allowHalf",
    "autoFocus",
    "count",
    "defaultValue",
    "disabled",
    "form",
    "id",
    "ids",
    "name",
    "onHoverChange",
    "onValueChange",
    "readOnly",
    "required",
    "translations",
    "value"
  ]);
  const ratingGroup = useRatingGroup(useRatingProps);
  const mergedProps = mergeProps2(ratingGroup.getRootProps(), localProps);
  return (0, import_jsx_runtime301.jsx)(RatingGroupProvider, { value: ratingGroup, children: (0, import_jsx_runtime301.jsx)(ark.div, { ...mergedProps, ref }) });
});
RatingGroupRoot.displayName = "RatingGroupRoot";

// node_modules/@ark-ui/react/dist/components/rating-group/rating-group-root-provider.js
var import_jsx_runtime302 = __toESM(require_jsx_runtime(), 1);
var import_react646 = __toESM(require_react(), 1);
var RatingGroupRootProvider = (0, import_react646.forwardRef)((props43, ref) => {
  const [{ value: ratingGroup }, localProps] = createSplitProps2()(props43, ["value"]);
  const mergedProps = mergeProps2(ratingGroup.getRootProps(), localProps);
  return (0, import_jsx_runtime302.jsx)(RatingGroupProvider, { value: ratingGroup, children: (0, import_jsx_runtime302.jsx)(ark.div, { ...mergedProps, ref }) });
});
RatingGroupRootProvider.displayName = "RatingGroupRootProvider";

// node_modules/@ark-ui/react/dist/components/rating-group/rating-group.js
var rating_group_exports = {};
__export(rating_group_exports, {
  Context: () => RatingGroupContext,
  Control: () => RatingGroupControl,
  HiddenInput: () => RatingGroupHiddenInput,
  Item: () => RatingGroupItem,
  ItemContext: () => RatingGroupItemContext,
  Label: () => RatingGroupLabel,
  Root: () => RatingGroupRoot,
  RootProvider: () => RatingGroupRootProvider
});

// node_modules/@ark-ui/react/dist/components/segment-group/use-segment-group-context.js
var [SegmentGroupProvider, useSegmentGroupContext] = createContext3({
  name: "SegmentGroupContext",
  hookName: "useSegmentGroupContext",
  providerName: "<SegmentGroupProvider />"
});

// node_modules/@ark-ui/react/dist/components/segment-group/segment-group-context.js
var SegmentGroupContext = (props43) => props43.children(useSegmentGroupContext());

// node_modules/@ark-ui/react/dist/components/segment-group/segment-group-indicator.js
var import_jsx_runtime303 = __toESM(require_jsx_runtime(), 1);
var import_react648 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/segment-group/segment-group.anatomy.js
var segmentGroupAnatomy = anatomy25.rename("segment-group");
var parts29 = segmentGroupAnatomy.build();

// node_modules/@ark-ui/react/dist/components/segment-group/segment-group-indicator.js
var SegmentGroupIndicator = (0, import_react648.forwardRef)((props43, ref) => {
  const segmentGroup = useSegmentGroupContext();
  const mergedProps = mergeProps2(
    segmentGroup.getIndicatorProps(),
    parts29.indicator.attrs,
    props43
  );
  return (0, import_jsx_runtime303.jsx)(ark.div, { ...mergedProps, ref });
});
SegmentGroupIndicator.displayName = "SegmentGroupIndicator";

// node_modules/@ark-ui/react/dist/components/segment-group/segment-group-item.js
var import_jsx_runtime304 = __toESM(require_jsx_runtime(), 1);
var import_react650 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/segment-group/use-segment-group-item-context.js
var [SegmentGroupItemProvider, useSegmentGroupItemContext] = createContext3({
  name: "SegmentGroupItemContext",
  hookName: "useSegmentGroupItemContext",
  providerName: "<SegmentGroupItemProvider />"
});

// node_modules/@ark-ui/react/dist/components/segment-group/use-segment-group-item-props-context.js
var [SegmentGroupItemPropsProvider, useSegmentGroupItemPropsContext] = createContext3({
  name: "SegmentGroupItemPropsContext",
  hookName: "useSegmentGroupItemPropsContext",
  providerName: "<SegmentGroupItemPropsProvider />"
});

// node_modules/@ark-ui/react/dist/components/segment-group/segment-group-item.js
var SegmentGroupItem = (0, import_react650.forwardRef)((props43, ref) => {
  const [itemProps14, localProps] = createSplitProps2()(props43, ["value", "disabled", "invalid"]);
  const segmentGroup = useSegmentGroupContext();
  const mergedProps = mergeProps2(
    segmentGroup.getItemProps(itemProps14),
    parts29.item.attrs,
    localProps
  );
  const itemState = segmentGroup.getItemState(itemProps14);
  return (0, import_jsx_runtime304.jsx)(SegmentGroupItemPropsProvider, { value: itemProps14, children: (0, import_jsx_runtime304.jsx)(SegmentGroupItemProvider, { value: itemState, children: (0, import_jsx_runtime304.jsx)(ark.label, { ...mergedProps, ref }) }) });
});
SegmentGroupItem.displayName = "SegmentGroupItem";

// node_modules/@ark-ui/react/dist/components/segment-group/segment-group-item-context.js
var SegmentGroupItemContext = (props43) => props43.children(useSegmentGroupItemContext());

// node_modules/@ark-ui/react/dist/components/segment-group/segment-group-item-control.js
var import_jsx_runtime305 = __toESM(require_jsx_runtime(), 1);
var import_react652 = __toESM(require_react(), 1);
var SegmentGroupItemControl = (0, import_react652.forwardRef)((props43, ref) => {
  const segmentGroup = useSegmentGroupContext();
  const itemProps14 = useSegmentGroupItemPropsContext();
  const mergedProps = mergeProps2(
    segmentGroup.getItemControlProps(itemProps14),
    parts29.itemControl.attrs,
    props43
  );
  return (0, import_jsx_runtime305.jsx)(ark.div, { ...mergedProps, ref });
});
SegmentGroupItemControl.displayName = "SegmentGroupItemControl";

// node_modules/@ark-ui/react/dist/components/segment-group/segment-group-item-hidden-input.js
var import_jsx_runtime306 = __toESM(require_jsx_runtime(), 1);
var import_react654 = __toESM(require_react(), 1);
var SegmentGroupItemHiddenInput = (0, import_react654.forwardRef)(
  (props43, ref) => {
    const segmentGroup = useSegmentGroupContext();
    const itemProps14 = useSegmentGroupItemPropsContext();
    const mergedProps = mergeProps2(segmentGroup.getItemHiddenInputProps(itemProps14), props43);
    return (0, import_jsx_runtime306.jsx)(ark.input, { ...mergedProps, ref });
  }
);
SegmentGroupItemHiddenInput.displayName = "SegmentGroupItemHiddenInput";

// node_modules/@ark-ui/react/dist/components/segment-group/segment-group-item-text.js
var import_jsx_runtime307 = __toESM(require_jsx_runtime(), 1);
var import_react656 = __toESM(require_react(), 1);
var SegmentGroupItemText = (0, import_react656.forwardRef)((props43, ref) => {
  const segmentGroup = useSegmentGroupContext();
  const itemProps14 = useSegmentGroupItemPropsContext();
  const mergedProps = mergeProps2(
    segmentGroup.getItemTextProps(itemProps14),
    parts29.itemText.attrs,
    props43
  );
  return (0, import_jsx_runtime307.jsx)(ark.span, { ...mergedProps, ref });
});
SegmentGroupItemText.displayName = "SegmentGroupItemText";

// node_modules/@ark-ui/react/dist/components/segment-group/segment-group-label.js
var import_jsx_runtime308 = __toESM(require_jsx_runtime(), 1);
var import_react658 = __toESM(require_react(), 1);
var SegmentGroupLabel = (0, import_react658.forwardRef)((props43, ref) => {
  const segmentGroup = useSegmentGroupContext();
  const mergedProps = mergeProps2(segmentGroup.getLabelProps(), parts29.label.attrs, props43);
  return (0, import_jsx_runtime308.jsx)(ark.label, { ...mergedProps, ref });
});
SegmentGroupLabel.displayName = "SegmentGroupLabel";

// node_modules/@ark-ui/react/dist/components/segment-group/segment-group-root.js
var import_jsx_runtime309 = __toESM(require_jsx_runtime(), 1);
var import_react662 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/segment-group/use-segment-group.js
var import_react660 = __toESM(require_react(), 1);
var useSegmentGroup = (props43) => {
  const id = (0, import_react660.useId)();
  const { getRootNode } = useEnvironmentContext();
  const { dir } = useLocaleContext();
  const machineProps = {
    id,
    dir,
    getRootNode,
    ...props43
  };
  const service = useMachine(machine26, machineProps);
  return connect26(service, normalizeProps);
};

// node_modules/@ark-ui/react/dist/components/segment-group/segment-group-root.js
var SegmentGroupRoot = (0, import_react662.forwardRef)((props43, ref) => {
  const [useSegmentGroupProps, localProps] = createSplitProps2()(props43, [
    "defaultValue",
    "disabled",
    "form",
    "id",
    "ids",
    "name",
    "onValueChange",
    "orientation",
    "readOnly",
    "value"
  ]);
  const segmentGroup = useSegmentGroup(useSegmentGroupProps);
  const mergedProps = mergeProps2(segmentGroup.getRootProps(), parts29.root.attrs, localProps);
  return (0, import_jsx_runtime309.jsx)(SegmentGroupProvider, { value: segmentGroup, children: (0, import_jsx_runtime309.jsx)(ark.div, { ...mergedProps, ref }) });
});
SegmentGroupRoot.displayName = "SegmentGroupRoot";

// node_modules/@ark-ui/react/dist/components/segment-group/segment-group-root-provider.js
var import_jsx_runtime310 = __toESM(require_jsx_runtime(), 1);
var import_react664 = __toESM(require_react(), 1);
var SegmentGroupRootProvider = (0, import_react664.forwardRef)((props43, ref) => {
  const [{ value: segmentGroup }, localProps] = createSplitProps2()(props43, ["value"]);
  const mergedProps = mergeProps2(segmentGroup.getRootProps(), parts29.root.attrs, localProps);
  return (0, import_jsx_runtime310.jsx)(SegmentGroupProvider, { value: segmentGroup, children: (0, import_jsx_runtime310.jsx)(ark.div, { ...mergedProps, ref }) });
});
SegmentGroupRootProvider.displayName = "SegmentGroupRootProvider";

// node_modules/@ark-ui/react/dist/components/segment-group/segment-group.js
var segment_group_exports = {};
__export(segment_group_exports, {
  Context: () => SegmentGroupContext,
  Indicator: () => SegmentGroupIndicator,
  Item: () => SegmentGroupItem,
  ItemContext: () => SegmentGroupItemContext,
  ItemControl: () => SegmentGroupItemControl,
  ItemHiddenInput: () => SegmentGroupItemHiddenInput,
  ItemText: () => SegmentGroupItemText,
  Label: () => SegmentGroupLabel,
  Root: () => SegmentGroupRoot,
  RootProvider: () => SegmentGroupRootProvider
});

// node_modules/@ark-ui/react/dist/components/select/select-clear-trigger.js
var import_jsx_runtime311 = __toESM(require_jsx_runtime(), 1);
var import_react666 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/select/use-select-context.js
var [SelectProvider, useSelectContext] = createContext3({
  name: "SelectContext",
  hookName: "useSelectContext",
  providerName: "<SelectProvider />"
});

// node_modules/@ark-ui/react/dist/components/select/select-clear-trigger.js
var SelectClearTrigger = (0, import_react666.forwardRef)((props43, ref) => {
  const select = useSelectContext();
  const mergedProps = mergeProps2(select.getClearTriggerProps(), props43);
  return (0, import_jsx_runtime311.jsx)(ark.button, { ...mergedProps, ref });
});
SelectClearTrigger.displayName = "SelectClearTrigger";

// node_modules/@ark-ui/react/dist/components/select/select-content.js
var import_jsx_runtime312 = __toESM(require_jsx_runtime(), 1);
var import_react668 = __toESM(require_react(), 1);
var SelectContent = (0, import_react668.forwardRef)((props43, ref) => {
  const select = useSelectContext();
  const presence = usePresenceContext();
  const mergedProps = mergeProps2(select.getContentProps(), presence.getPresenceProps(), props43);
  if (presence.unmounted) {
    return null;
  }
  return (0, import_jsx_runtime312.jsx)(ark.div, { ...mergedProps, ref: composeRefs(presence.ref, ref) });
});
SelectContent.displayName = "SelectContent";

// node_modules/@ark-ui/react/dist/components/select/select-context.js
var SelectContext = (props43) => props43.children(useSelectContext());

// node_modules/@ark-ui/react/dist/components/select/select-control.js
var import_jsx_runtime313 = __toESM(require_jsx_runtime(), 1);
var import_react670 = __toESM(require_react(), 1);
var SelectControl = (0, import_react670.forwardRef)((props43, ref) => {
  const select = useSelectContext();
  const mergedProps = mergeProps2(select.getControlProps(), props43);
  return (0, import_jsx_runtime313.jsx)(ark.div, { ...mergedProps, ref });
});
SelectControl.displayName = "SelectControl";

// node_modules/@ark-ui/react/dist/components/select/select-hidden-select.js
var import_jsx_runtime314 = __toESM(require_jsx_runtime(), 1);
var import_react672 = __toESM(require_react(), 1);
var SelectHiddenSelect = (0, import_react672.forwardRef)((props43, ref) => {
  const select = useSelectContext();
  const mergedProps = mergeProps2(select.getHiddenSelectProps(), props43);
  const isValueEmpty = select.value.length === 0;
  const field = useFieldContext();
  return (0, import_jsx_runtime314.jsxs)(ark.select, { "aria-describedby": field == null ? void 0 : field.ariaDescribedby, ...mergedProps, ref, children: [
    isValueEmpty && (0, import_jsx_runtime314.jsx)("option", { value: "" }),
    select.collection.items.map((item, index) => (0, import_jsx_runtime314.jsx)(
      "option",
      {
        value: select.collection.getItemValue(item) ?? "",
        disabled: select.collection.getItemDisabled(item),
        children: select.collection.stringifyItem(item)
      },
      index
    ))
  ] });
});
SelectHiddenSelect.displayName = "SelectHiddenSelect";

// node_modules/@ark-ui/react/dist/components/select/select-indicator.js
var import_jsx_runtime315 = __toESM(require_jsx_runtime(), 1);
var import_react674 = __toESM(require_react(), 1);
var SelectIndicator = (0, import_react674.forwardRef)((props43, ref) => {
  const select = useSelectContext();
  const mergedProps = mergeProps2(select.getIndicatorProps(), props43);
  return (0, import_jsx_runtime315.jsx)(ark.div, { ...mergedProps, ref });
});
SelectIndicator.displayName = "SelectIndicator";

// node_modules/@ark-ui/react/dist/components/select/select-item.js
var import_jsx_runtime316 = __toESM(require_jsx_runtime(), 1);
var import_react676 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/select/use-select-item-context.js
var [SelectItemProvider, useSelectItemContext] = createContext3({
  name: "SelectItemContext",
  hookName: "useSelectItemContext",
  providerName: "<SelectItemProvider />"
});

// node_modules/@ark-ui/react/dist/components/select/use-select-item-props-context.js
var [SelectItemPropsProvider, useSelectItemPropsContext] = createContext3({
  name: "SelectItemPropsContext",
  hookName: "useSelectItemPropsContext",
  providerName: "<SelectItemPropsProvider />"
});

// node_modules/@ark-ui/react/dist/components/select/select-item.js
var SelectItem = (0, import_react676.forwardRef)((props43, ref) => {
  const [itemProps14, localProps] = createSplitProps2()(props43, ["item", "persistFocus"]);
  const select = useSelectContext();
  const mergedProps = mergeProps2(select.getItemProps(itemProps14), localProps);
  const itemState = select.getItemState(itemProps14);
  return (0, import_jsx_runtime316.jsx)(SelectItemPropsProvider, { value: itemProps14, children: (0, import_jsx_runtime316.jsx)(SelectItemProvider, { value: itemState, children: (0, import_jsx_runtime316.jsx)(ark.div, { ...mergedProps, ref }) }) });
});
SelectItem.displayName = "SelectItem";

// node_modules/@ark-ui/react/dist/components/select/select-item-context.js
var SelectItemContext = (props43) => props43.children(useSelectItemContext());

// node_modules/@ark-ui/react/dist/components/select/select-item-group.js
var import_jsx_runtime317 = __toESM(require_jsx_runtime(), 1);
var import_react678 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/select/use-select-item-group-props.js
var [SelectItemGroupPropsProvider, useSelectItemGroupPropsContext] = createContext3({
  name: "SelectItemGroupPropsContext",
  hookName: "useSelectItemGroupPropsContext",
  providerName: "<SelectItemGroupPropsProvider />"
});

// node_modules/@ark-ui/react/dist/components/select/select-item-group.js
var SelectItemGroup = (0, import_react678.forwardRef)((props43, ref) => {
  const id = (0, import_react678.useId)();
  const [_itemGroupProps, localProps] = createSplitProps2()(props43, ["id"]);
  const itemGroupProps5 = { id, ..._itemGroupProps };
  const select = useSelectContext();
  const mergedProps = mergeProps2(select.getItemGroupProps(itemGroupProps5), localProps);
  return (0, import_jsx_runtime317.jsx)(SelectItemGroupPropsProvider, { value: itemGroupProps5, children: (0, import_jsx_runtime317.jsx)(ark.div, { ...mergedProps, ref }) });
});
SelectItemGroup.displayName = "SelectItemGroup";

// node_modules/@ark-ui/react/dist/components/select/select-item-group-label.js
var import_jsx_runtime318 = __toESM(require_jsx_runtime(), 1);
var import_react680 = __toESM(require_react(), 1);
var SelectItemGroupLabel = (0, import_react680.forwardRef)((props43, ref) => {
  const select = useSelectContext();
  const itemGroupProps5 = useSelectItemGroupPropsContext();
  const mergedProps = mergeProps2(select.getItemGroupLabelProps({ htmlFor: itemGroupProps5.id }), props43);
  return (0, import_jsx_runtime318.jsx)(ark.div, { ...mergedProps, ref });
});
SelectItemGroupLabel.displayName = "SelectItemGroupLabel";

// node_modules/@ark-ui/react/dist/components/select/select-item-indicator.js
var import_jsx_runtime319 = __toESM(require_jsx_runtime(), 1);
var import_react682 = __toESM(require_react(), 1);
var SelectItemIndicator = (0, import_react682.forwardRef)((props43, ref) => {
  const select = useSelectContext();
  const itemProps14 = useSelectItemPropsContext();
  const mergedProps = mergeProps2(select.getItemIndicatorProps(itemProps14), props43);
  return (0, import_jsx_runtime319.jsx)(ark.div, { ...mergedProps, ref });
});
SelectItemIndicator.displayName = "SelectItemIndicator";

// node_modules/@ark-ui/react/dist/components/select/select-item-text.js
var import_jsx_runtime320 = __toESM(require_jsx_runtime(), 1);
var import_react684 = __toESM(require_react(), 1);
var SelectItemText = (0, import_react684.forwardRef)((props43, ref) => {
  const select = useSelectContext();
  const itemProps14 = useSelectItemPropsContext();
  const mergedProps = mergeProps2(select.getItemTextProps(itemProps14), props43);
  return (0, import_jsx_runtime320.jsx)(ark.span, { ...mergedProps, ref });
});
SelectItemText.displayName = "SelectItemText";

// node_modules/@ark-ui/react/dist/components/select/select-label.js
var import_jsx_runtime321 = __toESM(require_jsx_runtime(), 1);
var import_react686 = __toESM(require_react(), 1);
var SelectLabel = (0, import_react686.forwardRef)((props43, ref) => {
  const select = useSelectContext();
  const mergedProps = mergeProps2(select.getLabelProps(), props43);
  return (0, import_jsx_runtime321.jsx)(ark.label, { ...mergedProps, ref });
});
SelectLabel.displayName = "SelectLabel";

// node_modules/@ark-ui/react/dist/components/select/select-list.js
var import_jsx_runtime322 = __toESM(require_jsx_runtime(), 1);
var import_react688 = __toESM(require_react(), 1);
var SelectList = (0, import_react688.forwardRef)((props43, ref) => {
  const select = useSelectContext();
  const mergedProps = mergeProps2(select.getListProps(), props43);
  return (0, import_jsx_runtime322.jsx)(ark.div, { ...mergedProps, ref });
});
SelectList.displayName = "SelectList";

// node_modules/@ark-ui/react/dist/components/select/select-positioner.js
var import_jsx_runtime323 = __toESM(require_jsx_runtime(), 1);
var import_react690 = __toESM(require_react(), 1);
var SelectPositioner = (0, import_react690.forwardRef)((props43, ref) => {
  const select = useSelectContext();
  const mergedProps = mergeProps2(select.getPositionerProps(), props43);
  const presence = usePresenceContext();
  if (presence.unmounted) {
    return null;
  }
  return (0, import_jsx_runtime323.jsx)(ark.div, { ...mergedProps, ref });
});
SelectPositioner.displayName = "SelectPositioner";

// node_modules/@ark-ui/react/dist/components/select/select-root.js
var import_jsx_runtime324 = __toESM(require_jsx_runtime(), 1);
var import_react694 = __toESM(require_react(), 1);

// node_modules/@zag-js/select/dist/index.mjs
var anatomy27 = createAnatomy("select").parts(
  "label",
  "positioner",
  "trigger",
  "indicator",
  "clearTrigger",
  "item",
  "itemText",
  "itemIndicator",
  "itemGroup",
  "itemGroupLabel",
  "list",
  "content",
  "root",
  "control",
  "valueText"
);
var parts30 = anatomy27.build();
var collection3 = (options) => {
  return new ListCollection(options);
};
collection3.empty = () => {
  return new ListCollection({ items: [] });
};
var getRootId21 = (ctx) => {
  var _a8;
  return ((_a8 = ctx.ids) == null ? void 0 : _a8.root) ?? `select:${ctx.id}`;
};
var getContentId11 = (ctx) => {
  var _a8;
  return ((_a8 = ctx.ids) == null ? void 0 : _a8.content) ?? `select:${ctx.id}:content`;
};
var getTriggerId11 = (ctx) => {
  var _a8;
  return ((_a8 = ctx.ids) == null ? void 0 : _a8.trigger) ?? `select:${ctx.id}:trigger`;
};
var getClearTriggerId3 = (ctx) => {
  var _a8;
  return ((_a8 = ctx.ids) == null ? void 0 : _a8.clearTrigger) ?? `select:${ctx.id}:clear-trigger`;
};
var getLabelId14 = (ctx) => {
  var _a8;
  return ((_a8 = ctx.ids) == null ? void 0 : _a8.label) ?? `select:${ctx.id}:label`;
};
var getControlId9 = (ctx) => {
  var _a8;
  return ((_a8 = ctx.ids) == null ? void 0 : _a8.control) ?? `select:${ctx.id}:control`;
};
var getItemId10 = (ctx, id) => {
  var _a8, _b7;
  return ((_b7 = (_a8 = ctx.ids) == null ? void 0 : _a8.item) == null ? void 0 : _b7.call(_a8, id)) ?? `select:${ctx.id}:option:${id}`;
};
var getHiddenSelectId = (ctx) => {
  var _a8;
  return ((_a8 = ctx.ids) == null ? void 0 : _a8.hiddenSelect) ?? `select:${ctx.id}:select`;
};
var getPositionerId9 = (ctx) => {
  var _a8;
  return ((_a8 = ctx.ids) == null ? void 0 : _a8.positioner) ?? `select:${ctx.id}:positioner`;
};
var getItemGroupId4 = (ctx, id) => {
  var _a8, _b7;
  return ((_b7 = (_a8 = ctx.ids) == null ? void 0 : _a8.itemGroup) == null ? void 0 : _b7.call(_a8, id)) ?? `select:${ctx.id}:optgroup:${id}`;
};
var getItemGroupLabelId3 = (ctx, id) => {
  var _a8, _b7;
  return ((_b7 = (_a8 = ctx.ids) == null ? void 0 : _a8.itemGroupLabel) == null ? void 0 : _b7.call(_a8, id)) ?? `select:${ctx.id}:optgroup-label:${id}`;
};
var getHiddenSelectEl = (ctx) => ctx.getById(getHiddenSelectId(ctx));
var getContentEl11 = (ctx) => ctx.getById(getContentId11(ctx));
var getTriggerEl9 = (ctx) => ctx.getById(getTriggerId11(ctx));
var getClearTriggerEl3 = (ctx) => ctx.getById(getClearTriggerId3(ctx));
var getPositionerEl9 = (ctx) => ctx.getById(getPositionerId9(ctx));
var getItemEl4 = (ctx, id) => ctx.getById(getItemId10(ctx, id));
function connect28(service, normalize4) {
  const { context, prop, scope, state: state2, computed, send } = service;
  const disabled = prop("disabled") || context.get("fieldsetDisabled");
  const invalid = prop("invalid");
  const readOnly = prop("readOnly");
  const composite = prop("composite");
  const collection22 = prop("collection");
  const open = state2.hasTag("open");
  const focused = state2.matches("focused");
  const highlightedValue = context.get("highlightedValue");
  const highlightedItem = context.get("highlightedItem");
  const selectedItems = context.get("selectedItems");
  const currentPlacement = context.get("currentPlacement");
  const isTypingAhead = computed("isTypingAhead");
  const interactive = computed("isInteractive");
  const ariaActiveDescendant = highlightedValue ? getItemId10(scope, highlightedValue) : void 0;
  function getItemState(props210) {
    const _disabled = collection22.getItemDisabled(props210.item);
    const value = collection22.getItemValue(props210.item);
    ensure(value, () => `[zag-js] No value found for item ${JSON.stringify(props210.item)}`);
    return {
      value,
      disabled: Boolean(disabled || _disabled),
      highlighted: highlightedValue === value,
      selected: context.get("value").includes(value)
    };
  }
  const popperStyles = getPlacementStyles({
    ...prop("positioning"),
    placement: currentPlacement
  });
  return {
    open,
    focused,
    empty: context.get("value").length === 0,
    highlightedItem,
    highlightedValue,
    selectedItems,
    hasSelectedItems: computed("hasSelectedItems"),
    value: context.get("value"),
    valueAsString: context.get("valueAsString"),
    collection: collection22,
    multiple: !!prop("multiple"),
    disabled: !!disabled,
    reposition(options = {}) {
      send({ type: "POSITIONING.SET", options });
    },
    focus() {
      var _a8;
      (_a8 = getTriggerEl9(scope)) == null ? void 0 : _a8.focus({ preventScroll: true });
    },
    setOpen(nextOpen) {
      const open2 = state2.hasTag("open");
      if (open2 === nextOpen) return;
      send({ type: nextOpen ? "OPEN" : "CLOSE" });
    },
    selectValue(value) {
      send({ type: "ITEM.SELECT", value });
    },
    setValue(value) {
      send({ type: "VALUE.SET", value });
    },
    selectAll() {
      send({ type: "VALUE.SET", value: collection22.getValues() });
    },
    highlightValue(value) {
      send({ type: "HIGHLIGHTED_VALUE.SET", value });
    },
    clearValue(value) {
      if (value) {
        send({ type: "ITEM.CLEAR", value });
      } else {
        send({ type: "VALUE.CLEAR" });
      }
    },
    getItemState,
    getRootProps() {
      return normalize4.element({
        ...parts30.root.attrs,
        dir: prop("dir"),
        id: getRootId21(scope),
        "data-invalid": dataAttr(invalid),
        "data-readonly": dataAttr(readOnly)
      });
    },
    getLabelProps() {
      return normalize4.label({
        dir: prop("dir"),
        id: getLabelId14(scope),
        ...parts30.label.attrs,
        "data-disabled": dataAttr(disabled),
        "data-invalid": dataAttr(invalid),
        "data-readonly": dataAttr(readOnly),
        htmlFor: getHiddenSelectId(scope),
        onClick(event) {
          var _a8;
          if (event.defaultPrevented) return;
          if (disabled) return;
          (_a8 = getTriggerEl9(scope)) == null ? void 0 : _a8.focus({ preventScroll: true });
        }
      });
    },
    getControlProps() {
      return normalize4.element({
        ...parts30.control.attrs,
        dir: prop("dir"),
        id: getControlId9(scope),
        "data-state": open ? "open" : "closed",
        "data-focus": dataAttr(focused),
        "data-disabled": dataAttr(disabled),
        "data-invalid": dataAttr(invalid)
      });
    },
    getValueTextProps() {
      return normalize4.element({
        ...parts30.valueText.attrs,
        dir: prop("dir"),
        "data-disabled": dataAttr(disabled),
        "data-invalid": dataAttr(invalid),
        "data-focus": dataAttr(focused)
      });
    },
    getTriggerProps() {
      return normalize4.button({
        id: getTriggerId11(scope),
        disabled,
        dir: prop("dir"),
        type: "button",
        role: "combobox",
        "aria-controls": getContentId11(scope),
        "aria-expanded": open,
        "aria-haspopup": "listbox",
        "data-state": open ? "open" : "closed",
        "aria-invalid": invalid,
        "aria-labelledby": getLabelId14(scope),
        ...parts30.trigger.attrs,
        "data-disabled": dataAttr(disabled),
        "data-invalid": dataAttr(invalid),
        "data-readonly": dataAttr(readOnly),
        "data-placement": currentPlacement,
        "data-placeholder-shown": dataAttr(!computed("hasSelectedItems")),
        onClick(event) {
          if (!interactive) return;
          if (event.defaultPrevented) return;
          send({ type: "TRIGGER.CLICK" });
        },
        onFocus() {
          send({ type: "TRIGGER.FOCUS" });
        },
        onBlur() {
          send({ type: "TRIGGER.BLUR" });
        },
        onKeyDown(event) {
          if (event.defaultPrevented) return;
          if (!interactive) return;
          const keyMap2 = {
            ArrowUp() {
              send({ type: "TRIGGER.ARROW_UP" });
            },
            ArrowDown(event2) {
              send({ type: event2.altKey ? "OPEN" : "TRIGGER.ARROW_DOWN" });
            },
            ArrowLeft() {
              send({ type: "TRIGGER.ARROW_LEFT" });
            },
            ArrowRight() {
              send({ type: "TRIGGER.ARROW_RIGHT" });
            },
            Home() {
              send({ type: "TRIGGER.HOME" });
            },
            End() {
              send({ type: "TRIGGER.END" });
            },
            Enter() {
              send({ type: "TRIGGER.ENTER" });
            },
            Space(event2) {
              if (isTypingAhead) {
                send({ type: "TRIGGER.TYPEAHEAD", key: event2.key });
              } else {
                send({ type: "TRIGGER.ENTER" });
              }
            }
          };
          const exec = keyMap2[getEventKey(event, {
            dir: prop("dir"),
            orientation: "vertical"
          })];
          if (exec) {
            exec(event);
            event.preventDefault();
            return;
          }
          if (getByTypeahead.isValidEvent(event)) {
            send({ type: "TRIGGER.TYPEAHEAD", key: event.key });
            event.preventDefault();
          }
        }
      });
    },
    getIndicatorProps() {
      return normalize4.element({
        ...parts30.indicator.attrs,
        dir: prop("dir"),
        "aria-hidden": true,
        "data-state": open ? "open" : "closed",
        "data-disabled": dataAttr(disabled),
        "data-invalid": dataAttr(invalid),
        "data-readonly": dataAttr(readOnly)
      });
    },
    getItemProps(props210) {
      const itemState = getItemState(props210);
      return normalize4.element({
        id: getItemId10(scope, itemState.value),
        role: "option",
        ...parts30.item.attrs,
        dir: prop("dir"),
        "data-value": itemState.value,
        "aria-selected": itemState.selected,
        "data-state": itemState.selected ? "checked" : "unchecked",
        "data-highlighted": dataAttr(itemState.highlighted),
        "data-disabled": dataAttr(itemState.disabled),
        "aria-disabled": ariaAttr(itemState.disabled),
        onPointerMove(event) {
          if (itemState.disabled || event.pointerType !== "mouse") return;
          if (itemState.value === highlightedValue) return;
          send({ type: "ITEM.POINTER_MOVE", value: itemState.value });
        },
        onClick(event) {
          if (event.defaultPrevented) return;
          if (itemState.disabled) return;
          send({ type: "ITEM.CLICK", src: "pointerup", value: itemState.value });
        },
        onPointerLeave(event) {
          var _a8;
          if (itemState.disabled) return;
          if (props210.persistFocus) return;
          if (event.pointerType !== "mouse") return;
          const pointerMoved = (_a8 = service.event.previous()) == null ? void 0 : _a8.type.includes("POINTER");
          if (!pointerMoved) return;
          send({ type: "ITEM.POINTER_LEAVE" });
        }
      });
    },
    getItemTextProps(props210) {
      const itemState = getItemState(props210);
      return normalize4.element({
        ...parts30.itemText.attrs,
        "data-state": itemState.selected ? "checked" : "unchecked",
        "data-disabled": dataAttr(itemState.disabled),
        "data-highlighted": dataAttr(itemState.highlighted)
      });
    },
    getItemIndicatorProps(props210) {
      const itemState = getItemState(props210);
      return normalize4.element({
        "aria-hidden": true,
        ...parts30.itemIndicator.attrs,
        "data-state": itemState.selected ? "checked" : "unchecked",
        hidden: !itemState.selected
      });
    },
    getItemGroupLabelProps(props210) {
      const { htmlFor } = props210;
      return normalize4.element({
        ...parts30.itemGroupLabel.attrs,
        id: getItemGroupLabelId3(scope, htmlFor),
        dir: prop("dir"),
        role: "presentation"
      });
    },
    getItemGroupProps(props210) {
      const { id } = props210;
      return normalize4.element({
        ...parts30.itemGroup.attrs,
        "data-disabled": dataAttr(disabled),
        id: getItemGroupId4(scope, id),
        "aria-labelledby": getItemGroupLabelId3(scope, id),
        role: "group",
        dir: prop("dir")
      });
    },
    getClearTriggerProps() {
      return normalize4.button({
        ...parts30.clearTrigger.attrs,
        id: getClearTriggerId3(scope),
        type: "button",
        "aria-label": "Clear value",
        "data-invalid": dataAttr(invalid),
        disabled,
        hidden: !computed("hasSelectedItems"),
        dir: prop("dir"),
        onClick(event) {
          if (event.defaultPrevented) return;
          send({ type: "CLEAR.CLICK" });
        }
      });
    },
    getHiddenSelectProps() {
      const value = context.get("value");
      const defaultValue = prop("multiple") ? value : value == null ? void 0 : value[0];
      return normalize4.select({
        name: prop("name"),
        form: prop("form"),
        disabled,
        multiple: prop("multiple"),
        required: prop("required"),
        "aria-hidden": true,
        id: getHiddenSelectId(scope),
        defaultValue,
        style: visuallyHiddenStyle,
        tabIndex: -1,
        // Some browser extensions will focus the hidden select.
        // Let's forward the focus to the trigger.
        onFocus() {
          var _a8;
          (_a8 = getTriggerEl9(scope)) == null ? void 0 : _a8.focus({ preventScroll: true });
        },
        "aria-labelledby": getLabelId14(scope)
      });
    },
    getPositionerProps() {
      return normalize4.element({
        ...parts30.positioner.attrs,
        dir: prop("dir"),
        id: getPositionerId9(scope),
        style: popperStyles.floating
      });
    },
    getContentProps() {
      return normalize4.element({
        hidden: !open,
        dir: prop("dir"),
        id: getContentId11(scope),
        role: composite ? "listbox" : "dialog",
        ...parts30.content.attrs,
        "data-state": open ? "open" : "closed",
        "data-placement": currentPlacement,
        "data-activedescendant": ariaActiveDescendant,
        "aria-activedescendant": composite ? ariaActiveDescendant : void 0,
        "aria-multiselectable": prop("multiple") && composite ? true : void 0,
        "aria-labelledby": getLabelId14(scope),
        tabIndex: 0,
        onKeyDown(event) {
          if (!interactive) return;
          if (!isSelfTarget(event)) return;
          if (event.key === "Tab") {
            const valid = isValidTabEvent(event);
            if (!valid) {
              event.preventDefault();
              return;
            }
          }
          const keyMap2 = {
            ArrowUp() {
              send({ type: "CONTENT.ARROW_UP" });
            },
            ArrowDown() {
              send({ type: "CONTENT.ARROW_DOWN" });
            },
            Home() {
              send({ type: "CONTENT.HOME" });
            },
            End() {
              send({ type: "CONTENT.END" });
            },
            Enter() {
              send({ type: "ITEM.CLICK", src: "keydown.enter" });
            },
            Space(event2) {
              var _a8;
              if (isTypingAhead) {
                send({ type: "CONTENT.TYPEAHEAD", key: event2.key });
              } else {
                (_a8 = keyMap2.Enter) == null ? void 0 : _a8.call(keyMap2, event2);
              }
            }
          };
          const exec = keyMap2[getEventKey(event)];
          if (exec) {
            exec(event);
            event.preventDefault();
            return;
          }
          const target = getEventTarget(event);
          if (isEditableElement(target)) {
            return;
          }
          if (getByTypeahead.isValidEvent(event)) {
            send({ type: "CONTENT.TYPEAHEAD", key: event.key });
            event.preventDefault();
          }
        }
      });
    },
    getListProps() {
      return normalize4.element({
        ...parts30.list.attrs,
        tabIndex: 0,
        role: !composite ? "listbox" : void 0,
        "aria-labelledby": getTriggerId11(scope),
        "aria-activedescendant": !composite ? ariaActiveDescendant : void 0,
        "aria-multiselectable": !composite && prop("multiple") ? true : void 0
      });
    }
  };
}
var { and: and9, not: not9, or: or2 } = createGuards();
var machine28 = createMachine({
  props({ props: props210 }) {
    return {
      loopFocus: false,
      closeOnSelect: !props210.multiple,
      composite: true,
      defaultValue: [],
      ...props210,
      collection: props210.collection ?? collection3.empty(),
      positioning: {
        placement: "bottom-start",
        gutter: 8,
        ...props210.positioning
      }
    };
  },
  context({ prop, bindable }) {
    return {
      value: bindable(() => ({
        defaultValue: prop("defaultValue"),
        value: prop("value"),
        isEqual,
        onChange(value) {
          var _a8;
          const items = prop("collection").findMany(value);
          return (_a8 = prop("onValueChange")) == null ? void 0 : _a8({ value, items });
        }
      })),
      highlightedValue: bindable(() => ({
        defaultValue: prop("defaultHighlightedValue") || null,
        value: prop("highlightedValue"),
        onChange(value) {
          var _a8;
          (_a8 = prop("onHighlightChange")) == null ? void 0 : _a8({
            highlightedValue: value,
            highlightedItem: prop("collection").find(value),
            highlightedIndex: prop("collection").indexOf(value)
          });
        }
      })),
      currentPlacement: bindable(() => ({
        defaultValue: void 0
      })),
      fieldsetDisabled: bindable(() => ({
        defaultValue: false
      })),
      highlightedItem: bindable(() => ({
        defaultValue: null
      })),
      selectedItems: bindable(() => {
        const value = prop("value") ?? prop("defaultValue") ?? [];
        const items = prop("collection").findMany(value);
        return { defaultValue: items };
      }),
      valueAsString: bindable(() => {
        const value = prop("value") ?? prop("defaultValue") ?? [];
        return { defaultValue: prop("collection").stringifyMany(value) };
      })
    };
  },
  refs() {
    return {
      typeahead: { ...getByTypeahead.defaultOptions }
    };
  },
  computed: {
    hasSelectedItems: ({ context }) => context.get("value").length > 0,
    isTypingAhead: ({ refs }) => refs.get("typeahead").keysSoFar !== "",
    isDisabled: ({ prop, context }) => !!prop("disabled") || !!context.get("fieldsetDisabled"),
    isInteractive: ({ prop }) => !(prop("disabled") || prop("readOnly"))
  },
  initialState({ prop }) {
    const open = prop("open") || prop("defaultOpen");
    return open ? "open" : "idle";
  },
  entry: ["syncSelectElement"],
  watch({ context, prop, track, action }) {
    track([() => context.get("value").toString()], () => {
      action(["syncSelectedItems", "syncSelectElement", "dispatchChangeEvent"]);
    });
    track([() => prop("open")], () => {
      action(["toggleVisibility"]);
    });
    track([() => context.get("highlightedValue")], () => {
      action(["syncHighlightedItem"]);
    });
    track([() => prop("collection").toString()], () => {
      action(["syncCollection"]);
    });
  },
  on: {
    "HIGHLIGHTED_VALUE.SET": {
      actions: ["setHighlightedItem"]
    },
    "ITEM.SELECT": {
      actions: ["selectItem"]
    },
    "ITEM.CLEAR": {
      actions: ["clearItem"]
    },
    "VALUE.SET": {
      actions: ["setSelectedItems"]
    },
    "VALUE.CLEAR": {
      actions: ["clearSelectedItems"]
    },
    "CLEAR.CLICK": {
      actions: ["clearSelectedItems", "focusTriggerEl"]
    }
  },
  effects: ["trackFormControlState"],
  states: {
    idle: {
      tags: ["closed"],
      on: {
        "CONTROLLED.OPEN": [
          {
            guard: "isTriggerClickEvent",
            target: "open",
            actions: ["setInitialFocus", "highlightFirstSelectedItem"]
          },
          {
            target: "open",
            actions: ["setInitialFocus"]
          }
        ],
        "TRIGGER.CLICK": [
          {
            guard: "isOpenControlled",
            actions: ["invokeOnOpen"]
          },
          {
            target: "open",
            actions: ["invokeOnOpen", "setInitialFocus", "highlightFirstSelectedItem"]
          }
        ],
        "TRIGGER.FOCUS": {
          target: "focused"
        },
        OPEN: [
          {
            guard: "isOpenControlled",
            actions: ["invokeOnOpen"]
          },
          {
            target: "open",
            actions: ["setInitialFocus", "invokeOnOpen"]
          }
        ]
      }
    },
    focused: {
      tags: ["closed"],
      on: {
        "CONTROLLED.OPEN": [
          {
            guard: "isTriggerClickEvent",
            target: "open",
            actions: ["setInitialFocus", "highlightFirstSelectedItem"]
          },
          {
            guard: "isTriggerArrowUpEvent",
            target: "open",
            actions: ["setInitialFocus", "highlightComputedLastItem"]
          },
          {
            guard: or2("isTriggerArrowDownEvent", "isTriggerEnterEvent"),
            target: "open",
            actions: ["setInitialFocus", "highlightComputedFirstItem"]
          },
          {
            target: "open",
            actions: ["setInitialFocus"]
          }
        ],
        OPEN: [
          {
            guard: "isOpenControlled",
            actions: ["invokeOnOpen"]
          },
          {
            target: "open",
            actions: ["setInitialFocus", "invokeOnOpen"]
          }
        ],
        "TRIGGER.BLUR": {
          target: "idle"
        },
        "TRIGGER.CLICK": [
          {
            guard: "isOpenControlled",
            actions: ["invokeOnOpen"]
          },
          {
            target: "open",
            actions: ["setInitialFocus", "invokeOnOpen", "highlightFirstSelectedItem"]
          }
        ],
        "TRIGGER.ENTER": [
          {
            guard: "isOpenControlled",
            actions: ["invokeOnOpen"]
          },
          {
            target: "open",
            actions: ["setInitialFocus", "invokeOnOpen", "highlightComputedFirstItem"]
          }
        ],
        "TRIGGER.ARROW_UP": [
          {
            guard: "isOpenControlled",
            actions: ["invokeOnOpen"]
          },
          {
            target: "open",
            actions: ["setInitialFocus", "invokeOnOpen", "highlightComputedLastItem"]
          }
        ],
        "TRIGGER.ARROW_DOWN": [
          {
            guard: "isOpenControlled",
            actions: ["invokeOnOpen"]
          },
          {
            target: "open",
            actions: ["setInitialFocus", "invokeOnOpen", "highlightComputedFirstItem"]
          }
        ],
        "TRIGGER.ARROW_LEFT": [
          {
            guard: and9(not9("multiple"), "hasSelectedItems"),
            actions: ["selectPreviousItem"]
          },
          {
            guard: not9("multiple"),
            actions: ["selectLastItem"]
          }
        ],
        "TRIGGER.ARROW_RIGHT": [
          {
            guard: and9(not9("multiple"), "hasSelectedItems"),
            actions: ["selectNextItem"]
          },
          {
            guard: not9("multiple"),
            actions: ["selectFirstItem"]
          }
        ],
        "TRIGGER.HOME": {
          guard: not9("multiple"),
          actions: ["selectFirstItem"]
        },
        "TRIGGER.END": {
          guard: not9("multiple"),
          actions: ["selectLastItem"]
        },
        "TRIGGER.TYPEAHEAD": {
          guard: not9("multiple"),
          actions: ["selectMatchingItem"]
        }
      }
    },
    open: {
      tags: ["open"],
      exit: ["scrollContentToTop"],
      effects: ["trackDismissableElement", "computePlacement", "scrollToHighlightedItem"],
      on: {
        "CONTROLLED.CLOSE": [
          {
            guard: "restoreFocus",
            target: "focused",
            actions: ["focusTriggerEl", "clearHighlightedItem"]
          },
          {
            target: "idle",
            actions: ["clearHighlightedItem"]
          }
        ],
        CLOSE: [
          {
            guard: "isOpenControlled",
            actions: ["invokeOnClose"]
          },
          {
            guard: "restoreFocus",
            target: "focused",
            actions: ["invokeOnClose", "focusTriggerEl", "clearHighlightedItem"]
          },
          {
            target: "idle",
            actions: ["invokeOnClose", "clearHighlightedItem"]
          }
        ],
        "TRIGGER.CLICK": [
          {
            guard: "isOpenControlled",
            actions: ["invokeOnClose"]
          },
          {
            target: "focused",
            actions: ["invokeOnClose", "clearHighlightedItem"]
          }
        ],
        "ITEM.CLICK": [
          {
            guard: and9("closeOnSelect", "isOpenControlled"),
            actions: ["selectHighlightedItem", "invokeOnClose"]
          },
          {
            guard: "closeOnSelect",
            target: "focused",
            actions: ["selectHighlightedItem", "invokeOnClose", "focusTriggerEl", "clearHighlightedItem"]
          },
          {
            actions: ["selectHighlightedItem"]
          }
        ],
        "CONTENT.HOME": {
          actions: ["highlightFirstItem"]
        },
        "CONTENT.END": {
          actions: ["highlightLastItem"]
        },
        "CONTENT.ARROW_DOWN": [
          {
            guard: and9("hasHighlightedItem", "loop", "isLastItemHighlighted"),
            actions: ["highlightFirstItem"]
          },
          {
            guard: "hasHighlightedItem",
            actions: ["highlightNextItem"]
          },
          {
            actions: ["highlightFirstItem"]
          }
        ],
        "CONTENT.ARROW_UP": [
          {
            guard: and9("hasHighlightedItem", "loop", "isFirstItemHighlighted"),
            actions: ["highlightLastItem"]
          },
          {
            guard: "hasHighlightedItem",
            actions: ["highlightPreviousItem"]
          },
          {
            actions: ["highlightLastItem"]
          }
        ],
        "CONTENT.TYPEAHEAD": {
          actions: ["highlightMatchingItem"]
        },
        "ITEM.POINTER_MOVE": {
          actions: ["highlightItem"]
        },
        "ITEM.POINTER_LEAVE": {
          actions: ["clearHighlightedItem"]
        },
        "POSITIONING.SET": {
          actions: ["reposition"]
        }
      }
    }
  },
  implementations: {
    guards: {
      loop: ({ prop }) => !!prop("loopFocus"),
      multiple: ({ prop }) => !!prop("multiple"),
      hasSelectedItems: ({ computed }) => !!computed("hasSelectedItems"),
      hasHighlightedItem: ({ context }) => context.get("highlightedValue") != null,
      isFirstItemHighlighted: ({ context, prop }) => context.get("highlightedValue") === prop("collection").firstValue,
      isLastItemHighlighted: ({ context, prop }) => context.get("highlightedValue") === prop("collection").lastValue,
      closeOnSelect: ({ prop, event }) => !!(event.closeOnSelect ?? prop("closeOnSelect")),
      restoreFocus: ({ event }) => restoreFocusFn(event),
      // guard assertions (for controlled mode)
      isOpenControlled: ({ prop }) => prop("open") !== void 0,
      isTriggerClickEvent: ({ event }) => {
        var _a8;
        return ((_a8 = event.previousEvent) == null ? void 0 : _a8.type) === "TRIGGER.CLICK";
      },
      isTriggerEnterEvent: ({ event }) => {
        var _a8;
        return ((_a8 = event.previousEvent) == null ? void 0 : _a8.type) === "TRIGGER.ENTER";
      },
      isTriggerArrowUpEvent: ({ event }) => {
        var _a8;
        return ((_a8 = event.previousEvent) == null ? void 0 : _a8.type) === "TRIGGER.ARROW_UP";
      },
      isTriggerArrowDownEvent: ({ event }) => {
        var _a8;
        return ((_a8 = event.previousEvent) == null ? void 0 : _a8.type) === "TRIGGER.ARROW_DOWN";
      }
    },
    effects: {
      trackFormControlState({ context, scope }) {
        return trackFormControl(getHiddenSelectEl(scope), {
          onFieldsetDisabledChange(disabled) {
            context.set("fieldsetDisabled", disabled);
          },
          onFormReset() {
            const value = context.initial("value");
            context.set("value", value);
          }
        });
      },
      trackDismissableElement({ scope, send, prop }) {
        const contentEl = () => getContentEl11(scope);
        let restoreFocus = true;
        return trackDismissableElement(contentEl, {
          defer: true,
          exclude: [getTriggerEl9(scope), getClearTriggerEl3(scope)],
          onFocusOutside: prop("onFocusOutside"),
          onPointerDownOutside: prop("onPointerDownOutside"),
          onInteractOutside(event) {
            var _a8;
            (_a8 = prop("onInteractOutside")) == null ? void 0 : _a8(event);
            restoreFocus = !(event.detail.focusable || event.detail.contextmenu);
          },
          onDismiss() {
            send({ type: "CLOSE", src: "interact-outside", restoreFocus });
          }
        });
      },
      computePlacement({ context, prop, scope }) {
        const positioning = prop("positioning");
        context.set("currentPlacement", positioning.placement);
        const triggerEl = () => getTriggerEl9(scope);
        const positionerEl = () => getPositionerEl9(scope);
        return getPlacement(triggerEl, positionerEl, {
          defer: true,
          ...positioning,
          onComplete(data) {
            context.set("currentPlacement", data.placement);
          }
        });
      },
      scrollToHighlightedItem({ context, prop, scope, event }) {
        const exec = (immediate) => {
          const highlightedValue = context.get("highlightedValue");
          if (highlightedValue == null) return;
          if (event.current().type.includes("POINTER")) return;
          const optionEl = getItemEl4(scope, highlightedValue);
          const contentEl2 = getContentEl11(scope);
          const scrollToIndexFn = prop("scrollToIndexFn");
          if (scrollToIndexFn) {
            const highlightedIndex = prop("collection").indexOf(highlightedValue);
            scrollToIndexFn == null ? void 0 : scrollToIndexFn({ index: highlightedIndex, immediate });
            return;
          }
          scrollIntoView(optionEl, { rootEl: contentEl2, block: "nearest" });
        };
        raf(() => exec(true));
        const contentEl = () => getContentEl11(scope);
        return observeAttributes(contentEl, {
          defer: true,
          attributes: ["data-activedescendant"],
          callback() {
            exec(false);
          }
        });
      }
    },
    actions: {
      reposition({ context, prop, scope, event }) {
        const positionerEl = () => getPositionerEl9(scope);
        getPlacement(getTriggerEl9(scope), positionerEl, {
          ...prop("positioning"),
          ...event.options,
          defer: true,
          listeners: false,
          onComplete(data) {
            context.set("currentPlacement", data.placement);
          }
        });
      },
      toggleVisibility({ send, prop, event }) {
        send({ type: prop("open") ? "CONTROLLED.OPEN" : "CONTROLLED.CLOSE", previousEvent: event });
      },
      highlightPreviousItem({ context, prop }) {
        const highlightedValue = context.get("highlightedValue");
        if (highlightedValue == null) return;
        const value = prop("collection").getPreviousValue(highlightedValue, 1, prop("loopFocus"));
        if (value == null) return;
        context.set("highlightedValue", value);
      },
      highlightNextItem({ context, prop }) {
        const highlightedValue = context.get("highlightedValue");
        if (highlightedValue == null) return;
        const value = prop("collection").getNextValue(highlightedValue, 1, prop("loopFocus"));
        if (value == null) return;
        context.set("highlightedValue", value);
      },
      highlightFirstItem({ context, prop }) {
        const value = prop("collection").firstValue;
        context.set("highlightedValue", value);
      },
      highlightLastItem({ context, prop }) {
        const value = prop("collection").lastValue;
        context.set("highlightedValue", value);
      },
      setInitialFocus({ scope }) {
        raf(() => {
          const element = getInitialFocus({
            root: getContentEl11(scope)
          });
          element == null ? void 0 : element.focus({ preventScroll: true });
        });
      },
      focusTriggerEl({ event, scope }) {
        if (!restoreFocusFn(event)) return;
        raf(() => {
          const element = getTriggerEl9(scope);
          element == null ? void 0 : element.focus({ preventScroll: true });
        });
      },
      selectHighlightedItem({ context, prop, event }) {
        var _a8;
        let value = event.value ?? context.get("highlightedValue");
        if (value == null) return;
        (_a8 = prop("onSelect")) == null ? void 0 : _a8({ value });
        const nullable = prop("deselectable") && !prop("multiple") && context.get("value").includes(value);
        value = nullable ? null : value;
        context.set("value", (prev2) => {
          if (value == null) return [];
          if (prop("multiple")) return addOrRemove(prev2, value);
          return [value];
        });
      },
      highlightComputedFirstItem({ context, prop, computed }) {
        const collection22 = prop("collection");
        const value = computed("hasSelectedItems") ? collection22.sort(context.get("value"))[0] : collection22.firstValue;
        context.set("highlightedValue", value);
      },
      highlightComputedLastItem({ context, prop, computed }) {
        const collection22 = prop("collection");
        const value = computed("hasSelectedItems") ? collection22.sort(context.get("value"))[0] : collection22.lastValue;
        context.set("highlightedValue", value);
      },
      highlightFirstSelectedItem({ context, prop, computed }) {
        if (!computed("hasSelectedItems")) return;
        const value = prop("collection").sort(context.get("value"))[0];
        context.set("highlightedValue", value);
      },
      highlightItem({ context, event }) {
        context.set("highlightedValue", event.value);
      },
      highlightMatchingItem({ context, prop, event, refs }) {
        const value = prop("collection").search(event.key, {
          state: refs.get("typeahead"),
          currentValue: context.get("highlightedValue")
        });
        if (value == null) return;
        context.set("highlightedValue", value);
      },
      setHighlightedItem({ context, event }) {
        context.set("highlightedValue", event.value);
      },
      clearHighlightedItem({ context }) {
        context.set("highlightedValue", null);
      },
      selectItem({ context, prop, event }) {
        var _a8;
        (_a8 = prop("onSelect")) == null ? void 0 : _a8({ value: event.value });
        const nullable = prop("deselectable") && !prop("multiple") && context.get("value").includes(event.value);
        const value = nullable ? null : event.value;
        context.set("value", (prev2) => {
          if (value == null) return [];
          if (prop("multiple")) return addOrRemove(prev2, value);
          return [value];
        });
      },
      clearItem({ context, event }) {
        context.set("value", (prev2) => prev2.filter((v) => v !== event.value));
      },
      setSelectedItems({ context, event }) {
        context.set("value", event.value);
      },
      clearSelectedItems({ context }) {
        context.set("value", []);
      },
      selectPreviousItem({ context, prop }) {
        const [firstItem] = context.get("value");
        const value = prop("collection").getPreviousValue(firstItem);
        if (value) context.set("value", [value]);
      },
      selectNextItem({ context, prop }) {
        const [firstItem] = context.get("value");
        const value = prop("collection").getNextValue(firstItem);
        if (value) context.set("value", [value]);
      },
      selectFirstItem({ context, prop }) {
        const value = prop("collection").firstValue;
        if (value) context.set("value", [value]);
      },
      selectLastItem({ context, prop }) {
        const value = prop("collection").lastValue;
        if (value) context.set("value", [value]);
      },
      selectMatchingItem({ context, prop, event, refs }) {
        const value = prop("collection").search(event.key, {
          state: refs.get("typeahead"),
          currentValue: context.get("value")[0]
        });
        if (value == null) return;
        context.set("value", [value]);
      },
      scrollContentToTop({ prop, scope }) {
        var _a8, _b7;
        if (prop("scrollToIndexFn")) {
          (_a8 = prop("scrollToIndexFn")) == null ? void 0 : _a8({ index: 0, immediate: true });
        } else {
          (_b7 = getContentEl11(scope)) == null ? void 0 : _b7.scrollTo(0, 0);
        }
      },
      invokeOnOpen({ prop }) {
        var _a8;
        (_a8 = prop("onOpenChange")) == null ? void 0 : _a8({ open: true });
      },
      invokeOnClose({ prop }) {
        var _a8;
        (_a8 = prop("onOpenChange")) == null ? void 0 : _a8({ open: false });
      },
      syncSelectElement({ context, prop, scope }) {
        const selectEl = getHiddenSelectEl(scope);
        if (!selectEl) return;
        if (context.get("value").length === 0 && !prop("multiple")) {
          selectEl.selectedIndex = -1;
          return;
        }
        for (const option of selectEl.options) {
          option.selected = context.get("value").includes(option.value);
        }
      },
      syncCollection({ context, prop }) {
        const collection22 = prop("collection");
        const highlightedItem = collection22.find(context.get("highlightedValue"));
        if (highlightedItem) context.set("highlightedItem", highlightedItem);
        const selectedItems = collection22.findMany(context.get("value"));
        context.set("selectedItems", selectedItems);
        const valueAsString = collection22.stringifyItems(selectedItems);
        context.set("valueAsString", valueAsString);
      },
      syncSelectedItems({ context, prop }) {
        const collection22 = prop("collection");
        const prevSelectedItems = context.get("selectedItems");
        const value = context.get("value");
        const selectedItems = value.map((value2) => {
          const item = prevSelectedItems.find((item2) => collection22.getItemValue(item2) === value2);
          return item || collection22.find(value2);
        });
        context.set("selectedItems", selectedItems);
        context.set("valueAsString", collection22.stringifyItems(selectedItems));
      },
      syncHighlightedItem({ context, prop }) {
        const collection22 = prop("collection");
        const highlightedValue = context.get("highlightedValue");
        const highlightedItem = highlightedValue ? collection22.find(highlightedValue) : null;
        context.set("highlightedItem", highlightedItem);
      },
      dispatchChangeEvent({ scope }) {
        queueMicrotask(() => {
          const node = getHiddenSelectEl(scope);
          if (!node) return;
          const win = scope.getWin();
          const changeEvent = new win.Event("change", { bubbles: true, composed: true });
          node.dispatchEvent(changeEvent);
        });
      }
    }
  }
});
function restoreFocusFn(event) {
  var _a8;
  const v = event.restoreFocus ?? ((_a8 = event.previousEvent) == null ? void 0 : _a8.restoreFocus);
  return v == null || !!v;
}
var props28 = createProps()([
  "closeOnSelect",
  "collection",
  "composite",
  "defaultHighlightedValue",
  "defaultOpen",
  "defaultValue",
  "deselectable",
  "dir",
  "disabled",
  "form",
  "getRootNode",
  "highlightedValue",
  "id",
  "ids",
  "invalid",
  "loopFocus",
  "multiple",
  "name",
  "onFocusOutside",
  "onHighlightChange",
  "onInteractOutside",
  "onOpenChange",
  "onPointerDownOutside",
  "onSelect",
  "onValueChange",
  "open",
  "positioning",
  "readOnly",
  "required",
  "scrollToIndexFn",
  "value"
]);
var splitProps28 = createSplitProps(props28);
var itemProps10 = createProps()(["item", "persistFocus"]);
var splitItemProps10 = createSplitProps(itemProps10);
var itemGroupProps4 = createProps()(["id"]);
var splitItemGroupProps4 = createSplitProps(itemGroupProps4);
var itemGroupLabelProps4 = createProps()(["htmlFor"]);
var splitItemGroupLabelProps4 = createSplitProps(itemGroupLabelProps4);

// node_modules/@ark-ui/react/dist/components/select/use-select.js
var import_react692 = __toESM(require_react(), 1);
var useSelect = (props43) => {
  const id = (0, import_react692.useId)();
  const { dir } = useLocaleContext();
  const { getRootNode } = useEnvironmentContext();
  const field = useFieldContext();
  const machineProps = {
    id,
    ids: {
      label: field == null ? void 0 : field.ids.label,
      hiddenSelect: field == null ? void 0 : field.ids.control
    },
    disabled: field == null ? void 0 : field.disabled,
    readOnly: field == null ? void 0 : field.readOnly,
    invalid: field == null ? void 0 : field.invalid,
    required: field == null ? void 0 : field.required,
    dir,
    getRootNode,
    ...props43
  };
  const service = useMachine(machine28, machineProps);
  return connect28(service, normalizeProps);
};

// node_modules/@ark-ui/react/dist/components/select/select-root.js
var SelectImpl = (props43, ref) => {
  const [presenceProps, selectProps] = splitPresenceProps(props43);
  const [useSelectProps, localProps] = createSplitProps2()(selectProps, [
    "closeOnSelect",
    "collection",
    "composite",
    "defaultHighlightedValue",
    "defaultOpen",
    "defaultValue",
    "deselectable",
    "disabled",
    "form",
    "highlightedValue",
    "id",
    "ids",
    "invalid",
    "loopFocus",
    "multiple",
    "name",
    "onFocusOutside",
    "onHighlightChange",
    "onInteractOutside",
    "onOpenChange",
    "onPointerDownOutside",
    "onSelect",
    "onValueChange",
    "open",
    "positioning",
    "readOnly",
    "required",
    "scrollToIndexFn",
    "value"
  ]);
  const select = useSelect(useSelectProps);
  const presence = usePresence(mergeProps2({ present: select.open }, presenceProps));
  const mergedProps = mergeProps2(select.getRootProps(), localProps);
  return (0, import_jsx_runtime324.jsx)(SelectProvider, { value: select, children: (0, import_jsx_runtime324.jsx)(PresenceProvider, { value: presence, children: (0, import_jsx_runtime324.jsx)(ark.div, { ...mergedProps, ref }) }) });
};
var SelectRoot = (0, import_react694.forwardRef)(SelectImpl);

// node_modules/@ark-ui/react/dist/components/select/select-root-provider.js
var import_jsx_runtime325 = __toESM(require_jsx_runtime(), 1);
var import_react696 = __toESM(require_react(), 1);
var SelectImpl2 = (props43, ref) => {
  const [presenceProps, selectProps] = splitPresenceProps(props43);
  const [{ value: select }, localProps] = createSplitProps2()(selectProps, ["value"]);
  const presence = usePresence(mergeProps2({ present: select.open }, presenceProps));
  const mergedProps = mergeProps2(select.getRootProps(), localProps);
  return (0, import_jsx_runtime325.jsx)(SelectProvider, { value: select, children: (0, import_jsx_runtime325.jsx)(PresenceProvider, { value: presence, children: (0, import_jsx_runtime325.jsx)(ark.div, { ...mergedProps, ref }) }) });
};
var SelectRootProvider = (0, import_react696.forwardRef)(SelectImpl2);

// node_modules/@ark-ui/react/dist/components/select/select-trigger.js
var import_jsx_runtime326 = __toESM(require_jsx_runtime(), 1);
var import_react698 = __toESM(require_react(), 1);
var SelectTrigger = (0, import_react698.forwardRef)((props43, ref) => {
  const select = useSelectContext();
  const mergedProps = mergeProps2(select.getTriggerProps(), props43);
  return (0, import_jsx_runtime326.jsx)(ark.button, { ...mergedProps, ref });
});
SelectTrigger.displayName = "SelectTrigger";

// node_modules/@ark-ui/react/dist/components/select/select-value-text.js
var import_jsx_runtime327 = __toESM(require_jsx_runtime(), 1);
var import_react700 = __toESM(require_react(), 1);
var SelectValueText = (0, import_react700.forwardRef)((props43, ref) => {
  const { children, placeholder, ...localprops } = props43;
  const select = useSelectContext();
  const mergedProps = mergeProps2(select.getValueTextProps(), localprops);
  return (0, import_jsx_runtime327.jsx)(ark.span, { ...mergedProps, ref, children: children || select.valueAsString || placeholder });
});
SelectValueText.displayName = "SelectValueText";

// node_modules/@ark-ui/react/dist/components/select/select.js
var select_exports = {};
__export(select_exports, {
  ClearTrigger: () => SelectClearTrigger,
  Content: () => SelectContent,
  Context: () => SelectContext,
  Control: () => SelectControl,
  HiddenSelect: () => SelectHiddenSelect,
  Indicator: () => SelectIndicator,
  Item: () => SelectItem,
  ItemContext: () => SelectItemContext,
  ItemGroup: () => SelectItemGroup,
  ItemGroupLabel: () => SelectItemGroupLabel,
  ItemIndicator: () => SelectItemIndicator,
  ItemText: () => SelectItemText,
  Label: () => SelectLabel,
  List: () => SelectList,
  Positioner: () => SelectPositioner,
  Root: () => SelectRoot,
  RootProvider: () => SelectRootProvider,
  Trigger: () => SelectTrigger,
  ValueText: () => SelectValueText
});

// node_modules/@ark-ui/react/dist/components/signature-pad/signature-pad-clear-trigger.js
var import_jsx_runtime328 = __toESM(require_jsx_runtime(), 1);
var import_react702 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/signature-pad/use-signature-pad-context.js
var [SignaturePadProvider, useSignaturePadContext] = createContext3({
  name: "SignaturePadContext",
  hookName: "useSignaturePadContext",
  providerName: "<SignaturePadProvider />"
});

// node_modules/@ark-ui/react/dist/components/signature-pad/signature-pad-clear-trigger.js
var SignaturePadClearTrigger = (0, import_react702.forwardRef)((props43, ref) => {
  const signaturePad = useSignaturePadContext();
  const mergedProps = mergeProps2(signaturePad.getClearTriggerProps(), props43);
  return (0, import_jsx_runtime328.jsx)(ark.button, { ...mergedProps, ref });
});
SignaturePadClearTrigger.displayName = "SignaturePadClearTrigger";

// node_modules/@ark-ui/react/dist/components/signature-pad/signature-pad-control.js
var import_jsx_runtime329 = __toESM(require_jsx_runtime(), 1);
var import_react704 = __toESM(require_react(), 1);
var SignaturePadControl = (0, import_react704.forwardRef)((props43, ref) => {
  const signaturePad = useSignaturePadContext();
  const mergedProps = mergeProps2(signaturePad.getControlProps(), props43);
  return (0, import_jsx_runtime329.jsx)(ark.div, { ...mergedProps, ref });
});
SignaturePadControl.displayName = "SignaturePadControl";

// node_modules/@ark-ui/react/dist/components/signature-pad/signature-pad-guide.js
var import_jsx_runtime330 = __toESM(require_jsx_runtime(), 1);
var import_react706 = __toESM(require_react(), 1);
var SignaturePadGuide = (0, import_react706.forwardRef)((props43, ref) => {
  const signaturePad = useSignaturePadContext();
  const mergedProps = mergeProps2(signaturePad.getGuideProps(), props43);
  return (0, import_jsx_runtime330.jsx)(ark.div, { ...mergedProps, ref });
});
SignaturePadGuide.displayName = "SignaturePadGuide";

// node_modules/@ark-ui/react/dist/components/signature-pad/signature-pad-hidden-input.js
var import_jsx_runtime331 = __toESM(require_jsx_runtime(), 1);
var import_react708 = __toESM(require_react(), 1);
var SignaturePadHiddenInput = (0, import_react708.forwardRef)((props43, ref) => {
  const [hiddenInputProps, localProps] = createSplitProps2()(props43, ["value"]);
  const signaturePad = useSignaturePadContext();
  const mergedProps = mergeProps2(signaturePad.getHiddenInputProps(hiddenInputProps), localProps);
  const field = useFieldContext();
  return (0, import_jsx_runtime331.jsx)(ark.input, { "aria-describedby": field == null ? void 0 : field.ariaDescribedby, ...mergedProps, ref });
});
SignaturePadHiddenInput.displayName = "SignaturePadHiddenInput";

// node_modules/@ark-ui/react/dist/components/signature-pad/signature-pad-label.js
var import_jsx_runtime332 = __toESM(require_jsx_runtime(), 1);
var import_react710 = __toESM(require_react(), 1);
var SignaturePadLabel = (0, import_react710.forwardRef)((props43, ref) => {
  const signaturePad = useSignaturePadContext();
  const mergedProps = mergeProps2(signaturePad.getLabelProps(), props43);
  return (0, import_jsx_runtime332.jsx)(ark.label, { ...mergedProps, ref });
});
SignaturePadLabel.displayName = "SignaturePadLabel";

// node_modules/@ark-ui/react/dist/components/signature-pad/signature-pad-root.js
var import_jsx_runtime333 = __toESM(require_jsx_runtime(), 1);
var import_react714 = __toESM(require_react(), 1);

// node_modules/perfect-freehand/dist/esm/index.mjs
function $(e, t, u, x = (h) => h) {
  return e * x(0.5 - t * (0.5 - u));
}
function se(e) {
  return [-e[0], -e[1]];
}
function l(e, t) {
  return [e[0] + t[0], e[1] + t[1]];
}
function a(e, t) {
  return [e[0] - t[0], e[1] - t[1]];
}
function b(e, t) {
  return [e[0] * t, e[1] * t];
}
function he(e, t) {
  return [e[0] / t, e[1] / t];
}
function R(e) {
  return [e[1], -e[0]];
}
function B(e, t) {
  return e[0] * t[0] + e[1] * t[1];
}
function ue(e, t) {
  return e[0] === t[0] && e[1] === t[1];
}
function ge(e) {
  return Math.hypot(e[0], e[1]);
}
function de(e) {
  return e[0] * e[0] + e[1] * e[1];
}
function A(e, t) {
  return de(a(e, t));
}
function G(e) {
  return he(e, ge(e));
}
function ie(e, t) {
  return Math.hypot(e[1] - t[1], e[0] - t[0]);
}
function L(e, t, u) {
  let x = Math.sin(u), h = Math.cos(u), y = e[0] - t[0], n = e[1] - t[1], f = y * h - n * x, d = y * x + n * h;
  return [f + t[0], d + t[1]];
}
function K(e, t, u) {
  return l(e, b(a(t, e), u));
}
function ee(e, t, u) {
  return l(e, b(t, u));
}
var { min: C, PI: xe } = Math;
var pe = 0.275;
var V = xe + 1e-4;
function ce(e, t = {}) {
  let { size: u = 16, smoothing: x = 0.5, thinning: h = 0.5, simulatePressure: y = true, easing: n = (r) => r, start: f = {}, end: d = {}, last: D = false } = t, { cap: S = true, easing: j = (r) => r * (2 - r) } = f, { cap: q = true, easing: c = (r) => --r * r * r + 1 } = d;
  if (e.length === 0 || u <= 0) return [];
  let p = e[e.length - 1].runningLength, g = f.taper === false ? 0 : f.taper === true ? Math.max(u, p) : f.taper, T = d.taper === false ? 0 : d.taper === true ? Math.max(u, p) : d.taper, te = Math.pow(u * x, 2), _ = [], M = [], H = e.slice(0, 10).reduce((r, i) => {
    let o = i.pressure;
    if (y) {
      let s = C(1, i.distance / u), W = C(1, 1 - s);
      o = C(1, r + (W - r) * (s * pe));
    }
    return (r + o) / 2;
  }, e[0].pressure), m = $(u, h, e[e.length - 1].pressure, n), U, X = e[0].vector, z = e[0].point, F = z, O = z, E = F, J = false;
  for (let r = 0; r < e.length; r++) {
    let { pressure: i } = e[r], { point: o, vector: s, distance: W, runningLength: I } = e[r];
    if (r < e.length - 1 && p - I < 3) continue;
    if (h) {
      if (y) {
        let v = C(1, W / u), Z = C(1, 1 - v);
        i = C(1, H + (Z - H) * (v * pe));
      }
      m = $(u, h, i, n);
    } else m = u / 2;
    U === void 0 && (U = m);
    let le = I < g ? j(I / g) : 1, fe = p - I < T ? c((p - I) / T) : 1;
    m = Math.max(0.01, m * Math.min(le, fe));
    let re = (r < e.length - 1 ? e[r + 1] : e[r]).vector, Y = r < e.length - 1 ? B(s, re) : 1, be = B(s, X) < 0 && !J, ne = Y !== null && Y < 0;
    if (be || ne) {
      let v = b(R(X), m);
      for (let Z = 1 / 13, w = 0; w <= 1; w += Z) O = L(a(o, v), o, V * w), _.push(O), E = L(l(o, v), o, V * -w), M.push(E);
      z = O, F = E, ne && (J = true);
      continue;
    }
    if (J = false, r === e.length - 1) {
      let v = b(R(s), m);
      _.push(a(o, v)), M.push(l(o, v));
      continue;
    }
    let oe = b(R(K(re, s, Y)), m);
    O = a(o, oe), (r <= 1 || A(z, O) > te) && (_.push(O), z = O), E = l(o, oe), (r <= 1 || A(F, E) > te) && (M.push(E), F = E), H = i, X = s;
  }
  let P = e[0].point.slice(0, 2), k = e.length > 1 ? e[e.length - 1].point.slice(0, 2) : l(e[0].point, [1, 1]), Q = [], N = [];
  if (e.length === 1) {
    if (!(g || T) || D) {
      let r = ee(P, G(R(a(P, k))), -(U || m)), i = [];
      for (let o = 1 / 13, s = o; s <= 1; s += o) i.push(L(r, P, V * 2 * s));
      return i;
    }
  } else {
    if (!(g || T && e.length === 1)) if (S) for (let i = 1 / 13, o = i; o <= 1; o += i) {
      let s = L(M[0], P, V * o);
      Q.push(s);
    }
    else {
      let i = a(_[0], M[0]), o = b(i, 0.5), s = b(i, 0.51);
      Q.push(a(P, o), a(P, s), l(P, s), l(P, o));
    }
    let r = R(se(e[e.length - 1].vector));
    if (T || g && e.length === 1) N.push(k);
    else if (q) {
      let i = ee(k, r, m);
      for (let o = 1 / 29, s = o; s < 1; s += o) N.push(L(i, k, V * 3 * s));
    } else N.push(l(k, b(r, m)), l(k, b(r, m * 0.99)), a(k, b(r, m * 0.99)), a(k, b(r, m)));
  }
  return _.concat(N, M.reverse(), Q);
}
function me(e, t = {}) {
  var q;
  let { streamline: u = 0.5, size: x = 16, last: h = false } = t;
  if (e.length === 0) return [];
  let y = 0.15 + (1 - u) * 0.85, n = Array.isArray(e[0]) ? e : e.map(({ x: c, y: p, pressure: g = 0.5 }) => [c, p, g]);
  if (n.length === 2) {
    let c = n[1];
    n = n.slice(0, -1);
    for (let p = 1; p < 5; p++) n.push(K(n[0], c, p / 4));
  }
  n.length === 1 && (n = [...n, [...l(n[0], [1, 1]), ...n[0].slice(2)]]);
  let f = [{ point: [n[0][0], n[0][1]], pressure: n[0][2] >= 0 ? n[0][2] : 0.25, vector: [1, 1], distance: 0, runningLength: 0 }], d = false, D = 0, S = f[0], j = n.length - 1;
  for (let c = 1; c < n.length; c++) {
    let p = h && c === j ? n[c].slice(0, 2) : K(S.point, n[c], y);
    if (ue(S.point, p)) continue;
    let g = ie(p, S.point);
    if (D += g, c < j && !d) {
      if (D < x) continue;
      d = true;
    }
    S = { point: p, pressure: n[c][2] >= 0 ? n[c][2] : 0.5, vector: G(a(S.point, p)), distance: g, runningLength: D }, f.push(S);
  }
  return f[0].vector = ((q = f[1]) == null ? void 0 : q.vector) || [0, 0], f;
}
function ae(e, t = {}) {
  return ce(me(e, t), t);
}
var _e = ae;

// node_modules/@zag-js/signature-pad/dist/index.mjs
var anatomy28 = createAnatomy("signature-pad").parts(
  "root",
  "control",
  "segment",
  "segmentPath",
  "guide",
  "clearTrigger",
  "label"
);
var parts31 = anatomy28.build();
var getRootId22 = (ctx) => {
  var _a8;
  return ((_a8 = ctx.ids) == null ? void 0 : _a8.root) ?? `signature-${ctx.id}`;
};
var getControlId10 = (ctx) => {
  var _a8;
  return ((_a8 = ctx.ids) == null ? void 0 : _a8.control) ?? `signature-control-${ctx.id}`;
};
var getLabelId15 = (ctx) => {
  var _a8;
  return ((_a8 = ctx.ids) == null ? void 0 : _a8.label) ?? `signature-label-${ctx.id}`;
};
var getHiddenInputId7 = (ctx) => {
  var _a8;
  return ((_a8 = ctx.ids) == null ? void 0 : _a8.hiddenInput) ?? `signature-input-${ctx.id}`;
};
var getControlEl6 = (ctx) => ctx.getById(getControlId10(ctx));
var getSegmentEl = (ctx) => query(getControlEl6(ctx), "[data-part=segment]");
var getDataUrl2 = (ctx, options) => {
  return getDataUrl(getSegmentEl(ctx), options);
};
function connect29(service, normalize4) {
  const { state: state2, send, prop, computed, context, scope } = service;
  const drawing = state2.matches("drawing");
  const empty2 = computed("isEmpty");
  const interactive = computed("isInteractive");
  const disabled = prop("disabled");
  const translations = prop("translations");
  return {
    empty: empty2,
    drawing,
    currentPath: context.get("currentPath"),
    paths: context.get("paths"),
    clear() {
      send({ type: "CLEAR" });
    },
    getDataUrl(type, quality) {
      if (computed("isEmpty")) return Promise.resolve("");
      return getDataUrl2(scope, { type, quality });
    },
    getLabelProps() {
      return normalize4.label({
        ...parts31.label.attrs,
        id: getLabelId15(scope),
        "data-disabled": dataAttr(disabled),
        htmlFor: getHiddenInputId7(scope),
        onClick(event) {
          if (!interactive) return;
          if (event.defaultPrevented) return;
          const controlEl = getControlEl6(scope);
          controlEl == null ? void 0 : controlEl.focus({ preventScroll: true });
        }
      });
    },
    getRootProps() {
      return normalize4.element({
        ...parts31.root.attrs,
        "data-disabled": dataAttr(disabled),
        id: getRootId22(scope)
      });
    },
    getControlProps() {
      return normalize4.element({
        ...parts31.control.attrs,
        tabIndex: disabled ? void 0 : 0,
        id: getControlId10(scope),
        role: "application",
        "aria-roledescription": "signature pad",
        "aria-label": translations.control,
        "aria-disabled": disabled,
        "data-disabled": dataAttr(disabled),
        onPointerDown(event) {
          if (!isLeftClick(event)) return;
          if (isModifierKey(event)) return;
          if (!interactive) return;
          const target = getEventTarget(event);
          if (target == null ? void 0 : target.closest("[data-part=clear-trigger]")) return;
          event.currentTarget.setPointerCapture(event.pointerId);
          const point = { x: event.clientX, y: event.clientY };
          const controlEl = getControlEl6(scope);
          if (!controlEl) return;
          const { offset: offset4 } = getRelativePoint(point, controlEl);
          send({ type: "POINTER_DOWN", point: offset4, pressure: event.pressure });
        },
        onPointerUp(event) {
          if (!interactive) return;
          if (event.currentTarget.hasPointerCapture(event.pointerId)) {
            event.currentTarget.releasePointerCapture(event.pointerId);
          }
        },
        style: {
          position: "relative",
          touchAction: "none",
          userSelect: "none",
          WebkitUserSelect: "none"
        }
      });
    },
    getSegmentProps() {
      return normalize4.svg({
        ...parts31.segment.attrs,
        style: {
          position: "absolute",
          top: 0,
          left: 0,
          width: "100%",
          height: "100%",
          pointerEvents: "none",
          fill: prop("drawing").fill
        }
      });
    },
    getSegmentPathProps(props210) {
      return normalize4.path({
        ...parts31.segmentPath.attrs,
        d: props210.path
      });
    },
    getGuideProps() {
      return normalize4.element({
        ...parts31.guide.attrs,
        "data-disabled": dataAttr(disabled)
      });
    },
    getClearTriggerProps() {
      return normalize4.button({
        ...parts31.clearTrigger.attrs,
        type: "button",
        "aria-label": translations.clearTrigger,
        hidden: !context.get("paths").length || drawing,
        disabled,
        onClick() {
          send({ type: "CLEAR" });
        }
      });
    },
    getHiddenInputProps(props210) {
      return normalize4.input({
        id: getHiddenInputId7(scope),
        type: "text",
        hidden: true,
        disabled,
        required: prop("required"),
        readOnly: true,
        name: prop("name"),
        value: props210.value
      });
    }
  };
}
var average = (a2, b2) => (a2 + b2) / 2;
function getSvgPathFromStroke(points, closed = true) {
  const len = points.length;
  if (len < 4) {
    return "";
  }
  let a2 = points[0];
  let b2 = points[1];
  const c = points[2];
  let result = `M${a2[0].toFixed(2)},${a2[1].toFixed(2)} Q${b2[0].toFixed(2)},${b2[1].toFixed(2)} ${average(b2[0], c[0]).toFixed(2)},${average(
    b2[1],
    c[1]
  ).toFixed(2)} T`;
  for (let i = 2, max4 = len - 1; i < max4; i++) {
    a2 = points[i];
    b2 = points[i + 1];
    result += `${average(a2[0], b2[0]).toFixed(2)},${average(a2[1], b2[1]).toFixed(2)} `;
  }
  if (closed) {
    result += "Z";
  }
  return result;
}
var machine29 = createMachine({
  props({ props: props210 }) {
    return {
      ...props210,
      drawing: {
        size: 2,
        simulatePressure: false,
        thinning: 0.7,
        smoothing: 0.4,
        streamline: 0.6,
        ...props210.drawing
      },
      translations: {
        control: "signature pad",
        clearTrigger: "clear signature",
        ...props210.translations
      }
    };
  },
  initialState() {
    return "idle";
  },
  context({ prop, bindable }) {
    return {
      paths: bindable(() => ({
        defaultValue: [],
        sync: true,
        onChange(value) {
          var _a8;
          (_a8 = prop("onDraw")) == null ? void 0 : _a8({ paths: value });
        }
      })),
      currentPoints: bindable(() => ({
        defaultValue: []
      })),
      currentPath: bindable(() => ({
        defaultValue: null
      }))
    };
  },
  computed: {
    isInteractive: ({ prop }) => !(prop("disabled") || prop("readOnly")),
    isEmpty: ({ context }) => context.get("paths").length === 0
  },
  on: {
    CLEAR: {
      actions: ["clearPoints", "invokeOnDrawEnd", "focusCanvasEl"]
    }
  },
  states: {
    idle: {
      on: {
        POINTER_DOWN: {
          target: "drawing",
          actions: ["addPoint"]
        }
      }
    },
    drawing: {
      effects: ["trackPointerMove"],
      on: {
        POINTER_MOVE: {
          actions: ["addPoint", "invokeOnDraw"]
        },
        POINTER_UP: {
          target: "idle",
          actions: ["endStroke", "invokeOnDrawEnd"]
        }
      }
    }
  },
  implementations: {
    effects: {
      trackPointerMove({ scope, send }) {
        const doc = scope.getDoc();
        return trackPointerMove(doc, {
          onPointerMove({ event, point }) {
            const controlEl = getControlEl6(scope);
            if (!controlEl) return;
            const { offset: offset4 } = getRelativePoint(point, controlEl);
            send({ type: "POINTER_MOVE", point: offset4, pressure: event.pressure });
          },
          onPointerUp() {
            send({ type: "POINTER_UP" });
          }
        });
      }
    },
    actions: {
      addPoint({ context, event, prop }) {
        const nextPoints = [...context.get("currentPoints"), event.point];
        context.set("currentPoints", nextPoints);
        const stroke = _e(nextPoints, prop("drawing"));
        context.set("currentPath", getSvgPathFromStroke(stroke));
      },
      endStroke({ context }) {
        context.set("paths", [...context.get("paths"), context.get("currentPath")]);
        context.set("currentPoints", []);
        context.set("currentPath", null);
      },
      clearPoints({ context }) {
        context.set("currentPoints", []);
        context.set("paths", []);
      },
      focusCanvasEl({ scope }) {
        queueMicrotask(() => {
          var _a8;
          (_a8 = scope.getActiveElement()) == null ? void 0 : _a8.focus({ preventScroll: true });
        });
      },
      invokeOnDraw({ context, prop }) {
        var _a8;
        (_a8 = prop("onDraw")) == null ? void 0 : _a8({
          paths: [...context.get("paths"), context.get("currentPath")]
        });
      },
      invokeOnDrawEnd({ context, prop, scope, computed }) {
        var _a8;
        (_a8 = prop("onDrawEnd")) == null ? void 0 : _a8({
          paths: [...context.get("paths")],
          getDataUrl(type, quality = 0.92) {
            if (computed("isEmpty")) return Promise.resolve("");
            return getDataUrl2(scope, { type, quality });
          }
        });
      }
    }
  }
});
var props29 = createProps()([
  "dir",
  "disabled",
  "drawing",
  "getRootNode",
  "id",
  "ids",
  "name",
  "onDraw",
  "onDrawEnd",
  "readOnly",
  "required",
  "translations"
]);
var splitProps29 = createSplitProps(props29);

// node_modules/@ark-ui/react/dist/components/signature-pad/use-signature-pad.js
var import_react712 = __toESM(require_react(), 1);
var useSignaturePad = (props43) => {
  const id = (0, import_react712.useId)();
  const { getRootNode } = useEnvironmentContext();
  const { dir } = useLocaleContext();
  const field = useFieldContext();
  const machineProps = {
    id,
    ids: {
      label: field == null ? void 0 : field.ids.label,
      hiddenInput: field == null ? void 0 : field.ids.control
    },
    dir,
    disabled: field == null ? void 0 : field.disabled,
    readOnly: field == null ? void 0 : field.readOnly,
    required: field == null ? void 0 : field.required,
    getRootNode,
    ...props43
  };
  const service = useMachine(machine29, machineProps);
  return connect29(service, normalizeProps);
};

// node_modules/@ark-ui/react/dist/components/signature-pad/signature-pad-root.js
var SignaturePadRoot = (0, import_react714.forwardRef)((props43, ref) => {
  const [useSignaturePadProps, localProps] = createSplitProps2()(props43, [
    "id",
    "ids",
    "drawing",
    "disabled",
    "readOnly",
    "name",
    "onDraw",
    "onDrawEnd",
    "readOnly",
    "required",
    "translations"
  ]);
  const signaturePad = useSignaturePad(useSignaturePadProps);
  const mergedProps = mergeProps2(signaturePad.getRootProps(), localProps);
  return (0, import_jsx_runtime333.jsx)(SignaturePadProvider, { value: signaturePad, children: (0, import_jsx_runtime333.jsx)(ark.div, { ...mergedProps, ref }) });
});
SignaturePadRoot.displayName = "SignaturePadRoot";

// node_modules/@ark-ui/react/dist/components/signature-pad/signature-pad-root-provider.js
var import_jsx_runtime334 = __toESM(require_jsx_runtime(), 1);
var import_react716 = __toESM(require_react(), 1);
var SignaturePadRootProvider = (0, import_react716.forwardRef)((props43, ref) => {
  const [{ value: signaturePad }, localProps] = createSplitProps2()(props43, ["value"]);
  const mergedProps = mergeProps2(signaturePad.getRootProps(), localProps);
  return (0, import_jsx_runtime334.jsx)(SignaturePadProvider, { value: signaturePad, children: (0, import_jsx_runtime334.jsx)(ark.div, { ...mergedProps, ref }) });
});
SignaturePadRootProvider.displayName = "SignaturePadRootProvider";

// node_modules/@ark-ui/react/dist/components/signature-pad/signature-pad-segment.js
var import_jsx_runtime335 = __toESM(require_jsx_runtime(), 1);
var import_react718 = __toESM(require_react(), 1);
var SignaturePadSegment = (0, import_react718.forwardRef)((props43, ref) => {
  const signaturePad = useSignaturePadContext();
  const mergedProps = mergeProps2(signaturePad.getSegmentProps(), props43);
  return (0, import_jsx_runtime335.jsxs)(ark.svg, { ...mergedProps, ref, children: [
    (0, import_jsx_runtime335.jsx)("title", { children: "Signature" }),
    signaturePad.paths.map((path, i) => (0, import_jsx_runtime335.jsx)("path", { ...signaturePad.getSegmentPathProps({ path }) }, i)),
    signaturePad.currentPath && (0, import_jsx_runtime335.jsx)("path", { ...signaturePad.getSegmentPathProps({ path: signaturePad.currentPath }) })
  ] });
});
SignaturePadSegment.displayName = "SignaturePadSegment";

// node_modules/@ark-ui/react/dist/components/slider/use-slider-context.js
var [SliderProvider, useSliderContext] = createContext3({
  name: "SliderContext",
  hookName: "useSliderContext",
  providerName: "<SliderProvider />"
});

// node_modules/@ark-ui/react/dist/components/slider/slider-context.js
var SliderContext = (props43) => props43.children(useSliderContext());

// node_modules/@ark-ui/react/dist/components/slider/slider-control.js
var import_jsx_runtime336 = __toESM(require_jsx_runtime(), 1);
var import_react720 = __toESM(require_react(), 1);
var SliderControl = (0, import_react720.forwardRef)((props43, ref) => {
  const slider = useSliderContext();
  const mergedProps = mergeProps2(slider.getControlProps(), props43);
  return (0, import_jsx_runtime336.jsx)(ark.div, { ...mergedProps, ref });
});
SliderControl.displayName = "SliderControl";

// node_modules/@ark-ui/react/dist/components/slider/slider-dragging-indicator.js
var import_jsx_runtime337 = __toESM(require_jsx_runtime(), 1);
var import_react722 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/slider/use-slider-thumb-props-context.js
var [SliderThumbPropsProvider, useSliderThumbPropsContext] = createContext3({
  name: "SliderThumbPropsContext",
  hookName: "useSliderThumbPropsContext",
  providerName: "<SliderThumbPropsProvider />"
});

// node_modules/@ark-ui/react/dist/components/slider/slider-dragging-indicator.js
var SliderDraggingIndicator = (0, import_react722.forwardRef)((props43, ref) => {
  const slider = useSliderContext();
  const { index } = useSliderThumbPropsContext();
  const mergedProps = mergeProps2(slider.getDraggingIndicatorProps({ index }), props43);
  return (0, import_jsx_runtime337.jsx)(ark.span, { ...mergedProps, ref, children: props43.children || slider.getThumbValue(index) });
});
SliderDraggingIndicator.displayName = "SliderDraggingIndicator";

// node_modules/@ark-ui/react/dist/components/slider/slider-hidden-input.js
var import_jsx_runtime338 = __toESM(require_jsx_runtime(), 1);
var import_react724 = __toESM(require_react(), 1);
var SliderHiddenInput = (0, import_react724.forwardRef)((props43, ref) => {
  const slider = useSliderContext();
  const thumbProps2 = useSliderThumbPropsContext();
  const mergedProps = mergeProps2(slider.getHiddenInputProps(thumbProps2), props43);
  return (0, import_jsx_runtime338.jsx)(ark.input, { ...mergedProps, ref });
});
SliderHiddenInput.displayName = "SliderHiddenInput";

// node_modules/@ark-ui/react/dist/components/slider/slider-label.js
var import_jsx_runtime339 = __toESM(require_jsx_runtime(), 1);
var import_react726 = __toESM(require_react(), 1);
var SliderLabel = (0, import_react726.forwardRef)((props43, ref) => {
  const slider = useSliderContext();
  const mergedProps = mergeProps2(slider.getLabelProps(), props43);
  return (0, import_jsx_runtime339.jsx)(ark.label, { ...mergedProps, ref });
});
SliderLabel.displayName = "SliderLabel";

// node_modules/@ark-ui/react/dist/components/slider/slider-marker.js
var import_jsx_runtime340 = __toESM(require_jsx_runtime(), 1);
var import_react728 = __toESM(require_react(), 1);
var SliderMarker = (0, import_react728.forwardRef)((props43, ref) => {
  const [markerProps, localProps] = createSplitProps2()(props43, ["value"]);
  const slider = useSliderContext();
  const mergedProps = mergeProps2(slider.getMarkerProps(markerProps), localProps);
  return (0, import_jsx_runtime340.jsx)(ark.span, { ...mergedProps, ref });
});
SliderMarker.displayName = "SliderMarker";

// node_modules/@ark-ui/react/dist/components/slider/slider-marker-group.js
var import_jsx_runtime341 = __toESM(require_jsx_runtime(), 1);
var import_react730 = __toESM(require_react(), 1);
var SliderMarkerGroup = (0, import_react730.forwardRef)((props43, ref) => {
  const slider = useSliderContext();
  const mergedProps = mergeProps2(slider.getMarkerGroupProps(), props43);
  return (0, import_jsx_runtime341.jsx)(ark.div, { ...mergedProps, ref });
});
SliderMarkerGroup.displayName = "SliderMarkerGroup";

// node_modules/@ark-ui/react/dist/components/slider/slider-range.js
var import_jsx_runtime342 = __toESM(require_jsx_runtime(), 1);
var import_react732 = __toESM(require_react(), 1);
var SliderRange = (0, import_react732.forwardRef)((props43, ref) => {
  const slider = useSliderContext();
  const mergedProps = mergeProps2(slider.getRangeProps(), props43);
  return (0, import_jsx_runtime342.jsx)(ark.div, { ...mergedProps, ref });
});
SliderRange.displayName = "SliderRange";

// node_modules/@ark-ui/react/dist/components/slider/slider-root.js
var import_jsx_runtime343 = __toESM(require_jsx_runtime(), 1);
var import_react736 = __toESM(require_react(), 1);

// node_modules/@zag-js/slider/dist/index.mjs
var anatomy29 = createAnatomy("slider").parts(
  "root",
  "label",
  "thumb",
  "valueText",
  "track",
  "range",
  "control",
  "markerGroup",
  "marker",
  "draggingIndicator"
);
var parts32 = anatomy29.build();
var getRootId23 = (ctx) => {
  var _a8;
  return ((_a8 = ctx.ids) == null ? void 0 : _a8.root) ?? `slider:${ctx.id}`;
};
var getThumbId2 = (ctx, index) => {
  var _a8, _b7;
  return ((_b7 = (_a8 = ctx.ids) == null ? void 0 : _a8.thumb) == null ? void 0 : _b7.call(_a8, index)) ?? `slider:${ctx.id}:thumb:${index}`;
};
var getHiddenInputId8 = (ctx, index) => {
  var _a8, _b7;
  return ((_b7 = (_a8 = ctx.ids) == null ? void 0 : _a8.hiddenInput) == null ? void 0 : _b7.call(_a8, index)) ?? `slider:${ctx.id}:input:${index}`;
};
var getControlId11 = (ctx) => {
  var _a8;
  return ((_a8 = ctx.ids) == null ? void 0 : _a8.control) ?? `slider:${ctx.id}:control`;
};
var getTrackId2 = (ctx) => {
  var _a8;
  return ((_a8 = ctx.ids) == null ? void 0 : _a8.track) ?? `slider:${ctx.id}:track`;
};
var getRangeId = (ctx) => {
  var _a8;
  return ((_a8 = ctx.ids) == null ? void 0 : _a8.range) ?? `slider:${ctx.id}:range`;
};
var getLabelId16 = (ctx) => {
  var _a8;
  return ((_a8 = ctx.ids) == null ? void 0 : _a8.label) ?? `slider:${ctx.id}:label`;
};
var getValueTextId2 = (ctx) => {
  var _a8;
  return ((_a8 = ctx.ids) == null ? void 0 : _a8.valueText) ?? `slider:${ctx.id}:value-text`;
};
var getMarkerId = (ctx, value) => {
  var _a8, _b7;
  return ((_b7 = (_a8 = ctx.ids) == null ? void 0 : _a8.marker) == null ? void 0 : _b7.call(_a8, value)) ?? `slider:${ctx.id}:marker:${value}`;
};
var getRootEl7 = (ctx) => ctx.getById(getRootId23(ctx));
var getThumbEl2 = (ctx, index) => ctx.getById(getThumbId2(ctx, index));
var getThumbEls = (ctx) => queryAll(getControlEl7(ctx), "[role=slider]");
var getFirstThumbEl = (ctx) => getThumbEls(ctx)[0];
var getHiddenInputEl7 = (ctx, index) => ctx.getById(getHiddenInputId8(ctx, index));
var getControlEl7 = (ctx) => ctx.getById(getControlId11(ctx));
var getPointValue = (params, point) => {
  const { prop, scope } = params;
  const controlEl = getControlEl7(scope);
  if (!controlEl) return;
  const relativePoint = getRelativePoint(point, controlEl);
  const percent = relativePoint.getPercentValue({
    orientation: prop("orientation"),
    dir: prop("dir"),
    inverted: { y: true }
  });
  return getPercentValue(percent, prop("min"), prop("max"), prop("step"));
};
var dispatchChangeEvent2 = (ctx, value) => {
  value.forEach((value2, index) => {
    const inputEl = getHiddenInputEl7(ctx, index);
    if (!inputEl) return;
    dispatchInputValueEvent(inputEl, { value: value2 });
  });
};
var getOffsetRect2 = (el) => ({
  left: (el == null ? void 0 : el.offsetLeft) ?? 0,
  top: (el == null ? void 0 : el.offsetTop) ?? 0,
  width: (el == null ? void 0 : el.offsetWidth) ?? 0,
  height: (el == null ? void 0 : el.offsetHeight) ?? 0
});
function getBounds(value) {
  const firstValue = value[0];
  const lastThumb = value[value.length - 1];
  return [firstValue, lastThumb];
}
function getRangeOffsets(params) {
  const { prop, computed } = params;
  const valuePercent = computed("valuePercent");
  const [firstPercent, lastPercent] = getBounds(valuePercent);
  if (valuePercent.length === 1) {
    if (prop("origin") === "center") {
      const isNegative = valuePercent[0] < 50;
      const start = isNegative ? `${valuePercent[0]}%` : "50%";
      const end = isNegative ? "50%" : `${100 - valuePercent[0]}%`;
      return { start, end };
    }
    if (prop("origin") === "end") {
      return { start: `${lastPercent}%`, end: "0%" };
    }
    return { start: "0%", end: `${100 - lastPercent}%` };
  }
  return { start: `${firstPercent}%`, end: `${100 - lastPercent}%` };
}
function getRangeStyle(params) {
  const { computed } = params;
  const isVertical = computed("isVertical");
  const isRtl = computed("isRtl");
  if (isVertical) {
    return {
      position: "absolute",
      bottom: "var(--slider-range-start)",
      top: "var(--slider-range-end)"
    };
  }
  return {
    position: "absolute",
    [isRtl ? "right" : "left"]: "var(--slider-range-start)",
    [isRtl ? "left" : "right"]: "var(--slider-range-end)"
  };
}
function getVerticalThumbOffset(params, value) {
  const { context, prop } = params;
  const { height = 0 } = context.get("thumbSize") ?? {};
  const getValue = getValueTransformer([prop("min"), prop("max")], [-height / 2, height / 2]);
  return parseFloat(getValue(value).toFixed(2));
}
function getHorizontalThumbOffset(params, value) {
  const { computed, context, prop } = params;
  const { width = 0 } = context.get("thumbSize") ?? {};
  const isRtl = computed("isRtl");
  if (isRtl) {
    const getValue2 = getValueTransformer([prop("max"), prop("min")], [-width / 2, width / 2]);
    return -1 * parseFloat(getValue2(value).toFixed(2));
  }
  const getValue = getValueTransformer([prop("min"), prop("max")], [-width / 2, width / 2]);
  return parseFloat(getValue(value).toFixed(2));
}
function getOffset(params, percent, value) {
  const { computed, prop } = params;
  if (prop("thumbAlignment") === "center") return `${percent}%`;
  const offset4 = computed("isVertical") ? getVerticalThumbOffset(params, value) : getHorizontalThumbOffset(params, value);
  return `calc(${percent}% - ${offset4}px)`;
}
function getThumbOffset(params, value) {
  const { prop } = params;
  const percent = getValuePercent(value, prop("min"), prop("max")) * 100;
  return getOffset(params, percent, value);
}
function getVisibility(params) {
  const { computed, prop } = params;
  let visibility = "visible";
  if (prop("thumbAlignment") === "contain" && !computed("hasMeasuredThumbSize")) {
    visibility = "hidden";
  }
  return visibility;
}
function getThumbStyle(params, index) {
  const { computed } = params;
  const placementProp = computed("isVertical") ? "bottom" : "insetInlineStart";
  return {
    visibility: getVisibility(params),
    position: "absolute",
    transform: "var(--slider-thumb-transform)",
    [placementProp]: `var(--slider-thumb-offset-${index})`
  };
}
function getControlStyle() {
  return {
    touchAction: "none",
    userSelect: "none",
    WebkitUserSelect: "none",
    position: "relative"
  };
}
function getRootStyle(params) {
  const { context, computed } = params;
  const isVertical = computed("isVertical");
  const isRtl = computed("isRtl");
  const range2 = getRangeOffsets(params);
  const thumbSize = context.get("thumbSize");
  const offsetStyles = context.get("value").reduce((styles, value, index) => {
    const offset4 = getThumbOffset(params, value);
    return { ...styles, [`--slider-thumb-offset-${index}`]: offset4 };
  }, {});
  return {
    ...offsetStyles,
    "--slider-thumb-width": toPx(thumbSize == null ? void 0 : thumbSize.width),
    "--slider-thumb-height": toPx(thumbSize == null ? void 0 : thumbSize.height),
    "--slider-thumb-transform": isVertical ? "translateY(50%)" : isRtl ? "translateX(50%)" : "translateX(-50%)",
    "--slider-range-start": range2.start,
    "--slider-range-end": range2.end
  };
}
function getMarkerStyle(params, value) {
  const { computed } = params;
  const isHorizontal = computed("isHorizontal");
  const isRtl = computed("isRtl");
  return {
    visibility: getVisibility(params),
    position: "absolute",
    pointerEvents: "none",
    [isHorizontal ? "insetInlineStart" : "bottom"]: getThumbOffset(params, value),
    translate: "var(--tx) var(--ty)",
    "--tx": isHorizontal ? isRtl ? "50%" : "-50%" : "0%",
    "--ty": !isHorizontal ? "50%" : "0%"
  };
}
function getMarkerGroupStyle() {
  return {
    userSelect: "none",
    WebkitUserSelect: "none",
    pointerEvents: "none",
    position: "relative"
  };
}
function normalizeValues(params, nextValues) {
  return nextValues.map((value, index) => {
    return constrainValue2(params, value, index);
  });
}
function getRangeAtIndex(params, index) {
  const { context, prop } = params;
  const step = prop("step") * prop("minStepsBetweenThumbs");
  return getValueRanges(context.get("value"), prop("min"), prop("max"), step)[index];
}
function constrainValue2(params, value, index) {
  const { prop } = params;
  const range2 = getRangeAtIndex(params, index);
  const snapValue = snapValueToStep(value, prop("min"), prop("max"), prop("step"));
  return clampValue(snapValue, range2.min, range2.max);
}
function decrement(params, index, step) {
  const { context, prop } = params;
  const idx = index ?? context.get("focusedIndex");
  const range2 = getRangeAtIndex(params, idx);
  const nextValues = getPreviousStepValue(idx, {
    ...range2,
    step: step ?? prop("step"),
    values: context.get("value")
  });
  nextValues[idx] = clampValue(nextValues[idx], range2.min, range2.max);
  return nextValues;
}
function increment(params, index, step) {
  const { context, prop } = params;
  const idx = index ?? context.get("focusedIndex");
  const range2 = getRangeAtIndex(params, idx);
  const nextValues = getNextStepValue(idx, {
    ...range2,
    step: step ?? prop("step"),
    values: context.get("value")
  });
  nextValues[idx] = clampValue(nextValues[idx], range2.min, range2.max);
  return nextValues;
}
function getClosestIndex(params, pointValue) {
  const { context } = params;
  return getClosestValueIndex(context.get("value"), pointValue);
}
function connect30(service, normalize22) {
  const { state: state2, send, context, prop, computed, scope } = service;
  const ariaLabel = prop("aria-label");
  const ariaLabelledBy = prop("aria-labelledby");
  const sliderValue = context.get("value");
  const focusedIndex = context.get("focusedIndex");
  const focused = state2.matches("focus");
  const dragging = state2.matches("dragging");
  const disabled = computed("isDisabled");
  const invalid = prop("invalid");
  const interactive = computed("isInteractive");
  const isHorizontal = prop("orientation") === "horizontal";
  const isVertical = prop("orientation") === "vertical";
  function getValuePercentFn(value) {
    return getValuePercent(value, prop("min"), prop("max"));
  }
  function getPercentValueFn(percent) {
    return getPercentValue(percent, prop("min"), prop("max"), prop("step"));
  }
  return {
    value: sliderValue,
    dragging,
    focused,
    setValue(value) {
      send({ type: "SET_VALUE", value });
    },
    getThumbValue(index) {
      return sliderValue[index];
    },
    setThumbValue(index, value) {
      send({ type: "SET_VALUE", index, value });
    },
    getValuePercent: getValuePercentFn,
    getPercentValue: getPercentValueFn,
    getThumbPercent(index) {
      return getValuePercentFn(sliderValue[index]);
    },
    setThumbPercent(index, percent) {
      const value = getPercentValueFn(percent);
      send({ type: "SET_VALUE", index, value });
    },
    getThumbMin(index) {
      return getRangeAtIndex(service, index).min;
    },
    getThumbMax(index) {
      return getRangeAtIndex(service, index).max;
    },
    increment(index) {
      send({ type: "INCREMENT", index });
    },
    decrement(index) {
      send({ type: "DECREMENT", index });
    },
    focus() {
      if (!interactive) return;
      send({ type: "FOCUS", index: 0 });
    },
    getLabelProps() {
      return normalize22.label({
        ...parts32.label.attrs,
        dir: prop("dir"),
        "data-disabled": dataAttr(disabled),
        "data-orientation": prop("orientation"),
        "data-invalid": dataAttr(invalid),
        "data-dragging": dataAttr(dragging),
        "data-focus": dataAttr(focused),
        id: getLabelId16(scope),
        htmlFor: getHiddenInputId8(scope, 0),
        onClick(event) {
          var _a8;
          if (!interactive) return;
          event.preventDefault();
          (_a8 = getFirstThumbEl(scope)) == null ? void 0 : _a8.focus();
        },
        style: {
          userSelect: "none",
          WebkitUserSelect: "none"
        }
      });
    },
    getRootProps() {
      return normalize22.element({
        ...parts32.root.attrs,
        "data-disabled": dataAttr(disabled),
        "data-orientation": prop("orientation"),
        "data-dragging": dataAttr(dragging),
        "data-invalid": dataAttr(invalid),
        "data-focus": dataAttr(focused),
        id: getRootId23(scope),
        dir: prop("dir"),
        style: getRootStyle(service)
      });
    },
    getValueTextProps() {
      return normalize22.element({
        ...parts32.valueText.attrs,
        dir: prop("dir"),
        "data-disabled": dataAttr(disabled),
        "data-orientation": prop("orientation"),
        "data-invalid": dataAttr(invalid),
        "data-focus": dataAttr(focused),
        id: getValueTextId2(scope)
      });
    },
    getTrackProps() {
      return normalize22.element({
        ...parts32.track.attrs,
        dir: prop("dir"),
        id: getTrackId2(scope),
        "data-disabled": dataAttr(disabled),
        "data-invalid": dataAttr(invalid),
        "data-dragging": dataAttr(dragging),
        "data-orientation": prop("orientation"),
        "data-focus": dataAttr(focused),
        style: { position: "relative" }
      });
    },
    getThumbProps(props210) {
      var _a8;
      const { index = 0, name } = props210;
      const value = sliderValue[index];
      const range2 = getRangeAtIndex(service, index);
      const valueText = (_a8 = prop("getAriaValueText")) == null ? void 0 : _a8({ value, index });
      const _ariaLabel = Array.isArray(ariaLabel) ? ariaLabel[index] : ariaLabel;
      const _ariaLabelledBy = Array.isArray(ariaLabelledBy) ? ariaLabelledBy[index] : ariaLabelledBy;
      return normalize22.element({
        ...parts32.thumb.attrs,
        dir: prop("dir"),
        "data-index": index,
        "data-name": name,
        id: getThumbId2(scope, index),
        "data-disabled": dataAttr(disabled),
        "data-orientation": prop("orientation"),
        "data-focus": dataAttr(focused && focusedIndex === index),
        "data-dragging": dataAttr(dragging && focusedIndex === index),
        draggable: false,
        "aria-disabled": ariaAttr(disabled),
        "aria-label": _ariaLabel,
        "aria-labelledby": _ariaLabelledBy ?? getLabelId16(scope),
        "aria-orientation": prop("orientation"),
        "aria-valuemax": range2.max,
        "aria-valuemin": range2.min,
        "aria-valuenow": sliderValue[index],
        "aria-valuetext": valueText,
        role: "slider",
        tabIndex: disabled ? void 0 : 0,
        style: getThumbStyle(service, index),
        onPointerDown(event) {
          if (!interactive) return;
          send({ type: "THUMB_POINTER_DOWN", index });
          event.stopPropagation();
        },
        onBlur() {
          if (!interactive) return;
          send({ type: "BLUR" });
        },
        onFocus() {
          if (!interactive) return;
          send({ type: "FOCUS", index });
        },
        onKeyDown(event) {
          if (event.defaultPrevented) return;
          if (!interactive) return;
          const step = getEventStep(event) * prop("step");
          const keyMap2 = {
            ArrowUp() {
              if (isHorizontal) return;
              send({ type: "ARROW_INC", step, src: "ArrowUp" });
            },
            ArrowDown() {
              if (isHorizontal) return;
              send({ type: "ARROW_DEC", step, src: "ArrowDown" });
            },
            ArrowLeft() {
              if (isVertical) return;
              send({ type: "ARROW_DEC", step, src: "ArrowLeft" });
            },
            ArrowRight() {
              if (isVertical) return;
              send({ type: "ARROW_INC", step, src: "ArrowRight" });
            },
            PageUp() {
              send({ type: "ARROW_INC", step, src: "PageUp" });
            },
            PageDown() {
              send({ type: "ARROW_DEC", step, src: "PageDown" });
            },
            Home() {
              send({ type: "HOME" });
            },
            End() {
              send({ type: "END" });
            }
          };
          const key = getEventKey(event, {
            dir: prop("dir"),
            orientation: prop("orientation")
          });
          const exec = keyMap2[key];
          if (exec) {
            exec(event);
            event.preventDefault();
            event.stopPropagation();
          }
        }
      });
    },
    getHiddenInputProps(props210) {
      const { index = 0, name } = props210;
      return normalize22.input({
        name: name ?? (prop("name") ? prop("name") + (sliderValue.length > 1 ? "[]" : "") : void 0),
        form: prop("form"),
        type: "text",
        hidden: true,
        defaultValue: sliderValue[index],
        id: getHiddenInputId8(scope, index)
      });
    },
    getRangeProps() {
      return normalize22.element({
        id: getRangeId(scope),
        ...parts32.range.attrs,
        dir: prop("dir"),
        "data-dragging": dataAttr(dragging),
        "data-focus": dataAttr(focused),
        "data-invalid": dataAttr(invalid),
        "data-disabled": dataAttr(disabled),
        "data-orientation": prop("orientation"),
        style: getRangeStyle(service)
      });
    },
    getControlProps() {
      return normalize22.element({
        ...parts32.control.attrs,
        dir: prop("dir"),
        id: getControlId11(scope),
        "data-dragging": dataAttr(dragging),
        "data-disabled": dataAttr(disabled),
        "data-orientation": prop("orientation"),
        "data-invalid": dataAttr(invalid),
        "data-focus": dataAttr(focused),
        style: getControlStyle(),
        onPointerDown(event) {
          if (!interactive) return;
          if (!isLeftClick(event)) return;
          if (isModifierKey(event)) return;
          const point = getEventPoint(event);
          send({ type: "POINTER_DOWN", point });
          event.preventDefault();
          event.stopPropagation();
        }
      });
    },
    getMarkerGroupProps() {
      return normalize22.element({
        ...parts32.markerGroup.attrs,
        role: "presentation",
        dir: prop("dir"),
        "aria-hidden": true,
        "data-orientation": prop("orientation"),
        style: getMarkerGroupStyle()
      });
    },
    getMarkerProps(props210) {
      const style = getMarkerStyle(service, props210.value);
      let markerState;
      if (props210.value < first(sliderValue)) {
        markerState = "under-value";
      } else if (props210.value > last(sliderValue)) {
        markerState = "over-value";
      } else {
        markerState = "at-value";
      }
      return normalize22.element({
        ...parts32.marker.attrs,
        id: getMarkerId(scope, props210.value),
        role: "presentation",
        dir: prop("dir"),
        "data-orientation": prop("orientation"),
        "data-value": props210.value,
        "data-disabled": dataAttr(disabled),
        "data-state": markerState,
        style
      });
    },
    getDraggingIndicatorProps(props210) {
      const { index = 0 } = props210;
      const isDragging = index === focusedIndex && dragging;
      return normalize22.element({
        ...parts32.draggingIndicator.attrs,
        role: "presentation",
        dir: prop("dir"),
        hidden: !isDragging,
        "data-orientation": prop("orientation"),
        "data-state": isDragging ? "open" : "closed",
        style: getThumbStyle(service, index)
      });
    }
  };
}
var isEqualSize = (a2, b2) => {
  return (a2 == null ? void 0 : a2.width) === (b2 == null ? void 0 : b2.width) && (a2 == null ? void 0 : a2.height) === (b2 == null ? void 0 : b2.height);
};
var normalize = (value, min4, max4, step, minStepsBetweenThumbs) => {
  const ranges = getValueRanges(value, min4, max4, minStepsBetweenThumbs * step);
  return ranges.map((range2) => {
    const snapValue = snapValueToStep(range2.value, range2.min, range2.max, step);
    const rangeValue = clampValue(snapValue, range2.min, range2.max);
    if (!isValueWithinRange(rangeValue, min4, max4)) {
      throw new Error(
        "[zag-js/slider] The configured `min`, `max`, `step` or `minStepsBetweenThumbs` values are invalid"
      );
    }
    return rangeValue;
  });
};
var machine30 = createMachine({
  props({ props: props210 }) {
    const min4 = props210.min ?? 0;
    const max4 = props210.max ?? 100;
    const step = props210.step ?? 1;
    const defaultValue = props210.defaultValue ?? [min4];
    const minStepsBetweenThumbs = props210.minStepsBetweenThumbs ?? 0;
    return {
      dir: "ltr",
      thumbAlignment: "contain",
      origin: "start",
      orientation: "horizontal",
      minStepsBetweenThumbs,
      ...props210,
      defaultValue: normalize(defaultValue, min4, max4, step, minStepsBetweenThumbs),
      value: props210.value ? normalize(props210.value, min4, max4, step, minStepsBetweenThumbs) : void 0,
      max: max4,
      step,
      min: min4
    };
  },
  initialState() {
    return "idle";
  },
  context({ prop, bindable, getContext }) {
    return {
      thumbSize: bindable(() => ({
        defaultValue: prop("thumbSize") || null
      })),
      value: bindable(() => ({
        defaultValue: prop("defaultValue"),
        value: prop("value"),
        isEqual,
        hash(a2) {
          return a2.join(",");
        },
        onChange(value) {
          var _a8;
          (_a8 = prop("onValueChange")) == null ? void 0 : _a8({ value });
        }
      })),
      focusedIndex: bindable(() => ({
        defaultValue: -1,
        onChange(value) {
          var _a8;
          const ctx = getContext();
          (_a8 = prop("onFocusChange")) == null ? void 0 : _a8({ focusedIndex: value, value: ctx.get("value") });
        }
      })),
      fieldsetDisabled: bindable(() => ({
        defaultValue: false
      }))
    };
  },
  computed: {
    isHorizontal: ({ prop }) => prop("orientation") === "horizontal",
    isVertical: ({ prop }) => prop("orientation") === "vertical",
    isRtl: ({ prop }) => prop("orientation") === "horizontal" && prop("dir") === "rtl",
    isDisabled: ({ context, prop }) => !!prop("disabled") || context.get("fieldsetDisabled"),
    isInteractive: ({ prop, computed }) => !(prop("readOnly") || computed("isDisabled")),
    hasMeasuredThumbSize: ({ context }) => context.get("thumbSize") != null,
    valuePercent({ context, prop }) {
      return context.get("value").map((value) => 100 * getValuePercent(value, prop("min"), prop("max")));
    }
  },
  watch({ track, action, context }) {
    track([() => context.hash("value")], () => {
      action(["syncInputElements", "dispatchChangeEvent"]);
    });
  },
  effects: ["trackFormControlState", "trackThumbSize"],
  on: {
    SET_VALUE: [
      {
        guard: "hasIndex",
        actions: ["setValueAtIndex"]
      },
      {
        actions: ["setValue"]
      }
    ],
    INCREMENT: {
      actions: ["incrementThumbAtIndex"]
    },
    DECREMENT: {
      actions: ["decrementThumbAtIndex"]
    }
  },
  states: {
    idle: {
      on: {
        POINTER_DOWN: {
          target: "dragging",
          actions: ["setClosestThumbIndex", "setPointerValue", "focusActiveThumb"]
        },
        FOCUS: {
          target: "focus",
          actions: ["setFocusedIndex"]
        },
        THUMB_POINTER_DOWN: {
          target: "dragging",
          actions: ["setFocusedIndex", "focusActiveThumb"]
        }
      }
    },
    focus: {
      entry: ["focusActiveThumb"],
      on: {
        POINTER_DOWN: {
          target: "dragging",
          actions: ["setClosestThumbIndex", "setPointerValue", "focusActiveThumb"]
        },
        THUMB_POINTER_DOWN: {
          target: "dragging",
          actions: ["setFocusedIndex", "focusActiveThumb"]
        },
        ARROW_DEC: {
          actions: ["decrementThumbAtIndex", "invokeOnChangeEnd"]
        },
        ARROW_INC: {
          actions: ["incrementThumbAtIndex", "invokeOnChangeEnd"]
        },
        HOME: {
          actions: ["setFocusedThumbToMin", "invokeOnChangeEnd"]
        },
        END: {
          actions: ["setFocusedThumbToMax", "invokeOnChangeEnd"]
        },
        BLUR: {
          target: "idle",
          actions: ["clearFocusedIndex"]
        }
      }
    },
    dragging: {
      entry: ["focusActiveThumb"],
      effects: ["trackPointerMove"],
      on: {
        POINTER_UP: {
          target: "focus",
          actions: ["invokeOnChangeEnd"]
        },
        POINTER_MOVE: {
          actions: ["setPointerValue"]
        }
      }
    }
  },
  implementations: {
    guards: {
      hasIndex: ({ event }) => event.index != null
    },
    effects: {
      trackFormControlState({ context, scope }) {
        return trackFormControl(getRootEl7(scope), {
          onFieldsetDisabledChange(disabled) {
            context.set("fieldsetDisabled", disabled);
          },
          onFormReset() {
            context.set("value", context.initial("value"));
          }
        });
      },
      trackPointerMove({ scope, send }) {
        return trackPointerMove(scope.getDoc(), {
          onPointerMove(info) {
            send({ type: "POINTER_MOVE", point: info.point });
          },
          onPointerUp() {
            send({ type: "POINTER_UP" });
          }
        });
      },
      trackThumbSize({ context, scope, prop }) {
        if (prop("thumbAlignment") !== "contain" || prop("thumbSize")) return;
        return trackElementRect(getThumbEls(scope), {
          box: "border-box",
          measure(el) {
            return getOffsetRect2(el);
          },
          onEntry({ rects }) {
            if (rects.length === 0) return;
            const size3 = pick(rects[0], ["width", "height"]);
            if (isEqualSize(context.get("thumbSize"), size3)) return;
            context.set("thumbSize", size3);
          }
        });
      }
    },
    actions: {
      dispatchChangeEvent({ context, scope }) {
        dispatchChangeEvent2(scope, context.get("value"));
      },
      syncInputElements({ context, scope }) {
        context.get("value").forEach((value, index) => {
          const inputEl = getHiddenInputEl7(scope, index);
          setElementValue(inputEl, value.toString());
        });
      },
      invokeOnChangeEnd({ prop, context }) {
        queueMicrotask(() => {
          var _a8;
          (_a8 = prop("onValueChangeEnd")) == null ? void 0 : _a8({ value: context.get("value") });
        });
      },
      setClosestThumbIndex(params) {
        const { context, event } = params;
        const pointValue = getPointValue(params, event.point);
        if (pointValue == null) return;
        const focusedIndex = getClosestIndex(params, pointValue);
        context.set("focusedIndex", focusedIndex);
      },
      setFocusedIndex({ context, event }) {
        context.set("focusedIndex", event.index);
      },
      clearFocusedIndex({ context }) {
        context.set("focusedIndex", -1);
      },
      setPointerValue(params) {
        queueMicrotask(() => {
          const { context, event } = params;
          const pointValue = getPointValue(params, event.point);
          if (pointValue == null) return;
          const focusedIndex = context.get("focusedIndex");
          const value = constrainValue2(params, pointValue, focusedIndex);
          context.set("value", (prev2) => setValueAtIndex(prev2, focusedIndex, value));
        });
      },
      focusActiveThumb({ scope, context }) {
        raf(() => {
          const thumbEl = getThumbEl2(scope, context.get("focusedIndex"));
          thumbEl == null ? void 0 : thumbEl.focus({ preventScroll: true });
        });
      },
      decrementThumbAtIndex(params) {
        const { context, event } = params;
        const value = decrement(params, event.index, event.step);
        context.set("value", value);
      },
      incrementThumbAtIndex(params) {
        const { context, event } = params;
        const value = increment(params, event.index, event.step);
        context.set("value", value);
      },
      setFocusedThumbToMin(params) {
        const { context } = params;
        const index = context.get("focusedIndex");
        const { min: min4 } = getRangeAtIndex(params, index);
        context.set("value", (prev2) => setValueAtIndex(prev2, index, min4));
      },
      setFocusedThumbToMax(params) {
        const { context } = params;
        const index = context.get("focusedIndex");
        const { max: max4 } = getRangeAtIndex(params, index);
        context.set("value", (prev2) => setValueAtIndex(prev2, index, max4));
      },
      setValueAtIndex(params) {
        const { context, event } = params;
        const value = constrainValue2(params, event.value, event.index);
        context.set("value", (prev2) => setValueAtIndex(prev2, event.index, value));
      },
      setValue(params) {
        const { context, event } = params;
        const value = normalizeValues(params, event.value);
        context.set("value", value);
      }
    }
  }
});
var props30 = createProps()([
  "aria-label",
  "aria-labelledby",
  "dir",
  "disabled",
  "form",
  "getAriaValueText",
  "getRootNode",
  "id",
  "ids",
  "invalid",
  "max",
  "min",
  "minStepsBetweenThumbs",
  "name",
  "onFocusChange",
  "onValueChange",
  "onValueChangeEnd",
  "orientation",
  "origin",
  "readOnly",
  "step",
  "thumbAlignment",
  "thumbAlignment",
  "thumbSize",
  "value",
  "defaultValue"
]);
var splitProps30 = createSplitProps(props30);
var thumbProps = createProps()(["index", "name"]);
var splitThumbProps = createSplitProps(thumbProps);

// node_modules/@ark-ui/react/dist/components/slider/use-slider.js
var import_react734 = __toESM(require_react(), 1);
var useSlider = (props43) => {
  const id = (0, import_react734.useId)();
  const { getRootNode } = useEnvironmentContext();
  const { dir } = useLocaleContext();
  const machineProps = {
    id,
    dir,
    getRootNode,
    ...props43
  };
  const service = useMachine(machine30, machineProps);
  return connect30(service, normalizeProps);
};

// node_modules/@ark-ui/react/dist/components/slider/slider-root.js
var SliderRoot = (0, import_react736.forwardRef)((props43, ref) => {
  const [useSliderProps, localProps] = createSplitProps2()(props43, [
    "aria-label",
    "aria-labelledby",
    "defaultValue",
    "disabled",
    "form",
    "getAriaValueText",
    "id",
    "ids",
    "invalid",
    "max",
    "min",
    "minStepsBetweenThumbs",
    "name",
    "onFocusChange",
    "onValueChange",
    "onValueChangeEnd",
    "orientation",
    "origin",
    "readOnly",
    "step",
    "thumbAlignment",
    "thumbAlignment",
    "thumbSize",
    "value"
  ]);
  const slider = useSlider(useSliderProps);
  const mergedProps = mergeProps2(slider.getRootProps(), localProps);
  return (0, import_jsx_runtime343.jsx)(SliderProvider, { value: slider, children: (0, import_jsx_runtime343.jsx)(ark.div, { ...mergedProps, ref }) });
});
SliderRoot.displayName = "SliderRoot";

// node_modules/@ark-ui/react/dist/components/slider/slider-root-provider.js
var import_jsx_runtime344 = __toESM(require_jsx_runtime(), 1);
var import_react738 = __toESM(require_react(), 1);
var SliderRootProvider = (0, import_react738.forwardRef)((props43, ref) => {
  const [{ value: slider }, localProps] = createSplitProps2()(props43, ["value"]);
  const mergedProps = mergeProps2(slider.getRootProps(), localProps);
  return (0, import_jsx_runtime344.jsx)(SliderProvider, { value: slider, children: (0, import_jsx_runtime344.jsx)(ark.div, { ...mergedProps, ref }) });
});
SliderRootProvider.displayName = "SliderRootProvider";

// node_modules/@ark-ui/react/dist/components/slider/slider-thumb.js
var import_jsx_runtime345 = __toESM(require_jsx_runtime(), 1);
var import_react740 = __toESM(require_react(), 1);
var SliderThumb = (0, import_react740.forwardRef)((props43, ref) => {
  const [thumbProps2, localProps] = createSplitProps2()(props43, ["index", "name"]);
  const slider = useSliderContext();
  const mergedProps = mergeProps2(slider.getThumbProps(thumbProps2), localProps);
  return (0, import_jsx_runtime345.jsx)(SliderThumbPropsProvider, { value: thumbProps2, children: (0, import_jsx_runtime345.jsx)(ark.div, { ...mergedProps, ref }) });
});
SliderThumb.displayName = "SliderThumb";

// node_modules/@ark-ui/react/dist/components/slider/slider-track.js
var import_jsx_runtime346 = __toESM(require_jsx_runtime(), 1);
var import_react742 = __toESM(require_react(), 1);
var SliderTrack = (0, import_react742.forwardRef)((props43, ref) => {
  const slider = useSliderContext();
  const mergedProps = mergeProps2(slider.getTrackProps(), props43);
  return (0, import_jsx_runtime346.jsx)(ark.div, { ...mergedProps, ref });
});
SliderTrack.displayName = "SliderTrack";

// node_modules/@ark-ui/react/dist/components/slider/slider-value-text.js
var import_jsx_runtime347 = __toESM(require_jsx_runtime(), 1);
var import_react744 = __toESM(require_react(), 1);
var SliderValueText = (0, import_react744.forwardRef)((props43, ref) => {
  const { children, ...rest } = props43;
  const slider = useSliderContext();
  const mergedProps = mergeProps2(slider.getValueTextProps(), rest);
  return (0, import_jsx_runtime347.jsx)(ark.span, { ...mergedProps, ref, children: children || slider.value.join(", ") });
});
SliderValueText.displayName = "SliderValueText";

// node_modules/@ark-ui/react/dist/components/slider/slider.js
var slider_exports = {};
__export(slider_exports, {
  Context: () => SliderContext,
  Control: () => SliderControl,
  DraggingIndicator: () => SliderDraggingIndicator,
  HiddenInput: () => SliderHiddenInput,
  Label: () => SliderLabel,
  Marker: () => SliderMarker,
  MarkerGroup: () => SliderMarkerGroup,
  Range: () => SliderRange,
  Root: () => SliderRoot,
  RootProvider: () => SliderRootProvider,
  Thumb: () => SliderThumb,
  Track: () => SliderTrack,
  ValueText: () => SliderValueText
});

// node_modules/@ark-ui/react/dist/components/splitter/use-splitter-context.js
var [SplitterProvider, useSplitterContext] = createContext3({
  name: "SplitterContext",
  hookName: "useSplitterContext",
  providerName: "<SplitterProvider />"
});

// node_modules/@ark-ui/react/dist/components/splitter/splitter-panel.js
var import_jsx_runtime348 = __toESM(require_jsx_runtime(), 1);
var import_react746 = __toESM(require_react(), 1);
var SplitterPanel = (0, import_react746.forwardRef)((props43, ref) => {
  const [splitterPanelProps, localProps] = createSplitProps2()(props43, ["id"]);
  const splitter = useSplitterContext();
  const mergedProps = mergeProps2(splitter.getPanelProps(splitterPanelProps), localProps);
  return (0, import_jsx_runtime348.jsx)(ark.div, { ...mergedProps, ref });
});
SplitterPanel.displayName = "SplitterPanel";

// node_modules/@ark-ui/react/dist/components/splitter/splitter-resize-trigger.js
var import_jsx_runtime349 = __toESM(require_jsx_runtime(), 1);
var import_react748 = __toESM(require_react(), 1);
var SplitterResizeTrigger = (0, import_react748.forwardRef)((props43, ref) => {
  const [triggerProps2, localProps] = createSplitProps2()(props43, ["disabled", "id"]);
  const splitter = useSplitterContext();
  const mergedProps = mergeProps2(splitter.getResizeTriggerProps(triggerProps2), localProps);
  return (0, import_jsx_runtime349.jsx)(ark.button, { ref, ...mergedProps });
});
SplitterResizeTrigger.displayName = "SplitterResizeTrigger";

// node_modules/@ark-ui/react/dist/components/splitter/splitter-root.js
var import_jsx_runtime350 = __toESM(require_jsx_runtime(), 1);
var import_react752 = __toESM(require_react(), 1);

// node_modules/@zag-js/splitter/dist/index.mjs
var anatomy30 = createAnatomy("splitter").parts("root", "panel", "resizeTrigger");
var parts33 = anatomy30.build();
var getRootId24 = (ctx) => {
  var _a8;
  return ((_a8 = ctx.ids) == null ? void 0 : _a8.root) ?? `splitter:${ctx.id}`;
};
var getResizeTriggerId = (ctx, id) => {
  var _a8, _b7;
  return ((_b7 = (_a8 = ctx.ids) == null ? void 0 : _a8.resizeTrigger) == null ? void 0 : _b7.call(_a8, id)) ?? `splitter:${ctx.id}:splitter:${id}`;
};
var getPanelId = (ctx, id) => {
  var _a8, _b7;
  return ((_b7 = (_a8 = ctx.ids) == null ? void 0 : _a8.panel) == null ? void 0 : _b7.call(_a8, id)) ?? `splitter:${ctx.id}:panel:${id}`;
};
var getGlobalCursorId = (ctx) => `splitter:${ctx.id}:global-cursor`;
var getRootEl8 = (ctx) => ctx.getById(getRootId24(ctx));
var getResizeTriggerEl = (ctx, id) => ctx.getById(getResizeTriggerId(ctx, id));
var getCursor = (state2, x) => {
  let cursor2 = x ? "col-resize" : "row-resize";
  if (state2.isAtMin) cursor2 = x ? "e-resize" : "s-resize";
  if (state2.isAtMax) cursor2 = x ? "w-resize" : "n-resize";
  return cursor2;
};
var getResizeTriggerEls = (ctx) => {
  return queryAll(getRootEl8(ctx), `[role=separator][data-ownedby='${CSS.escape(getRootId24(ctx))}']`);
};
var setupGlobalCursor = (ctx, state2, x, nonce) => {
  const styleEl = ctx.getById(getGlobalCursorId(ctx));
  const textContent = `* { cursor: ${getCursor(state2, x)} !important; }`;
  if (styleEl) {
    styleEl.textContent = textContent;
  } else {
    const style = ctx.getDoc().createElement("style");
    if (nonce) style.nonce = nonce;
    style.id = getGlobalCursorId(ctx);
    style.textContent = textContent;
    ctx.getDoc().head.appendChild(style);
  }
};
var removeGlobalCursor = (ctx) => {
  const styleEl = ctx.getById(getGlobalCursorId(ctx));
  styleEl == null ? void 0 : styleEl.remove();
};
function calculateAriaValues({
  size: size3,
  panels,
  pivotIndices
}) {
  let currentMinSize = 0;
  let currentMaxSize = 100;
  let totalMinSize = 0;
  let totalMaxSize = 0;
  const firstIndex = pivotIndices[0];
  ensure(firstIndex, () => "No pivot index found");
  panels.forEach((panel, index) => {
    const { maxSize = 100, minSize = 0 } = panel;
    if (index === firstIndex) {
      currentMinSize = minSize;
      currentMaxSize = maxSize;
    } else {
      totalMinSize += minSize;
      totalMaxSize += maxSize;
    }
  });
  const valueMax = Math.min(currentMaxSize, 100 - totalMinSize);
  const valueMin = Math.max(currentMinSize, 100 - totalMaxSize);
  const valueNow = size3[firstIndex];
  return {
    valueMax,
    valueMin,
    valueNow
  };
}
function getAriaValue(size3, panels, handleId) {
  const [beforeId, afterId] = handleId.split(":");
  const beforeIndex = panels.findIndex((panel) => panel.id === beforeId);
  const afterIndex = panels.findIndex((panel) => panel.id === afterId);
  const { valueMax, valueMin, valueNow } = calculateAriaValues({
    size: size3,
    panels,
    pivotIndices: [beforeIndex, afterIndex]
  });
  return {
    beforeId,
    afterId,
    valueMax: Math.round(valueMax),
    valueMin: Math.round(valueMin),
    valueNow: valueNow != null ? Math.round(valueNow) : void 0
  };
}
var PRECISION = 10;
function fuzzyCompareNumbers(actual, expected, fractionDigits = PRECISION) {
  if (actual.toFixed(fractionDigits) === expected.toFixed(fractionDigits)) {
    return 0;
  } else {
    return actual > expected ? 1 : -1;
  }
}
function fuzzyNumbersEqual(actual, expected, fractionDigits = PRECISION) {
  if (actual == null || expected == null) return false;
  return fuzzyCompareNumbers(actual, expected, fractionDigits) === 0;
}
function fuzzySizeEqual(actual, expected, fractionDigits) {
  if (actual.length !== expected.length) {
    return false;
  }
  for (let index = 0; index < actual.length; index++) {
    const actualSize = actual[index];
    const expectedSize = expected[index];
    if (!fuzzyNumbersEqual(actualSize, expectedSize, fractionDigits)) {
      return false;
    }
  }
  return true;
}
function getPanelById(panels, id) {
  const panel = panels.find((panel2) => panel2.id === id);
  ensure(panel, () => `Panel data not found for id "${id}"`);
  return panel;
}
function findPanelDataIndex(panels, panel) {
  return panels.findIndex((prevPanel) => prevPanel === panel || prevPanel.id === panel.id);
}
function findPanelIndex(panels, id) {
  return panels.findIndex((panel) => panel.id === id);
}
function panelDataHelper(panels, panel, sizes2) {
  const index = findPanelIndex(panels, panel.id);
  const pivotIndices = index === panels.length - 1 ? [index - 1, index] : [index, index + 1];
  const panelSize = sizes2[index];
  return { ...panel, panelSize, pivotIndices };
}
function sortPanels(panels) {
  return panels.sort((panelA, panelB) => {
    const orderA = panelA.order;
    const orderB = panelB.order;
    if (orderA == null && orderB == null) {
      return 0;
    } else if (orderA == null) {
      return -1;
    } else if (orderB == null) {
      return 1;
    } else {
      return orderA - orderB;
    }
  });
}
function getPanelLayout(panels) {
  return panels.map((panel) => panel.id).sort().join(":");
}
function serializePanels(panels) {
  const keys = panels.map((panel) => panel.id);
  const sortedKeys = keys.sort();
  const serialized = sortedKeys.map((key) => {
    const panel = panels.find((panel2) => panel2.id === key);
    return JSON.stringify(panel);
  });
  return serialized.join(",");
}
function getPanelFlexBoxStyle({
  defaultSize,
  dragState,
  sizes: sizes2,
  panels,
  panelIndex,
  precision = 3
}) {
  const size3 = sizes2[panelIndex];
  let flexGrow;
  if (size3 == null) {
    flexGrow = defaultSize != void 0 ? defaultSize.toPrecision(precision) : "1";
  } else if (panels.length === 1) {
    flexGrow = "1";
  } else {
    flexGrow = size3.toPrecision(precision);
  }
  return {
    flexBasis: 0,
    flexGrow,
    flexShrink: 1,
    // Without this, Panel sizes may be unintentionally overridden by their content
    overflow: "hidden",
    // Disable pointer events inside of a panel during resize
    // This avoid edge cases like nested iframes
    pointerEvents: dragState !== null ? "none" : void 0
  };
}
function getUnsafeDefaultSize({ panels, size: sizes2 }) {
  const finalSizes = Array(panels.length);
  let numPanelsWithSizes = 0;
  let remainingSize = 100;
  for (let index = 0; index < panels.length; index++) {
    const panel = panels[index];
    ensure(panel, () => `Panel data not found for index ${index}`);
    const defaultSize = sizes2[index];
    if (defaultSize != null) {
      numPanelsWithSizes++;
      finalSizes[index] = defaultSize;
      remainingSize -= defaultSize;
    }
  }
  for (let index = 0; index < panels.length; index++) {
    const panel = panels[index];
    ensure(panel, () => `Panel data not found for index ${index}`);
    const defaultSize = sizes2[index];
    if (defaultSize != null) {
      continue;
    }
    const numRemainingPanels = panels.length - numPanelsWithSizes;
    const size3 = remainingSize / numRemainingPanels;
    numPanelsWithSizes++;
    finalSizes[index] = size3;
    remainingSize -= size3;
  }
  return finalSizes;
}
function connect31(service, normalize4) {
  const { state: state2, send, prop, computed, context, scope } = service;
  const horizontal = computed("horizontal");
  const dragging = state2.matches("dragging");
  const getPanelStyle = (id) => {
    const panels = prop("panels");
    const panelIndex = panels.findIndex((panel) => panel.id === id);
    const defaultSize = context.initial("size")[panelIndex];
    const dragState = context.get("dragState");
    return getPanelFlexBoxStyle({
      defaultSize,
      dragState,
      sizes: context.get("size"),
      panels,
      panelIndex
    });
  };
  return {
    dragging,
    getItems() {
      return prop("panels").flatMap((panel, index, arr) => {
        const nextPanel = arr[index + 1];
        if (panel && nextPanel) {
          return [
            { type: "panel", id: panel.id },
            { type: "handle", id: `${panel.id}:${nextPanel.id}` }
          ];
        }
        return [{ type: "panel", id: panel.id }];
      });
    },
    getSizes() {
      return context.get("size");
    },
    setSizes(size3) {
      send({ type: "SIZE.SET", size: size3 });
    },
    resetSizes() {
      send({ type: "SIZE.SET", size: context.initial("size") });
    },
    collapsePanel(id) {
      send({ type: "PANEL.COLLAPSE", id });
    },
    expandPanel(id, minSize) {
      send({ type: "PANEL.EXPAND", id, minSize });
    },
    resizePanel(id, unsafePanelSize) {
      send({ type: "PANEL.RESIZE", id, size: unsafePanelSize });
    },
    getPanelSize(id) {
      const panels = prop("panels");
      const size3 = context.get("size");
      const panelData = getPanelById(panels, id);
      const { panelSize } = panelDataHelper(panels, panelData, size3);
      ensure(panelSize, () => `Panel size not found for panel "${panelData.id}"`);
      return panelSize;
    },
    isPanelCollapsed(id) {
      const panels = prop("panels");
      const size3 = context.get("size");
      const panelData = getPanelById(panels, id);
      const { collapsedSize = 0, collapsible, panelSize } = panelDataHelper(panels, panelData, size3);
      ensure(panelSize, () => `Panel size not found for panel "${panelData.id}"`);
      return collapsible === true && fuzzyNumbersEqual(panelSize, collapsedSize);
    },
    isPanelExpanded(id) {
      const panels = prop("panels");
      const size3 = context.get("size");
      const panelData = getPanelById(panels, id);
      const { collapsedSize = 0, collapsible, panelSize } = panelDataHelper(panels, panelData, size3);
      ensure(panelSize, () => `Panel size not found for panel "${panelData.id}"`);
      return !collapsible || fuzzyCompareNumbers(panelSize, collapsedSize) > 0;
    },
    getLayout() {
      return getPanelLayout(prop("panels"));
    },
    getRootProps() {
      return normalize4.element({
        ...parts33.root.attrs,
        "data-orientation": prop("orientation"),
        id: getRootId24(scope),
        dir: prop("dir"),
        style: {
          display: "flex",
          flexDirection: horizontal ? "row" : "column",
          height: "100%",
          width: "100%",
          overflow: "hidden"
        }
      });
    },
    getPanelProps(props210) {
      const { id } = props210;
      return normalize4.element({
        ...parts33.panel.attrs,
        "data-orientation": prop("orientation"),
        dir: prop("dir"),
        "data-id": id,
        "data-index": findPanelIndex(prop("panels"), id),
        id: getPanelId(scope, id),
        "data-ownedby": getRootId24(scope),
        style: getPanelStyle(id)
      });
    },
    getResizeTriggerProps(props210) {
      var _a8, _b7;
      const { id, disabled } = props210;
      const aria = getAriaValue(context.get("size"), prop("panels"), id);
      const dragging2 = ((_a8 = context.get("dragState")) == null ? void 0 : _a8.resizeTriggerId) === id;
      const focused = dragging2 || ((_b7 = context.get("keyboardState")) == null ? void 0 : _b7.resizeTriggerId) === id;
      return normalize4.element({
        ...parts33.resizeTrigger.attrs,
        dir: prop("dir"),
        id: getResizeTriggerId(scope, id),
        role: "separator",
        "data-id": id,
        "data-ownedby": getRootId24(scope),
        tabIndex: disabled ? void 0 : 0,
        "aria-valuenow": aria.valueNow,
        "aria-valuemin": aria.valueMin,
        "aria-valuemax": aria.valueMax,
        "data-orientation": prop("orientation"),
        "aria-orientation": prop("orientation"),
        "aria-controls": `${getPanelId(scope, aria.beforeId)} ${getPanelId(scope, aria.afterId)}`,
        "data-focus": dataAttr(focused),
        "data-disabled": dataAttr(disabled),
        style: {
          touchAction: "none",
          userSelect: "none",
          WebkitUserSelect: "none",
          flex: "0 0 auto",
          pointerEvents: dragging2 && !focused ? "none" : void 0,
          cursor: horizontal ? "col-resize" : "row-resize",
          [horizontal ? "minHeight" : "minWidth"]: "0"
        },
        onPointerDown(event) {
          if (event.button !== 0) return;
          if (disabled) {
            event.preventDefault();
            return;
          }
          const point = getEventPoint(event);
          send({ type: "POINTER_DOWN", id, point });
          event.currentTarget.setPointerCapture(event.pointerId);
          event.preventDefault();
          event.stopPropagation();
        },
        onPointerUp(event) {
          if (disabled) return;
          if (event.currentTarget.hasPointerCapture(event.pointerId)) {
            event.currentTarget.releasePointerCapture(event.pointerId);
          }
        },
        onPointerOver() {
          if (disabled) return;
          send({ type: "POINTER_OVER", id });
        },
        onPointerLeave() {
          if (disabled) return;
          send({ type: "POINTER_LEAVE", id });
        },
        onBlur() {
          if (disabled) return;
          send({ type: "BLUR" });
        },
        onFocus() {
          if (disabled) return;
          send({ type: "FOCUS", id });
        },
        onKeyDown(event) {
          if (event.defaultPrevented) return;
          if (disabled) return;
          const keyboardResizeBy = prop("keyboardResizeBy");
          let delta = 0;
          if (event.shiftKey) {
            delta = 10;
          } else if (keyboardResizeBy != null) {
            delta = keyboardResizeBy;
          } else {
            delta = 1;
          }
          const keyMap2 = {
            Enter() {
              send({ type: "ENTER", id });
            },
            ArrowUp() {
              send({ type: "KEYBOARD_MOVE", id, delta: horizontal ? 0 : -delta });
            },
            ArrowDown() {
              send({ type: "KEYBOARD_MOVE", id, delta: horizontal ? 0 : delta });
            },
            ArrowLeft() {
              send({ type: "KEYBOARD_MOVE", id, delta: horizontal ? -delta : 0 });
            },
            ArrowRight() {
              send({ type: "KEYBOARD_MOVE", id, delta: horizontal ? delta : 0 });
            },
            Home() {
              send({ type: "KEYBOARD_MOVE", id, delta: -100 });
            },
            End() {
              send({ type: "KEYBOARD_MOVE", id, delta: 100 });
            },
            F6() {
              send({ type: "FOCUS.CYCLE", id, shiftKey: event.shiftKey });
            }
          };
          const key = getEventKey(event, {
            dir: prop("dir"),
            orientation: prop("orientation")
          });
          const exec = keyMap2[key];
          if (exec) {
            exec(event);
            event.preventDefault();
          }
        }
      });
    }
  };
}
function resizePanel({ panels, index, size: size3 }) {
  const panel = panels[index];
  ensure(panel, () => `Panel data not found for index ${index}`);
  let { collapsedSize = 0, collapsible, maxSize = 100, minSize = 0 } = panel;
  if (fuzzyCompareNumbers(size3, minSize) < 0) {
    if (collapsible) {
      const halfwayPoint = (collapsedSize + minSize) / 2;
      if (fuzzyCompareNumbers(size3, halfwayPoint) < 0) {
        size3 = collapsedSize;
      } else {
        size3 = minSize;
      }
    } else {
      size3 = minSize;
    }
  }
  size3 = Math.min(maxSize, size3);
  size3 = parseFloat(size3.toFixed(PRECISION));
  return size3;
}
function resizeByDelta(props210) {
  let { delta, initialSize, panels, pivotIndices, prevSize, trigger } = props210;
  if (fuzzyNumbersEqual(delta, 0)) {
    return initialSize;
  }
  const nextSize = [...initialSize];
  const [firstPivotIndex, secondPivotIndex] = pivotIndices;
  ensure(firstPivotIndex, () => "Invalid first pivot index");
  ensure(secondPivotIndex, () => "Invalid second pivot index");
  let deltaApplied = 0;
  {
    if (trigger === "keyboard") {
      {
        const index = delta < 0 ? secondPivotIndex : firstPivotIndex;
        const panel = panels[index];
        ensure(panel, () => `Panel data not found for index ${index}`);
        const { collapsedSize = 0, collapsible, minSize = 0 } = panel;
        if (collapsible) {
          const prevSize2 = initialSize[index];
          ensure(prevSize2, () => `Previous size not found for panel index ${index}`);
          if (fuzzyNumbersEqual(prevSize2, collapsedSize)) {
            const localDelta = minSize - prevSize2;
            if (fuzzyCompareNumbers(localDelta, Math.abs(delta)) > 0) {
              delta = delta < 0 ? 0 - localDelta : localDelta;
            }
          }
        }
      }
      {
        const index = delta < 0 ? firstPivotIndex : secondPivotIndex;
        const panel = panels[index];
        ensure(panel, () => `No panel data found for index ${index}`);
        const { collapsedSize = 0, collapsible, minSize = 0 } = panel;
        if (collapsible) {
          const prevSize2 = initialSize[index];
          ensure(prevSize2, () => `Previous size not found for panel index ${index}`);
          if (fuzzyNumbersEqual(prevSize2, minSize)) {
            const localDelta = prevSize2 - collapsedSize;
            if (fuzzyCompareNumbers(localDelta, Math.abs(delta)) > 0) {
              delta = delta < 0 ? 0 - localDelta : localDelta;
            }
          }
        }
      }
    }
  }
  {
    const increment2 = delta < 0 ? 1 : -1;
    let index = delta < 0 ? secondPivotIndex : firstPivotIndex;
    let maxAvailableDelta = 0;
    while (true) {
      const prevSize2 = initialSize[index];
      ensure(prevSize2, () => `Previous size not found for panel index ${index}`);
      const maxSafeSize = resizePanel({
        panels,
        index,
        size: 100
      });
      const delta2 = maxSafeSize - prevSize2;
      maxAvailableDelta += delta2;
      index += increment2;
      if (index < 0 || index >= panels.length) {
        break;
      }
    }
    const minAbsDelta = Math.min(Math.abs(delta), Math.abs(maxAvailableDelta));
    delta = delta < 0 ? 0 - minAbsDelta : minAbsDelta;
  }
  {
    const pivotIndex = delta < 0 ? firstPivotIndex : secondPivotIndex;
    let index = pivotIndex;
    while (index >= 0 && index < panels.length) {
      const deltaRemaining = Math.abs(delta) - Math.abs(deltaApplied);
      const prevSize2 = initialSize[index];
      ensure(prevSize2, () => `Previous size not found for panel index ${index}`);
      const unsafeSize = prevSize2 - deltaRemaining;
      const safeSize = resizePanel({ panels, index, size: unsafeSize });
      if (!fuzzyNumbersEqual(prevSize2, safeSize)) {
        deltaApplied += prevSize2 - safeSize;
        nextSize[index] = safeSize;
        if (deltaApplied.toPrecision(3).localeCompare(Math.abs(delta).toPrecision(3), void 0, {
          numeric: true
        }) >= 0) {
          break;
        }
      }
      if (delta < 0) {
        index--;
      } else {
        index++;
      }
    }
  }
  if (fuzzySizeEqual(prevSize, nextSize)) {
    return prevSize;
  }
  {
    const pivotIndex = delta < 0 ? secondPivotIndex : firstPivotIndex;
    const prevSize2 = initialSize[pivotIndex];
    ensure(prevSize2, () => `Previous size not found for panel index ${pivotIndex}`);
    const unsafeSize = prevSize2 + deltaApplied;
    const safeSize = resizePanel({ panels, index: pivotIndex, size: unsafeSize });
    nextSize[pivotIndex] = safeSize;
    if (!fuzzyNumbersEqual(safeSize, unsafeSize)) {
      let deltaRemaining = unsafeSize - safeSize;
      const pivotIndex2 = delta < 0 ? secondPivotIndex : firstPivotIndex;
      let index = pivotIndex2;
      while (index >= 0 && index < panels.length) {
        const prevSize3 = nextSize[index];
        ensure(prevSize3, () => `Previous size not found for panel index ${index}`);
        const unsafeSize2 = prevSize3 + deltaRemaining;
        const safeSize2 = resizePanel({ panels, index, size: unsafeSize2 });
        if (!fuzzyNumbersEqual(prevSize3, safeSize2)) {
          deltaRemaining -= safeSize2 - prevSize3;
          nextSize[index] = safeSize2;
        }
        if (fuzzyNumbersEqual(deltaRemaining, 0)) {
          break;
        }
        if (delta > 0) {
          index--;
        } else {
          index++;
        }
      }
    }
  }
  const totalSize = nextSize.reduce((total, size3) => size3 + total, 0);
  if (!fuzzyNumbersEqual(totalSize, 100)) {
    return prevSize;
  }
  return nextSize;
}
function validateSizes({ size: prevSize, panels }) {
  const nextSize = [...prevSize];
  const nextSizeTotalSize = nextSize.reduce((accumulated, current) => accumulated + current, 0);
  if (nextSize.length !== panels.length) {
    throw Error(`Invalid ${panels.length} panel size: ${nextSize.map((size3) => `${size3}%`).join(", ")}`);
  } else if (!fuzzyNumbersEqual(nextSizeTotalSize, 100) && nextSize.length > 0) {
    for (let index = 0; index < panels.length; index++) {
      const unsafeSize = nextSize[index];
      ensure(unsafeSize, () => `No size data found for index ${index}`);
      const safeSize = 100 / nextSizeTotalSize * unsafeSize;
      nextSize[index] = safeSize;
    }
  }
  let remainingSize = 0;
  for (let index = 0; index < panels.length; index++) {
    const unsafeSize = nextSize[index];
    ensure(unsafeSize, () => `No size data found for index ${index}`);
    const safeSize = resizePanel({ panels, index, size: unsafeSize });
    if (unsafeSize != safeSize) {
      remainingSize += unsafeSize - safeSize;
      nextSize[index] = safeSize;
    }
  }
  if (!fuzzyNumbersEqual(remainingSize, 0)) {
    for (let index = 0; index < panels.length; index++) {
      const prevSize2 = nextSize[index];
      ensure(prevSize2, () => `No size data found for index ${index}`);
      const unsafeSize = prevSize2 + remainingSize;
      const safeSize = resizePanel({ panels, index, size: unsafeSize });
      if (prevSize2 !== safeSize) {
        remainingSize -= safeSize - prevSize2;
        nextSize[index] = safeSize;
        if (fuzzyNumbersEqual(remainingSize, 0)) {
          break;
        }
      }
    }
  }
  return nextSize;
}
var machine31 = createMachine({
  props({ props: props210 }) {
    ensureProps(props210, ["panels"]);
    return {
      orientation: "horizontal",
      defaultSize: [],
      dir: "ltr",
      ...props210,
      panels: sortPanels(props210.panels)
    };
  },
  initialState() {
    return "idle";
  },
  context({ prop, bindable, getContext, getRefs }) {
    return {
      size: bindable(() => ({
        value: prop("size"),
        defaultValue: prop("defaultSize"),
        isEqual(a2, b2) {
          return b2 != null && fuzzySizeEqual(a2, b2);
        },
        onChange(value) {
          var _a8, _b7;
          const ctx = getContext();
          const refs = getRefs();
          const sizesBeforeCollapse = refs.get("panelSizeBeforeCollapse");
          const expandToSizes = Object.fromEntries(sizesBeforeCollapse.entries());
          const resizeTriggerId = ((_a8 = ctx.get("dragState")) == null ? void 0 : _a8.resizeTriggerId) ?? null;
          const layout = getPanelLayout(prop("panels"));
          (_b7 = prop("onResize")) == null ? void 0 : _b7({
            size: value,
            layout,
            resizeTriggerId,
            expandToSizes
          });
        }
      })),
      dragState: bindable(() => ({
        defaultValue: null
      })),
      keyboardState: bindable(() => ({
        defaultValue: null
      }))
    };
  },
  watch({ track, action, prop }) {
    track([() => serializePanels(prop("panels"))], () => {
      action(["syncSize"]);
    });
  },
  refs() {
    return {
      panelSizeBeforeCollapse: /* @__PURE__ */ new Map(),
      prevDelta: 0,
      panelIdToLastNotifiedSizeMap: /* @__PURE__ */ new Map()
    };
  },
  computed: {
    horizontal({ prop }) {
      return prop("orientation") === "horizontal";
    }
  },
  on: {
    "SIZE.SET": {
      actions: ["setSize"]
    },
    "PANEL.COLLAPSE": {
      actions: ["collapsePanel"]
    },
    "PANEL.EXPAND": {
      actions: ["expandPanel"]
    },
    "PANEL.RESIZE": {
      actions: ["resizePanel"]
    }
  },
  entry: ["syncSize"],
  states: {
    idle: {
      entry: ["clearDraggingState", "clearKeyboardState"],
      on: {
        POINTER_OVER: {
          target: "hover:temp",
          actions: ["setKeyboardState"]
        },
        FOCUS: {
          target: "focused",
          actions: ["setKeyboardState"]
        },
        POINTER_DOWN: {
          target: "dragging",
          actions: ["setDraggingState"]
        }
      }
    },
    "hover:temp": {
      effects: ["waitForHoverDelay"],
      on: {
        HOVER_DELAY: {
          target: "hover"
        },
        POINTER_DOWN: {
          target: "dragging",
          actions: ["setDraggingState"]
        },
        POINTER_LEAVE: {
          target: "idle"
        }
      }
    },
    hover: {
      tags: ["focus"],
      on: {
        POINTER_DOWN: {
          target: "dragging",
          actions: ["setDraggingState"]
        },
        POINTER_LEAVE: {
          target: "idle"
        }
      }
    },
    focused: {
      tags: ["focus"],
      on: {
        BLUR: {
          target: "idle"
        },
        ENTER: {
          actions: ["collapseOrExpandPanel"]
        },
        POINTER_DOWN: {
          target: "dragging",
          actions: ["setDraggingState"]
        },
        KEYBOARD_MOVE: {
          actions: ["invokeOnResizeStart", "setKeyboardValue", "invokeOnResizeEnd"]
        },
        "FOCUS.CYCLE": {
          actions: ["focusNextResizeTrigger"]
        }
      }
    },
    dragging: {
      tags: ["focus"],
      effects: ["trackPointerMove"],
      entry: ["invokeOnResizeStart"],
      on: {
        POINTER_MOVE: {
          actions: ["setPointerValue", "setGlobalCursor"]
        },
        POINTER_UP: {
          target: "idle",
          actions: ["invokeOnResizeEnd", "clearGlobalCursor"]
        }
      }
    }
  },
  implementations: {
    effects: {
      waitForHoverDelay: ({ send }) => {
        return setRafTimeout(() => {
          send({ type: "HOVER_DELAY" });
        }, 250);
      },
      trackPointerMove: ({ scope, send }) => {
        const doc = scope.getDoc();
        return trackPointerMove(doc, {
          onPointerMove(info) {
            send({ type: "POINTER_MOVE", point: info.point });
          },
          onPointerUp() {
            send({ type: "POINTER_UP" });
          }
        });
      }
    },
    actions: {
      setSize(params) {
        const { context, event, prop } = params;
        const unsafeSize = event.size;
        const prevSize = context.get("size");
        const panels = prop("panels");
        const safeSize = validateSizes({
          size: unsafeSize,
          panels
        });
        if (!isEqual(prevSize, safeSize)) {
          setSize(params, safeSize);
        }
      },
      syncSize({ context, prop }) {
        const panels = prop("panels");
        let prevSize = context.get("size");
        let unsafeSize = null;
        if (prevSize.length === 0) {
          unsafeSize = getUnsafeDefaultSize({
            panels,
            size: context.initial("size")
          });
        }
        const nextSize = validateSizes({
          size: unsafeSize ?? prevSize,
          panels
        });
        if (!isEqual(prevSize, nextSize)) {
          context.set("size", nextSize);
        }
      },
      setDraggingState({ context, event, prop, scope }) {
        const orientation = prop("orientation");
        const size3 = context.get("size");
        const resizeTriggerId = event.id;
        const panelGroupEl = getRootEl8(scope);
        if (!panelGroupEl) return;
        const handleElement = getResizeTriggerEl(scope, resizeTriggerId);
        ensure(handleElement, () => `Drag handle element not found for id "${resizeTriggerId}"`);
        const initialCursorPosition = orientation === "horizontal" ? event.point.x : event.point.y;
        context.set("dragState", {
          resizeTriggerId: event.id,
          resizeTriggerRect: handleElement.getBoundingClientRect(),
          initialCursorPosition,
          initialSize: size3
        });
      },
      clearDraggingState({ context }) {
        context.set("dragState", null);
      },
      setKeyboardState({ context, event }) {
        context.set("keyboardState", {
          resizeTriggerId: event.id
        });
      },
      clearKeyboardState({ context }) {
        context.set("keyboardState", null);
      },
      collapsePanel(params) {
        const { context, prop, event, refs } = params;
        const prevSize = context.get("size");
        const panels = prop("panels");
        const panel = panels.find((panel2) => panel2.id === event.id);
        ensure(panel, () => `Panel data not found for id "${event.id}"`);
        if (panel.collapsible) {
          const { collapsedSize = 0, panelSize, pivotIndices } = panelDataHelper(panels, panel, prevSize);
          ensure(panelSize, () => `Panel size not found for panel "${panel.id}"`);
          if (!fuzzyNumbersEqual(panelSize, collapsedSize)) {
            refs.get("panelSizeBeforeCollapse").set(panel.id, panelSize);
            const isLastPanel = findPanelDataIndex(panels, panel) === panels.length - 1;
            const delta = isLastPanel ? panelSize - collapsedSize : collapsedSize - panelSize;
            const nextSize = resizeByDelta({
              delta,
              initialSize: prevSize,
              panels,
              pivotIndices,
              prevSize,
              trigger: "imperative-api"
            });
            if (!isEqual(prevSize, nextSize)) {
              setSize(params, nextSize);
            }
          }
        }
      },
      expandPanel(params) {
        const { context, prop, event, refs } = params;
        const panels = prop("panels");
        const prevSize = context.get("size");
        const panel = panels.find((panel2) => panel2.id === event.id);
        ensure(panel, () => `Panel data not found for id "${event.id}"`);
        if (panel.collapsible) {
          const {
            collapsedSize = 0,
            panelSize = 0,
            minSize: minSizeFromProps = 0,
            pivotIndices
          } = panelDataHelper(panels, panel, prevSize);
          const minSize = event.minSize ?? minSizeFromProps;
          if (fuzzyNumbersEqual(panelSize, collapsedSize)) {
            const prevPanelSize = refs.get("panelSizeBeforeCollapse").get(panel.id);
            const baseSize = prevPanelSize != null && prevPanelSize >= minSize ? prevPanelSize : minSize;
            const isLastPanel = findPanelDataIndex(panels, panel) === panels.length - 1;
            const delta = isLastPanel ? panelSize - baseSize : baseSize - panelSize;
            const nextSize = resizeByDelta({
              delta,
              initialSize: prevSize,
              panels,
              pivotIndices,
              prevSize,
              trigger: "imperative-api"
            });
            if (!isEqual(prevSize, nextSize)) {
              setSize(params, nextSize);
            }
          }
        }
      },
      resizePanel(params) {
        const { context, prop, event } = params;
        const prevSize = context.get("size");
        const panels = prop("panels");
        const panel = getPanelById(panels, event.id);
        const unsafePanelSize = event.size;
        const { panelSize, pivotIndices } = panelDataHelper(panels, panel, prevSize);
        ensure(panelSize, () => `Panel size not found for panel "${panel.id}"`);
        const isLastPanel = findPanelDataIndex(panels, panel) === panels.length - 1;
        const delta = isLastPanel ? panelSize - unsafePanelSize : unsafePanelSize - panelSize;
        const nextSize = resizeByDelta({
          delta,
          initialSize: prevSize,
          panels,
          pivotIndices,
          prevSize,
          trigger: "imperative-api"
        });
        if (!isEqual(prevSize, nextSize)) {
          setSize(params, nextSize);
        }
      },
      setPointerValue(params) {
        const { context, event, prop, scope } = params;
        const dragState = context.get("dragState");
        if (!dragState) return;
        const { resizeTriggerId, initialSize, initialCursorPosition } = dragState;
        const panels = prop("panels");
        const panelGroupElement = getRootEl8(scope);
        ensure(panelGroupElement, () => `Panel group element not found`);
        const pivotIndices = resizeTriggerId.split(":").map((id) => panels.findIndex((panel) => panel.id === id));
        const horizontal = prop("orientation") === "horizontal";
        const cursorPosition = horizontal ? event.point.x : event.point.y;
        const groupRect = panelGroupElement.getBoundingClientRect();
        const groupSizeInPixels = horizontal ? groupRect.width : groupRect.height;
        const offsetPixels = cursorPosition - initialCursorPosition;
        const offsetPercentage = offsetPixels / groupSizeInPixels * 100;
        const prevSize = context.get("size");
        const nextSize = resizeByDelta({
          delta: offsetPercentage,
          initialSize: initialSize ?? prevSize,
          panels,
          pivotIndices,
          prevSize,
          trigger: "mouse-or-touch"
        });
        if (!isEqual(prevSize, nextSize)) {
          setSize(params, nextSize);
        }
      },
      setKeyboardValue(params) {
        const { context, event, prop } = params;
        const panelDataArray = prop("panels");
        const resizeTriggerId = event.id;
        const delta = event.delta;
        const pivotIndices = resizeTriggerId.split(":").map((id) => panelDataArray.findIndex((panelData) => panelData.id === id));
        const prevSize = context.get("size");
        const nextSize = resizeByDelta({
          delta,
          initialSize: prevSize,
          panels: panelDataArray,
          pivotIndices,
          prevSize,
          trigger: "keyboard"
        });
        if (!isEqual(prevSize, nextSize)) {
          setSize(params, nextSize);
        }
      },
      invokeOnResizeEnd({ context, prop }) {
        queueMicrotask(() => {
          var _a8;
          const dragState = context.get("dragState");
          (_a8 = prop("onResizeEnd")) == null ? void 0 : _a8({
            size: context.get("size"),
            resizeTriggerId: (dragState == null ? void 0 : dragState.resizeTriggerId) ?? null
          });
        });
      },
      invokeOnResizeStart({ prop }) {
        queueMicrotask(() => {
          var _a8;
          (_a8 = prop("onResizeStart")) == null ? void 0 : _a8();
        });
      },
      collapseOrExpandPanel(params) {
        var _a8;
        const { context, prop } = params;
        const panelDataArray = prop("panels");
        const sizes2 = context.get("size");
        const resizeTriggerId = (_a8 = context.get("keyboardState")) == null ? void 0 : _a8.resizeTriggerId;
        const [idBefore, idAfter] = (resizeTriggerId == null ? void 0 : resizeTriggerId.split(":")) ?? [];
        const index = panelDataArray.findIndex((panelData2) => panelData2.id === idBefore);
        if (index === -1) return;
        const panelData = panelDataArray[index];
        ensure(panelData, () => `No panel data found for index ${index}`);
        const size3 = sizes2[index];
        const { collapsedSize = 0, collapsible, minSize = 0 } = panelData;
        if (size3 != null && collapsible) {
          const pivotIndices = [idBefore, idAfter].map(
            (id) => panelDataArray.findIndex((panelData2) => panelData2.id === id)
          );
          const nextSize = resizeByDelta({
            delta: fuzzyNumbersEqual(size3, collapsedSize) ? minSize - collapsedSize : collapsedSize - size3,
            initialSize: context.initial("size"),
            panels: panelDataArray,
            pivotIndices,
            prevSize: sizes2,
            trigger: "keyboard"
          });
          if (!isEqual(sizes2, nextSize)) {
            setSize(params, nextSize);
          }
        }
      },
      setGlobalCursor({ context, scope, prop }) {
        const dragState = context.get("dragState");
        if (!dragState) return;
        const panels = prop("panels");
        const horizontal = prop("orientation") === "horizontal";
        const [idBefore] = dragState.resizeTriggerId.split(":");
        const indexBefore = panels.findIndex((panel2) => panel2.id === idBefore);
        const panel = panels[indexBefore];
        const size3 = context.get("size");
        const aria = getAriaValue(size3, panels, dragState.resizeTriggerId);
        const isAtMin = fuzzyNumbersEqual(aria.valueNow, aria.valueMin) || fuzzyNumbersEqual(aria.valueNow, panel.collapsedSize);
        const isAtMax = fuzzyNumbersEqual(aria.valueNow, aria.valueMax);
        const cursorState = { isAtMin, isAtMax };
        setupGlobalCursor(scope, cursorState, horizontal, prop("nonce"));
      },
      clearGlobalCursor({ scope }) {
        removeGlobalCursor(scope);
      },
      focusNextResizeTrigger({ event, scope }) {
        const resizeTriggers = getResizeTriggerEls(scope);
        const index = resizeTriggers.findIndex((el) => el.dataset.id === event.id);
        const handleEl = event.shiftKey ? prev(resizeTriggers, index) : next(resizeTriggers, index);
        handleEl == null ? void 0 : handleEl.focus();
      }
    }
  }
});
function setSize(params, sizes2) {
  const { refs, prop, context } = params;
  const panelsArray = prop("panels");
  const onCollapse = prop("onCollapse");
  const onExpand = prop("onExpand");
  const panelIdToLastNotifiedSizeMap = refs.get("panelIdToLastNotifiedSizeMap");
  context.set("size", sizes2);
  sizes2.forEach((size3, index) => {
    const panelData = panelsArray[index];
    ensure(panelData, () => `Panel data not found for index ${index}`);
    const { collapsedSize = 0, collapsible, id: panelId } = panelData;
    const lastNotifiedSize = panelIdToLastNotifiedSizeMap.get(panelId);
    if (lastNotifiedSize == null || size3 !== lastNotifiedSize) {
      panelIdToLastNotifiedSizeMap.set(panelId, size3);
      if (collapsible && (onCollapse || onExpand)) {
        if ((lastNotifiedSize == null || fuzzyNumbersEqual(lastNotifiedSize, collapsedSize)) && !fuzzyNumbersEqual(size3, collapsedSize)) {
          onExpand == null ? void 0 : onExpand({ panelId, size: size3 });
        }
        if (onCollapse && (lastNotifiedSize == null || !fuzzyNumbersEqual(lastNotifiedSize, collapsedSize)) && fuzzyNumbersEqual(size3, collapsedSize)) {
          onCollapse == null ? void 0 : onCollapse({ panelId, size: size3 });
        }
      }
    }
  });
}
var props31 = createProps()([
  "dir",
  "getRootNode",
  "id",
  "ids",
  "onResize",
  "onResizeStart",
  "onResizeEnd",
  "onCollapse",
  "onExpand",
  "orientation",
  "size",
  "defaultSize",
  "panels",
  "keyboardResizeBy",
  "nonce"
]);
var splitProps31 = createSplitProps(props31);
var panelProps = createProps()(["id"]);
var splitPanelProps = createSplitProps(panelProps);
var resizeTriggerProps2 = createProps()(["disabled", "id"]);
var splitResizeTriggerProps2 = createSplitProps(resizeTriggerProps2);

// node_modules/@ark-ui/react/dist/components/splitter/use-splitter.js
var import_react750 = __toESM(require_react(), 1);
var useSplitter = (props43) => {
  const id = (0, import_react750.useId)();
  const { getRootNode } = useEnvironmentContext();
  const { dir } = useLocaleContext();
  const machineProps = {
    id,
    dir,
    getRootNode,
    ...props43
  };
  const service = useMachine(machine31, machineProps);
  return connect31(service, normalizeProps);
};

// node_modules/@ark-ui/react/dist/components/splitter/splitter-root.js
var SplitterRoot = (0, import_react752.forwardRef)((props43, ref) => {
  const [useSplitterProps, localProps] = createSplitProps2()(props43, [
    "defaultSize",
    "id",
    "ids",
    "keyboardResizeBy",
    "nonce",
    "onCollapse",
    "onExpand",
    "onResize",
    "onResizeEnd",
    "onResizeStart",
    "orientation",
    "panels",
    "size"
  ]);
  const splitter = useSplitter(useSplitterProps);
  const mergedProps = mergeProps2(splitter.getRootProps(), localProps);
  return (0, import_jsx_runtime350.jsx)(SplitterProvider, { value: splitter, children: (0, import_jsx_runtime350.jsx)(ark.div, { ...mergedProps, ref }) });
});
SplitterRoot.displayName = "SplitterRoot";

// node_modules/@ark-ui/react/dist/components/splitter/splitter-root-provider.js
var import_jsx_runtime351 = __toESM(require_jsx_runtime(), 1);
var import_react754 = __toESM(require_react(), 1);
var SplitterRootProvider = (0, import_react754.forwardRef)((props43, ref) => {
  const [{ value: splitter }, localProps] = createSplitProps2()(props43, ["value"]);
  const mergedProps = mergeProps2(splitter.getRootProps(), localProps);
  return (0, import_jsx_runtime351.jsx)(SplitterProvider, { value: splitter, children: (0, import_jsx_runtime351.jsx)(ark.div, { ...mergedProps, ref }) });
});
SplitterRootProvider.displayName = "SplitterRootProvider";

// node_modules/@ark-ui/react/dist/components/steps/steps-completed-content.js
var import_jsx_runtime352 = __toESM(require_jsx_runtime(), 1);
var import_react756 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/steps/use-steps-context.js
var [StepsProvider, useStepsContext] = createContext3({
  name: "StepsContext",
  hookName: "useStepsContext",
  providerName: "<StepsProvider />"
});

// node_modules/@ark-ui/react/dist/components/steps/steps-completed-content.js
var StepsCompletedContent = (0, import_react756.forwardRef)((props43, ref) => {
  const steps = useStepsContext();
  const mergedProps = mergeProps2(steps.getContentProps({ index: steps.count }), props43);
  return (0, import_jsx_runtime352.jsx)(ark.div, { ...mergedProps, ref });
});
StepsCompletedContent.displayName = "StepsCompletedContent";

// node_modules/@ark-ui/react/dist/components/steps/steps-content.js
var import_jsx_runtime353 = __toESM(require_jsx_runtime(), 1);
var import_react758 = __toESM(require_react(), 1);
var StepsContent = (0, import_react758.forwardRef)((props43, ref) => {
  const [itemProps14, localProps] = createSplitProps2()(props43, ["index"]);
  const steps = useStepsContext();
  const mergedProps = mergeProps2(steps.getContentProps(itemProps14), localProps);
  return (0, import_jsx_runtime353.jsx)(ark.div, { ...mergedProps, ref });
});
StepsContent.displayName = "StepsContent";

// node_modules/@ark-ui/react/dist/components/steps/steps-context.js
var StepsContext = (props43) => {
  const context = useStepsContext();
  return props43.children(context);
};
StepsContext.displayName = "StepsContext";

// node_modules/@ark-ui/react/dist/components/steps/steps-indicator.js
var import_jsx_runtime354 = __toESM(require_jsx_runtime(), 1);
var import_react760 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/steps/use-steps-item-props-context.js
var [StepsItemPropsProvider, useStepsItemPropsContext] = createContext3({
  name: "StepsItemPropsContext",
  hookName: "useStepsItemPropsContext",
  providerName: "<StepsItemPropsProvider />"
});

// node_modules/@ark-ui/react/dist/components/steps/steps-indicator.js
var StepsIndicator = (0, import_react760.forwardRef)((props43, ref) => {
  const steps = useStepsContext();
  const itemProps14 = useStepsItemPropsContext();
  const mergedProps = mergeProps2(steps.getIndicatorProps(itemProps14), props43);
  return (0, import_jsx_runtime354.jsx)(ark.div, { ...mergedProps, ref });
});
StepsIndicator.displayName = "StepsIndicator";

// node_modules/@ark-ui/react/dist/components/steps/steps-item.js
var import_jsx_runtime355 = __toESM(require_jsx_runtime(), 1);
var import_react762 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/steps/use-steps-item-context.js
var [StepsItemProvider, useStepsItemContext] = createContext3({
  name: "StepsItemContext",
  hookName: "useStepsItemContext",
  providerName: "<StepsItem />"
});

// node_modules/@ark-ui/react/dist/components/steps/steps-item.js
var StepsItem = (0, import_react762.forwardRef)((props43, ref) => {
  const [itemProps14, localProps] = createSplitProps2()(props43, ["index"]);
  const steps = useStepsContext();
  const mergedProps = mergeProps2(steps.getItemProps(itemProps14), localProps);
  const itemState = steps.getItemState(itemProps14);
  return (0, import_jsx_runtime355.jsx)(StepsItemPropsProvider, { value: itemProps14, children: (0, import_jsx_runtime355.jsx)(StepsItemProvider, { value: itemState, children: (0, import_jsx_runtime355.jsx)(ark.div, { ...mergedProps, ref }) }) });
});
StepsItem.displayName = "StepsItem";

// node_modules/@ark-ui/react/dist/components/steps/steps-item-context.js
var StepsItemContext = (props43) => {
  return props43.children(useStepsItemContext());
};
StepsItemContext.displayName = "StepsItemContext";

// node_modules/@ark-ui/react/dist/components/steps/steps-list.js
var import_jsx_runtime356 = __toESM(require_jsx_runtime(), 1);
var import_react764 = __toESM(require_react(), 1);
var StepsList = (0, import_react764.forwardRef)((props43, ref) => {
  const steps = useStepsContext();
  const mergedProps = mergeProps2(steps.getListProps(), props43);
  return (0, import_jsx_runtime356.jsx)(ark.div, { ...mergedProps, ref });
});
StepsList.displayName = "StepsList";

// node_modules/@ark-ui/react/dist/components/steps/steps-next-trigger.js
var import_jsx_runtime357 = __toESM(require_jsx_runtime(), 1);
var import_react766 = __toESM(require_react(), 1);
var StepsNextTrigger = (0, import_react766.forwardRef)((props43, ref) => {
  const steps = useStepsContext();
  const mergedProps = mergeProps2(steps.getNextTriggerProps(), props43);
  return (0, import_jsx_runtime357.jsx)(ark.button, { ...mergedProps, ref });
});
StepsNextTrigger.displayName = "StepsNextTrigger";

// node_modules/@ark-ui/react/dist/components/steps/steps-prev-trigger.js
var import_jsx_runtime358 = __toESM(require_jsx_runtime(), 1);
var import_react768 = __toESM(require_react(), 1);
var StepsPrevTrigger = (0, import_react768.forwardRef)((props43, ref) => {
  const steps = useStepsContext();
  const mergedProps = mergeProps2(steps.getPrevTriggerProps(), props43);
  return (0, import_jsx_runtime358.jsx)(ark.button, { ...mergedProps, ref });
});
StepsPrevTrigger.displayName = "StepsPrevTrigger";

// node_modules/@ark-ui/react/dist/components/steps/steps-progress.js
var import_jsx_runtime359 = __toESM(require_jsx_runtime(), 1);
var import_react770 = __toESM(require_react(), 1);
var StepsProgress = (0, import_react770.forwardRef)((props43, ref) => {
  const steps = useStepsContext();
  const mergedProps = mergeProps2(steps.getProgressProps(), props43);
  return (0, import_jsx_runtime359.jsx)(ark.div, { ...mergedProps, ref });
});
StepsProgress.displayName = "StepsProgress";

// node_modules/@ark-ui/react/dist/components/steps/steps-root.js
var import_jsx_runtime360 = __toESM(require_jsx_runtime(), 1);
var import_react774 = __toESM(require_react(), 1);

// node_modules/@zag-js/steps/dist/index.mjs
var anatomy31 = createAnatomy("steps").parts(
  "root",
  "list",
  "item",
  "trigger",
  "indicator",
  "separator",
  "content",
  "nextTrigger",
  "prevTrigger",
  "progress"
);
var parts34 = anatomy31.build();
var getRootId25 = (ctx) => {
  var _a8;
  return ((_a8 = ctx.ids) == null ? void 0 : _a8.root) ?? `steps:${ctx.id}`;
};
var getListId = (ctx) => {
  var _a8;
  return ((_a8 = ctx.ids) == null ? void 0 : _a8.list) ?? `steps:${ctx.id}:list`;
};
var getTriggerId12 = (ctx, index) => {
  var _a8, _b7;
  return ((_b7 = (_a8 = ctx.ids) == null ? void 0 : _a8.triggerId) == null ? void 0 : _b7.call(_a8, index)) ?? `steps:${ctx.id}:trigger:${index}`;
};
var getContentId12 = (ctx, index) => {
  var _a8, _b7;
  return ((_b7 = (_a8 = ctx.ids) == null ? void 0 : _a8.contentId) == null ? void 0 : _b7.call(_a8, index)) ?? `steps:${ctx.id}:content:${index}`;
};
function connect32(service, normalize4) {
  const { context, send, computed, prop, scope } = service;
  const step = context.get("step");
  const count = prop("count");
  const percent = computed("percent");
  const hasNextStep = computed("hasNextStep");
  const hasPrevStep = computed("hasPrevStep");
  const getItemState = (props210) => ({
    triggerId: getTriggerId12(scope, props210.index),
    contentId: getContentId12(scope, props210.index),
    current: props210.index === step,
    completed: props210.index < step,
    incomplete: props210.index > step,
    index: props210.index,
    first: props210.index === 0,
    last: props210.index === count - 1
  });
  const goToNextStep = () => {
    send({ type: "STEP.NEXT", src: "next.trigger.click" });
  };
  const goToPrevStep = () => {
    send({ type: "STEP.PREV", src: "prev.trigger.click" });
  };
  const resetStep = () => {
    send({ type: "STEP.RESET", src: "reset.trigger.click" });
  };
  const setStep2 = (value) => {
    send({ type: "STEP.SET", value, src: "api.setValue" });
  };
  return {
    value: step,
    count,
    percent,
    hasNextStep,
    hasPrevStep,
    isCompleted: computed("completed"),
    goToNextStep,
    goToPrevStep,
    resetStep,
    getItemState,
    setStep: setStep2,
    getRootProps() {
      return normalize4.element({
        ...parts34.root.attrs,
        id: getRootId25(scope),
        dir: prop("dir"),
        "data-orientation": prop("orientation"),
        style: {
          "--percent": `${percent}%`
        }
      });
    },
    getListProps() {
      const arr = fromLength(count);
      const triggerIds = arr.map((_, index) => getTriggerId12(scope, index));
      return normalize4.element({
        ...parts34.list.attrs,
        dir: prop("dir"),
        id: getListId(scope),
        role: "tablist",
        "aria-owns": triggerIds.join(" "),
        "aria-orientation": prop("orientation"),
        "data-orientation": prop("orientation")
      });
    },
    getItemProps(props210) {
      const itemState = getItemState(props210);
      return normalize4.element({
        ...parts34.item.attrs,
        dir: prop("dir"),
        "aria-current": itemState.current ? "step" : void 0,
        "data-orientation": prop("orientation")
      });
    },
    getTriggerProps(props210) {
      const itemState = getItemState(props210);
      return normalize4.button({
        ...parts34.trigger.attrs,
        id: itemState.triggerId,
        role: "tab",
        dir: prop("dir"),
        tabIndex: !prop("linear") || itemState.current ? 0 : -1,
        "aria-selected": itemState.current,
        "aria-controls": itemState.contentId,
        "data-state": itemState.current ? "open" : "closed",
        "data-orientation": prop("orientation"),
        "data-complete": dataAttr(itemState.completed),
        "data-current": dataAttr(itemState.current),
        "data-incomplete": dataAttr(itemState.incomplete),
        onClick(event) {
          if (event.defaultPrevented) return;
          if (prop("linear")) return;
          send({ type: "STEP.SET", value: props210.index, src: "trigger.click" });
        }
      });
    },
    getContentProps(props210) {
      const itemState = getItemState(props210);
      return normalize4.element({
        ...parts34.content.attrs,
        dir: prop("dir"),
        id: itemState.contentId,
        role: "tabpanel",
        tabIndex: 0,
        hidden: !itemState.current,
        "data-state": itemState.current ? "open" : "closed",
        "data-orientation": prop("orientation"),
        "aria-labelledby": itemState.triggerId
      });
    },
    getIndicatorProps(props210) {
      const itemState = getItemState(props210);
      return normalize4.element({
        ...parts34.indicator.attrs,
        dir: prop("dir"),
        "aria-hidden": true,
        "data-complete": dataAttr(itemState.completed),
        "data-current": dataAttr(itemState.current),
        "data-incomplete": dataAttr(itemState.incomplete)
      });
    },
    getSeparatorProps(props210) {
      const itemState = getItemState(props210);
      return normalize4.element({
        ...parts34.separator.attrs,
        dir: prop("dir"),
        "data-orientation": prop("orientation"),
        "data-complete": dataAttr(itemState.completed),
        "data-current": dataAttr(itemState.current),
        "data-incomplete": dataAttr(itemState.incomplete)
      });
    },
    getNextTriggerProps() {
      return normalize4.button({
        ...parts34.nextTrigger.attrs,
        dir: prop("dir"),
        type: "button",
        disabled: !hasNextStep,
        onClick(event) {
          if (event.defaultPrevented) return;
          goToNextStep();
        }
      });
    },
    getPrevTriggerProps() {
      return normalize4.button({
        dir: prop("dir"),
        ...parts34.prevTrigger.attrs,
        type: "button",
        disabled: !hasPrevStep,
        onClick(event) {
          if (event.defaultPrevented) return;
          goToPrevStep();
        }
      });
    },
    getProgressProps() {
      return normalize4.element({
        dir: prop("dir"),
        ...parts34.progress.attrs,
        role: "progressbar",
        "aria-valuenow": percent,
        "aria-valuemin": 0,
        "aria-valuemax": 100,
        "aria-valuetext": `${percent}% complete`,
        "data-complete": dataAttr(percent === 100)
      });
    }
  };
}
var machine32 = createMachine({
  props({ props: props210 }) {
    return {
      defaultStep: 0,
      count: 1,
      linear: false,
      orientation: "horizontal",
      ...props210
    };
  },
  context({ prop, bindable }) {
    return {
      step: bindable(() => ({
        defaultValue: prop("defaultStep"),
        value: prop("step"),
        onChange(value) {
          var _a8, _b7;
          (_a8 = prop("onStepChange")) == null ? void 0 : _a8({ step: value });
          const completed = value == prop("count");
          if (completed) (_b7 = prop("onStepComplete")) == null ? void 0 : _b7();
        }
      }))
    };
  },
  computed: {
    percent: ({ context, prop }) => context.get("step") / prop("count") * 100,
    hasNextStep: ({ context, prop }) => context.get("step") < prop("count"),
    hasPrevStep: ({ context }) => context.get("step") > 0,
    completed: ({ context, prop }) => context.get("step") === prop("count")
  },
  initialState() {
    return "idle";
  },
  entry: ["validateStep"],
  states: {
    idle: {
      on: {
        "STEP.SET": {
          actions: ["setStep"]
        },
        "STEP.NEXT": {
          actions: ["goToNextStep"]
        },
        "STEP.PREV": {
          actions: ["goToPrevStep"]
        },
        "STEP.RESET": {
          actions: ["resetStep"]
        }
      }
    }
  },
  implementations: {
    actions: {
      goToNextStep({ context, prop }) {
        const value = Math.min(context.get("step") + 1, prop("count"));
        context.set("step", value);
      },
      goToPrevStep({ context }) {
        const value = Math.max(context.get("step") - 1, 0);
        context.set("step", value);
      },
      resetStep({ context }) {
        context.set("step", 0);
      },
      setStep({ context, event }) {
        context.set("step", event.value);
      },
      validateStep({ context, prop }) {
        validateStep(prop("count"), context.get("step"));
      }
    }
  }
});
var validateStep = (count, step) => {
  if (!isValueWithinRange(step, 0, count)) {
    throw new RangeError(`[zag-js/steps] step index ${step} is out of bounds`);
  }
};
var props32 = createProps()([
  "count",
  "dir",
  "getRootNode",
  "id",
  "ids",
  "linear",
  "onStepChange",
  "onStepComplete",
  "orientation",
  "step",
  "defaultStep"
]);
var splitProps32 = createSplitProps(props32);

// node_modules/@ark-ui/react/dist/components/steps/use-steps.js
var import_react772 = __toESM(require_react(), 1);
function useSteps(props43) {
  const id = (0, import_react772.useId)();
  const { getRootNode } = useEnvironmentContext();
  const { dir } = useLocaleContext();
  const machineProps = {
    id,
    dir,
    getRootNode,
    ...props43
  };
  const service = useMachine(machine32, machineProps);
  return connect32(service, normalizeProps);
}

// node_modules/@ark-ui/react/dist/components/steps/steps-root.js
var StepsRoot = (0, import_react774.forwardRef)((props43, ref) => {
  const [useStepsProps, localProps] = createSplitProps2()(props43, [
    "defaultStep",
    "id",
    "ids",
    "count",
    "linear",
    "onStepChange",
    "onStepComplete",
    "orientation",
    "step"
  ]);
  const steps = useSteps(useStepsProps);
  const mergedProps = mergeProps2(steps.getRootProps(), localProps);
  return (0, import_jsx_runtime360.jsx)(StepsProvider, { value: steps, children: (0, import_jsx_runtime360.jsx)(ark.div, { ...mergedProps, ref }) });
});
StepsRoot.displayName = "StepsRoot";

// node_modules/@ark-ui/react/dist/components/steps/steps-root-provider.js
var import_jsx_runtime361 = __toESM(require_jsx_runtime(), 1);
var import_react776 = __toESM(require_react(), 1);
var StepsRootProvider = (0, import_react776.forwardRef)((props43, ref) => {
  const [{ value: steps }, rootProps2] = createSplitProps2()(props43, ["value"]);
  const mergedProps = mergeProps2(steps.getRootProps(), rootProps2);
  return (0, import_jsx_runtime361.jsx)(StepsProvider, { value: steps, children: (0, import_jsx_runtime361.jsx)(ark.div, { ...mergedProps, ref, children: props43.children }) });
});
StepsRootProvider.displayName = "StepsRootProvider";

// node_modules/@ark-ui/react/dist/components/steps/steps-separator.js
var import_jsx_runtime362 = __toESM(require_jsx_runtime(), 1);
var import_react778 = __toESM(require_react(), 1);
var StepsSeparator = (0, import_react778.forwardRef)((props43, ref) => {
  const steps = useStepsContext();
  const itemProps14 = useStepsItemPropsContext();
  const mergedProps = mergeProps2(steps.getSeparatorProps(itemProps14), props43);
  return (0, import_jsx_runtime362.jsx)(ark.div, { ...mergedProps, ref });
});
StepsSeparator.displayName = "StepsSeparator";

// node_modules/@ark-ui/react/dist/components/steps/steps-trigger.js
var import_jsx_runtime363 = __toESM(require_jsx_runtime(), 1);
var import_react780 = __toESM(require_react(), 1);
var StepsTrigger = (0, import_react780.forwardRef)((props43, ref) => {
  const steps = useStepsContext();
  const itemProps14 = useStepsItemPropsContext();
  const mergedProps = mergeProps2(steps.getTriggerProps(itemProps14), props43);
  return (0, import_jsx_runtime363.jsx)(ark.button, { ...mergedProps, ref });
});
StepsTrigger.displayName = "StepsTrigger";

// node_modules/@ark-ui/react/dist/components/steps/steps.js
var steps_exports = {};
__export(steps_exports, {
  CompletedContent: () => StepsCompletedContent,
  Content: () => StepsContent,
  Context: () => StepsContext,
  Indicator: () => StepsIndicator,
  Item: () => StepsItem,
  ItemContext: () => StepsItemContext,
  List: () => StepsList,
  NextTrigger: () => StepsNextTrigger,
  PrevTrigger: () => StepsPrevTrigger,
  Progress: () => StepsProgress,
  Root: () => StepsRoot,
  RootProvider: () => StepsRootProvider,
  Separator: () => StepsSeparator,
  Trigger: () => StepsTrigger
});

// node_modules/@ark-ui/react/dist/components/switch/use-switch-context.js
var [SwitchProvider, useSwitchContext] = createContext3({
  name: "SwitchContext",
  hookName: "useSwitchContext",
  providerName: "<SwitchProvider />"
});

// node_modules/@ark-ui/react/dist/components/switch/switch-context.js
var SwitchContext = (props43) => props43.children(useSwitchContext());

// node_modules/@ark-ui/react/dist/components/switch/switch-control.js
var import_jsx_runtime364 = __toESM(require_jsx_runtime(), 1);
var import_react782 = __toESM(require_react(), 1);
var SwitchControl = (0, import_react782.forwardRef)((props43, ref) => {
  const switchContext = useSwitchContext();
  const mergedProps = mergeProps2(switchContext.getControlProps(), props43);
  return (0, import_jsx_runtime364.jsx)(ark.span, { ...mergedProps, ref });
});
SwitchControl.displayName = "SwitchControl";

// node_modules/@ark-ui/react/dist/components/switch/switch-hidden-input.js
var import_jsx_runtime365 = __toESM(require_jsx_runtime(), 1);
var import_react784 = __toESM(require_react(), 1);
var SwitchHiddenInput = (0, import_react784.forwardRef)((props43, ref) => {
  const switchContext = useSwitchContext();
  const mergedProps = mergeProps2(switchContext.getHiddenInputProps(), props43);
  const field = useFieldContext();
  return (0, import_jsx_runtime365.jsx)(ark.input, { "aria-describedby": field == null ? void 0 : field.ariaDescribedby, ...mergedProps, ref });
});
SwitchHiddenInput.displayName = "SwitchHiddenInput";

// node_modules/@ark-ui/react/dist/components/switch/switch-label.js
var import_jsx_runtime366 = __toESM(require_jsx_runtime(), 1);
var import_react786 = __toESM(require_react(), 1);
var SwitchLabel = (0, import_react786.forwardRef)((props43, ref) => {
  const switchContext = useSwitchContext();
  const mergedProps = mergeProps2(switchContext.getLabelProps(), props43);
  return (0, import_jsx_runtime366.jsx)(ark.span, { ...mergedProps, ref });
});
SwitchLabel.displayName = "SwitchLabel";

// node_modules/@ark-ui/react/dist/components/switch/switch-root.js
var import_jsx_runtime367 = __toESM(require_jsx_runtime(), 1);
var import_react790 = __toESM(require_react(), 1);

// node_modules/@zag-js/switch/dist/index.mjs
var anatomy32 = createAnatomy("switch").parts("root", "label", "control", "thumb");
var parts35 = anatomy32.build();
var getRootId26 = (ctx) => {
  var _a8;
  return ((_a8 = ctx.ids) == null ? void 0 : _a8.root) ?? `switch:${ctx.id}`;
};
var getLabelId17 = (ctx) => {
  var _a8;
  return ((_a8 = ctx.ids) == null ? void 0 : _a8.label) ?? `switch:${ctx.id}:label`;
};
var getThumbId3 = (ctx) => {
  var _a8;
  return ((_a8 = ctx.ids) == null ? void 0 : _a8.thumb) ?? `switch:${ctx.id}:thumb`;
};
var getControlId12 = (ctx) => {
  var _a8;
  return ((_a8 = ctx.ids) == null ? void 0 : _a8.control) ?? `switch:${ctx.id}:control`;
};
var getHiddenInputId9 = (ctx) => {
  var _a8;
  return ((_a8 = ctx.ids) == null ? void 0 : _a8.hiddenInput) ?? `switch:${ctx.id}:input`;
};
var getRootEl9 = (ctx) => ctx.getById(getRootId26(ctx));
var getHiddenInputEl8 = (ctx) => ctx.getById(getHiddenInputId9(ctx));
function connect33(service, normalize4) {
  const { context, send, prop, scope } = service;
  const disabled = prop("disabled");
  const readOnly = prop("readOnly");
  const checked = !!context.get("checked");
  const focused = !disabled && context.get("focused");
  const focusVisible = !disabled && context.get("focusVisible");
  const dataAttrs = {
    "data-active": dataAttr(context.get("active")),
    "data-focus": dataAttr(focused),
    "data-focus-visible": dataAttr(focusVisible),
    "data-readonly": dataAttr(readOnly),
    "data-hover": dataAttr(context.get("hovered")),
    "data-disabled": dataAttr(disabled),
    "data-state": checked ? "checked" : "unchecked",
    "data-invalid": dataAttr(prop("invalid"))
  };
  return {
    checked,
    disabled,
    focused,
    setChecked(checked2) {
      send({ type: "CHECKED.SET", checked: checked2, isTrusted: false });
    },
    toggleChecked() {
      send({ type: "CHECKED.TOGGLE", checked, isTrusted: false });
    },
    getRootProps() {
      return normalize4.label({
        ...parts35.root.attrs,
        ...dataAttrs,
        dir: prop("dir"),
        id: getRootId26(scope),
        htmlFor: getHiddenInputId9(scope),
        onPointerMove() {
          if (disabled) return;
          send({ type: "CONTEXT.SET", context: { hovered: true } });
        },
        onPointerLeave() {
          if (disabled) return;
          send({ type: "CONTEXT.SET", context: { hovered: false } });
        },
        onClick(event) {
          var _a8;
          if (disabled) return;
          const target = getEventTarget(event);
          if (target === getHiddenInputEl8(scope)) {
            event.stopPropagation();
          }
          if (isSafari()) {
            (_a8 = getHiddenInputEl8(scope)) == null ? void 0 : _a8.focus();
          }
        }
      });
    },
    getLabelProps() {
      return normalize4.element({
        ...parts35.label.attrs,
        ...dataAttrs,
        dir: prop("dir"),
        id: getLabelId17(scope)
      });
    },
    getThumbProps() {
      return normalize4.element({
        ...parts35.thumb.attrs,
        ...dataAttrs,
        dir: prop("dir"),
        id: getThumbId3(scope),
        "aria-hidden": true
      });
    },
    getControlProps() {
      return normalize4.element({
        ...parts35.control.attrs,
        ...dataAttrs,
        dir: prop("dir"),
        id: getControlId12(scope),
        "aria-hidden": true
      });
    },
    getHiddenInputProps() {
      return normalize4.input({
        id: getHiddenInputId9(scope),
        type: "checkbox",
        required: prop("required"),
        defaultChecked: checked,
        disabled,
        "aria-labelledby": getLabelId17(scope),
        "aria-invalid": prop("invalid"),
        name: prop("name"),
        form: prop("form"),
        value: prop("value"),
        style: visuallyHiddenStyle,
        onFocus() {
          const focusVisible2 = isFocusVisible();
          send({ type: "CONTEXT.SET", context: { focused: true, focusVisible: focusVisible2 } });
        },
        onBlur() {
          send({ type: "CONTEXT.SET", context: { focused: false, focusVisible: false } });
        },
        onClick(event) {
          if (readOnly) {
            event.preventDefault();
            return;
          }
          const checked2 = event.currentTarget.checked;
          send({ type: "CHECKED.SET", checked: checked2, isTrusted: true });
        }
      });
    }
  };
}
var { not: not10 } = createGuards();
var machine33 = createMachine({
  props({ props: props210 }) {
    return {
      defaultChecked: false,
      label: "switch",
      value: "on",
      ...props210
    };
  },
  initialState() {
    return "ready";
  },
  context({ prop, bindable }) {
    return {
      checked: bindable(() => ({
        defaultValue: prop("defaultChecked"),
        value: prop("checked"),
        onChange(value) {
          var _a8;
          (_a8 = prop("onCheckedChange")) == null ? void 0 : _a8({ checked: value });
        }
      })),
      fieldsetDisabled: bindable(() => ({
        defaultValue: false
      })),
      focusVisible: bindable(() => ({
        defaultValue: false
      })),
      active: bindable(() => ({
        defaultValue: false
      })),
      focused: bindable(() => ({
        defaultValue: false
      })),
      hovered: bindable(() => ({
        defaultValue: false
      }))
    };
  },
  computed: {
    isDisabled: ({ context, prop }) => prop("disabled") || context.get("fieldsetDisabled")
  },
  watch({ track, prop, context, action }) {
    track([() => prop("disabled")], () => {
      action(["removeFocusIfNeeded"]);
    });
    track([() => context.get("checked")], () => {
      action(["syncInputElement"]);
    });
  },
  effects: ["trackFormControlState", "trackPressEvent", "trackFocusVisible"],
  on: {
    "CHECKED.TOGGLE": [
      {
        guard: not10("isTrusted"),
        actions: ["toggleChecked", "dispatchChangeEvent"]
      },
      {
        actions: ["toggleChecked"]
      }
    ],
    "CHECKED.SET": [
      {
        guard: not10("isTrusted"),
        actions: ["setChecked", "dispatchChangeEvent"]
      },
      {
        actions: ["setChecked"]
      }
    ],
    "CONTEXT.SET": {
      actions: ["setContext"]
    }
  },
  states: {
    ready: {}
  },
  implementations: {
    guards: {
      isTrusted: ({ event }) => !!event.isTrusted
    },
    effects: {
      trackPressEvent({ computed, scope, context }) {
        if (computed("isDisabled")) return;
        return trackPress({
          pointerNode: getRootEl9(scope),
          keyboardNode: getHiddenInputEl8(scope),
          isValidKey: (event) => event.key === " ",
          onPress: () => context.set("active", false),
          onPressStart: () => context.set("active", true),
          onPressEnd: () => context.set("active", false)
        });
      },
      trackFocusVisible({ computed, scope }) {
        if (computed("isDisabled")) return;
        return trackFocusVisible({ root: scope.getRootNode() });
      },
      trackFormControlState({ context, send, scope }) {
        return trackFormControl(getHiddenInputEl8(scope), {
          onFieldsetDisabledChange(disabled) {
            context.set("fieldsetDisabled", disabled);
          },
          onFormReset() {
            const checked = context.initial("checked");
            send({ type: "CHECKED.SET", checked: !!checked, src: "form-reset" });
          }
        });
      }
    },
    actions: {
      setContext({ context, event }) {
        for (const key in event.context) {
          context.set(key, event.context[key]);
        }
      },
      syncInputElement({ context, scope }) {
        const inputEl = getHiddenInputEl8(scope);
        if (!inputEl) return;
        setElementChecked(inputEl, !!context.get("checked"));
      },
      removeFocusIfNeeded({ context, prop }) {
        if (prop("disabled")) {
          context.set("focused", false);
        }
      },
      setChecked({ context, event }) {
        context.set("checked", event.checked);
      },
      toggleChecked({ context }) {
        context.set("checked", !context.get("checked"));
      },
      dispatchChangeEvent({ context, scope }) {
        const inputEl = getHiddenInputEl8(scope);
        dispatchInputCheckedEvent(inputEl, { checked: context.get("checked") });
      }
    }
  }
});
var props33 = createProps()([
  "checked",
  "defaultChecked",
  "dir",
  "disabled",
  "form",
  "getRootNode",
  "id",
  "ids",
  "invalid",
  "label",
  "name",
  "onCheckedChange",
  "readOnly",
  "required",
  "value"
]);
var splitProps33 = createSplitProps(props33);

// node_modules/@ark-ui/react/dist/components/switch/use-switch.js
var import_react788 = __toESM(require_react(), 1);
var useSwitch = (props43) => {
  const id = (0, import_react788.useId)();
  const { getRootNode } = useEnvironmentContext();
  const { dir } = useLocaleContext();
  const field = useFieldContext();
  const machineProps = {
    id,
    ids: {
      label: field == null ? void 0 : field.ids.label,
      hiddenInput: field == null ? void 0 : field.ids.control
    },
    dir,
    disabled: field == null ? void 0 : field.disabled,
    readOnly: field == null ? void 0 : field.readOnly,
    invalid: field == null ? void 0 : field.invalid,
    required: field == null ? void 0 : field.required,
    getRootNode,
    ...props43
  };
  const service = useMachine(machine33, machineProps);
  return connect33(service, normalizeProps);
};

// node_modules/@ark-ui/react/dist/components/switch/switch-root.js
var SwitchRoot = (0, import_react790.forwardRef)((props43, ref) => {
  const [switchProps, localProps] = createSplitProps2()(props43, [
    "checked",
    "defaultChecked",
    "disabled",
    "form",
    "id",
    "ids",
    "invalid",
    "label",
    "name",
    "onCheckedChange",
    "readOnly",
    "required",
    "value"
  ]);
  const switchContext = useSwitch(switchProps);
  const mergedProps = mergeProps2(switchContext.getRootProps(), localProps);
  return (0, import_jsx_runtime367.jsx)(SwitchProvider, { value: switchContext, children: (0, import_jsx_runtime367.jsx)(ark.label, { ...mergedProps, ref }) });
});
SwitchRoot.displayName = "SwitchRoot";

// node_modules/@ark-ui/react/dist/components/switch/switch-root-provider.js
var import_jsx_runtime368 = __toESM(require_jsx_runtime(), 1);
var import_react792 = __toESM(require_react(), 1);
var SwitchRootProvider = (0, import_react792.forwardRef)((props43, ref) => {
  const [{ value: api }, localProps] = createSplitProps2()(props43, ["value"]);
  const mergedProps = mergeProps2(api.getRootProps(), localProps);
  return (0, import_jsx_runtime368.jsx)(SwitchProvider, { value: api, children: (0, import_jsx_runtime368.jsx)(ark.label, { ...mergedProps, ref }) });
});
SwitchRootProvider.displayName = "SwitchRootProvider";

// node_modules/@ark-ui/react/dist/components/switch/switch-thumb.js
var import_jsx_runtime369 = __toESM(require_jsx_runtime(), 1);
var import_react794 = __toESM(require_react(), 1);
var SwitchThumb = (0, import_react794.forwardRef)((props43, ref) => {
  const switchContext = useSwitchContext();
  const mergedProps = mergeProps2(switchContext.getThumbProps(), props43);
  return (0, import_jsx_runtime369.jsx)(ark.span, { ...mergedProps, ref });
});
SwitchThumb.displayName = "SwitchThumb";

// node_modules/@ark-ui/react/dist/components/switch/switch.js
var switch_exports = {};
__export(switch_exports, {
  Context: () => SwitchContext,
  Control: () => SwitchControl,
  HiddenInput: () => SwitchHiddenInput,
  Label: () => SwitchLabel,
  Root: () => SwitchRoot,
  RootProvider: () => SwitchRootProvider,
  Thumb: () => SwitchThumb
});

// node_modules/@ark-ui/react/dist/components/tabs/tab-content.js
var import_jsx_runtime370 = __toESM(require_jsx_runtime(), 1);
var import_react797 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/utils/use-debounce.js
var import_react795 = __toESM(require_react(), 1);
function useDebounce(value, delay2) {
  const [debouncedValue, setDebouncedValue] = (0, import_react795.useState)(value);
  (0, import_react795.useEffect)(() => {
    const timer = setTimeout(() => {
      setDebouncedValue(value);
    }, delay2);
    return () => {
      clearTimeout(timer);
    };
  }, [value, delay2]);
  return debouncedValue;
}

// node_modules/@ark-ui/react/dist/components/tabs/use-tabs-context.js
var [TabsProvider, useTabsContext] = createContext3({
  name: "TabsContext",
  hookName: "useTabsContext",
  providerName: "<TabsProvider />"
});

// node_modules/@ark-ui/react/dist/components/tabs/tab-content.js
var TabContent = (0, import_react797.forwardRef)((props43, ref) => {
  const [contentProps2, localProps] = createSplitProps2()(props43, ["value"]);
  const tabs = useTabsContext();
  const renderStrategyProps = useRenderStrategyPropsContext();
  const presence = usePresence({
    ...renderStrategyProps,
    present: useDebounce(tabs.value === props43.value, 0),
    immediate: true
  });
  const mergedProps = mergeProps2(tabs.getContentProps(contentProps2), presence.getPresenceProps(), localProps);
  return (0, import_jsx_runtime370.jsx)(PresenceProvider, { value: presence, children: presence.unmounted ? null : (0, import_jsx_runtime370.jsx)(ark.div, { ...mergedProps, ref: composeRefs(presence.ref, ref) }) });
});
TabContent.displayName = "TabContent";

// node_modules/@ark-ui/react/dist/components/tabs/tab-indicator.js
var import_jsx_runtime371 = __toESM(require_jsx_runtime(), 1);
var import_react799 = __toESM(require_react(), 1);
var TabIndicator = (0, import_react799.forwardRef)((props43, ref) => {
  const tabs = useTabsContext();
  const mergedProps = mergeProps2(tabs.getIndicatorProps(), props43);
  return (0, import_jsx_runtime371.jsx)(ark.div, { ...mergedProps, ref });
});
TabIndicator.displayName = "TabIndicator";

// node_modules/@ark-ui/react/dist/components/tabs/tab-list.js
var import_jsx_runtime372 = __toESM(require_jsx_runtime(), 1);
var import_react801 = __toESM(require_react(), 1);
var TabList = (0, import_react801.forwardRef)((props43, ref) => {
  const tabs = useTabsContext();
  const mergedProps = mergeProps2(tabs.getListProps(), props43);
  return (0, import_jsx_runtime372.jsx)(ark.div, { ...mergedProps, ref });
});
TabList.displayName = "TabList";

// node_modules/@ark-ui/react/dist/components/tabs/tab-trigger.js
var import_jsx_runtime373 = __toESM(require_jsx_runtime(), 1);
var import_react803 = __toESM(require_react(), 1);
var TabTrigger = (0, import_react803.forwardRef)((props43, ref) => {
  const [tabProps, localProps] = createSplitProps2()(props43, ["disabled", "value"]);
  const tabs = useTabsContext();
  const mergedProps = mergeProps2(tabs.getTriggerProps(tabProps), localProps);
  return (0, import_jsx_runtime373.jsx)(ark.button, { ...mergedProps, ref });
});
TabTrigger.displayName = "TabTrigger";

// node_modules/@ark-ui/react/dist/components/tabs/tabs-context.js
var TabsContext = (props43) => props43.children(useTabsContext());

// node_modules/@ark-ui/react/dist/components/tabs/tabs-root.js
var import_jsx_runtime374 = __toESM(require_jsx_runtime(), 1);
var import_react807 = __toESM(require_react(), 1);

// node_modules/@zag-js/tabs/dist/index.mjs
var anatomy33 = createAnatomy("tabs").parts("root", "list", "trigger", "content", "indicator");
var parts36 = anatomy33.build();
var getRootId27 = (ctx) => {
  var _a8;
  return ((_a8 = ctx.ids) == null ? void 0 : _a8.root) ?? `tabs:${ctx.id}`;
};
var getListId2 = (ctx) => {
  var _a8;
  return ((_a8 = ctx.ids) == null ? void 0 : _a8.list) ?? `tabs:${ctx.id}:list`;
};
var getContentId13 = (ctx, id) => {
  var _a8;
  return ((_a8 = ctx.ids) == null ? void 0 : _a8.content) ?? `tabs:${ctx.id}:content-${id}`;
};
var getTriggerId13 = (ctx, id) => {
  var _a8;
  return ((_a8 = ctx.ids) == null ? void 0 : _a8.trigger) ?? `tabs:${ctx.id}:trigger-${id}`;
};
var getIndicatorId3 = (ctx) => {
  var _a8;
  return ((_a8 = ctx.ids) == null ? void 0 : _a8.indicator) ?? `tabs:${ctx.id}:indicator`;
};
var getListEl = (ctx) => ctx.getById(getListId2(ctx));
var getContentEl12 = (ctx, id) => ctx.getById(getContentId13(ctx, id));
var getTriggerEl10 = (ctx, id) => ctx.getById(getTriggerId13(ctx, id));
var getIndicatorEl3 = (ctx) => ctx.getById(getIndicatorId3(ctx));
var getElements2 = (ctx) => {
  const ownerId = CSS.escape(getListId2(ctx));
  const selector = `[role=tab][data-ownedby='${ownerId}']:not([disabled])`;
  return queryAll(getListEl(ctx), selector);
};
var getFirstTriggerEl2 = (ctx) => first(getElements2(ctx));
var getLastTriggerEl2 = (ctx) => last(getElements2(ctx));
var getNextTriggerEl2 = (ctx, opts) => nextById(getElements2(ctx), getTriggerId13(ctx, opts.value), opts.loopFocus);
var getPrevTriggerEl2 = (ctx, opts) => prevById(getElements2(ctx), getTriggerId13(ctx, opts.value), opts.loopFocus);
var getOffsetRect3 = (el) => {
  return {
    left: (el == null ? void 0 : el.offsetLeft) ?? 0,
    top: (el == null ? void 0 : el.offsetTop) ?? 0,
    width: (el == null ? void 0 : el.offsetWidth) ?? 0,
    height: (el == null ? void 0 : el.offsetHeight) ?? 0
  };
};
var getRectById = (ctx, id) => {
  const tab = itemById(getElements2(ctx), getTriggerId13(ctx, id));
  return resolveRect2(getOffsetRect3(tab));
};
var resolveRect2 = (rect) => ({
  width: `${rect.width}px`,
  height: `${rect.height}px`,
  left: `${rect.left}px`,
  top: `${rect.top}px`
});
function connect34(service, normalize4) {
  const { state: state2, send, context, prop, scope } = service;
  const translations = prop("translations");
  const focused = state2.matches("focused");
  const isVertical = prop("orientation") === "vertical";
  const isHorizontal = prop("orientation") === "horizontal";
  const composite = prop("composite");
  function getTriggerState(props210) {
    return {
      selected: context.get("value") === props210.value,
      focused: context.get("focusedValue") === props210.value,
      disabled: !!props210.disabled
    };
  }
  return {
    value: context.get("value"),
    focusedValue: context.get("focusedValue"),
    setValue(value) {
      send({ type: "SET_VALUE", value });
    },
    clearValue() {
      send({ type: "CLEAR_VALUE" });
    },
    setIndicatorRect(value) {
      const id = getTriggerId13(scope, value);
      send({ type: "SET_INDICATOR_RECT", id });
    },
    syncTabIndex() {
      send({ type: "SYNC_TAB_INDEX" });
    },
    selectNext(fromValue) {
      send({ type: "TAB_FOCUS", value: fromValue, src: "selectNext" });
      send({ type: "ARROW_NEXT", src: "selectNext" });
    },
    selectPrev(fromValue) {
      send({ type: "TAB_FOCUS", value: fromValue, src: "selectPrev" });
      send({ type: "ARROW_PREV", src: "selectPrev" });
    },
    focus() {
      var _a8;
      const value = context.get("value");
      if (!value) return;
      (_a8 = getTriggerEl10(scope, value)) == null ? void 0 : _a8.focus();
    },
    getRootProps() {
      return normalize4.element({
        ...parts36.root.attrs,
        id: getRootId27(scope),
        "data-orientation": prop("orientation"),
        "data-focus": dataAttr(focused),
        dir: prop("dir")
      });
    },
    getListProps() {
      return normalize4.element({
        ...parts36.list.attrs,
        id: getListId2(scope),
        role: "tablist",
        dir: prop("dir"),
        "data-focus": dataAttr(focused),
        "aria-orientation": prop("orientation"),
        "data-orientation": prop("orientation"),
        "aria-label": translations == null ? void 0 : translations.listLabel,
        onKeyDown(event) {
          if (event.defaultPrevented) return;
          if (!isSelfTarget(event)) return;
          if (isComposingEvent(event)) return;
          const keyMap2 = {
            ArrowDown() {
              if (isHorizontal) return;
              send({ type: "ARROW_NEXT", key: "ArrowDown" });
            },
            ArrowUp() {
              if (isHorizontal) return;
              send({ type: "ARROW_PREV", key: "ArrowUp" });
            },
            ArrowLeft() {
              if (isVertical) return;
              send({ type: "ARROW_PREV", key: "ArrowLeft" });
            },
            ArrowRight() {
              if (isVertical) return;
              send({ type: "ARROW_NEXT", key: "ArrowRight" });
            },
            Home() {
              send({ type: "HOME" });
            },
            End() {
              send({ type: "END" });
            }
          };
          let key = getEventKey(event, {
            dir: prop("dir"),
            orientation: prop("orientation")
          });
          const exec = keyMap2[key];
          if (exec) {
            event.preventDefault();
            exec(event);
            return;
          }
        }
      });
    },
    getTriggerState,
    getTriggerProps(props210) {
      const { value, disabled } = props210;
      const triggerState = getTriggerState(props210);
      return normalize4.button({
        ...parts36.trigger.attrs,
        role: "tab",
        type: "button",
        disabled,
        dir: prop("dir"),
        "data-orientation": prop("orientation"),
        "data-disabled": dataAttr(disabled),
        "aria-disabled": disabled,
        "data-value": value,
        "aria-selected": triggerState.selected,
        "data-selected": dataAttr(triggerState.selected),
        "data-focus": dataAttr(triggerState.focused),
        "aria-controls": triggerState.selected ? getContentId13(scope, value) : void 0,
        "data-ownedby": getListId2(scope),
        "data-ssr": dataAttr(context.get("ssr")),
        id: getTriggerId13(scope, value),
        tabIndex: triggerState.selected && composite ? 0 : -1,
        onFocus() {
          send({ type: "TAB_FOCUS", value });
        },
        onBlur(event) {
          const target = event.relatedTarget;
          if ((target == null ? void 0 : target.getAttribute("role")) !== "tab") {
            send({ type: "TAB_BLUR" });
          }
        },
        onClick(event) {
          if (event.defaultPrevented) return;
          if (isOpeningInNewTab(event)) return;
          if (disabled) return;
          if (isSafari()) {
            event.currentTarget.focus();
          }
          send({ type: "TAB_CLICK", value });
        }
      });
    },
    getContentProps(props210) {
      const { value } = props210;
      const selected = context.get("value") === value;
      return normalize4.element({
        ...parts36.content.attrs,
        dir: prop("dir"),
        id: getContentId13(scope, value),
        tabIndex: composite ? 0 : -1,
        "aria-labelledby": getTriggerId13(scope, value),
        role: "tabpanel",
        "data-ownedby": getListId2(scope),
        "data-selected": dataAttr(selected),
        "data-orientation": prop("orientation"),
        hidden: !selected
      });
    },
    getIndicatorProps() {
      const indicatorRect = context.get("indicatorRect");
      const indicatorTransition = context.get("indicatorTransition");
      return normalize4.element({
        id: getIndicatorId3(scope),
        ...parts36.indicator.attrs,
        dir: prop("dir"),
        "data-orientation": prop("orientation"),
        style: {
          "--transition-property": "left, right, top, bottom, width, height",
          "--left": indicatorRect.left,
          "--top": indicatorRect.top,
          "--width": indicatorRect.width,
          "--height": indicatorRect.height,
          position: "absolute",
          willChange: "var(--transition-property)",
          transitionProperty: "var(--transition-property)",
          transitionDuration: indicatorTransition ? "var(--transition-duration, 150ms)" : "0ms",
          transitionTimingFunction: "var(--transition-timing-function)",
          [isHorizontal ? "left" : "top"]: isHorizontal ? "var(--left)" : "var(--top)"
        }
      });
    }
  };
}
var { createMachine: createMachine5 } = setup();
var machine34 = createMachine5({
  props({ props: props210 }) {
    return {
      dir: "ltr",
      orientation: "horizontal",
      activationMode: "automatic",
      loopFocus: true,
      composite: true,
      navigate(details) {
        clickIfLink(details.node);
      },
      defaultValue: null,
      ...props210
    };
  },
  initialState() {
    return "idle";
  },
  context({ prop, bindable }) {
    return {
      value: bindable(() => ({
        defaultValue: prop("defaultValue"),
        value: prop("value"),
        onChange(value) {
          var _a8;
          (_a8 = prop("onValueChange")) == null ? void 0 : _a8({ value });
        }
      })),
      focusedValue: bindable(() => ({
        defaultValue: prop("value") || prop("defaultValue"),
        sync: true,
        onChange(value) {
          var _a8;
          (_a8 = prop("onFocusChange")) == null ? void 0 : _a8({ focusedValue: value });
        }
      })),
      ssr: bindable(() => ({ defaultValue: true })),
      indicatorTransition: bindable(() => ({ defaultValue: false })),
      indicatorRect: bindable(() => ({
        defaultValue: { left: "0px", top: "0px", width: "0px", height: "0px" }
      }))
    };
  },
  watch({ context, prop, track, action }) {
    track([() => context.get("value")], () => {
      action(["allowIndicatorTransition", "syncIndicatorRect", "syncTabIndex", "navigateIfNeeded"]);
    });
    track([() => prop("dir"), () => prop("orientation")], () => {
      action(["syncIndicatorRect"]);
    });
  },
  on: {
    SET_VALUE: {
      actions: ["setValue"]
    },
    CLEAR_VALUE: {
      actions: ["clearValue"]
    },
    SET_INDICATOR_RECT: {
      actions: ["setIndicatorRect"]
    },
    SYNC_TAB_INDEX: {
      actions: ["syncTabIndex"]
    }
  },
  entry: ["syncIndicatorRect", "syncTabIndex", "syncSsr"],
  exit: ["cleanupObserver"],
  states: {
    idle: {
      on: {
        TAB_FOCUS: {
          target: "focused",
          actions: ["setFocusedValue"]
        },
        TAB_CLICK: {
          target: "focused",
          actions: ["setFocusedValue", "setValue"]
        }
      }
    },
    focused: {
      on: {
        TAB_CLICK: {
          actions: ["setFocusedValue", "setValue"]
        },
        ARROW_PREV: [
          {
            guard: "selectOnFocus",
            actions: ["focusPrevTab", "selectFocusedTab"]
          },
          {
            actions: ["focusPrevTab"]
          }
        ],
        ARROW_NEXT: [
          {
            guard: "selectOnFocus",
            actions: ["focusNextTab", "selectFocusedTab"]
          },
          {
            actions: ["focusNextTab"]
          }
        ],
        HOME: [
          {
            guard: "selectOnFocus",
            actions: ["focusFirstTab", "selectFocusedTab"]
          },
          {
            actions: ["focusFirstTab"]
          }
        ],
        END: [
          {
            guard: "selectOnFocus",
            actions: ["focusLastTab", "selectFocusedTab"]
          },
          {
            actions: ["focusLastTab"]
          }
        ],
        TAB_FOCUS: {
          actions: ["setFocusedValue"]
        },
        TAB_BLUR: {
          target: "idle",
          actions: ["clearFocusedValue"]
        }
      }
    }
  },
  implementations: {
    guards: {
      selectOnFocus: ({ prop }) => prop("activationMode") === "automatic"
    },
    actions: {
      selectFocusedTab({ context, prop }) {
        raf(() => {
          const focusedValue = context.get("focusedValue");
          if (!focusedValue) return;
          const nullable = prop("deselectable") && context.get("value") === focusedValue;
          const value = nullable ? null : focusedValue;
          context.set("value", value);
        });
      },
      setFocusedValue({ context, event, flush: flush2 }) {
        if (event.value == null) return;
        flush2(() => {
          context.set("focusedValue", event.value);
        });
      },
      clearFocusedValue({ context }) {
        context.set("focusedValue", null);
      },
      setValue({ context, event, prop }) {
        const nullable = prop("deselectable") && context.get("value") === context.get("focusedValue");
        context.set("value", nullable ? null : event.value);
      },
      clearValue({ context }) {
        context.set("value", null);
      },
      focusFirstTab({ scope }) {
        raf(() => {
          var _a8;
          (_a8 = getFirstTriggerEl2(scope)) == null ? void 0 : _a8.focus();
        });
      },
      focusLastTab({ scope }) {
        raf(() => {
          var _a8;
          (_a8 = getLastTriggerEl2(scope)) == null ? void 0 : _a8.focus();
        });
      },
      focusNextTab({ context, prop, scope, event }) {
        const focusedValue = event.value ?? context.get("focusedValue");
        if (!focusedValue) return;
        const triggerEl = getNextTriggerEl2(scope, {
          value: focusedValue,
          loopFocus: prop("loopFocus")
        });
        raf(() => {
          if (prop("composite")) {
            triggerEl == null ? void 0 : triggerEl.focus();
          } else if ((triggerEl == null ? void 0 : triggerEl.dataset.value) != null) {
            context.set("focusedValue", triggerEl.dataset.value);
          }
        });
      },
      focusPrevTab({ context, prop, scope, event }) {
        const focusedValue = event.value ?? context.get("focusedValue");
        if (!focusedValue) return;
        const triggerEl = getPrevTriggerEl2(scope, {
          value: focusedValue,
          loopFocus: prop("loopFocus")
        });
        raf(() => {
          if (prop("composite")) {
            triggerEl == null ? void 0 : triggerEl.focus();
          } else if ((triggerEl == null ? void 0 : triggerEl.dataset.value) != null) {
            context.set("focusedValue", triggerEl.dataset.value);
          }
        });
      },
      syncTabIndex({ context, scope }) {
        raf(() => {
          const value = context.get("value");
          if (!value) return;
          const contentEl = getContentEl12(scope, value);
          if (!contentEl) return;
          const focusables = getFocusables(contentEl);
          if (focusables.length > 0) {
            contentEl.removeAttribute("tabindex");
          } else {
            contentEl.setAttribute("tabindex", "0");
          }
        });
      },
      cleanupObserver({ refs }) {
        const cleanup = refs.get("indicatorCleanup");
        if (cleanup) cleanup();
      },
      allowIndicatorTransition({ context }) {
        context.set("indicatorTransition", true);
      },
      setIndicatorRect({ context, event, scope }) {
        const value = event.id ?? context.get("value");
        const indicatorEl = getIndicatorEl3(scope);
        if (!indicatorEl) return;
        if (!value) {
          context.set("indicatorTransition", false);
          return;
        }
        const triggerEl = getTriggerEl10(scope, value);
        if (!triggerEl) return;
        context.set("indicatorRect", getRectById(scope, value));
        nextTick(() => {
          context.set("indicatorTransition", false);
        });
      },
      syncSsr({ context }) {
        context.set("ssr", false);
      },
      syncIndicatorRect({ context, refs, scope }) {
        const cleanup = refs.get("indicatorCleanup");
        if (cleanup) cleanup();
        const value = context.get("value");
        if (!value) {
          context.set("indicatorTransition", false);
          return;
        }
        const triggerEl = getTriggerEl10(scope, value);
        const indicatorEl = getIndicatorEl3(scope);
        if (!triggerEl || !indicatorEl) return;
        const indicatorCleanup = trackElementRect([triggerEl], {
          measure(el) {
            return getOffsetRect3(el);
          },
          onEntry({ rects }) {
            const [rect] = rects;
            context.set("indicatorRect", resolveRect2(rect));
          }
        });
        refs.set("indicatorCleanup", indicatorCleanup);
      },
      navigateIfNeeded({ context, prop, scope }) {
        var _a8;
        const value = context.get("value");
        if (!value) return;
        const triggerEl = getTriggerEl10(scope, value);
        if (isAnchorElement(triggerEl)) {
          (_a8 = prop("navigate")) == null ? void 0 : _a8({ value, node: triggerEl, href: triggerEl.href });
        }
      }
    }
  }
});
var props34 = createProps()([
  "activationMode",
  "composite",
  "deselectable",
  "dir",
  "getRootNode",
  "id",
  "ids",
  "loopFocus",
  "navigate",
  "onFocusChange",
  "onValueChange",
  "orientation",
  "translations",
  "value",
  "defaultValue"
]);
var splitProps34 = createSplitProps(props34);
var triggerProps = createProps()(["disabled", "value"]);
var splitTriggerProps = createSplitProps(triggerProps);
var contentProps = createProps()(["value"]);
var splitContentProps = createSplitProps(contentProps);

// node_modules/@ark-ui/react/dist/components/tabs/use-tabs.js
var import_react805 = __toESM(require_react(), 1);
var useTabs = (props43) => {
  const id = (0, import_react805.useId)();
  const { getRootNode } = useEnvironmentContext();
  const { dir } = useLocaleContext();
  const machineProps = {
    id,
    dir,
    getRootNode,
    ...props43
  };
  const service = useMachine(machine34, machineProps);
  return connect34(service, normalizeProps);
};

// node_modules/@ark-ui/react/dist/components/tabs/tabs-root.js
var TabsRoot = (0, import_react807.forwardRef)((props43, ref) => {
  const [renderStrategyProps, tabsProps] = splitRenderStrategyProps(props43);
  const [useTabsProps, localprops] = createSplitProps2()(tabsProps, [
    "activationMode",
    "composite",
    "defaultValue",
    "deselectable",
    "id",
    "ids",
    "loopFocus",
    "navigate",
    "onFocusChange",
    "onValueChange",
    "orientation",
    "translations",
    "value"
  ]);
  const tabs = useTabs(useTabsProps);
  const mergedProps = mergeProps2(tabs.getRootProps(), localprops);
  return (0, import_jsx_runtime374.jsx)(TabsProvider, { value: tabs, children: (0, import_jsx_runtime374.jsx)(RenderStrategyPropsProvider, { value: renderStrategyProps, children: (0, import_jsx_runtime374.jsx)(ark.div, { ...mergedProps, ref }) }) });
});
TabsRoot.displayName = "TabsRoot";

// node_modules/@ark-ui/react/dist/components/tabs/tabs-root-provider.js
var import_jsx_runtime375 = __toESM(require_jsx_runtime(), 1);
var import_react809 = __toESM(require_react(), 1);
var TabsRootProvider = (0, import_react809.forwardRef)((props43, ref) => {
  const [renderStrategyProps, tabsProps] = splitRenderStrategyProps(props43);
  const [{ value: tabs }, localprops] = createSplitProps2()(tabsProps, ["value"]);
  const mergedProps = mergeProps2(tabs.getRootProps(), localprops);
  return (0, import_jsx_runtime375.jsx)(TabsProvider, { value: tabs, children: (0, import_jsx_runtime375.jsx)(RenderStrategyPropsProvider, { value: renderStrategyProps, children: (0, import_jsx_runtime375.jsx)(ark.div, { ...mergedProps, ref }) }) });
});
TabsRootProvider.displayName = "TabsRootProvider";

// node_modules/@ark-ui/react/dist/components/tabs/tabs.js
var tabs_exports = {};
__export(tabs_exports, {
  Content: () => TabContent,
  Context: () => TabsContext,
  Indicator: () => TabIndicator,
  List: () => TabList,
  Root: () => TabsRoot,
  RootProvider: () => TabsRootProvider,
  Trigger: () => TabTrigger
});

// node_modules/@ark-ui/react/dist/components/tags-input/tags-input-clear-trigger.js
var import_jsx_runtime376 = __toESM(require_jsx_runtime(), 1);
var import_react811 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/tags-input/use-tags-input-context.js
var [TagsInputProvider, useTagsInputContext] = createContext3({
  name: "TagsInputContext",
  hookName: "useTagsInputContext",
  providerName: "<TagsInputProvider />"
});

// node_modules/@ark-ui/react/dist/components/tags-input/tags-input-clear-trigger.js
var TagsInputClearTrigger = (0, import_react811.forwardRef)((props43, ref) => {
  const tagsInput = useTagsInputContext();
  const mergedProps = mergeProps2(tagsInput.getClearTriggerProps(), props43);
  return (0, import_jsx_runtime376.jsx)(ark.button, { ...mergedProps, ref });
});
TagsInputClearTrigger.displayName = "TagsInputClearTrigger";

// node_modules/@ark-ui/react/dist/components/tags-input/tags-input-control.js
var import_jsx_runtime377 = __toESM(require_jsx_runtime(), 1);
var import_react813 = __toESM(require_react(), 1);
var TagsInputControl = (0, import_react813.forwardRef)((props43, ref) => {
  const tagsInput = useTagsInputContext();
  const mergedProps = mergeProps2(tagsInput.getControlProps(), props43);
  return (0, import_jsx_runtime377.jsx)(ark.div, { ...mergedProps, ref });
});
TagsInputControl.displayName = "TagsInputControl";

// node_modules/@ark-ui/react/dist/components/tags-input/tags-input-hidden-input.js
var import_jsx_runtime378 = __toESM(require_jsx_runtime(), 1);
var import_react815 = __toESM(require_react(), 1);
var TagsInputHiddenInput = (0, import_react815.forwardRef)((props43, ref) => {
  const tagsInput = useTagsInputContext();
  const mergedProps = mergeProps2(tagsInput.getHiddenInputProps(), props43);
  const field = useFieldContext();
  return (0, import_jsx_runtime378.jsx)(ark.input, { "aria-describedby": field == null ? void 0 : field.ariaDescribedby, ...mergedProps, ref });
});
TagsInputHiddenInput.displayName = "TagsInputHiddenInput";

// node_modules/@ark-ui/react/dist/components/tags-input/tags-input-input.js
var import_jsx_runtime379 = __toESM(require_jsx_runtime(), 1);
var import_react817 = __toESM(require_react(), 1);
var TagsInputInput = (0, import_react817.forwardRef)((props43, ref) => {
  const tagsInput = useTagsInputContext();
  const mergedProps = mergeProps2(tagsInput.getInputProps(), props43);
  return (0, import_jsx_runtime379.jsx)(ark.input, { ...mergedProps, ref });
});
TagsInputInput.displayName = "TagsInputInput";

// node_modules/@ark-ui/react/dist/components/tags-input/tags-input-item.js
var import_jsx_runtime380 = __toESM(require_jsx_runtime(), 1);
var import_react819 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/tags-input/use-tags-input-item-context.js
var [TagsInputItemProvider, useTagsInputItemContext] = createContext3({
  name: "TagsInputItemContext",
  hookName: "useTagsInputItemContext",
  providerName: "<TagsInputItemProvider />"
});

// node_modules/@ark-ui/react/dist/components/tags-input/use-tags-input-item-props-context.js
var [TagsInputItemPropsProvider, useTagsInputItemPropsContext] = createContext3({
  name: "TagsInputItemPropsContext",
  hookName: "useTagsInputItemPropsContext",
  providerName: "<TagsInputItemPropsProvider />"
});

// node_modules/@ark-ui/react/dist/components/tags-input/tags-input-item.js
var TagsInputItem = (0, import_react819.forwardRef)((props43, ref) => {
  const [itemProps14, localProps] = createSplitProps2()(props43, ["index", "disabled", "value"]);
  const tagsInput = useTagsInputContext();
  const mergedProps = mergeProps2(tagsInput.getItemProps(itemProps14), localProps);
  const tagsInputItem = tagsInput.getItemState(itemProps14);
  return (0, import_jsx_runtime380.jsx)(TagsInputItemPropsProvider, { value: itemProps14, children: (0, import_jsx_runtime380.jsx)(TagsInputItemProvider, { value: tagsInputItem, children: (0, import_jsx_runtime380.jsx)(ark.div, { ...mergedProps, ref }) }) });
});
TagsInputItem.displayName = "TagsInputItem";

// node_modules/@ark-ui/react/dist/components/tags-input/tags-input-item-delete-trigger.js
var import_jsx_runtime381 = __toESM(require_jsx_runtime(), 1);
var import_react821 = __toESM(require_react(), 1);
var TagsInputItemDeleteTrigger = (0, import_react821.forwardRef)(
  (props43, ref) => {
    const tagsInput = useTagsInputContext();
    const itemProps14 = useTagsInputItemPropsContext();
    const mergedProps = mergeProps2(tagsInput.getItemDeleteTriggerProps(itemProps14), props43);
    return (0, import_jsx_runtime381.jsx)(ark.button, { ...mergedProps, ref });
  }
);
TagsInputItemDeleteTrigger.displayName = "TagsInputItemDeleteTrigger";

// node_modules/@ark-ui/react/dist/components/tags-input/tags-input-item-input.js
var import_jsx_runtime382 = __toESM(require_jsx_runtime(), 1);
var import_react823 = __toESM(require_react(), 1);
var TagsInputItemInput = (0, import_react823.forwardRef)((props43, ref) => {
  const tagsInput = useTagsInputContext();
  const itemProps14 = useTagsInputItemPropsContext();
  const mergedProps = mergeProps2(tagsInput.getItemInputProps(itemProps14), props43);
  return (0, import_jsx_runtime382.jsx)(ark.input, { ...mergedProps, ref });
});
TagsInputItemInput.displayName = "TagsInputItemInput";

// node_modules/@ark-ui/react/dist/components/tags-input/tags-input-item-preview.js
var import_jsx_runtime383 = __toESM(require_jsx_runtime(), 1);
var import_react825 = __toESM(require_react(), 1);
var TagsInputItemPreview = (0, import_react825.forwardRef)((props43, ref) => {
  const tagsInput = useTagsInputContext();
  const itemProps14 = useTagsInputItemPropsContext();
  const mergedProps = mergeProps2(tagsInput.getItemPreviewProps(itemProps14), props43);
  return (0, import_jsx_runtime383.jsx)(ark.div, { ...mergedProps, ref });
});
TagsInputItemPreview.displayName = "TagsInputItemPreview";

// node_modules/@ark-ui/react/dist/components/tags-input/tags-input-item-text.js
var import_jsx_runtime384 = __toESM(require_jsx_runtime(), 1);
var import_react827 = __toESM(require_react(), 1);
var TagsInputItemText = (0, import_react827.forwardRef)((props43, ref) => {
  const tagsInput = useTagsInputContext();
  const itemProps14 = useTagsInputItemPropsContext();
  const mergedProps = mergeProps2(tagsInput.getItemTextProps(itemProps14), props43);
  return (0, import_jsx_runtime384.jsx)(ark.span, { ...mergedProps, ref });
});
TagsInputItemText.displayName = "TagsInputItemText";

// node_modules/@ark-ui/react/dist/components/tags-input/tags-input-label.js
var import_jsx_runtime385 = __toESM(require_jsx_runtime(), 1);
var import_react829 = __toESM(require_react(), 1);
var TagsInputLabel = (0, import_react829.forwardRef)((props43, ref) => {
  const tagsInput = useTagsInputContext();
  const mergedProps = mergeProps2(tagsInput.getLabelProps(), props43);
  return (0, import_jsx_runtime385.jsx)(ark.label, { ...mergedProps, ref });
});
TagsInputLabel.displayName = "TagsInputLabel";

// node_modules/@ark-ui/react/dist/components/tags-input/tags-input-root.js
var import_jsx_runtime386 = __toESM(require_jsx_runtime(), 1);
var import_react833 = __toESM(require_react(), 1);

// node_modules/@zag-js/tags-input/dist/index.mjs
var anatomy34 = createAnatomy("tagsInput").parts(
  "root",
  "label",
  "control",
  "input",
  "clearTrigger",
  "item",
  "itemPreview",
  "itemInput",
  "itemText",
  "itemDeleteTrigger"
);
var parts37 = anatomy34.build();
var getRootId28 = (ctx) => {
  var _a8;
  return ((_a8 = ctx.ids) == null ? void 0 : _a8.root) ?? `tags-input:${ctx.id}`;
};
var getInputId8 = (ctx) => {
  var _a8;
  return ((_a8 = ctx.ids) == null ? void 0 : _a8.input) ?? `tags-input:${ctx.id}:input`;
};
var getClearTriggerId4 = (ctx) => {
  var _a8;
  return ((_a8 = ctx.ids) == null ? void 0 : _a8.clearBtn) ?? `tags-input:${ctx.id}:clear-btn`;
};
var getHiddenInputId10 = (ctx) => {
  var _a8;
  return ((_a8 = ctx.ids) == null ? void 0 : _a8.hiddenInput) ?? `tags-input:${ctx.id}:hidden-input`;
};
var getLabelId18 = (ctx) => {
  var _a8;
  return ((_a8 = ctx.ids) == null ? void 0 : _a8.label) ?? `tags-input:${ctx.id}:label`;
};
var getControlId13 = (ctx) => {
  var _a8;
  return ((_a8 = ctx.ids) == null ? void 0 : _a8.control) ?? `tags-input:${ctx.id}:control`;
};
var getItemId11 = (ctx, opt) => {
  var _a8, _b7;
  return ((_b7 = (_a8 = ctx.ids) == null ? void 0 : _a8.item) == null ? void 0 : _b7.call(_a8, opt)) ?? `tags-input:${ctx.id}:tag:${opt.value}:${opt.index}`;
};
var getItemDeleteTriggerId = (ctx, opt) => {
  var _a8, _b7;
  return ((_b7 = (_a8 = ctx.ids) == null ? void 0 : _a8.itemDeleteTrigger) == null ? void 0 : _b7.call(_a8, opt)) ?? `${getItemId11(ctx, opt)}:delete-btn`;
};
var getItemInputId = (ctx, opt) => {
  var _a8, _b7;
  return ((_b7 = (_a8 = ctx.ids) == null ? void 0 : _a8.itemInput) == null ? void 0 : _b7.call(_a8, opt)) ?? `${getItemId11(ctx, opt)}:input`;
};
var getEditInputId = (id) => `${id}:input`;
var getEditInputEl = (ctx, id) => ctx.getById(getEditInputId(id));
var getTagInputEl = (ctx, opt) => ctx.getById(getItemInputId(ctx, opt));
var getRootEl10 = (ctx) => ctx.getById(getRootId28(ctx));
var getInputEl6 = (ctx) => ctx.getById(getInputId8(ctx));
var getHiddenInputEl9 = (ctx) => ctx.getById(getHiddenInputId10(ctx));
var getTagElements = (ctx) => queryAll(getRootEl10(ctx), `[data-part=item-preview]:not([data-disabled])`);
var getFirstEl2 = (ctx) => getTagElements(ctx)[0];
var getLastEl2 = (ctx) => getTagElements(ctx)[getTagElements(ctx).length - 1];
var getPrevEl2 = (ctx, id) => prevById(getTagElements(ctx), id, false);
var getNextEl2 = (ctx, id) => nextById(getTagElements(ctx), id, false);
var getTagElAtIndex = (ctx, index) => getTagElements(ctx)[index];
var getIndexOfId = (ctx, id) => indexOfId(getTagElements(ctx), id);
var setHoverIntent = (el) => {
  const tagEl = el.closest("[data-part=item-preview]");
  if (!tagEl) return;
  tagEl.dataset.deleteIntent = "";
};
var clearHoverIntent = (el) => {
  const tagEl = el.closest("[data-part=item-preview]");
  if (!tagEl) return;
  delete tagEl.dataset.deleteIntent;
};
var dispatchInputEvent = (ctx, value) => {
  const inputEl = getHiddenInputEl9(ctx);
  if (!inputEl) return;
  dispatchInputValueEvent(inputEl, { value });
};
function connect35(service, normalize4) {
  const { state: state2, send, computed, prop, scope, context } = service;
  const interactive = computed("isInteractive");
  const disabled = prop("disabled");
  const readOnly = prop("readOnly");
  const invalid = prop("invalid") || computed("isOverflowing");
  const translations = prop("translations");
  const focused = state2.hasTag("focused");
  const editingTag = state2.matches("editing:tag");
  const empty2 = computed("count") === 0;
  function getItemState(options) {
    const id = getItemId11(scope, options);
    const editedTagId = context.get("editedTagId");
    const highlightedTagId = context.get("highlightedTagId");
    return {
      id,
      editing: editingTag && editedTagId === id,
      highlighted: id === highlightedTagId,
      disabled: Boolean(options.disabled || disabled)
    };
  }
  return {
    empty: empty2,
    inputValue: computed("trimmedInputValue"),
    value: context.get("value"),
    valueAsString: computed("valueAsString"),
    count: computed("count"),
    atMax: computed("isAtMax"),
    setValue(value) {
      send({ type: "SET_VALUE", value });
    },
    clearValue(id) {
      if (id) {
        send({ type: "CLEAR_TAG", id });
      } else {
        send({ type: "CLEAR_VALUE" });
      }
    },
    addValue(value) {
      send({ type: "ADD_TAG", value });
    },
    setValueAtIndex(index, value) {
      send({ type: "SET_VALUE_AT_INDEX", index, value });
    },
    setInputValue(value) {
      send({ type: "SET_INPUT_VALUE", value });
    },
    clearInputValue() {
      send({ type: "SET_INPUT_VALUE", value: "" });
    },
    focus() {
      var _a8;
      (_a8 = getInputEl6(scope)) == null ? void 0 : _a8.focus();
    },
    getItemState,
    getRootProps() {
      return normalize4.element({
        dir: prop("dir"),
        ...parts37.root.attrs,
        "data-invalid": dataAttr(invalid),
        "data-readonly": dataAttr(readOnly),
        "data-disabled": dataAttr(disabled),
        "data-focus": dataAttr(focused),
        "data-empty": dataAttr(empty2),
        id: getRootId28(scope),
        onPointerDown() {
          if (!interactive) return;
          send({ type: "POINTER_DOWN" });
        }
      });
    },
    getLabelProps() {
      return normalize4.label({
        ...parts37.label.attrs,
        "data-disabled": dataAttr(disabled),
        "data-invalid": dataAttr(invalid),
        "data-readonly": dataAttr(readOnly),
        id: getLabelId18(scope),
        dir: prop("dir"),
        htmlFor: getInputId8(scope)
      });
    },
    getControlProps() {
      return normalize4.element({
        id: getControlId13(scope),
        ...parts37.control.attrs,
        dir: prop("dir"),
        tabIndex: readOnly ? 0 : void 0,
        "data-disabled": dataAttr(disabled),
        "data-readonly": dataAttr(readOnly),
        "data-invalid": dataAttr(invalid),
        "data-focus": dataAttr(focused)
      });
    },
    getInputProps() {
      return normalize4.input({
        ...parts37.input.attrs,
        dir: prop("dir"),
        "data-invalid": dataAttr(invalid),
        "aria-invalid": ariaAttr(invalid),
        "data-readonly": dataAttr(readOnly),
        maxLength: prop("maxLength"),
        id: getInputId8(scope),
        defaultValue: context.get("inputValue"),
        autoComplete: "off",
        autoCorrect: "off",
        autoCapitalize: "none",
        disabled: disabled || readOnly,
        onInput(event) {
          const evt = getNativeEvent(event);
          const value = event.currentTarget.value;
          if (evt.inputType === "insertFromPaste") {
            send({ type: "PASTE", value });
            return;
          }
          if (endsWith(value, prop("delimiter"))) {
            send({ type: "DELIMITER_KEY" });
            return;
          }
          send({ type: "TYPE", value, key: evt.inputType });
        },
        onFocus() {
          queueMicrotask(() => {
            send({ type: "FOCUS" });
          });
        },
        onKeyDown(event) {
          if (event.defaultPrevented) return;
          if (isComposingEvent(event)) return;
          const target = event.currentTarget;
          const isCombobox = target.getAttribute("role") === "combobox";
          const isExpanded = target.ariaExpanded === "true";
          const keyMap2 = {
            ArrowDown() {
              send({ type: "ARROW_DOWN" });
            },
            ArrowLeft() {
              if (isCombobox && isExpanded) return;
              send({ type: "ARROW_LEFT" });
            },
            ArrowRight(event2) {
              if (context.get("highlightedTagId")) {
                event2.preventDefault();
              }
              if (isCombobox && isExpanded) return;
              send({ type: "ARROW_RIGHT" });
            },
            Escape(event2) {
              event2.preventDefault();
              send({ type: "ESCAPE" });
            },
            Backspace() {
              send({ type: "BACKSPACE" });
            },
            Delete() {
              send({ type: "DELETE" });
            },
            Enter(event2) {
              if (isCombobox && isExpanded) return;
              send({ type: "ENTER" });
              event2.preventDefault();
            }
          };
          const key = getEventKey(event, { dir: prop("dir") });
          const exec = keyMap2[key];
          if (exec) {
            exec(event);
            return;
          }
        }
      });
    },
    getHiddenInputProps() {
      return normalize4.input({
        type: "text",
        hidden: true,
        name: prop("name"),
        form: prop("form"),
        disabled,
        readOnly,
        required: prop("required"),
        id: getHiddenInputId10(scope),
        defaultValue: computed("valueAsString")
      });
    },
    getItemProps(props210) {
      return normalize4.element({
        ...parts37.item.attrs,
        dir: prop("dir"),
        "data-value": props210.value,
        "data-disabled": dataAttr(disabled)
      });
    },
    getItemPreviewProps(props210) {
      const itemState = getItemState(props210);
      return normalize4.element({
        ...parts37.itemPreview.attrs,
        id: itemState.id,
        dir: prop("dir"),
        hidden: itemState.editing,
        "data-value": props210.value,
        "data-disabled": dataAttr(disabled),
        "data-highlighted": dataAttr(itemState.highlighted),
        onPointerDown(event) {
          if (!interactive || itemState.disabled) return;
          event.preventDefault();
          send({ type: "POINTER_DOWN_TAG", id: itemState.id });
        },
        onDoubleClick() {
          if (!interactive || itemState.disabled) return;
          send({ type: "DOUBLE_CLICK_TAG", id: itemState.id });
        }
      });
    },
    getItemTextProps(props210) {
      const itemState = getItemState(props210);
      return normalize4.element({
        ...parts37.itemText.attrs,
        dir: prop("dir"),
        "data-disabled": dataAttr(disabled),
        "data-highlighted": dataAttr(itemState.highlighted)
      });
    },
    getItemInputProps(props210) {
      var _a8;
      const itemState = getItemState(props210);
      return normalize4.input({
        ...parts37.itemInput.attrs,
        dir: prop("dir"),
        "aria-label": (_a8 = translations == null ? void 0 : translations.tagEdited) == null ? void 0 : _a8.call(translations, props210.value),
        disabled,
        id: getItemInputId(scope, props210),
        tabIndex: -1,
        hidden: !itemState.editing,
        defaultValue: itemState.editing ? context.get("editedTagValue") : "",
        onInput(event) {
          send({ type: "TAG_INPUT_TYPE", value: event.currentTarget.value });
        },
        onBlur(event) {
          queueMicrotask(() => {
            send({ type: "TAG_INPUT_BLUR", target: event.relatedTarget, id: itemState.id });
          });
        },
        onKeyDown(event) {
          if (event.defaultPrevented) return;
          if (isComposingEvent(event)) return;
          const keyMap2 = {
            Enter() {
              send({ type: "TAG_INPUT_ENTER" });
            },
            Escape() {
              send({ type: "TAG_INPUT_ESCAPE" });
            }
          };
          const exec = keyMap2[event.key];
          if (exec) {
            event.preventDefault();
            exec(event);
          }
        }
      });
    },
    getItemDeleteTriggerProps(props210) {
      var _a8;
      const id = getItemId11(scope, props210);
      return normalize4.button({
        ...parts37.itemDeleteTrigger.attrs,
        dir: prop("dir"),
        id: getItemDeleteTriggerId(scope, props210),
        type: "button",
        disabled,
        "aria-label": (_a8 = translations == null ? void 0 : translations.deleteTagTriggerLabel) == null ? void 0 : _a8.call(translations, props210.value),
        tabIndex: -1,
        onPointerDown(event) {
          if (!interactive) {
            event.preventDefault();
          }
        },
        onPointerMove(event) {
          if (!interactive) return;
          setHoverIntent(event.currentTarget);
        },
        onPointerLeave(event) {
          if (!interactive) return;
          clearHoverIntent(event.currentTarget);
        },
        onClick() {
          if (!interactive) return;
          send({ type: "CLICK_DELETE_TAG", id });
        }
      });
    },
    getClearTriggerProps() {
      return normalize4.button({
        ...parts37.clearTrigger.attrs,
        dir: prop("dir"),
        id: getClearTriggerId4(scope),
        type: "button",
        "data-readonly": dataAttr(readOnly),
        disabled,
        "aria-label": translations == null ? void 0 : translations.clearTriggerLabel,
        hidden: empty2,
        onClick() {
          if (!interactive) return;
          send({ type: "CLEAR_VALUE" });
        }
      });
    }
  };
}
function endsWith(str, del) {
  if (!del) return false;
  if (typeof del === "string") return str.endsWith(del);
  return new RegExp(`${del.source}$`).test(str);
}
var { and: and10, not: not11, or: or3 } = createGuards();
var machine35 = createMachine({
  props({ props: props210 }) {
    return {
      dir: "ltr",
      addOnPaste: false,
      editable: true,
      validate: () => true,
      delimiter: ",",
      defaultValue: [],
      defaultInputValue: "",
      max: Infinity,
      ...props210,
      translations: {
        clearTriggerLabel: "Clear all tags",
        deleteTagTriggerLabel: (value) => `Delete tag ${value}`,
        tagAdded: (value) => `Added tag ${value}`,
        tagsPasted: (values) => `Pasted ${values.length} tags`,
        tagEdited: (value) => `Editing tag ${value}. Press enter to save or escape to cancel.`,
        tagUpdated: (value) => `Tag update to ${value}`,
        tagDeleted: (value) => `Tag ${value} deleted`,
        tagSelected: (value) => `Tag ${value} selected. Press enter to edit, delete or backspace to remove.`,
        ...props210.translations
      }
    };
  },
  initialState({ prop }) {
    return prop("autoFocus") ? "focused:input" : "idle";
  },
  refs() {
    return {
      liveRegion: null,
      log: { current: null, prev: null }
    };
  },
  context({ bindable, prop }) {
    return {
      value: bindable(() => ({
        defaultValue: prop("defaultValue"),
        value: prop("value"),
        isEqual,
        hash(value) {
          return value.join(", ");
        },
        onChange(value) {
          var _a8;
          (_a8 = prop("onValueChange")) == null ? void 0 : _a8({ value });
        }
      })),
      inputValue: bindable(() => ({
        sync: true,
        defaultValue: prop("defaultInputValue"),
        value: prop("inputValue"),
        onChange(value) {
          var _a8;
          (_a8 = prop("onInputValueChange")) == null ? void 0 : _a8({ inputValue: value });
        }
      })),
      fieldsetDisabled: bindable(() => ({ defaultValue: false })),
      editedTagValue: bindable(() => ({ defaultValue: "" })),
      editedTagId: bindable(() => ({ defaultValue: null })),
      editedTagIndex: bindable(() => ({
        defaultValue: null,
        sync: true
      })),
      highlightedTagId: bindable(() => ({
        defaultValue: null,
        sync: true,
        onChange(value) {
          var _a8;
          (_a8 = prop("onHighlightChange")) == null ? void 0 : _a8({ highlightedValue: value });
        }
      }))
    };
  },
  computed: {
    count: ({ context }) => context.get("value").length,
    valueAsString: ({ context }) => context.hash("value"),
    trimmedInputValue: ({ context }) => context.get("inputValue").trim(),
    isDisabled: ({ prop }) => !!prop("disabled"),
    isInteractive: ({ prop }) => !(prop("readOnly") || !!prop("disabled")),
    isAtMax: ({ context, prop }) => context.get("value").length === prop("max"),
    isOverflowing: ({ context, prop }) => context.get("value").length > prop("max")
  },
  watch({ track, context, action, computed, refs }) {
    track([() => context.get("editedTagValue")], () => {
      action(["syncEditedTagInputValue"]);
    });
    track([() => context.get("inputValue")], () => {
      action(["syncInputValue"]);
    });
    track([() => context.get("highlightedTagId")], () => {
      action(["logHighlightedTag"]);
    });
    track([() => computed("isOverflowing")], () => {
      action(["invokeOnInvalid"]);
    });
    track([() => JSON.stringify(refs.get("log"))], () => {
      action(["announceLog"]);
    });
  },
  effects: ["trackLiveRegion", "trackFormControlState"],
  exit: ["clearLog"],
  on: {
    DOUBLE_CLICK_TAG: {
      // internal: true,
      guard: "isTagEditable",
      target: "editing:tag",
      actions: ["setEditedId"]
    },
    POINTER_DOWN_TAG: {
      // internal: true,
      target: "navigating:tag",
      actions: ["highlightTag", "focusInput"]
    },
    CLICK_DELETE_TAG: {
      target: "focused:input",
      actions: ["deleteTag"]
    },
    SET_INPUT_VALUE: {
      actions: ["setInputValue"]
    },
    SET_VALUE: {
      actions: ["setValue"]
    },
    CLEAR_TAG: {
      actions: ["deleteTag"]
    },
    SET_VALUE_AT_INDEX: {
      actions: ["setValueAtIndex"]
    },
    CLEAR_VALUE: {
      actions: ["clearTags", "clearInputValue", "focusInput"]
    },
    ADD_TAG: {
      actions: ["addTag"]
    },
    INSERT_TAG: {
      // (!isAtMax || allowOverflow) && !inputValueIsEmpty
      guard: and10(or3(not11("isAtMax"), "allowOverflow"), not11("isInputValueEmpty")),
      actions: ["addTag", "clearInputValue"]
    },
    EXTERNAL_BLUR: [
      { guard: "addOnBlur", actions: ["raiseInsertTagEvent"] },
      { guard: "clearOnBlur", actions: ["clearInputValue"] }
    ]
  },
  states: {
    idle: {
      on: {
        FOCUS: {
          target: "focused:input"
        },
        POINTER_DOWN: {
          guard: not11("hasHighlightedTag"),
          target: "focused:input"
        }
      }
    },
    "focused:input": {
      tags: ["focused"],
      entry: ["focusInput", "clearHighlightedId"],
      effects: ["trackInteractOutside"],
      on: {
        TYPE: {
          actions: ["setInputValue"]
        },
        BLUR: [
          {
            guard: "addOnBlur",
            target: "idle",
            actions: ["raiseInsertTagEvent"]
          },
          {
            guard: "clearOnBlur",
            target: "idle",
            actions: ["clearInputValue"]
          },
          { target: "idle" }
        ],
        ENTER: {
          actions: ["raiseInsertTagEvent"]
        },
        DELIMITER_KEY: {
          actions: ["raiseInsertTagEvent"]
        },
        ARROW_LEFT: {
          guard: and10("hasTags", "isCaretAtStart"),
          target: "navigating:tag",
          actions: ["highlightLastTag"]
        },
        BACKSPACE: {
          target: "navigating:tag",
          guard: and10("hasTags", "isCaretAtStart"),
          actions: ["highlightLastTag"]
        },
        DELETE: {
          guard: "hasHighlightedTag",
          actions: ["deleteHighlightedTag", "highlightTagAtIndex"]
        },
        PASTE: [
          {
            guard: "addOnPaste",
            actions: ["setInputValue", "addTagFromPaste"]
          },
          {
            actions: ["setInputValue"]
          }
        ]
      }
    },
    "navigating:tag": {
      tags: ["focused"],
      effects: ["trackInteractOutside"],
      on: {
        ARROW_RIGHT: [
          {
            guard: and10("hasTags", "isCaretAtStart", not11("isLastTagHighlighted")),
            actions: ["highlightNextTag"]
          },
          { target: "focused:input" }
        ],
        ARROW_LEFT: [
          {
            guard: not11("isCaretAtStart"),
            target: "focused:input"
          },
          {
            actions: ["highlightPrevTag"]
          }
        ],
        BLUR: {
          target: "idle",
          actions: ["clearHighlightedId"]
        },
        ENTER: {
          guard: and10("isTagEditable", "hasHighlightedTag"),
          target: "editing:tag",
          actions: ["setEditedId", "focusEditedTagInput"]
        },
        ARROW_DOWN: {
          target: "focused:input"
        },
        ESCAPE: {
          target: "focused:input"
        },
        TYPE: {
          target: "focused:input",
          actions: ["setInputValue"]
        },
        BACKSPACE: [
          {
            guard: not11("isCaretAtStart"),
            target: "focused:input"
          },
          {
            guard: "isFirstTagHighlighted",
            actions: ["deleteHighlightedTag", "highlightFirstTag"]
          },
          {
            guard: "hasHighlightedTag",
            actions: ["deleteHighlightedTag", "highlightPrevTag"]
          },
          {
            actions: ["highlightLastTag"]
          }
        ],
        DELETE: [
          {
            guard: not11("isCaretAtStart"),
            target: "focused:input"
          },
          {
            target: "focused:input",
            actions: ["deleteHighlightedTag", "highlightTagAtIndex"]
          }
        ],
        PASTE: [
          {
            guard: "addOnPaste",
            target: "focused:input",
            actions: ["setInputValue", "addTagFromPaste"]
          },
          {
            target: "focused:input",
            actions: ["setInputValue"]
          }
        ]
      }
    },
    "editing:tag": {
      tags: ["editing", "focused"],
      entry: ["focusEditedTagInput"],
      effects: ["autoResize"],
      on: {
        TAG_INPUT_TYPE: {
          actions: ["setEditedTagValue"]
        },
        TAG_INPUT_ESCAPE: {
          target: "navigating:tag",
          actions: ["clearEditedTagValue", "focusInput", "clearEditedId", "highlightTagAtIndex"]
        },
        TAG_INPUT_BLUR: [
          {
            guard: "isInputRelatedTarget",
            target: "navigating:tag",
            actions: ["clearEditedTagValue", "clearHighlightedId", "clearEditedId"]
          },
          {
            target: "idle",
            actions: ["clearEditedTagValue", "clearHighlightedId", "clearEditedId", "raiseExternalBlurEvent"]
          }
        ],
        TAG_INPUT_ENTER: [
          {
            guard: "isEditedTagEmpty",
            target: "navigating:tag",
            actions: ["deleteHighlightedTag", "focusInput", "clearEditedId", "highlightTagAtIndex"]
          },
          {
            target: "navigating:tag",
            actions: ["submitEditedTagValue", "focusInput", "clearEditedId", "highlightTagAtIndex"]
          }
        ]
      }
    }
  },
  implementations: {
    guards: {
      isInputRelatedTarget: ({ scope, event }) => event.relatedTarget === getInputEl6(scope),
      isAtMax: ({ computed }) => computed("isAtMax"),
      hasHighlightedTag: ({ context }) => context.get("highlightedTagId") != null,
      isFirstTagHighlighted: ({ context, scope }) => {
        const value = context.get("value");
        const firstItemId = getItemId11(scope, { value: value[0], index: 0 });
        return firstItemId === context.get("highlightedTagId");
      },
      isEditedTagEmpty: ({ context }) => context.get("editedTagValue").trim() === "",
      isLastTagHighlighted: ({ context, scope }) => {
        const value = context.get("value");
        const lastIndex = value.length - 1;
        const lastItemId = getItemId11(scope, { value: value[lastIndex], index: lastIndex });
        return lastItemId === context.get("highlightedTagId");
      },
      isInputValueEmpty: ({ context }) => context.get("inputValue").trim().length === 0,
      hasTags: ({ context }) => context.get("value").length > 0,
      allowOverflow: ({ prop }) => !!prop("allowOverflow"),
      autoFocus: ({ prop }) => !!prop("autoFocus"),
      addOnBlur: ({ prop }) => prop("blurBehavior") === "add",
      clearOnBlur: ({ prop }) => prop("blurBehavior") === "clear",
      addOnPaste: ({ prop }) => !!prop("addOnPaste"),
      isTagEditable: ({ prop }) => !!prop("editable"),
      isCaretAtStart: ({ scope }) => isCaretAtStart(getInputEl6(scope))
    },
    effects: {
      trackInteractOutside({ scope, prop, send }) {
        return trackInteractOutside(getInputEl6(scope), {
          exclude(target) {
            return contains(getRootEl10(scope), target);
          },
          onFocusOutside: prop("onFocusOutside"),
          onPointerDownOutside: prop("onPointerDownOutside"),
          onInteractOutside(event) {
            var _a8;
            (_a8 = prop("onInteractOutside")) == null ? void 0 : _a8(event);
            if (event.defaultPrevented) return;
            send({ type: "BLUR", src: "interact-outside" });
          }
        });
      },
      trackFormControlState({ context, send, scope }) {
        return trackFormControl(getHiddenInputEl9(scope), {
          onFieldsetDisabledChange(disabled) {
            context.set("fieldsetDisabled", disabled);
          },
          onFormReset() {
            const value = context.initial("value");
            send({ type: "SET_VALUE", value, src: "form-reset" });
          }
        });
      },
      autoResize({ context, prop, scope }) {
        let fn_cleanup;
        const raf_cleanup = raf(() => {
          const editedTagValue = context.get("editedTagValue");
          const editedTagIndex = context.get("editedTagIndex");
          if (!editedTagValue || editedTagIndex == null || !prop("editable")) return;
          const inputEl = getTagInputEl(scope, {
            value: editedTagValue,
            index: editedTagIndex
          });
          fn_cleanup = autoResizeInput(inputEl);
        });
        return () => {
          raf_cleanup();
          fn_cleanup == null ? void 0 : fn_cleanup();
        };
      },
      trackLiveRegion({ scope, refs }) {
        const liveRegion = createLiveRegion({
          level: "assertive",
          document: scope.getDoc()
        });
        refs.set("liveRegion", liveRegion);
        return () => liveRegion.destroy();
      }
    },
    actions: {
      raiseInsertTagEvent({ send }) {
        send({ type: "INSERT_TAG" });
      },
      raiseExternalBlurEvent({ send, event }) {
        send({ type: "EXTERNAL_BLUR", id: event.id });
      },
      dispatchChangeEvent({ scope, computed }) {
        dispatchInputEvent(scope, computed("valueAsString"));
      },
      highlightNextTag({ context, scope }) {
        const highlightedTagId = context.get("highlightedTagId");
        if (highlightedTagId == null) return;
        const next2 = getNextEl2(scope, highlightedTagId);
        context.set("highlightedTagId", (next2 == null ? void 0 : next2.id) ?? null);
      },
      highlightFirstTag({ context, scope }) {
        raf(() => {
          const first2 = getFirstEl2(scope);
          context.set("highlightedTagId", (first2 == null ? void 0 : first2.id) ?? null);
        });
      },
      highlightLastTag({ context, scope }) {
        const last2 = getLastEl2(scope);
        context.set("highlightedTagId", (last2 == null ? void 0 : last2.id) ?? null);
      },
      highlightPrevTag({ context, scope }) {
        const highlightedTagId = context.get("highlightedTagId");
        if (highlightedTagId == null) return;
        const prev2 = getPrevEl2(scope, highlightedTagId);
        context.set("highlightedTagId", (prev2 == null ? void 0 : prev2.id) ?? null);
      },
      highlightTag({ context, event }) {
        context.set("highlightedTagId", event.id);
      },
      highlightTagAtIndex({ context, scope }) {
        raf(() => {
          const idx = context.get("editedTagIndex");
          if (idx == null) return;
          const tagEl = getTagElAtIndex(scope, idx);
          if (tagEl == null) return;
          context.set("highlightedTagId", tagEl.id);
          context.set("editedTagIndex", null);
        });
      },
      deleteTag({ context, scope, event, refs }) {
        const index = getIndexOfId(scope, event.id);
        const value = context.get("value")[index];
        const prevLog = refs.get("log");
        refs.set("log", {
          prev: prevLog.current,
          current: { type: "delete", value }
        });
        context.set("value", (prev2) => removeAt(prev2, index));
      },
      deleteHighlightedTag({ context, scope, refs }) {
        const highlightedTagId = context.get("highlightedTagId");
        if (highlightedTagId == null) return;
        const index = getIndexOfId(scope, highlightedTagId);
        context.set("editedTagIndex", index);
        const value = context.get("value");
        const prevLog = refs.get("log");
        refs.set("log", {
          prev: prevLog.current,
          current: { type: "delete", value: value[index] }
        });
        context.set("value", (prev2) => removeAt(prev2, index));
      },
      setEditedId({ context, event, scope }) {
        const highlightedTagId = context.get("highlightedTagId");
        const editedTagId = event.id ?? highlightedTagId;
        context.set("editedTagId", editedTagId);
        const index = getIndexOfId(scope, editedTagId);
        const valueAtIndex = context.get("value")[index];
        context.set("editedTagIndex", index);
        context.set("editedTagValue", valueAtIndex);
      },
      clearEditedId({ context }) {
        context.set("editedTagId", null);
      },
      clearEditedTagValue({ context }) {
        context.set("editedTagValue", "");
      },
      setEditedTagValue({ context, event }) {
        context.set("editedTagValue", event.value);
      },
      submitEditedTagValue({ context, scope, refs }) {
        const editedTagId = context.get("editedTagId");
        if (!editedTagId) return;
        const index = getIndexOfId(scope, editedTagId);
        context.set("value", (prev2) => {
          const value = prev2.slice();
          value[index] = context.get("editedTagValue");
          return value;
        });
        const prevLog = refs.get("log");
        refs.set("log", {
          prev: prevLog.current,
          current: { type: "update", value: context.get("editedTagValue") }
        });
      },
      setValueAtIndex({ context, event, refs }) {
        if (event.value) {
          context.set("value", (prev2) => {
            const value = prev2.slice();
            value[event.index] = event.value;
            return value;
          });
          const prevLog = refs.get("log");
          refs.set("log", {
            prev: prevLog.current,
            current: { type: "update", value: event.value }
          });
        } else {
          warn("You need to provide a value for the tag");
        }
      },
      focusEditedTagInput({ context, scope }) {
        raf(() => {
          const editedTagId = context.get("editedTagId");
          if (!editedTagId) return;
          const editTagInputEl = getEditInputEl(scope, editedTagId);
          editTagInputEl == null ? void 0 : editTagInputEl.select();
        });
      },
      setInputValue({ context, event }) {
        context.set("inputValue", event.value);
      },
      clearHighlightedId({ context }) {
        context.set("highlightedTagId", null);
      },
      focusInput({ scope }) {
        raf(() => {
          var _a8;
          (_a8 = getInputEl6(scope)) == null ? void 0 : _a8.focus();
        });
      },
      clearInputValue({ context }) {
        raf(() => {
          context.set("inputValue", "");
        });
      },
      syncInputValue({ context, scope }) {
        const inputEl = getInputEl6(scope);
        if (!inputEl) return;
        setElementValue(inputEl, context.get("inputValue"));
      },
      syncEditedTagInputValue({ context, event, scope }) {
        const id = context.get("editedTagId") || context.get("highlightedTagId") || event.id;
        if (id == null) return;
        const editTagInputEl = getEditInputEl(scope, id);
        if (!editTagInputEl) return;
        setElementValue(editTagInputEl, context.get("editedTagValue"));
      },
      addTag({ context, event, computed, prop, refs }) {
        var _a8, _b7;
        const inputValue = event.value ?? computed("trimmedInputValue");
        const value = context.get("value");
        const guard = (_a8 = prop("validate")) == null ? void 0 : _a8({ inputValue, value: Array.from(value) });
        if (guard) {
          const nextValue = uniq2(value.concat(inputValue));
          context.set("value", nextValue);
          const prevLog = refs.get("log");
          refs.set("log", {
            prev: prevLog.current,
            current: { type: "add", value: inputValue }
          });
        } else {
          (_b7 = prop("onValueInvalid")) == null ? void 0 : _b7({ reason: "invalidTag" });
        }
      },
      addTagFromPaste({ context, computed, prop, refs }) {
        raf(() => {
          var _a8, _b7;
          const inputValue = computed("trimmedInputValue");
          const value = context.get("value");
          const guard = (_a8 = prop("validate")) == null ? void 0 : _a8({
            inputValue,
            value: Array.from(value)
          });
          if (guard) {
            const delimiter = prop("delimiter");
            const trimmedValue = delimiter ? inputValue.split(delimiter).map((v) => v.trim()) : [inputValue];
            const nextValue = uniq2(value.concat(...trimmedValue));
            context.set("value", nextValue);
            const prevLog = refs.get("log");
            refs.set("log", {
              prev: prevLog.current,
              current: { type: "paste", values: trimmedValue }
            });
          } else {
            (_b7 = prop("onValueInvalid")) == null ? void 0 : _b7({ reason: "invalidTag" });
          }
          context.set("inputValue", "");
        });
      },
      clearTags({ context, refs }) {
        context.set("value", []);
        const prevLog = refs.get("log");
        refs.set("log", {
          prev: prevLog.current,
          current: { type: "clear" }
        });
      },
      setValue({ context, event }) {
        context.set("value", event.value);
      },
      invokeOnInvalid({ prop, computed }) {
        var _a8;
        if (computed("isOverflowing")) {
          (_a8 = prop("onValueInvalid")) == null ? void 0 : _a8({ reason: "rangeOverflow" });
        }
      },
      clearLog({ refs }) {
        const log = refs.get("log");
        log.prev = log.current = null;
      },
      logHighlightedTag({ refs, context, scope }) {
        const highlightedTagId = context.get("highlightedTagId");
        const log = refs.get("log");
        if (highlightedTagId == null || !log.current) return;
        const index = getIndexOfId(scope, highlightedTagId);
        const value = context.get("value")[index];
        const prevLog = refs.get("log");
        refs.set("log", {
          prev: prevLog.current,
          current: { type: "select", value }
        });
      },
      // queue logs with screen reader and get it announced
      announceLog({ refs, prop }) {
        const liveRegion = refs.get("liveRegion");
        const translations = prop("translations");
        const log = refs.get("log");
        if (!log.current || liveRegion == null) return;
        const region = liveRegion;
        const { current, prev: prev2 } = log;
        let msg;
        switch (current.type) {
          case "add":
            msg = translations.tagAdded(current.value);
            break;
          case "delete":
            msg = translations.tagDeleted(current.value);
            break;
          case "update":
            msg = translations.tagUpdated(current.value);
            break;
          case "paste":
            msg = translations.tagsPasted(current.values);
            break;
          case "select":
            msg = translations.tagSelected(current.value);
            if ((prev2 == null ? void 0 : prev2.type) === "delete") {
              msg = `${translations.tagDeleted(prev2.value)}. ${msg}`;
            } else if ((prev2 == null ? void 0 : prev2.type) === "update") {
              msg = `${translations.tagUpdated(prev2.value)}. ${msg}`;
            }
            break;
        }
        if (msg) region.announce(msg);
      }
    }
  }
});
var props35 = createProps()([
  "addOnPaste",
  "allowOverflow",
  "autoFocus",
  "blurBehavior",
  "delimiter",
  "dir",
  "disabled",
  "editable",
  "form",
  "getRootNode",
  "id",
  "ids",
  "inputValue",
  "invalid",
  "max",
  "maxLength",
  "name",
  "onFocusOutside",
  "onHighlightChange",
  "onInputValueChange",
  "onInteractOutside",
  "onPointerDownOutside",
  "onValueChange",
  "onValueInvalid",
  "required",
  "readOnly",
  "translations",
  "validate",
  "value",
  "defaultValue",
  "defaultInputValue"
]);
var splitProps35 = createSplitProps(props35);
var itemProps11 = createProps()(["index", "disabled", "value"]);
var splitItemProps11 = createSplitProps(itemProps11);

// node_modules/@ark-ui/react/dist/components/tags-input/use-tags-input.js
var import_react831 = __toESM(require_react(), 1);
var useTagsInput = (props43) => {
  const id = (0, import_react831.useId)();
  const { getRootNode } = useEnvironmentContext();
  const { dir } = useLocaleContext();
  const field = useFieldContext();
  const machineProps = {
    id,
    ids: {
      label: field == null ? void 0 : field.ids.label,
      hiddenInput: field == null ? void 0 : field.ids.control
    },
    dir,
    disabled: field == null ? void 0 : field.disabled,
    invalid: field == null ? void 0 : field.invalid,
    readOnly: field == null ? void 0 : field.readOnly,
    required: field == null ? void 0 : field.required,
    getRootNode,
    ...props43
  };
  const service = useMachine(machine35, machineProps);
  return connect35(service, normalizeProps);
};

// node_modules/@ark-ui/react/dist/components/tags-input/tags-input-root.js
var TagsInputRoot = (0, import_react833.forwardRef)((props43, ref) => {
  const [useTagsInputProps, localProps] = createSplitProps2()(props43, [
    "addOnPaste",
    "allowOverflow",
    "autoFocus",
    "blurBehavior",
    "defaultInputValue",
    "defaultValue",
    "delimiter",
    "disabled",
    "editable",
    "form",
    "id",
    "ids",
    "inputValue",
    "invalid",
    "max",
    "maxLength",
    "name",
    "onFocusOutside",
    "onHighlightChange",
    "onInputValueChange",
    "onInteractOutside",
    "onPointerDownOutside",
    "onValueChange",
    "onValueInvalid",
    "readOnly",
    "required",
    "translations",
    "validate",
    "value"
  ]);
  const tagsInput = useTagsInput(useTagsInputProps);
  const mergedProps = mergeProps2(tagsInput.getRootProps(), localProps);
  return (0, import_jsx_runtime386.jsx)(TagsInputProvider, { value: tagsInput, children: (0, import_jsx_runtime386.jsx)(ark.div, { ...mergedProps, ref }) });
});
TagsInputRoot.displayName = "TagsInputRoot";

// node_modules/@ark-ui/react/dist/components/tags-input/tags-input-root-provider.js
var import_jsx_runtime387 = __toESM(require_jsx_runtime(), 1);
var import_react835 = __toESM(require_react(), 1);
var TagsInputRootProvider = (0, import_react835.forwardRef)((props43, ref) => {
  const [{ value: tagsInput }, localProps] = createSplitProps2()(props43, ["value"]);
  const mergedProps = mergeProps2(tagsInput.getRootProps(), localProps);
  return (0, import_jsx_runtime387.jsx)(TagsInputProvider, { value: tagsInput, children: (0, import_jsx_runtime387.jsx)(ark.div, { ...mergedProps, ref }) });
});
TagsInputRootProvider.displayName = "TagsInputRootProvider";

// node_modules/@ark-ui/react/dist/components/time-picker/time-picker-cell.js
var import_jsx_runtime388 = __toESM(require_jsx_runtime(), 1);
var import_react837 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/time-picker/use-time-picker-column-props-context.js
var [TimePickerColumnPropsProvider, useTimePickerColumnPropsContext] = createContext3({
  name: "TimePickerColumnPropsContext",
  hookName: "useTimePickerColumnPropsContext",
  providerName: "<TimePickerColumnPropsProvider />"
});

// node_modules/@ark-ui/react/dist/components/time-picker/use-time-picker-context.js
var [TimePickerProvider, useTimePickerContext] = createContext3({
  name: "TimePickerContext",
  hookName: "useTimePickerContext",
  providerName: "<TimePickerProvider />"
});

// node_modules/@ark-ui/react/dist/components/time-picker/time-picker-cell.js
var TimePickerCell = (0, import_react837.forwardRef)((props43, ref) => {
  const [cellProps, localProps] = createSplitProps2()(props43, ["value"]);
  const timePicker = useTimePickerContext();
  const columnProps = useTimePickerColumnPropsContext();
  const unitToPropsMap = {
    hour: () => timePicker.getHourCellProps(cellProps),
    minute: () => timePicker.getMinuteCellProps(cellProps),
    second: () => timePicker.getSecondCellProps(cellProps),
    period: () => timePicker.getPeriodCellProps(cellProps)
  };
  const mergedProps = mergeProps2(unitToPropsMap[columnProps.unit](), localProps);
  return (0, import_jsx_runtime388.jsx)(ark.button, { ...mergedProps, ref });
});
TimePickerCell.displayName = "TimePickerCell";

// node_modules/@ark-ui/react/dist/components/time-picker/time-picker-clear-trigger.js
var import_jsx_runtime389 = __toESM(require_jsx_runtime(), 1);
var import_react839 = __toESM(require_react(), 1);
var TimePickerClearTrigger = (0, import_react839.forwardRef)((props43, ref) => {
  const timePicker = useTimePickerContext();
  const mergedProps = mergeProps2(timePicker.getClearTriggerProps(), props43);
  return (0, import_jsx_runtime389.jsx)(ark.button, { ...mergedProps, ref });
});
TimePickerClearTrigger.displayName = "TimePickerClearTrigger";

// node_modules/@ark-ui/react/dist/components/time-picker/time-picker-column.js
var import_jsx_runtime390 = __toESM(require_jsx_runtime(), 1);
var import_react841 = __toESM(require_react(), 1);
var TimePickerColumn = (0, import_react841.forwardRef)((props43, ref) => {
  const [columnProps, localProps] = createSplitProps2()(props43, ["unit"]);
  const timePicker = useTimePickerContext();
  const mergedProps = mergeProps2(timePicker.getColumnProps(columnProps), localProps);
  return (0, import_jsx_runtime390.jsx)(TimePickerColumnPropsProvider, { value: columnProps, children: (0, import_jsx_runtime390.jsx)(ark.div, { ...mergedProps, ref }) });
});
TimePickerColumn.displayName = "TimePickerColumn";

// node_modules/@ark-ui/react/dist/components/time-picker/time-picker-content.js
var import_jsx_runtime391 = __toESM(require_jsx_runtime(), 1);
var import_react843 = __toESM(require_react(), 1);
var TimePickerContent = (0, import_react843.forwardRef)((props43, ref) => {
  const timePicker = useTimePickerContext();
  const presence = usePresenceContext();
  const mergedProps = mergeProps2(timePicker.getContentProps(), presence.getPresenceProps(), props43);
  if (presence.unmounted) {
    return null;
  }
  return (0, import_jsx_runtime391.jsx)(ark.div, { ...mergedProps, ref: composeRefs(presence.ref, ref) });
});
TimePickerContent.displayName = "TimePickerContent";

// node_modules/@ark-ui/react/dist/components/time-picker/time-picker-control.js
var import_jsx_runtime392 = __toESM(require_jsx_runtime(), 1);
var import_react845 = __toESM(require_react(), 1);
var TimePickerControl = (0, import_react845.forwardRef)((props43, ref) => {
  const timePicker = useTimePickerContext();
  const mergedProps = mergeProps2(timePicker.getControlProps(), props43);
  return (0, import_jsx_runtime392.jsx)(ark.div, { ...mergedProps, ref });
});
TimePickerControl.displayName = "TimePickerControl";

// node_modules/@ark-ui/react/dist/components/time-picker/time-picker-input.js
var import_jsx_runtime393 = __toESM(require_jsx_runtime(), 1);
var import_react847 = __toESM(require_react(), 1);
var TimePickerInput = (0, import_react847.forwardRef)((props43, ref) => {
  const timePicker = useTimePickerContext();
  const mergedProps = mergeProps2(timePicker.getInputProps(), props43);
  return (0, import_jsx_runtime393.jsx)(ark.input, { ...mergedProps, ref });
});
TimePickerInput.displayName = "TimePickerInput";

// node_modules/@ark-ui/react/dist/components/time-picker/time-picker-label.js
var import_jsx_runtime394 = __toESM(require_jsx_runtime(), 1);
var import_react849 = __toESM(require_react(), 1);
var TimePickerLabel = (0, import_react849.forwardRef)((props43, ref) => {
  const timePicker = useTimePickerContext();
  const mergedProps = mergeProps2(timePicker.getLabelProps(), props43);
  return (0, import_jsx_runtime394.jsx)(ark.label, { ...mergedProps, ref });
});
TimePickerLabel.displayName = "TimePickerLabel";

// node_modules/@ark-ui/react/dist/components/time-picker/time-picker-positioner.js
var import_jsx_runtime395 = __toESM(require_jsx_runtime(), 1);
var import_react851 = __toESM(require_react(), 1);
var TimePickerPositioner = (0, import_react851.forwardRef)((props43, ref) => {
  const timePicker = useTimePickerContext();
  const mergedProps = mergeProps2(timePicker.getPositionerProps(), props43);
  const presence = usePresenceContext();
  if (presence.unmounted) {
    return null;
  }
  return (0, import_jsx_runtime395.jsx)(ark.div, { ...mergedProps, ref });
});
TimePickerPositioner.displayName = "TimePickerPositioner";

// node_modules/@ark-ui/react/dist/components/time-picker/time-picker-root.js
var import_jsx_runtime396 = __toESM(require_jsx_runtime(), 1);
var import_react855 = __toESM(require_react(), 1);

// node_modules/@zag-js/time-picker/dist/index.mjs
var anatomy35 = createAnatomy("time-picker").parts(
  "cell",
  "clearTrigger",
  "column",
  "content",
  "control",
  "input",
  "label",
  "positioner",
  "root",
  "spacer",
  "trigger"
);
var parts38 = anatomy35.build();
var getContentId14 = (ctx) => {
  var _a8;
  return ((_a8 = ctx.ids) == null ? void 0 : _a8.content) ?? `time-picker:${ctx.id}:content`;
};
var getColumnId = (ctx, unit) => {
  var _a8, _b7;
  return ((_b7 = (_a8 = ctx.ids) == null ? void 0 : _a8.column) == null ? void 0 : _b7.call(_a8, unit)) ?? `time-picker:${ctx.id}:column:${unit}`;
};
var getControlId14 = (ctx) => {
  var _a8;
  return ((_a8 = ctx.ids) == null ? void 0 : _a8.control) ?? `time-picker:${ctx.id}:control`;
};
var getClearTriggerId5 = (ctx) => {
  var _a8;
  return ((_a8 = ctx.ids) == null ? void 0 : _a8.clearTrigger) ?? `time-picker:${ctx.id}:clear-trigger`;
};
var getPositionerId10 = (ctx) => {
  var _a8;
  return ((_a8 = ctx.ids) == null ? void 0 : _a8.positioner) ?? `time-picker:${ctx.id}:positioner`;
};
var getInputId9 = (ctx) => {
  var _a8;
  return ((_a8 = ctx.ids) == null ? void 0 : _a8.input) ?? `time-picker:${ctx.id}:input`;
};
var getTriggerId14 = (ctx) => {
  var _a8;
  return ((_a8 = ctx.ids) == null ? void 0 : _a8.trigger) ?? `time-picker:${ctx.id}:trigger`;
};
var getContentEl13 = (ctx) => ctx.getById(getContentId14(ctx));
var getColumnEl = (ctx, unit) => query(getContentEl13(ctx), `[data-part=column][data-unit=${unit}]`);
var getColumnEls = (ctx) => queryAll(getContentEl13(ctx), `[data-part=column]:not([hidden])`);
var getColumnCellEls = (ctx, unit) => queryAll(getColumnEl(ctx, unit), `[data-part=cell]`);
var getControlEl8 = (ctx) => ctx.getById(getControlId14(ctx));
var getClearTriggerEl4 = (ctx) => ctx.getById(getClearTriggerId5(ctx));
var getPositionerEl10 = (ctx) => ctx.getById(getPositionerId10(ctx));
var getInputEl7 = (ctx) => ctx.getById(getInputId9(ctx));
var getTriggerEl11 = (ctx) => ctx.getById(getTriggerId14(ctx));
var getFocusedCell2 = (ctx) => query(getContentEl13(ctx), `[data-part=cell][data-focus]`);
var getInitialFocusCell = (ctx, unit) => {
  const contentEl = getContentEl13(ctx);
  let cellEl = query(contentEl, `[data-part=cell][data-unit=${unit}][aria-current]`);
  cellEl || (cellEl = query(contentEl, `[data-part=cell][data-unit=${unit}][data-now]`));
  cellEl || (cellEl = query(contentEl, `[data-part=cell][data-unit=${unit}]`));
  return cellEl;
};
var getColumnUnit = (el) => el.dataset.unit;
var getCellValue = (el) => {
  const value = el == null ? void 0 : el.dataset.value;
  return (el == null ? void 0 : el.dataset.unit) === "period" ? value : Number(value ?? "0");
};
function getCurrentTime() {
  const now = /* @__PURE__ */ new Date();
  return new $35ea8db9cb2ccb90$export$680ea196effce5f(now.getHours(), now.getMinutes(), now.getSeconds());
}
var padStart = (value) => value.toString().padStart(2, "0");
function getValueString(value, hour12, period, allowSeconds) {
  if (!value) return "";
  let hourValue = value.hour;
  if (hour12 && hourValue === 0) {
    hourValue = 12;
  } else if (hour12 && hourValue > 12) {
    hourValue -= 12;
  }
  let result = `${padStart(hourValue)}:${padStart(value.minute)}`;
  if (allowSeconds) {
    const second = padStart(value.second);
    result += `:${second}`;
  }
  if (hour12 && period) {
    result += ` ${period.toUpperCase()}`;
  }
  return result;
}
var TIME_REX = /(\d{1,2}):(\d{1,2})(?::(\d{1,2}))?\s?(AM|PM|am|pm)?/;
function getTimeValue(locale, periodProp, value) {
  const match22 = value.match(TIME_REX);
  if (!match22) return;
  let [, hourString, minuteString, secondString, periodString] = match22;
  let hour = parseInt(hourString);
  const minute = parseInt(minuteString);
  const second = secondString ? parseInt(secondString) : void 0;
  if (!is12HourFormat(locale) && periodProp) {
    return { time: new $35ea8db9cb2ccb90$export$680ea196effce5f(hour, minute, second), period: periodProp };
  }
  let period = periodString ? periodString.toLowerCase() : "am";
  if (hour > 11) {
    period = "pm";
  } else if (period === "pm") {
    hour += 12;
  }
  return { time: new $35ea8db9cb2ccb90$export$680ea196effce5f(hour, minute, second), period };
}
function get12HourFormatPeriodHour(hour, period) {
  if (!period) return hour;
  return period === "pm" ? hour + 12 : hour;
}
function getHourPeriod(hour, locale) {
  if (hour === void 0 || !is12HourFormat(locale)) return null;
  return hour > 11 ? "pm" : "am";
}
function is12HourFormat(locale) {
  return new Intl.DateTimeFormat(locale, { hour: "numeric" }).formatToParts(/* @__PURE__ */ new Date()).some((part) => part.type === "dayPeriod");
}
function getInputPlaceholder2(placeholder, allowSeconds, locale) {
  if (placeholder) return placeholder;
  const secondsPart = allowSeconds ? ":ss" : "";
  const periodPart = is12HourFormat(locale) ? " aa" : "";
  return `hh:mm${secondsPart}${periodPart}`;
}
function clampTime(value, min4, max4) {
  let time = value;
  if (min4 && min4.compare(value) > 0) {
    time = min4.copy();
  } else if (max4 && max4.compare(value) < 0) {
    time = max4.copy();
  }
  return time;
}
function isTimeEqual(a2, b2) {
  if (!a2 || !b2) return false;
  return a2.hour === b2.hour && a2.minute === b2.minute && a2.second === b2.second;
}
function connect36(service, normalize4) {
  const { state: state2, send, prop, computed, scope, context } = service;
  const disabled = prop("disabled");
  const readOnly = prop("readOnly");
  const locale = prop("locale");
  const hour12 = is12HourFormat(locale);
  const min4 = prop("min");
  const max4 = prop("max");
  const steps = prop("steps");
  const focused = state2.matches("focused");
  const open = state2.hasTag("open");
  const value = context.get("value");
  const valueAsString = computed("valueAsString");
  const currentTime = context.get("currentTime");
  const focusedColumn = context.get("focusedColumn");
  const currentPlacement = context.get("currentPlacement");
  const popperStyles = getPlacementStyles({
    ...prop("positioning"),
    placement: currentPlacement
  });
  return {
    focused,
    open,
    value,
    valueAsString,
    hour12,
    reposition(options = {}) {
      send({ type: "POSITIONING.SET", options });
    },
    setOpen(nextOpen) {
      const open2 = state2.hasTag("open");
      if (open2 === nextOpen) return;
      send({ type: nextOpen ? "OPEN" : "CLOSE" });
    },
    setUnitValue(unit, value2) {
      send({ type: "UNIT.SET", unit, value: value2 });
    },
    setValue(value2) {
      send({ type: "VALUE.SET", value: value2 });
    },
    clearValue() {
      send({ type: "VALUE.CLEAR" });
    },
    getHours() {
      const length = hour12 ? 12 : 24;
      const arr = Array.from({ length }, (_, i) => i);
      const step = steps == null ? void 0 : steps.hour;
      const hours = step != null ? arr.filter((hour) => hour % step === 0) : arr;
      return hours.map((value2) => ({ label: hour12 && value2 === 0 ? "12" : padStart(value2), value: value2 }));
    },
    getMinutes() {
      const arr = Array.from({ length: 60 }, (_, i) => i);
      const step = steps == null ? void 0 : steps.minute;
      const minutes = step != null ? arr.filter((minute) => minute % step === 0) : arr;
      return minutes.map((value2) => ({ label: padStart(value2), value: value2 }));
    },
    getSeconds() {
      const arr = Array.from({ length: 60 }, (_, i) => i);
      const step = steps == null ? void 0 : steps.second;
      const seconds = step != null ? arr.filter((second) => second % step === 0) : arr;
      return seconds.map((value2) => ({ label: padStart(value2), value: value2 }));
    },
    getRootProps() {
      return normalize4.element({
        ...parts38.root.attrs,
        "data-state": open ? "open" : "closed",
        "data-disabled": dataAttr(disabled),
        "data-readonly": dataAttr(readOnly)
      });
    },
    getLabelProps() {
      return normalize4.label({
        ...parts38.label.attrs,
        dir: prop("dir"),
        htmlFor: getInputId9(scope),
        "data-state": open ? "open" : "closed",
        "data-disabled": dataAttr(disabled),
        "data-readonly": dataAttr(readOnly)
      });
    },
    getControlProps() {
      return normalize4.element({
        ...parts38.control.attrs,
        dir: prop("dir"),
        id: getControlId14(scope),
        "data-disabled": dataAttr(disabled)
      });
    },
    getInputProps() {
      return normalize4.input({
        ...parts38.input.attrs,
        dir: prop("dir"),
        autoComplete: "off",
        autoCorrect: "off",
        spellCheck: "false",
        id: getInputId9(scope),
        name: prop("name"),
        defaultValue: valueAsString,
        placeholder: getInputPlaceholder2(prop("placeholder"), prop("allowSeconds"), locale),
        disabled,
        readOnly,
        onFocus() {
          send({ type: "INPUT.FOCUS" });
        },
        onBlur(event) {
          send({ type: "INPUT.BLUR", value: event.currentTarget.value });
        },
        onKeyDown(event) {
          if (isComposingEvent(event)) return;
          if (event.key !== "Enter") return;
          send({ type: "INPUT.ENTER", value: event.currentTarget.value });
          event.preventDefault();
        }
      });
    },
    getTriggerProps() {
      return normalize4.button({
        ...parts38.trigger.attrs,
        id: getTriggerId14(scope),
        type: "button",
        "data-placement": currentPlacement,
        disabled,
        "data-readonly": dataAttr(readOnly),
        "aria-label": open ? "Close calendar" : "Open calendar",
        "aria-controls": getContentId14(scope),
        "data-state": open ? "open" : "closed",
        onClick(event) {
          if (event.defaultPrevented) return;
          send({ type: "TRIGGER.CLICK" });
        }
      });
    },
    getClearTriggerProps() {
      return normalize4.button({
        ...parts38.clearTrigger.attrs,
        id: getClearTriggerId5(scope),
        type: "button",
        hidden: !value,
        disabled,
        "data-readonly": dataAttr(readOnly),
        "aria-label": "Clear time",
        onClick(event) {
          if (event.defaultPrevented) return;
          send({ type: "VALUE.CLEAR" });
        }
      });
    },
    getPositionerProps() {
      return normalize4.element({
        ...parts38.positioner.attrs,
        dir: prop("dir"),
        id: getPositionerId10(scope),
        style: popperStyles.floating
      });
    },
    getSpacerProps() {
      return normalize4.element({
        ...parts38.spacer.attrs
      });
    },
    getContentProps() {
      return normalize4.element({
        ...parts38.content.attrs,
        dir: prop("dir"),
        id: getContentId14(scope),
        hidden: !open,
        tabIndex: 0,
        role: "application",
        "data-state": open ? "open" : "closed",
        "data-placement": currentPlacement,
        "aria-roledescription": "timepicker",
        "aria-label": "timepicker",
        onKeyDown(event) {
          if (event.defaultPrevented) return;
          if (isComposingEvent(event)) return;
          const keyMap2 = {
            ArrowUp() {
              send({ type: "CONTENT.ARROW_UP" });
            },
            ArrowDown() {
              send({ type: "CONTENT.ARROW_DOWN" });
            },
            ArrowLeft() {
              send({ type: "CONTENT.ARROW_LEFT" });
            },
            ArrowRight() {
              send({ type: "CONTENT.ARROW_RIGHT" });
            },
            Enter() {
              send({ type: "CONTENT.ENTER" });
            },
            // prevent tabbing out of the time picker
            Tab() {
            },
            Escape() {
              if (!prop("disableLayer")) return;
              send({ type: "CONTENT.ESCAPE" });
            }
          };
          const exec = keyMap2[getEventKey(event, { dir: prop("dir") })];
          if (exec) {
            exec(event);
            event.preventDefault();
          }
        }
      });
    },
    getColumnProps(props210) {
      const hidden = props210.unit === "second" && !prop("allowSeconds") || props210.unit === "period" && !hour12;
      return normalize4.element({
        ...parts38.column.attrs,
        id: getColumnId(scope, props210.unit),
        "data-unit": props210.unit,
        "data-focus": dataAttr(focusedColumn === props210.unit),
        hidden
      });
    },
    getHourCellProps(props210) {
      const hour = props210.value;
      const isSelectable = !(min4 && get12HourFormatPeriodHour(hour, computed("period")) < min4.hour || max4 && get12HourFormatPeriodHour(hour, computed("period")) > max4.hour);
      const isSelected = (value == null ? void 0 : value.hour) === get12HourFormatPeriodHour(hour, computed("period"));
      const isFocused = focusedColumn === "hour" && context.get("focusedValue") === hour;
      const currentHour = hour12 && currentTime ? (currentTime == null ? void 0 : currentTime.hour) % 12 : currentTime == null ? void 0 : currentTime.hour;
      const isCurrent = currentHour === hour || hour === 12 && currentHour === 0;
      return normalize4.button({
        ...parts38.cell.attrs,
        type: "button",
        "aria-disabled": ariaAttr(!isSelectable),
        "data-disabled": dataAttr(!isSelectable),
        "aria-current": ariaAttr(isSelected),
        "data-selected": dataAttr(isSelected),
        "data-now": dataAttr(isCurrent),
        "data-focus": dataAttr(isFocused),
        "aria-label": `${hour} hours`,
        "data-value": hour,
        "data-unit": "hour",
        onClick(event) {
          if (event.defaultPrevented) return;
          if (!isSelectable) return;
          send({ type: "UNIT.CLICK", unit: "hour", value: hour });
        }
      });
    },
    getMinuteCellProps(props210) {
      const minute = props210.value;
      const value2 = context.get("value");
      const minMinute = min4 == null ? void 0 : min4.set({ second: 0 });
      const maxMinute = max4 == null ? void 0 : max4.set({ second: 0 });
      const isSelectable = !(minMinute && value2 && minMinute.compare(value2.set({ minute })) > 0 || maxMinute && value2 && maxMinute.compare(value2.set({ minute })) < 0);
      const isSelected = (value2 == null ? void 0 : value2.minute) === minute;
      const isCurrent = (currentTime == null ? void 0 : currentTime.minute) === minute;
      const isFocused = focusedColumn === "minute" && context.get("focusedValue") === minute;
      return normalize4.button({
        ...parts38.cell.attrs,
        type: "button",
        "aria-disabled": ariaAttr(!isSelectable),
        "data-disabled": dataAttr(!isSelectable),
        "aria-current": ariaAttr(isSelected),
        "data-selected": dataAttr(isSelected),
        "aria-label": `${minute} minutes`,
        "data-value": minute,
        "data-now": dataAttr(isCurrent),
        "data-focus": dataAttr(isFocused),
        "data-unit": "minute",
        onClick(event) {
          if (event.defaultPrevented) return;
          if (!isSelectable) return;
          send({ type: "UNIT.CLICK", unit: "minute", value: minute });
        }
      });
    },
    getSecondCellProps(props210) {
      const second = props210.value;
      const isSelectable = !(min4 && (value == null ? void 0 : value.minute) && min4.compare(value.set({ second })) > 0 || max4 && (value == null ? void 0 : value.minute) && max4.compare(value.set({ second })) < 0);
      const isSelected = (value == null ? void 0 : value.second) === second;
      const isCurrent = (currentTime == null ? void 0 : currentTime.second) === second;
      const isFocused = focusedColumn === "second" && context.get("focusedValue") === second;
      return normalize4.button({
        ...parts38.cell.attrs,
        type: "button",
        "aria-disabled": ariaAttr(!isSelectable),
        "data-disabled": dataAttr(!isSelectable),
        "aria-current": ariaAttr(isSelected),
        "data-selected": dataAttr(isSelected),
        "aria-label": `${second} seconds`,
        "data-value": second,
        "data-unit": "second",
        "data-focus": dataAttr(isFocused),
        "data-now": dataAttr(isCurrent),
        onClick(event) {
          if (event.defaultPrevented) return;
          if (!isSelectable) return;
          send({ type: "UNIT.CLICK", unit: "second", value: second });
        }
      });
    },
    getPeriodCellProps(props210) {
      const isSelected = computed("period") === props210.value;
      const currentPeriod = getHourPeriod(currentTime == null ? void 0 : currentTime.hour, locale);
      const isCurrent = currentPeriod === props210.value;
      const isFocused = focusedColumn === "period" && context.get("focusedValue") === props210.value;
      return normalize4.button({
        ...parts38.cell.attrs,
        type: "button",
        "aria-current": ariaAttr(isSelected),
        "data-selected": dataAttr(isSelected),
        "data-focus": dataAttr(isFocused),
        "data-now": dataAttr(isCurrent),
        "aria-label": props210.value,
        "data-value": props210.value,
        "data-unit": "period",
        onClick(event) {
          if (event.defaultPrevented) return;
          send({ type: "UNIT.CLICK", unit: "period", value: props210.value });
        }
      });
    }
  };
}
var { and: and11 } = createGuards();
var machine36 = createMachine({
  props({ props: props210 }) {
    return {
      locale: "en-US",
      ...props210,
      positioning: {
        placement: "bottom-start",
        gutter: 8,
        ...props210.positioning
      }
    };
  },
  initialState({ prop }) {
    const open = prop("open") || prop("defaultOpen");
    return open ? "open" : "idle";
  },
  context({ prop, bindable, getComputed }) {
    return {
      value: bindable(() => ({
        value: prop("value"),
        defaultValue: prop("defaultValue"),
        hash(a2) {
          return (a2 == null ? void 0 : a2.toString()) ?? "";
        },
        isEqual: isTimeEqual,
        onChange(value) {
          var _a8;
          const computed = getComputed();
          const valueAsString = getValueString(value, computed("hour12"), computed("period"), prop("allowSeconds"));
          (_a8 = prop("onValueChange")) == null ? void 0 : _a8({ value, valueAsString });
        }
      })),
      focusedColumn: bindable(() => ({ defaultValue: "hour" })),
      focusedValue: bindable(() => ({ defaultValue: null })),
      currentTime: bindable(() => ({ defaultValue: null })),
      currentPlacement: bindable(() => ({ defaultValue: void 0 })),
      restoreFocus: bindable(() => ({ defaultValue: void 0 }))
    };
  },
  computed: {
    valueAsString: ({ context, prop, computed }) => getValueString(context.get("value"), computed("hour12"), computed("period"), prop("allowSeconds")),
    hour12: ({ prop }) => is12HourFormat(prop("locale")),
    period: ({ context, prop }) => {
      var _a8;
      return getHourPeriod((_a8 = context.get("value")) == null ? void 0 : _a8.hour, prop("locale"));
    }
  },
  watch({ track, action, prop, context, computed }) {
    track([() => prop("open")], () => {
      action(["toggleVisibility"]);
    });
    track([() => context.hash("value"), () => computed("period")], () => {
      action(["syncInputElement"]);
    });
    track([() => context.get("focusedColumn")], () => {
      action(["syncFocusedValue"]);
    });
    track([() => context.get("focusedValue")], () => {
      action(["focusCell"]);
    });
  },
  on: {
    "VALUE.CLEAR": {
      actions: ["clearValue"]
    },
    "VALUE.SET": {
      actions: ["setValue"]
    },
    "UNIT.SET": {
      actions: ["setUnitValue"]
    }
  },
  states: {
    idle: {
      tags: ["closed"],
      on: {
        "INPUT.FOCUS": {
          target: "focused"
        },
        "TRIGGER.CLICK": [
          {
            guard: "isOpenControlled",
            actions: ["invokeOnOpen"]
          },
          {
            target: "open",
            actions: ["invokeOnOpen"]
          }
        ],
        OPEN: [
          {
            guard: "isOpenControlled",
            actions: ["invokeOnOpen"]
          },
          {
            target: "open",
            actions: ["invokeOnOpen"]
          }
        ],
        "CONTROLLED.OPEN": {
          target: "open",
          actions: ["invokeOnOpen"]
        }
      }
    },
    focused: {
      tags: ["closed"],
      on: {
        "TRIGGER.CLICK": [
          {
            guard: "isOpenControlled",
            actions: ["invokeOnOpen"]
          },
          {
            target: "open",
            actions: ["invokeOnOpen"]
          }
        ],
        OPEN: [
          {
            guard: "isOpenControlled",
            actions: ["invokeOnOpen"]
          },
          {
            target: "open",
            actions: ["invokeOnOpen"]
          }
        ],
        "INPUT.ENTER": {
          actions: ["setInputValue", "clampTimeValue"]
        },
        "INPUT.BLUR": {
          target: "idle",
          actions: ["setInputValue", "clampTimeValue"]
        },
        "CONTROLLED.OPEN": {
          target: "open",
          actions: ["invokeOnOpen"]
        }
      }
    },
    open: {
      tags: ["open"],
      entry: ["setCurrentTime", "scrollColumnsToTop", "focusHourColumn"],
      exit: ["resetFocusedCell"],
      effects: ["computePlacement", "trackDismissableElement"],
      on: {
        "TRIGGER.CLICK": [
          {
            guard: "isOpenControlled",
            actions: ["invokeOnClose"]
          },
          {
            target: "focused",
            actions: ["invokeOnClose"]
          }
        ],
        "INPUT.ENTER": {
          actions: ["setInputValue", "clampTimeValue"]
        },
        CLOSE: [
          {
            guard: "isOpenControlled",
            actions: ["invokeOnClose"]
          },
          {
            target: "idle",
            actions: ["invokeOnClose"]
          }
        ],
        "CONTROLLED.CLOSE": [
          {
            guard: and11("shouldRestoreFocus", "isInteractOutsideEvent"),
            target: "focused",
            actions: ["focusTriggerElement"]
          },
          {
            guard: "shouldRestoreFocus",
            target: "focused",
            actions: ["focusInputElement"]
          },
          {
            target: "idle"
          }
        ],
        "CONTENT.ESCAPE": [
          {
            guard: "isOpenControlled",
            actions: ["invokeOnClose"]
          },
          {
            target: "focused",
            actions: ["invokeOnClose", "focusInputElement"]
          }
        ],
        INTERACT_OUTSIDE: [
          {
            guard: "isOpenControlled",
            actions: ["invokeOnClose"]
          },
          {
            guard: "shouldRestoreFocus",
            target: "focused",
            actions: ["invokeOnClose", "focusTriggerElement"]
          },
          {
            target: "idle",
            actions: ["invokeOnClose"]
          }
        ],
        "POSITIONING.SET": {
          actions: ["reposition"]
        },
        "UNIT.CLICK": {
          actions: ["setFocusedValue", "setFocusedColumn", "setUnitValue"]
        },
        "CONTENT.ARROW_UP": {
          actions: ["focusPreviousCell"]
        },
        "CONTENT.ARROW_DOWN": {
          actions: ["focusNextCell"]
        },
        "CONTENT.ARROW_LEFT": {
          actions: ["focusPreviousColumnCell"]
        },
        "CONTENT.ARROW_RIGHT": {
          actions: ["focusNextColumnCell"]
        },
        "CONTENT.ENTER": {
          actions: ["selectFocusedCell", "focusNextColumnCell"]
        }
      }
    }
  },
  implementations: {
    guards: {
      shouldRestoreFocus: ({ context }) => !!context.get("restoreFocus"),
      isOpenControlled: ({ prop }) => prop("open") != null,
      isInteractOutsideEvent: ({ event }) => {
        var _a8;
        return ((_a8 = event.previousEvent) == null ? void 0 : _a8.type) === "INTERACT_OUTSIDE";
      }
    },
    effects: {
      computePlacement({ context, prop, scope }) {
        context.set("currentPlacement", prop("positioning").placement);
        const anchorEl = () => getControlEl8(scope);
        const positionerEl = () => getPositionerEl10(scope);
        return getPlacement(anchorEl, positionerEl, {
          defer: true,
          ...prop("positioning"),
          onComplete(data) {
            context.set("currentPlacement", data.placement);
          }
        });
      },
      trackDismissableElement({ context, prop, scope, send }) {
        if (prop("disableLayer")) return;
        const contentEl = () => getContentEl13(scope);
        return trackDismissableElement(contentEl, {
          defer: true,
          exclude: [getTriggerEl11(scope), getClearTriggerEl4(scope)],
          onEscapeKeyDown(event) {
            event.preventDefault();
            context.set("restoreFocus", true);
            send({ type: "CONTENT.ESCAPE" });
          },
          onInteractOutside(event) {
            context.set("restoreFocus", !event.detail.focusable);
          },
          onDismiss() {
            send({ type: "INTERACT_OUTSIDE" });
          }
        });
      }
    },
    actions: {
      reposition({ context, prop, scope, event }) {
        const positionerEl = () => getPositionerEl10(scope);
        getPlacement(getTriggerEl11(scope), positionerEl, {
          ...prop("positioning"),
          ...event.options,
          defer: true,
          listeners: false,
          onComplete(data) {
            context.set("currentPlacement", data.placement);
          }
        });
      },
      toggleVisibility({ prop, send, event }) {
        send({ type: prop("open") ? "CONTROLLED.OPEN" : "CONTROLLED.CLOSE", previousEvent: event });
      },
      invokeOnOpen({ prop }) {
        var _a8;
        (_a8 = prop("onOpenChange")) == null ? void 0 : _a8({ open: true });
      },
      invokeOnClose({ prop }) {
        var _a8;
        (_a8 = prop("onOpenChange")) == null ? void 0 : _a8({ open: false });
      },
      setInputValue({ context, event, prop, computed }) {
        const timeValue = getTimeValue(prop("locale"), computed("period"), event.value);
        if (!timeValue) return;
        context.set("value", timeValue.time);
      },
      syncInputElement({ scope, computed }) {
        const inputEl = getInputEl7(scope);
        if (!inputEl) return;
        inputEl.value = computed("valueAsString");
      },
      setUnitValue({ context, event, computed }) {
        const { unit, value } = event;
        const _value = context.get("value");
        const current = _value ?? context.get("currentTime") ?? new $35ea8db9cb2ccb90$export$680ea196effce5f(0);
        const nextTime = match(unit, {
          hour: () => current.set({ hour: computed("hour12") ? value + 12 : value }),
          minute: () => current.set({ minute: value }),
          second: () => current.set({ second: value }),
          period: () => {
            if (!_value) return;
            const diff3 = value === "pm" ? 12 : 0;
            return _value.set({ hour: _value.hour % 12 + diff3 });
          }
        });
        if (!nextTime) return;
        context.set("value", nextTime);
      },
      setValue({ context, event }) {
        if (!(event.value instanceof $35ea8db9cb2ccb90$export$680ea196effce5f)) return;
        context.set("value", event.value);
      },
      clearValue({ context }) {
        context.set("value", null);
      },
      setFocusedValue({ context, event }) {
        context.set("focusedValue", event.value);
      },
      setFocusedColumn({ context, event }) {
        context.set("focusedColumn", event.unit);
      },
      resetFocusedCell({ context }) {
        context.set("focusedColumn", "hour");
        context.set("focusedValue", null);
      },
      clampTimeValue({ context, prop }) {
        const value = context.get("value");
        if (!value) return;
        const nextTime = clampTime(value, prop("min"), prop("max"));
        context.set("value", nextTime);
      },
      setCurrentTime({ context }) {
        context.set("currentTime", getCurrentTime());
      },
      scrollColumnsToTop({ scope }) {
        raf(() => {
          const columnEls = getColumnEls(scope);
          for (const columnEl of columnEls) {
            const cellEl = getInitialFocusCell(scope, columnEl.dataset.unit);
            if (!cellEl) continue;
            columnEl.scrollTop = cellEl.offsetTop - 4;
          }
        });
      },
      focusTriggerElement({ scope }) {
        var _a8;
        (_a8 = getTriggerEl11(scope)) == null ? void 0 : _a8.focus({ preventScroll: true });
      },
      focusInputElement({ scope }) {
        var _a8;
        (_a8 = getInputEl7(scope)) == null ? void 0 : _a8.focus({ preventScroll: true });
      },
      focusHourColumn({ context, scope }) {
        raf(() => {
          const hourEl = getInitialFocusCell(scope, "hour");
          if (!hourEl) return;
          context.set("focusedValue", getCellValue(hourEl));
        });
      },
      focusPreviousCell({ context, scope }) {
        raf(() => {
          const cells = getColumnCellEls(scope, context.get("focusedColumn"));
          const focusedEl = getFocusedCell2(scope);
          const focusedIndex = focusedEl ? cells.indexOf(focusedEl) : -1;
          const prevCell = prev(cells, focusedIndex, { loop: false });
          if (!prevCell) return;
          context.set("focusedValue", getCellValue(prevCell));
        });
      },
      focusNextCell({ context, scope }) {
        raf(() => {
          const cells = getColumnCellEls(scope, context.get("focusedColumn"));
          const focusedEl = getFocusedCell2(scope);
          const focusedIndex = focusedEl ? cells.indexOf(focusedEl) : -1;
          const nextCell = next(cells, focusedIndex, { loop: false });
          if (!nextCell) return;
          context.set("focusedValue", getCellValue(nextCell));
        });
      },
      selectFocusedCell({ context, computed }) {
        const current = context.get("value") ?? context.get("currentTime") ?? new $35ea8db9cb2ccb90$export$680ea196effce5f(0);
        let value = context.get("focusedValue");
        let column = context.get("focusedColumn");
        if (column === "hour" && computed("hour12")) {
          value = computed("hour12") ? value + 12 : value;
        } else if (context.get("focusedColumn") === "period") {
          column = "hour";
          const diff3 = value === "pm" ? 12 : 0;
          value = current.hour % 12 + diff3;
        }
        const nextTime = current.set({ [column]: value });
        context.set("value", nextTime);
      },
      focusPreviousColumnCell({ context, scope }) {
        raf(() => {
          const columns = getColumnEls(scope);
          const currentColumnEl = getColumnEl(scope, context.get("focusedColumn"));
          const focusedIndex = columns.indexOf(currentColumnEl);
          const prevColumnEl = prev(columns, focusedIndex, { loop: false });
          if (!prevColumnEl) return;
          context.set("focusedColumn", getColumnUnit(prevColumnEl));
        });
      },
      focusNextColumnCell({ context, scope }) {
        raf(() => {
          const columns = getColumnEls(scope);
          const currentColumnEl = getColumnEl(scope, context.get("focusedColumn"));
          const focusedIndex = columns.indexOf(currentColumnEl);
          const nextColumnEl = next(columns, focusedIndex, { loop: false });
          if (!nextColumnEl) return;
          context.set("focusedColumn", getColumnUnit(nextColumnEl));
        });
      },
      focusCell({ scope }) {
        queueMicrotask(() => {
          const cellEl = getFocusedCell2(scope);
          cellEl == null ? void 0 : cellEl.focus();
        });
      },
      syncFocusedValue({ context, scope }) {
        if (context.get("focusedValue") === null) return;
        queueMicrotask(() => {
          const cellEl = getInitialFocusCell(scope, context.get("focusedColumn"));
          context.set("focusedValue", getCellValue(cellEl));
        });
      }
    }
  }
});
var props36 = createProps()([
  "dir",
  "disabled",
  "disableLayer",
  "getRootNode",
  "id",
  "ids",
  "locale",
  "max",
  "min",
  "name",
  "onFocusChange",
  "onOpenChange",
  "onValueChange",
  "open",
  "placeholder",
  "positioning",
  "readOnly",
  "steps",
  "value",
  "allowSeconds",
  "defaultValue",
  "defaultOpen"
]);
var splitProps36 = createSplitProps(props36);

// node_modules/@ark-ui/react/dist/components/time-picker/use-time-picker.js
var import_react853 = __toESM(require_react(), 1);
var useTimePicker = (props43) => {
  const id = (0, import_react853.useId)();
  const { getRootNode } = useEnvironmentContext();
  const { dir, locale } = useLocaleContext();
  const machineProps = {
    id,
    dir,
    locale,
    getRootNode,
    ...props43
  };
  const service = useMachine(machine36, machineProps);
  return connect36(service, normalizeProps);
};

// node_modules/@ark-ui/react/dist/components/time-picker/time-picker-root.js
var TimePickerRoot = (0, import_react855.forwardRef)((props43, ref) => {
  const [presenceProps, timePickerProps] = splitPresenceProps(props43);
  const [useTimePickerProps, localProps] = createSplitProps2()(timePickerProps, [
    "allowSeconds",
    "defaultOpen",
    "defaultValue",
    "disableLayer",
    "disabled",
    "id",
    "ids",
    "locale",
    "max",
    "min",
    "name",
    "onFocusChange",
    "onOpenChange",
    "onValueChange",
    "open",
    "placeholder",
    "positioning",
    "readOnly",
    "steps",
    "value"
  ]);
  const timePicker = useTimePicker(useTimePickerProps);
  const presence = usePresence(mergeProps2({ present: timePicker.open }, presenceProps));
  const mergedProps = mergeProps2(timePicker.getRootProps(), localProps);
  return (0, import_jsx_runtime396.jsx)(TimePickerProvider, { value: timePicker, children: (0, import_jsx_runtime396.jsx)(PresenceProvider, { value: presence, children: (0, import_jsx_runtime396.jsx)(ark.div, { ...mergedProps, ref }) }) });
});
TimePickerRoot.displayName = "TimePickerRoot";

// node_modules/@ark-ui/react/dist/components/time-picker/time-picker-root-provider.js
var import_jsx_runtime397 = __toESM(require_jsx_runtime(), 1);
var import_react857 = __toESM(require_react(), 1);
var TimePickerRootProvider = (0, import_react857.forwardRef)((props43, ref) => {
  const [presenceProps, timePickerProps] = splitPresenceProps(props43);
  const [{ value: timePicker }, localProps] = createSplitProps2()(timePickerProps, ["value"]);
  const presence = usePresence(mergeProps2({ present: timePicker.open }, presenceProps));
  const mergedProps = mergeProps2(timePicker.getRootProps(), localProps);
  return (0, import_jsx_runtime397.jsx)(TimePickerProvider, { value: timePicker, children: (0, import_jsx_runtime397.jsx)(PresenceProvider, { value: presence, children: (0, import_jsx_runtime397.jsx)(ark.div, { ...mergedProps, ref }) }) });
});
TimePickerRootProvider.displayName = "TimePickerRootProvider";

// node_modules/@ark-ui/react/dist/components/time-picker/time-picker-spacer.js
var import_jsx_runtime398 = __toESM(require_jsx_runtime(), 1);
var import_react859 = __toESM(require_react(), 1);
var TimePickerSpacer = (0, import_react859.forwardRef)((props43, ref) => {
  const timePicker = useTimePickerContext();
  const mergedProps = mergeProps2(timePicker.getSpacerProps(), props43);
  return (0, import_jsx_runtime398.jsx)(ark.div, { ...mergedProps, ref });
});
TimePickerSpacer.displayName = "TimePickerSpacer";

// node_modules/@ark-ui/react/dist/components/time-picker/time-picker-trigger.js
var import_jsx_runtime399 = __toESM(require_jsx_runtime(), 1);
var import_react861 = __toESM(require_react(), 1);
var TimePickerTrigger = (0, import_react861.forwardRef)((props43, ref) => {
  const timePicker = useTimePickerContext();
  const mergedProps = mergeProps2(timePicker.getTriggerProps(), props43);
  return (0, import_jsx_runtime399.jsx)(ark.button, { ...mergedProps, ref });
});
TimePickerTrigger.displayName = "TimePickerTrigger";

// node_modules/@ark-ui/react/dist/components/timer/timer-action-trigger.js
var import_jsx_runtime400 = __toESM(require_jsx_runtime(), 1);
var import_react863 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/timer/use-timer-context.js
var [TimerProvider, useTimerContext] = createContext3({
  name: "TimerContext",
  hookName: "useTimerContext",
  providerName: "<TimerProvider />"
});

// node_modules/@ark-ui/react/dist/components/timer/timer-action-trigger.js
var TimerActionTrigger = (0, import_react863.forwardRef)((props43, ref) => {
  const [actionTriggerProps, localProps] = createSplitProps2()(props43, ["action"]);
  const timer = useTimerContext();
  const mergedProps = mergeProps2(timer.getActionTriggerProps(actionTriggerProps), localProps);
  return (0, import_jsx_runtime400.jsx)(ark.button, { ...mergedProps, ref });
});
TimerActionTrigger.displayName = "TimerActionTrigger";

// node_modules/@ark-ui/react/dist/components/timer/timer-area.js
var import_jsx_runtime401 = __toESM(require_jsx_runtime(), 1);
var import_react865 = __toESM(require_react(), 1);
var TimerArea = (0, import_react865.forwardRef)((props43, ref) => {
  const timer = useTimerContext();
  const mergedProps = mergeProps2(timer.getAreaProps(), props43);
  return (0, import_jsx_runtime401.jsx)(ark.div, { ...mergedProps, ref });
});
TimerArea.displayName = "TimerArea";

// node_modules/@ark-ui/react/dist/components/timer/timer-control.js
var import_jsx_runtime402 = __toESM(require_jsx_runtime(), 1);
var import_react867 = __toESM(require_react(), 1);
var TimerControl = (0, import_react867.forwardRef)((props43, ref) => {
  const timer = useTimerContext();
  const mergedProps = mergeProps2(timer.getControlProps(), props43);
  return (0, import_jsx_runtime402.jsx)(ark.div, { ...mergedProps, ref });
});
TimerControl.displayName = "TimerControl";

// node_modules/@ark-ui/react/dist/components/timer/timer-item.js
var import_jsx_runtime403 = __toESM(require_jsx_runtime(), 1);
var import_react869 = __toESM(require_react(), 1);
var TimerItem = (0, import_react869.forwardRef)((props43, ref) => {
  const [itemProps14, localProps] = createSplitProps2()(props43, ["type"]);
  const timer = useTimerContext();
  const mergedProps = mergeProps2(timer.getItemProps(itemProps14), localProps);
  return (0, import_jsx_runtime403.jsx)(ark.div, { ...mergedProps, ref, children: timer.formattedTime[itemProps14.type] });
});
TimerItem.displayName = "TimerItem";

// node_modules/@ark-ui/react/dist/components/timer/timer-root.js
var import_jsx_runtime404 = __toESM(require_jsx_runtime(), 1);
var import_react873 = __toESM(require_react(), 1);

// node_modules/@zag-js/timer/dist/index.mjs
var anatomy36 = createAnatomy("timer").parts(
  "root",
  "area",
  "control",
  "item",
  "itemValue",
  "itemLabel",
  "actionTrigger",
  "separator"
);
var parts39 = anatomy36.build();
var getRootId29 = (ctx) => {
  var _a8;
  return ((_a8 = ctx.ids) == null ? void 0 : _a8.root) ?? `timer:${ctx.id}:root`;
};
var getAreaId3 = (ctx) => {
  var _a8;
  return ((_a8 = ctx.ids) == null ? void 0 : _a8.area) ?? `timer:${ctx.id}:area`;
};
var validActions = /* @__PURE__ */ new Set(["start", "pause", "resume", "reset"]);
function connect37(service, normalize4) {
  const { state: state2, send, computed, scope } = service;
  const running = state2.matches("running");
  const paused = state2.matches("paused");
  const time = computed("time");
  const formattedTime = computed("formattedTime");
  const progressPercent = computed("progressPercent");
  return {
    running,
    paused,
    time,
    formattedTime,
    progressPercent,
    start() {
      send({ type: "START" });
    },
    pause() {
      send({ type: "PAUSE" });
    },
    resume() {
      send({ type: "RESUME" });
    },
    reset() {
      send({ type: "RESET" });
    },
    restart() {
      send({ type: "RESTART" });
    },
    getRootProps() {
      return normalize4.element({
        id: getRootId29(scope),
        ...parts39.root.attrs
      });
    },
    getAreaProps() {
      return normalize4.element({
        role: "timer",
        id: getAreaId3(scope),
        "aria-label": `${time.days} days ${formattedTime.hours}:${formattedTime.minutes}:${formattedTime.seconds}`,
        "aria-atomic": true,
        ...parts39.area.attrs
      });
    },
    getControlProps() {
      return normalize4.element({
        ...parts39.control.attrs
      });
    },
    getItemProps(props210) {
      const value = time[props210.type];
      return normalize4.element({
        ...parts39.item.attrs,
        "data-type": props210.type,
        style: {
          "--value": value
        }
      });
    },
    getItemLabelProps(props210) {
      return normalize4.element({
        ...parts39.itemLabel.attrs,
        "data-type": props210.type
      });
    },
    getItemValueProps(props210) {
      return normalize4.element({
        ...parts39.itemValue.attrs,
        "data-type": props210.type
      });
    },
    getSeparatorProps() {
      return normalize4.element({
        "aria-hidden": true,
        ...parts39.separator.attrs
      });
    },
    getActionTriggerProps(props210) {
      if (!validActions.has(props210.action)) {
        throw new Error(
          `[zag-js] Invalid action: ${props210.action}. Must be one of: ${Array.from(validActions).join(", ")}`
        );
      }
      return normalize4.button({
        ...parts39.actionTrigger.attrs,
        hidden: (() => {
          switch (props210.action) {
            case "start":
              return running || paused;
            case "pause":
              return !running;
            case "reset":
              return !running && !paused;
            case "resume":
              return !paused;
            default:
              return;
          }
        })(),
        type: "button",
        onClick(event) {
          if (event.defaultPrevented) return;
          send({ type: props210.action.toUpperCase() });
        }
      });
    }
  };
}
var machine37 = createMachine({
  props({ props: props210 }) {
    return {
      interval: 1e3,
      ...props210
    };
  },
  initialState({ prop }) {
    return prop("autoStart") ? "running" : "idle";
  },
  context({ prop, bindable }) {
    return {
      currentMs: bindable(() => ({
        defaultValue: prop("startMs") ?? 0
      }))
    };
  },
  watch({ track, send, prop }) {
    track([() => prop("startMs")], () => {
      send({ type: "RESTART" });
    });
  },
  on: {
    RESTART: {
      target: "running:temp",
      actions: ["resetTime"]
    }
  },
  computed: {
    time: ({ context }) => msToTime(context.get("currentMs")),
    formattedTime: ({ computed }) => formatTime(computed("time")),
    progressPercent: ({ context, prop }) => {
      const targetMs = prop("targetMs");
      if (targetMs == null) return 0;
      return toPercent(context.get("currentMs"), prop("startMs") ?? 0, targetMs);
    }
  },
  states: {
    idle: {
      on: {
        START: {
          target: "running"
        },
        RESET: {
          actions: ["resetTime"]
        }
      }
    },
    "running:temp": {
      effects: ["waitForNextTick"],
      on: {
        CONTINUE: {
          target: "running"
        }
      }
    },
    running: {
      effects: ["keepTicking"],
      on: {
        PAUSE: {
          target: "paused"
        },
        TICK: [
          {
            target: "idle",
            guard: "hasReachedTarget",
            actions: ["invokeOnComplete"]
          },
          {
            actions: ["updateTime", "invokeOnTick"]
          }
        ],
        RESET: {
          actions: ["resetTime"]
        }
      }
    },
    paused: {
      on: {
        RESUME: {
          target: "running"
        },
        RESET: {
          target: "idle",
          actions: ["resetTime"]
        }
      }
    }
  },
  implementations: {
    effects: {
      keepTicking({ prop, send }) {
        return setRafInterval(({ deltaMs }) => {
          send({ type: "TICK", deltaMs });
        }, prop("interval"));
      },
      waitForNextTick({ send }) {
        return setRafTimeout(() => {
          send({ type: "CONTINUE" });
        }, 0);
      }
    },
    actions: {
      updateTime({ context, prop, event }) {
        const sign3 = prop("countdown") ? -1 : 1;
        const deltaMs = roundToInterval(event.deltaMs, prop("interval"));
        context.set("currentMs", (prev2) => prev2 + sign3 * deltaMs);
      },
      resetTime({ context, prop }) {
        let targetMs = prop("targetMs");
        if (targetMs == null && prop("countdown")) targetMs = 0;
        context.set("currentMs", prop("startMs") ?? 0);
      },
      invokeOnTick({ context, prop, computed }) {
        var _a8;
        (_a8 = prop("onTick")) == null ? void 0 : _a8({
          value: context.get("currentMs"),
          time: computed("time"),
          formattedTime: computed("formattedTime")
        });
      },
      invokeOnComplete({ prop }) {
        var _a8;
        (_a8 = prop("onComplete")) == null ? void 0 : _a8();
      }
    },
    guards: {
      hasReachedTarget: ({ context, prop }) => {
        let targetMs = prop("targetMs");
        if (targetMs == null && prop("countdown")) targetMs = 0;
        if (targetMs == null) return false;
        return context.get("currentMs") === targetMs;
      }
    }
  }
});
function msToTime(ms) {
  const milliseconds = ms % 1e3;
  const seconds = Math.floor(ms / 1e3) % 60;
  const minutes = Math.floor(ms / (1e3 * 60)) % 60;
  const hours = Math.floor(ms / (1e3 * 60 * 60)) % 24;
  const days = Math.floor(ms / (1e3 * 60 * 60 * 24));
  return {
    days,
    hours,
    minutes,
    seconds,
    milliseconds
  };
}
function toPercent(value, minValue, maxValue2) {
  return (value - minValue) / (maxValue2 - minValue);
}
function padStart2(num, size3 = 2) {
  return num.toString().padStart(size3, "0");
}
function roundToInterval(value, interval) {
  return Math.round(value / interval) * interval;
}
function formatTime(time) {
  const { days, hours, minutes, seconds } = time;
  return {
    days: padStart2(days),
    hours: padStart2(hours),
    minutes: padStart2(minutes),
    seconds: padStart2(seconds),
    milliseconds: time.milliseconds.toString()
  };
}
var props37 = createProps()([
  "autoStart",
  "countdown",
  "getRootNode",
  "id",
  "ids",
  "interval",
  "onComplete",
  "onTick",
  "startMs",
  "targetMs"
]);
var splitProps37 = createSplitProps(props37);

// node_modules/@ark-ui/react/dist/components/timer/use-timer.js
var import_react871 = __toESM(require_react(), 1);
var useTimer = (props43) => {
  const id = (0, import_react871.useId)();
  const { getRootNode } = useEnvironmentContext();
  const machineProps = {
    id,
    getRootNode,
    ...props43
  };
  const service = useMachine(machine37, machineProps);
  return connect37(service, normalizeProps);
};

// node_modules/@ark-ui/react/dist/components/timer/timer-root.js
var TimerRoot = (0, import_react873.forwardRef)((props43, ref) => {
  const [useTimerProps, localProps] = createSplitProps2()(props43, [
    "id",
    "ids",
    "autoStart",
    "interval",
    "countdown",
    "startMs",
    "targetMs",
    "onComplete",
    "onTick"
  ]);
  const timer = useTimer(useTimerProps);
  const mergedProps = mergeProps2(timer.getRootProps(), localProps);
  return (0, import_jsx_runtime404.jsx)(TimerProvider, { value: timer, children: (0, import_jsx_runtime404.jsx)(ark.div, { ...mergedProps, ref }) });
});
TimerRoot.displayName = "TimerRoot";

// node_modules/@ark-ui/react/dist/components/timer/timer-root-provider.js
var import_jsx_runtime405 = __toESM(require_jsx_runtime(), 1);
var import_react875 = __toESM(require_react(), 1);
var TimerRootProvider = (0, import_react875.forwardRef)((props43, ref) => {
  const [{ value: timer }, localProps] = createSplitProps2()(props43, ["value"]);
  const mergedProps = mergeProps2(timer.getRootProps(), localProps);
  return (0, import_jsx_runtime405.jsx)(TimerProvider, { value: timer, children: (0, import_jsx_runtime405.jsx)(ark.div, { ...mergedProps, ref }) });
});
TimerRootProvider.displayName = "TimerRootProvider";

// node_modules/@ark-ui/react/dist/components/timer/timer-separator.js
var import_jsx_runtime406 = __toESM(require_jsx_runtime(), 1);
var import_react877 = __toESM(require_react(), 1);
var TimerSeparator = (0, import_react877.forwardRef)((props43, ref) => {
  const timer = useTimerContext();
  const mergedProps = mergeProps2(timer.getSeparatorProps(), props43);
  return (0, import_jsx_runtime406.jsx)(ark.div, { ...mergedProps, ref });
});
TimerSeparator.displayName = "TimerSeparator";

// node_modules/@zag-js/toast/dist/index.mjs
var anatomy37 = createAnatomy("toast").parts(
  "group",
  "root",
  "title",
  "description",
  "actionTrigger",
  "closeTrigger"
);
var parts40 = anatomy37.build();
var getRegionId = (placement) => `toast-group:${placement}`;
var getRegionEl = (ctx, placement) => ctx.getById(`toast-group:${placement}`);
var getRootId30 = (ctx) => `toast:${ctx.id}`;
var getRootEl11 = (ctx) => ctx.getById(getRootId30(ctx));
var getTitleId3 = (ctx) => `toast:${ctx.id}:title`;
var getDescriptionId3 = (ctx) => `toast:${ctx.id}:description`;
var getCloseTriggerId3 = (ctx) => `toast${ctx.id}:close`;
var defaultTimeouts = {
  info: 5e3,
  error: 5e3,
  success: 2e3,
  loading: Infinity,
  DEFAULT: 5e3
};
function getToastDuration(duration, type) {
  return duration ?? defaultTimeouts[type] ?? defaultTimeouts.DEFAULT;
}
var getOffsets = (offsets) => typeof offsets === "string" ? { left: offsets, right: offsets, bottom: offsets, top: offsets } : offsets;
function getGroupPlacementStyle(service, placement) {
  var _a8;
  const { prop, computed, context } = service;
  const { offsets, gap } = prop("store").attrs;
  const heights = context.get("heights");
  const computedOffset = getOffsets(offsets);
  const rtl = prop("dir") === "rtl";
  const computedPlacement = placement.replace("-start", rtl ? "-right" : "-left").replace("-end", rtl ? "-left" : "-right");
  const isRighty = computedPlacement.includes("right");
  const isLefty = computedPlacement.includes("left");
  const styles = {
    position: "fixed",
    pointerEvents: computed("count") > 0 ? void 0 : "none",
    display: "flex",
    flexDirection: "column",
    "--gap": `${gap}px`,
    "--first-height": `${((_a8 = heights[0]) == null ? void 0 : _a8.height) || 0}px`,
    zIndex: MAX_Z_INDEX
  };
  let alignItems = "center";
  if (isRighty) alignItems = "flex-end";
  if (isLefty) alignItems = "flex-start";
  styles.alignItems = alignItems;
  if (computedPlacement.includes("top")) {
    const offset4 = computedOffset.top;
    styles.top = `max(env(safe-area-inset-top, 0px), ${offset4})`;
  }
  if (computedPlacement.includes("bottom")) {
    const offset4 = computedOffset.bottom;
    styles.bottom = `max(env(safe-area-inset-bottom, 0px), ${offset4})`;
  }
  if (!computedPlacement.includes("left")) {
    const offset4 = computedOffset.right;
    styles.insetInlineEnd = `calc(env(safe-area-inset-right, 0px) + ${offset4})`;
  }
  if (!computedPlacement.includes("right")) {
    const offset4 = computedOffset.left;
    styles.insetInlineStart = `calc(env(safe-area-inset-left, 0px) + ${offset4})`;
  }
  return styles;
}
function getPlacementStyle(service, visible) {
  const { prop, context, computed } = service;
  const parent = prop("parent");
  const placement = parent.computed("placement");
  const { gap } = parent.prop("store").attrs;
  const [side] = placement.split("-");
  const mounted = context.get("mounted");
  const remainingTime = context.get("remainingTime");
  const height = computed("height");
  const frontmost = computed("frontmost");
  const sibling = !frontmost;
  const overlap = !prop("stacked");
  const stacked = prop("stacked");
  const type = prop("type");
  const duration = type === "loading" ? Number.MAX_SAFE_INTEGER : remainingTime;
  const offset4 = computed("heightIndex") * gap + computed("heightBefore");
  const styles = {
    position: "absolute",
    pointerEvents: "auto",
    "--opacity": "0",
    "--remove-delay": `${prop("removeDelay")}ms`,
    "--duration": `${duration}ms`,
    "--initial-height": `${height}px`,
    "--offset": `${offset4}px`,
    "--index": prop("index"),
    "--z-index": computed("zIndex"),
    "--lift-amount": "calc(var(--lift) * var(--gap))",
    "--y": "100%",
    "--x": "0"
  };
  const assign = (overrides) => Object.assign(styles, overrides);
  if (side === "top") {
    assign({
      top: "0",
      "--sign": "-1",
      "--y": "-100%",
      "--lift": "1"
    });
  } else if (side === "bottom") {
    assign({
      bottom: "0",
      "--sign": "1",
      "--y": "100%",
      "--lift": "-1"
    });
  }
  if (mounted) {
    assign({
      "--y": "0",
      "--opacity": "1"
    });
    if (stacked) {
      assign({
        "--y": "calc(var(--lift) * var(--offset))",
        "--height": "var(--initial-height)"
      });
    }
  }
  if (!visible) {
    assign({
      "--opacity": "0",
      pointerEvents: "none"
    });
  }
  if (sibling && overlap) {
    assign({
      "--base-scale": "var(--index) * 0.05 + 1",
      "--y": "calc(var(--lift-amount) * var(--index))",
      "--scale": "calc(-1 * var(--base-scale))",
      "--height": "var(--first-height)"
    });
    if (!visible) {
      assign({
        "--y": "calc(var(--sign) * 40%)"
      });
    }
  }
  if (sibling && stacked && !visible) {
    assign({
      "--y": "calc(var(--lift) * var(--offset) + var(--lift) * -100%)"
    });
  }
  if (frontmost && !visible) {
    assign({
      "--y": "calc(var(--lift) * -100%)"
    });
  }
  return styles;
}
function getGhostBeforeStyle(service, visible) {
  const { computed } = service;
  const styles = {
    position: "absolute",
    inset: "0",
    scale: "1 2",
    pointerEvents: visible ? "none" : "auto"
  };
  const assign = (overrides) => Object.assign(styles, overrides);
  if (computed("frontmost") && !visible) {
    assign({
      height: "calc(var(--initial-height) + 80%)"
    });
  }
  return styles;
}
function getGhostAfterStyle() {
  return {
    position: "absolute",
    left: "0",
    height: "calc(var(--gap) + 2px)",
    bottom: "100%",
    width: "100%"
  };
}
function groupConnect(service, normalize4) {
  const { context, prop, send, refs, computed } = service;
  return {
    getCount() {
      return context.get("toasts").length;
    },
    getToasts() {
      return context.get("toasts");
    },
    getGroupProps(options = {}) {
      const { label = "Notifications" } = options;
      const { hotkey } = prop("store").attrs;
      const hotkeyLabel = hotkey.join("+").replace(/Key/g, "").replace(/Digit/g, "");
      const placement = computed("placement");
      const [side, align = "center"] = placement.split("-");
      return normalize4.element({
        ...parts40.group.attrs,
        dir: prop("dir"),
        tabIndex: -1,
        "aria-label": `${placement} ${label} ${hotkeyLabel}`,
        id: getRegionId(placement),
        "data-placement": placement,
        "data-side": side,
        "data-align": align,
        "aria-live": "polite",
        role: "region",
        style: getGroupPlacementStyle(service, placement),
        onMouseMove() {
          send({ type: "REGION.POINTER_ENTER", placement });
        },
        onMouseLeave() {
          send({ type: "REGION.POINTER_LEAVE", placement });
        },
        onFocus(event) {
          send({ type: "REGION.FOCUS", target: event.relatedTarget });
        },
        onBlur(event) {
          if (refs.get("isFocusWithin") && !contains(event.currentTarget, event.relatedTarget)) {
            queueMicrotask(() => send({ type: "REGION.BLUR" }));
          }
        }
      });
    },
    subscribe(fn) {
      const store2 = prop("store");
      return store2.subscribe(() => fn(context.get("toasts")));
    }
  };
}
var groupMachine = createMachine({
  props({ props: props43 }) {
    return {
      dir: "ltr",
      id: uuid(),
      ...props43,
      store: props43.store
    };
  },
  initialState({ prop }) {
    return prop("store").attrs.overlap ? "overlap" : "stack";
  },
  refs() {
    return {
      lastFocusedEl: null,
      isFocusWithin: false,
      dismissableCleanup: void 0
    };
  },
  context({ bindable }) {
    return {
      toasts: bindable(() => ({
        defaultValue: [],
        sync: true,
        hash: (toasts) => toasts.map((t) => t.id).join(",")
      })),
      heights: bindable(() => ({
        defaultValue: [],
        sync: true
      }))
    };
  },
  computed: {
    count: ({ context }) => context.get("toasts").length,
    overlap: ({ prop }) => prop("store").attrs.overlap,
    placement: ({ prop }) => prop("store").attrs.placement
  },
  effects: ["subscribeToStore", "trackDocumentVisibility", "trackHotKeyPress"],
  watch({ track, context, action }) {
    track([() => context.hash("toasts")], () => {
      queueMicrotask(() => {
        action(["collapsedIfEmpty", "setDismissableBranch"]);
      });
    });
  },
  exit: ["clearDismissableBranch", "clearLastFocusedEl"],
  on: {
    "DOC.HOTKEY": {
      actions: ["focusRegionEl"]
    },
    "REGION.BLUR": [
      {
        guard: "isOverlapping",
        target: "overlap",
        actions: ["collapseToasts", "resumeToasts", "restoreLastFocusedEl"]
      },
      {
        target: "stack",
        actions: ["resumeToasts", "restoreLastFocusedEl"]
      }
    ],
    "TOAST.REMOVE": {
      actions: ["removeToast", "removeHeight"]
    },
    "TOAST.PAUSE": {
      actions: ["pauseToasts"]
    }
  },
  states: {
    stack: {
      on: {
        "REGION.POINTER_LEAVE": [
          {
            guard: "isOverlapping",
            target: "overlap",
            actions: ["resumeToasts", "collapseToasts"]
          },
          {
            actions: ["resumeToasts"]
          }
        ],
        "REGION.OVERLAP": {
          target: "overlap",
          actions: ["collapseToasts"]
        },
        "REGION.FOCUS": {
          actions: ["setLastFocusedEl", "pauseToasts"]
        },
        "REGION.POINTER_ENTER": {
          actions: ["pauseToasts"]
        }
      }
    },
    overlap: {
      on: {
        "REGION.STACK": {
          target: "stack",
          actions: ["expandToasts"]
        },
        "REGION.POINTER_ENTER": {
          target: "stack",
          actions: ["pauseToasts", "expandToasts"]
        },
        "REGION.FOCUS": {
          target: "stack",
          actions: ["setLastFocusedEl", "pauseToasts", "expandToasts"]
        }
      }
    }
  },
  implementations: {
    guards: {
      isOverlapping: ({ computed }) => computed("overlap")
    },
    effects: {
      subscribeToStore({ context, prop }) {
        return prop("store").subscribe((toast) => {
          if (toast.dismiss) {
            context.set("toasts", (prev2) => prev2.filter((t) => t.id !== toast.id));
            return;
          }
          context.set("toasts", (prev2) => {
            const index = prev2.findIndex((t) => t.id === toast.id);
            if (index !== -1) {
              return [...prev2.slice(0, index), { ...prev2[index], ...toast }, ...prev2.slice(index + 1)];
            }
            return [toast, ...prev2];
          });
        });
      },
      trackHotKeyPress({ prop, send }) {
        const handleKeyDown = (event) => {
          const { hotkey } = prop("store").attrs;
          const isHotkeyPressed = hotkey.every((key) => event[key] || event.code === key);
          if (!isHotkeyPressed) return;
          send({ type: "DOC.HOTKEY" });
        };
        return addDomEvent(document, "keydown", handleKeyDown, { capture: true });
      },
      trackDocumentVisibility({ prop, send, scope }) {
        const { pauseOnPageIdle } = prop("store").attrs;
        if (!pauseOnPageIdle) return;
        const doc = scope.getDoc();
        return addDomEvent(doc, "visibilitychange", () => {
          const isHidden = doc.visibilityState === "hidden";
          send({ type: isHidden ? "PAUSE_ALL" : "RESUME_ALL" });
        });
      }
    },
    actions: {
      setDismissableBranch({ refs, context, computed, scope }) {
        var _a8;
        const toasts = context.get("toasts");
        const placement = computed("placement");
        const hasToasts = toasts.length > 0;
        if (!hasToasts) {
          (_a8 = refs.get("dismissableCleanup")) == null ? void 0 : _a8();
          return;
        }
        if (hasToasts && refs.get("dismissableCleanup")) {
          return;
        }
        const groupEl = () => getRegionEl(scope, placement);
        const cleanup = trackDismissableBranch(groupEl, { defer: true });
        refs.set("dismissableCleanup", cleanup);
      },
      clearDismissableBranch({ refs }) {
        var _a8;
        (_a8 = refs.get("dismissableCleanup")) == null ? void 0 : _a8();
      },
      focusRegionEl({ scope, computed }) {
        queueMicrotask(() => {
          var _a8;
          (_a8 = getRegionEl(scope, computed("placement"))) == null ? void 0 : _a8.focus();
        });
      },
      pauseToasts({ prop }) {
        prop("store").pause();
      },
      resumeToasts({ prop }) {
        prop("store").resume();
      },
      expandToasts({ prop }) {
        prop("store").expand();
      },
      collapseToasts({ prop }) {
        prop("store").collapse();
      },
      removeToast({ prop, event }) {
        prop("store").remove(event.id);
      },
      removeHeight({ event, context }) {
        if ((event == null ? void 0 : event.id) == null) return;
        queueMicrotask(() => {
          context.set("heights", (heights) => heights.filter((height) => height.id !== event.id));
        });
      },
      collapsedIfEmpty({ send, computed }) {
        if (!computed("overlap") || computed("count") > 1) return;
        send({ type: "REGION.OVERLAP" });
      },
      setLastFocusedEl({ refs, event }) {
        if (refs.get("isFocusWithin") || !event.target) return;
        refs.set("isFocusWithin", true);
        refs.set("lastFocusedEl", event.target);
      },
      restoreLastFocusedEl({ refs }) {
        var _a8;
        if (!refs.get("lastFocusedEl")) return;
        (_a8 = refs.get("lastFocusedEl")) == null ? void 0 : _a8.focus({ preventScroll: true });
        refs.set("lastFocusedEl", null);
        refs.set("isFocusWithin", false);
      },
      clearLastFocusedEl({ refs }) {
        var _a8;
        if (!refs.get("lastFocusedEl")) return;
        (_a8 = refs.get("lastFocusedEl")) == null ? void 0 : _a8.focus({ preventScroll: true });
        refs.set("lastFocusedEl", null);
        refs.set("isFocusWithin", false);
      }
    }
  }
});
function connect38(service, normalize4) {
  const { state: state2, send, prop, scope, context, computed } = service;
  const visible = state2.hasTag("visible");
  const paused = state2.hasTag("paused");
  const mounted = context.get("mounted");
  const frontmost = computed("frontmost");
  const placement = prop("parent").computed("placement");
  const type = prop("type");
  const stacked = prop("stacked");
  const title = prop("title");
  const description = prop("description");
  const action = prop("action");
  const [side, align = "center"] = placement.split("-");
  return {
    type,
    title,
    description,
    placement,
    visible,
    paused,
    closable: !!prop("closable"),
    pause() {
      send({ type: "PAUSE" });
    },
    resume() {
      send({ type: "RESUME" });
    },
    dismiss() {
      send({ type: "DISMISS", src: "programmatic" });
    },
    getRootProps() {
      return normalize4.element({
        ...parts40.root.attrs,
        dir: prop("dir"),
        id: getRootId30(scope),
        "data-state": visible ? "open" : "closed",
        "data-type": type,
        "data-placement": placement,
        "data-align": align,
        "data-side": side,
        "data-mounted": dataAttr(mounted),
        "data-paused": dataAttr(paused),
        "data-first": dataAttr(frontmost),
        "data-sibling": dataAttr(!frontmost),
        "data-stack": dataAttr(stacked),
        "data-overlap": dataAttr(!stacked),
        role: "status",
        "aria-atomic": "true",
        "aria-describedby": description ? getDescriptionId3(scope) : void 0,
        "aria-labelledby": title ? getTitleId3(scope) : void 0,
        tabIndex: 0,
        style: getPlacementStyle(service, visible),
        onKeyDown(event) {
          if (event.defaultPrevented) return;
          if (event.key == "Escape") {
            send({ type: "DISMISS", src: "keyboard" });
            event.preventDefault();
          }
        }
      });
    },
    /* Leave a ghost div to avoid setting hover to false when transitioning out */
    getGhostBeforeProps() {
      return normalize4.element({
        "data-ghost": "before",
        style: getGhostBeforeStyle(service, visible)
      });
    },
    /* Needed to avoid setting hover to false when in between toasts */
    getGhostAfterProps() {
      return normalize4.element({
        "data-ghost": "after",
        style: getGhostAfterStyle()
      });
    },
    getTitleProps() {
      return normalize4.element({
        ...parts40.title.attrs,
        id: getTitleId3(scope)
      });
    },
    getDescriptionProps() {
      return normalize4.element({
        ...parts40.description.attrs,
        id: getDescriptionId3(scope)
      });
    },
    getActionTriggerProps() {
      return normalize4.button({
        ...parts40.actionTrigger.attrs,
        type: "button",
        onClick(event) {
          var _a8;
          if (event.defaultPrevented) return;
          (_a8 = action == null ? void 0 : action.onClick) == null ? void 0 : _a8.call(action);
          send({ type: "DISMISS", src: "user" });
        }
      });
    },
    getCloseTriggerProps() {
      return normalize4.button({
        id: getCloseTriggerId3(scope),
        ...parts40.closeTrigger.attrs,
        type: "button",
        "aria-label": "Dismiss notification",
        onClick(event) {
          if (event.defaultPrevented) return;
          send({ type: "DISMISS", src: "user" });
        }
      });
    }
  };
}
var { not: not12 } = createGuards();
var machine38 = createMachine({
  props({ props: props43 }) {
    ensureProps(props43, ["id", "type", "parent", "removeDelay"], "toast");
    return {
      closable: true,
      ...props43,
      duration: getToastDuration(props43.duration, props43.type)
    };
  },
  initialState({ prop }) {
    const persist = prop("type") === "loading" || prop("duration") === Infinity;
    return persist ? "visible:persist" : "visible";
  },
  context({ prop, bindable }) {
    return {
      remainingTime: bindable(() => ({
        defaultValue: getToastDuration(prop("duration"), prop("type"))
      })),
      createdAt: bindable(() => ({
        defaultValue: Date.now()
      })),
      mounted: bindable(() => ({
        defaultValue: false
      })),
      initialHeight: bindable(() => ({
        defaultValue: 0
      }))
    };
  },
  refs() {
    return {
      closeTimerStartTime: Date.now(),
      lastCloseStartTimerStartTime: 0
    };
  },
  computed: {
    zIndex: ({ prop }) => {
      const toasts = prop("parent").context.get("toasts");
      const index = toasts.findIndex((toast) => toast.id === prop("id"));
      return toasts.length - index;
    },
    height: ({ prop }) => {
      const heights = prop("parent").context.get("heights");
      const height = heights.find((height2) => height2.id === prop("id"));
      return (height == null ? void 0 : height.height) ?? 0;
    },
    heightIndex: ({ prop }) => {
      const heights = prop("parent").context.get("heights");
      return heights.findIndex((height) => height.id === prop("id"));
    },
    frontmost: ({ prop }) => prop("index") === 0,
    heightBefore: ({ prop }) => {
      const heights = prop("parent").context.get("heights");
      const heightIndex = heights.findIndex((height) => height.id === prop("id"));
      return heights.reduce((prev2, curr, reducerIndex) => {
        if (reducerIndex >= heightIndex) return prev2;
        return prev2 + curr.height;
      }, 0);
    },
    shouldPersist: ({ prop }) => prop("type") === "loading" || prop("duration") === Infinity
  },
  watch({ track, prop, send }) {
    track([() => prop("message")], () => {
      const message = prop("message");
      if (message) send({ type: message, src: "programmatic" });
    });
    track([() => prop("type"), () => prop("duration")], () => {
      send({ type: "UPDATE" });
    });
  },
  on: {
    UPDATE: [
      {
        guard: "shouldPersist",
        target: "visible:persist",
        actions: ["resetCloseTimer"]
      },
      {
        target: "visible:updating",
        actions: ["resetCloseTimer"]
      }
    ],
    MEASURE: {
      actions: ["measureHeight"]
    }
  },
  entry: ["setMounted", "measureHeight", "invokeOnVisible"],
  effects: ["trackHeight"],
  states: {
    "visible:updating": {
      tags: ["visible", "updating"],
      effects: ["waitForNextTick"],
      on: {
        SHOW: {
          target: "visible"
        }
      }
    },
    "visible:persist": {
      tags: ["visible", "paused"],
      on: {
        RESUME: {
          guard: not12("isLoadingType"),
          target: "visible",
          actions: ["setCloseTimer"]
        },
        DISMISS: {
          target: "dismissing"
        }
      }
    },
    visible: {
      tags: ["visible"],
      effects: ["waitForDuration"],
      on: {
        DISMISS: {
          target: "dismissing"
        },
        PAUSE: {
          target: "visible:persist",
          actions: ["syncRemainingTime"]
        }
      }
    },
    dismissing: {
      entry: ["invokeOnDismiss"],
      effects: ["waitForRemoveDelay"],
      on: {
        REMOVE: {
          target: "unmounted",
          actions: ["notifyParentToRemove"]
        }
      }
    },
    unmounted: {
      entry: ["invokeOnUnmount"]
    }
  },
  implementations: {
    effects: {
      waitForRemoveDelay({ prop, send }) {
        return setRafTimeout(() => {
          send({ type: "REMOVE", src: "timer" });
        }, prop("removeDelay"));
      },
      waitForDuration({ send, context, computed }) {
        if (computed("shouldPersist")) return;
        return setRafTimeout(() => {
          send({ type: "DISMISS", src: "timer" });
        }, context.get("remainingTime"));
      },
      waitForNextTick({ send }) {
        return setRafTimeout(() => {
          send({ type: "SHOW", src: "timer" });
        }, 0);
      },
      trackHeight({ scope, prop }) {
        let cleanup;
        raf(() => {
          const rootEl = getRootEl11(scope);
          if (!rootEl) return;
          const syncHeight = () => {
            const originalHeight = rootEl.style.height;
            rootEl.style.height = "auto";
            const height = rootEl.getBoundingClientRect().height;
            rootEl.style.height = originalHeight;
            const item = { id: prop("id"), height };
            setHeight(prop("parent"), item);
          };
          const win = scope.getWin();
          const observer = new win.MutationObserver(syncHeight);
          observer.observe(rootEl, {
            childList: true,
            subtree: true,
            characterData: true
          });
          cleanup = () => observer.disconnect();
        });
        return () => cleanup == null ? void 0 : cleanup();
      }
    },
    guards: {
      isLoadingType: ({ prop }) => prop("type") === "loading",
      shouldPersist: ({ computed }) => computed("shouldPersist")
    },
    actions: {
      setMounted({ context }) {
        raf(() => {
          context.set("mounted", true);
        });
      },
      measureHeight({ scope, prop, context }) {
        queueMicrotask(() => {
          const rootEl = getRootEl11(scope);
          if (!rootEl) return;
          const originalHeight = rootEl.style.height;
          rootEl.style.height = "auto";
          const height = rootEl.getBoundingClientRect().height;
          rootEl.style.height = originalHeight;
          context.set("initialHeight", height);
          const item = { id: prop("id"), height };
          setHeight(prop("parent"), item);
        });
      },
      setCloseTimer({ refs }) {
        refs.set("closeTimerStartTime", Date.now());
      },
      resetCloseTimer({ context, refs, prop }) {
        refs.set("closeTimerStartTime", Date.now());
        context.set("remainingTime", getToastDuration(prop("duration"), prop("type")));
      },
      syncRemainingTime({ context, refs }) {
        context.set("remainingTime", (prev2) => {
          const closeTimerStartTime = refs.get("closeTimerStartTime");
          const elapsedTime = Date.now() - closeTimerStartTime;
          refs.set("lastCloseStartTimerStartTime", Date.now());
          return prev2 - elapsedTime;
        });
      },
      notifyParentToRemove({ prop }) {
        const parent = prop("parent");
        parent.send({ type: "TOAST.REMOVE", id: prop("id") });
      },
      invokeOnDismiss({ prop, event }) {
        var _a8;
        (_a8 = prop("onStatusChange")) == null ? void 0 : _a8({ status: "dismissing", src: event.src });
      },
      invokeOnUnmount({ prop }) {
        var _a8;
        (_a8 = prop("onStatusChange")) == null ? void 0 : _a8({ status: "unmounted" });
      },
      invokeOnVisible({ prop }) {
        var _a8;
        (_a8 = prop("onStatusChange")) == null ? void 0 : _a8({ status: "visible" });
      }
    }
  }
});
function setHeight(parent, item) {
  const { id, height } = item;
  parent.context.set("heights", (prev2) => {
    const alreadyExists = prev2.find((i) => i.id === id);
    if (!alreadyExists) {
      return [{ id, height }, ...prev2];
    } else {
      return prev2.map((i) => i.id === id ? { ...i, height } : i);
    }
  });
}
var withDefaults = (options, defaults2) => {
  return { ...defaults2, ...compact2(options) };
};
function createToastStore(props43) {
  const attrs = withDefaults(props43, {
    placement: "bottom",
    overlap: false,
    max: 24,
    gap: 16,
    offsets: "1rem",
    hotkey: ["altKey", "KeyT"],
    removeDelay: 200,
    pauseOnPageIdle: true
  });
  let subscribers = [];
  let toasts = [];
  let dismissedToasts = /* @__PURE__ */ new Set();
  let toastQueue = [];
  const subscribe3 = (subscriber) => {
    subscribers.push(subscriber);
    return () => {
      const index = subscribers.indexOf(subscriber);
      subscribers.splice(index, 1);
    };
  };
  const publish = (data) => {
    subscribers.forEach((subscriber) => subscriber(data));
    return data;
  };
  const addToast = (data) => {
    if (toasts.length >= attrs.max) {
      toastQueue.push(data);
      return;
    }
    publish(data);
    toasts.unshift(data);
  };
  const processQueue = () => {
    while (toastQueue.length > 0 && toasts.length < attrs.max) {
      const nextToast = toastQueue.shift();
      if (nextToast) {
        publish(nextToast);
        toasts.unshift(nextToast);
      }
    }
  };
  const create = (data) => {
    const id = data.id ?? `toast:${uuid()}`;
    const exists = toasts.find((toast) => toast.id === id);
    if (dismissedToasts.has(id)) dismissedToasts.delete(id);
    if (exists) {
      toasts = toasts.map((toast) => {
        if (toast.id === id) {
          return publish({ ...toast, ...data, id });
        }
        return toast;
      });
    } else {
      addToast({
        id,
        duration: attrs.duration,
        removeDelay: attrs.removeDelay,
        type: "info",
        ...data,
        stacked: !attrs.overlap,
        gap: attrs.gap
      });
    }
    return id;
  };
  const remove3 = (id) => {
    dismissedToasts.add(id);
    if (!id) {
      toasts.forEach((toast) => {
        subscribers.forEach((subscriber) => subscriber({ id: toast.id, dismiss: true }));
      });
      toasts = [];
      toastQueue = [];
    } else {
      subscribers.forEach((subscriber) => subscriber({ id, dismiss: true }));
      toasts = toasts.filter((toast) => toast.id !== id);
      processQueue();
    }
    return id;
  };
  const error = (data) => {
    return create({ ...data, type: "error" });
  };
  const success = (data) => {
    return create({ ...data, type: "success" });
  };
  const info = (data) => {
    return create({ ...data, type: "info" });
  };
  const warning = (data) => {
    return create({ ...data, type: "warning" });
  };
  const loading = (data) => {
    return create({ ...data, type: "loading" });
  };
  const getVisibleToasts = () => {
    return toasts.filter((toast) => !dismissedToasts.has(toast.id));
  };
  const getCount = () => {
    return toasts.length;
  };
  const promise = (promise2, options, shared = {}) => {
    if (!options) return;
    let id = void 0;
    if (options.loading !== void 0) {
      id = create({
        ...shared,
        ...options.loading,
        promise: promise2,
        type: "loading"
      });
    }
    let removable = id !== void 0;
    let result;
    const prom = runIfFn(promise2).then(async (response) => {
      result = ["resolve", response];
      if (isHttpResponse(response) && !response.ok) {
        removable = false;
        const errorOptions = runIfFn(options.error, `HTTP Error! status: ${response.status}`);
        create({ ...shared, ...errorOptions, id, type: "error" });
      } else if (options.success !== void 0) {
        removable = false;
        const successOptions = runIfFn(options.success, response);
        create({ ...shared, ...successOptions, id, type: "success" });
      }
    }).catch(async (error2) => {
      result = ["reject", error2];
      if (options.error !== void 0) {
        removable = false;
        const errorOptions = runIfFn(options.error, error2);
        create({ ...shared, ...errorOptions, id, type: "error" });
      }
    }).finally(() => {
      var _a8;
      if (removable) {
        remove3(id);
        id = void 0;
      }
      (_a8 = options.finally) == null ? void 0 : _a8.call(options);
    });
    const unwrap = () => new Promise(
      (resolve, reject) => prom.then(() => result[0] === "reject" ? reject(result[1]) : resolve(result[1])).catch(reject)
    );
    return { id, unwrap };
  };
  const update = (id, data) => {
    return create({ id, ...data });
  };
  const pause = (id) => {
    if (id != null) {
      toasts = toasts.map((toast) => {
        if (toast.id === id) return publish({ ...toast, message: "PAUSE" });
        return toast;
      });
    } else {
      toasts = toasts.map((toast) => publish({ ...toast, message: "PAUSE" }));
    }
  };
  const resume = (id) => {
    if (id != null) {
      toasts = toasts.map((toast) => {
        if (toast.id === id) return publish({ ...toast, message: "RESUME" });
        return toast;
      });
    } else {
      toasts = toasts.map((toast) => publish({ ...toast, message: "RESUME" }));
    }
  };
  const dismiss = (id) => {
    if (id != null) {
      toasts = toasts.map((toast) => {
        if (toast.id === id) return publish({ ...toast, message: "DISMISS" });
        return toast;
      });
    } else {
      toasts = toasts.map((toast) => publish({ ...toast, message: "DISMISS" }));
    }
  };
  const isVisible = (id) => {
    return !dismissedToasts.has(id) && !!toasts.find((toast) => toast.id === id);
  };
  const isDismissed = (id) => {
    return dismissedToasts.has(id);
  };
  const expand = () => {
    toasts = toasts.map((toast) => publish({ ...toast, stacked: true }));
  };
  const collapse = () => {
    toasts = toasts.map((toast) => publish({ ...toast, stacked: false }));
  };
  return {
    attrs,
    subscribe: subscribe3,
    create,
    update,
    remove: remove3,
    dismiss,
    error,
    success,
    info,
    warning,
    loading,
    getVisibleToasts,
    getCount,
    promise,
    pause,
    resume,
    isVisible,
    isDismissed,
    expand,
    collapse
  };
}
var isHttpResponse = (data) => {
  return data && typeof data === "object" && "ok" in data && typeof data.ok === "boolean" && "status" in data && typeof data.status === "number";
};
var group = {
  connect: groupConnect,
  machine: groupMachine
};

// node_modules/@ark-ui/react/dist/components/toast/create-toaster.js
var createToaster = (props43) => {
  return createToastStore(props43);
};

// node_modules/@ark-ui/react/dist/components/toast/toast-action-trigger.js
var import_jsx_runtime407 = __toESM(require_jsx_runtime(), 1);
var import_react879 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/toast/use-toast-context.js
var [ToastProvider, useToastContext] = createContext3({
  name: "ToastContext",
  hookName: "useToastContext",
  providerName: "<ToastProvider />"
});

// node_modules/@ark-ui/react/dist/components/toast/toast-action-trigger.js
var ToastActionTrigger = (0, import_react879.forwardRef)((props43, ref) => {
  const toast = useToastContext();
  const mergedProps = mergeProps2(toast.getActionTriggerProps(), props43);
  return (0, import_jsx_runtime407.jsx)(ark.button, { ...mergedProps, ref });
});
ToastActionTrigger.displayName = "ToastActionTrigger";

// node_modules/@ark-ui/react/dist/components/toast/toast-close-trigger.js
var import_jsx_runtime408 = __toESM(require_jsx_runtime(), 1);
var import_react881 = __toESM(require_react(), 1);
var ToastCloseTrigger = (0, import_react881.forwardRef)((props43, ref) => {
  const toast = useToastContext();
  const mergedProps = mergeProps2(toast.getCloseTriggerProps(), props43);
  return (0, import_jsx_runtime408.jsx)(ark.button, { ...mergedProps, ref });
});
ToastCloseTrigger.displayName = "ToastCloseTrigger";

// node_modules/@ark-ui/react/dist/components/toast/toast-context.js
var ToastContext = (props43) => props43.children(useToastContext());

// node_modules/@ark-ui/react/dist/components/toast/toast-description.js
var import_jsx_runtime409 = __toESM(require_jsx_runtime(), 1);
var import_react883 = __toESM(require_react(), 1);
var ToastDescription = (0, import_react883.forwardRef)((props43, ref) => {
  const toast = useToastContext();
  const mergedProps = mergeProps2(toast.getDescriptionProps(), props43);
  return (0, import_jsx_runtime409.jsx)(ark.div, { ...mergedProps, ref });
});
ToastDescription.displayName = "ToastDescription";

// node_modules/@ark-ui/react/dist/components/toast/toast-root.js
var import_jsx_runtime410 = __toESM(require_jsx_runtime(), 1);
var import_react885 = __toESM(require_react(), 1);
var ToastRoot = (0, import_react885.forwardRef)((props43, ref) => {
  const toast = useToastContext();
  const mergedProps = mergeProps2(toast.getRootProps(), props43);
  return (0, import_jsx_runtime410.jsxs)("div", { ...mergedProps, ref, children: [
    (0, import_jsx_runtime410.jsx)("div", { ...toast.getGhostBeforeProps() }),
    props43.children,
    (0, import_jsx_runtime410.jsx)("div", { ...toast.getGhostAfterProps() })
  ] });
});
ToastRoot.displayName = "ToastRoot";

// node_modules/@ark-ui/react/dist/components/toast/toast-title.js
var import_jsx_runtime411 = __toESM(require_jsx_runtime(), 1);
var import_react887 = __toESM(require_react(), 1);
var ToastTitle = (0, import_react887.forwardRef)((props43, ref) => {
  const toast = useToastContext();
  const mergedProps = mergeProps2(toast.getTitleProps(), props43);
  return (0, import_jsx_runtime411.jsx)(ark.div, { ...mergedProps, ref });
});
ToastTitle.displayName = "ToastTitle";

// node_modules/@ark-ui/react/dist/components/toast/toaster.js
var import_jsx_runtime412 = __toESM(require_jsx_runtime(), 1);
var import_react889 = __toESM(require_react(), 1);
var Toaster = (0, import_react889.forwardRef)((props43, ref) => {
  const { toaster, children, ...localProps } = props43;
  const locale = useLocaleContext();
  const env = useEnvironmentContext();
  const service = useMachine(group.machine, {
    store: toaster,
    id: (0, import_react889.useId)(),
    dir: locale == null ? void 0 : locale.dir,
    getRootNode: env == null ? void 0 : env.getRootNode
  });
  const api = group.connect(service, normalizeProps);
  const mergedProps = mergeProps2(api.getGroupProps(), localProps);
  return (0, import_jsx_runtime412.jsx)(ark.div, { ...mergedProps, ref, children: api.getToasts().map((toast2, index) => (0, import_jsx_runtime412.jsx)(ToastActor, { value: toast2, parent: service, index, children: (ctx) => children(ctx) }, toast2.id)) });
});
Toaster.displayName = "Toaster";
var ToastActor = (props43) => {
  const env = useEnvironmentContext();
  const localProps = {
    ...props43.value,
    parent: props43.parent,
    index: props43.index,
    getRootNode: env.getRootNode
  };
  const service = useMachine(machine38, { ...localProps });
  const api = connect38(service, normalizeProps);
  return (0, import_jsx_runtime412.jsx)(ToastProvider, { value: api, children: props43.children(props43.value) });
};
ToastActor.displayName = "ToastActor";

// node_modules/@ark-ui/react/dist/components/toast/toast.js
var toast_exports = {};
__export(toast_exports, {
  ActionTrigger: () => ToastActionTrigger,
  CloseTrigger: () => ToastCloseTrigger,
  Context: () => ToastContext,
  Description: () => ToastDescription,
  Root: () => ToastRoot,
  Title: () => ToastTitle
});

// node_modules/@ark-ui/react/dist/components/toggle/toggle.js
var toggle_exports = {};
__export(toggle_exports, {
  Context: () => ToggleContext,
  Indicator: () => ToggleIndicator,
  Root: () => ToggleRoot,
  toggleAnatomy: () => toggleAnatomy
});

// node_modules/@ark-ui/react/dist/components/toggle/use-toggle-context.js
var [ToggleProvider, useToggleContext] = createContext3({
  name: "ToggleContext",
  hookName: "useToggleContext",
  providerName: "<ToggleProvider />"
});

// node_modules/@ark-ui/react/dist/components/toggle/toggle-context.js
var ToggleContext = (props43) => props43.children(useToggleContext());

// node_modules/@ark-ui/react/dist/components/toggle/toggle-indicator.js
var import_jsx_runtime413 = __toESM(require_jsx_runtime(), 1);
var import_react891 = __toESM(require_react(), 1);
var ToggleIndicator = (0, import_react891.forwardRef)((props43, ref) => {
  const { children, fallback: fallback4, ...restProps } = props43;
  const toggle = useToggleContext();
  const mergedProps = mergeProps2(toggle.getIndicatorProps(), restProps);
  return (0, import_jsx_runtime413.jsx)(ark.div, { ...mergedProps, ref, children: toggle.pressed ? children : fallback4 });
});
ToggleIndicator.displayName = "ToggleIndicator";

// node_modules/@ark-ui/react/dist/components/toggle/toggle-root.js
var import_jsx_runtime414 = __toESM(require_jsx_runtime(), 1);
var import_react894 = __toESM(require_react(), 1);

// node_modules/@zag-js/toggle/dist/index.mjs
var anatomy38 = createAnatomy("toggle", ["root", "indicator"]);
var parts41 = anatomy38.build();
function connect39(service, normalize4) {
  const { context, prop, send } = service;
  const pressed = context.get("pressed");
  return {
    pressed,
    disabled: !!prop("disabled"),
    setPressed(value) {
      send({ type: "PRESS.SET", value });
    },
    getRootProps() {
      return normalize4.element({
        type: "button",
        ...parts41.root.attrs,
        disabled: prop("disabled"),
        "aria-pressed": pressed,
        "data-state": pressed ? "on" : "off",
        "data-pressed": dataAttr(pressed),
        "data-disabled": dataAttr(prop("disabled")),
        onClick(event) {
          if (event.defaultPrevented) return;
          if (prop("disabled")) return;
          send({ type: "PRESS.TOGGLE" });
        }
      });
    },
    getIndicatorProps() {
      return normalize4.element({
        ...parts41.indicator.attrs,
        "data-disabled": dataAttr(prop("disabled")),
        "data-pressed": dataAttr(pressed),
        "data-state": pressed ? "on" : "off"
      });
    }
  };
}
var machine39 = createMachine({
  props({ props: props210 }) {
    return {
      defaultPressed: false,
      ...props210
    };
  },
  context({ prop, bindable }) {
    return {
      pressed: bindable(() => ({
        value: prop("pressed"),
        defaultValue: prop("defaultPressed"),
        onChange(value) {
          var _a8;
          (_a8 = prop("onPressedChange")) == null ? void 0 : _a8(value);
        }
      }))
    };
  },
  initialState() {
    return "idle";
  },
  on: {
    "PRESS.TOGGLE": {
      actions: ["togglePressed"]
    },
    "PRESS.SET": {
      actions: ["setPressed"]
    }
  },
  states: {
    idle: {}
  },
  implementations: {
    actions: {
      togglePressed({ context }) {
        context.set("pressed", !context.get("pressed"));
      },
      setPressed({ context, event }) {
        context.set("pressed", event.value);
      }
    }
  }
});
var props38 = createProps()(["defaultPressed", "pressed", "onPressedChange", "disabled"]);
var splitProps38 = createSplitProps(props38);

// node_modules/@ark-ui/react/dist/components/toggle/use-toggle.js
function useToggle(props43) {
  const service = useMachine(machine39, props43);
  return connect39(service, normalizeProps);
}

// node_modules/@ark-ui/react/dist/components/toggle/toggle-root.js
var ToggleRoot = (0, import_react894.forwardRef)((props43, ref) => {
  const [useToggleProps, localProps] = createSplitProps2()(props43, [
    "pressed",
    "defaultPressed",
    "disabled",
    "onPressedChange"
  ]);
  const toggle = useToggle(useToggleProps);
  const mergedProps = mergeProps2(toggle.getRootProps(), localProps);
  return (0, import_jsx_runtime414.jsx)(ToggleProvider, { value: toggle, children: (0, import_jsx_runtime414.jsx)(ark.button, { ...mergedProps, ref }) });
});
ToggleRoot.displayName = "ToggleRoot";

// node_modules/@ark-ui/react/dist/components/toggle/toggle.anatomy.js
var toggleAnatomy = createAnatomy("toggle", ["root", "indicator"]);
toggleAnatomy.build();

// node_modules/@ark-ui/react/dist/components/toggle-group/use-toggle-group-context.js
var [ToggleGroupProvider, useToggleGroupContext] = createContext3({
  name: "ToggleGroupContext",
  hookName: "useToggleGroupContext",
  providerName: "<ToggleGroupProvider />"
});

// node_modules/@ark-ui/react/dist/components/toggle-group/toggle-group-item.js
var import_jsx_runtime415 = __toESM(require_jsx_runtime(), 1);
var import_react896 = __toESM(require_react(), 1);
var ToggleGroupItem = (0, import_react896.forwardRef)((props43, ref) => {
  const [itemProps14, localProps] = createSplitProps2()(props43, ["value", "disabled"]);
  const toggleGroup = useToggleGroupContext();
  const mergedProps = mergeProps2(toggleGroup.getItemProps(itemProps14), localProps);
  return (0, import_jsx_runtime415.jsx)(ark.button, { ...mergedProps, ref });
});
ToggleGroupItem.displayName = "ToggleGroupItem";

// node_modules/@ark-ui/react/dist/components/toggle-group/toggle-group-root.js
var import_jsx_runtime416 = __toESM(require_jsx_runtime(), 1);
var import_react900 = __toESM(require_react(), 1);

// node_modules/@zag-js/toggle-group/dist/index.mjs
var anatomy39 = createAnatomy("toggle-group").parts("root", "item");
var parts42 = anatomy39.build();
var getRootId31 = (ctx) => {
  var _a8;
  return ((_a8 = ctx.ids) == null ? void 0 : _a8.root) ?? `toggle-group:${ctx.id}`;
};
var getItemId12 = (ctx, value) => {
  var _a8, _b7;
  return ((_b7 = (_a8 = ctx.ids) == null ? void 0 : _a8.item) == null ? void 0 : _b7.call(_a8, value)) ?? `toggle-group:${ctx.id}:${value}`;
};
var getRootEl12 = (ctx) => ctx.getById(getRootId31(ctx));
var getElements3 = (ctx) => {
  const ownerId = CSS.escape(getRootId31(ctx));
  const selector = `[data-ownedby='${ownerId}']:not([data-disabled])`;
  return queryAll(getRootEl12(ctx), selector);
};
var getFirstEl3 = (ctx) => first(getElements3(ctx));
var getLastEl3 = (ctx) => last(getElements3(ctx));
var getNextEl3 = (ctx, id, loopFocus) => nextById(getElements3(ctx), id, loopFocus);
var getPrevEl3 = (ctx, id, loopFocus) => prevById(getElements3(ctx), id, loopFocus);
function connect40(service, normalize4) {
  const { context, send, prop, scope } = service;
  const value = context.get("value");
  const disabled = prop("disabled");
  const isSingle = !prop("multiple");
  const rovingFocus = prop("rovingFocus");
  const isHorizontal = prop("orientation") === "horizontal";
  function getItemState(props210) {
    const id = getItemId12(scope, props210.value);
    return {
      id,
      disabled: Boolean(props210.disabled || disabled),
      pressed: !!value.includes(props210.value),
      focused: context.get("focusedId") === id
    };
  }
  return {
    value,
    setValue(value2) {
      send({ type: "VALUE.SET", value: value2 });
    },
    getRootProps() {
      return normalize4.element({
        ...parts42.root.attrs,
        id: getRootId31(scope),
        dir: prop("dir"),
        role: isSingle ? "radiogroup" : "group",
        tabIndex: context.get("isTabbingBackward") ? -1 : 0,
        "data-disabled": dataAttr(disabled),
        "data-orientation": prop("orientation"),
        "data-focus": dataAttr(context.get("focusedId") != null),
        style: { outline: "none" },
        onMouseDown() {
          if (disabled) return;
          send({ type: "ROOT.MOUSE_DOWN" });
        },
        onFocus(event) {
          if (disabled) return;
          if (event.currentTarget !== getEventTarget(event)) return;
          if (context.get("isClickFocus")) return;
          if (context.get("isTabbingBackward")) return;
          send({ type: "ROOT.FOCUS" });
        },
        onBlur() {
          if (disabled) return;
          send({ type: "ROOT.BLUR" });
        }
      });
    },
    getItemState,
    getItemProps(props210) {
      const itemState = getItemState(props210);
      const rovingTabIndex = itemState.focused ? 0 : -1;
      return normalize4.button({
        ...parts42.item.attrs,
        id: itemState.id,
        type: "button",
        "data-ownedby": getRootId31(scope),
        "data-focus": dataAttr(itemState.focused),
        disabled: itemState.disabled,
        tabIndex: rovingFocus ? rovingTabIndex : void 0,
        // radio
        role: isSingle ? "radio" : void 0,
        "aria-checked": isSingle ? itemState.pressed : void 0,
        "aria-pressed": isSingle ? void 0 : itemState.pressed,
        //
        "data-disabled": dataAttr(itemState.disabled),
        "data-orientation": prop("orientation"),
        dir: prop("dir"),
        "data-state": itemState.pressed ? "on" : "off",
        onFocus() {
          if (itemState.disabled) return;
          send({ type: "TOGGLE.FOCUS", id: itemState.id });
        },
        onClick(event) {
          if (itemState.disabled) return;
          send({ type: "TOGGLE.CLICK", id: itemState.id, value: props210.value });
          if (isSafari()) {
            event.currentTarget.focus({ preventScroll: true });
          }
        },
        onKeyDown(event) {
          if (event.defaultPrevented) return;
          if (!isSelfTarget(event)) return;
          if (itemState.disabled) return;
          const keyMap2 = {
            Tab(event2) {
              const isShiftTab = event2.shiftKey;
              send({ type: "TOGGLE.SHIFT_TAB", isShiftTab });
            },
            ArrowLeft() {
              if (!rovingFocus || !isHorizontal) return;
              send({ type: "TOGGLE.FOCUS_PREV" });
            },
            ArrowRight() {
              if (!rovingFocus || !isHorizontal) return;
              send({ type: "TOGGLE.FOCUS_NEXT" });
            },
            ArrowUp() {
              if (!rovingFocus || isHorizontal) return;
              send({ type: "TOGGLE.FOCUS_PREV" });
            },
            ArrowDown() {
              if (!rovingFocus || isHorizontal) return;
              send({ type: "TOGGLE.FOCUS_NEXT" });
            },
            Home() {
              if (!rovingFocus) return;
              send({ type: "TOGGLE.FOCUS_FIRST" });
            },
            End() {
              if (!rovingFocus) return;
              send({ type: "TOGGLE.FOCUS_LAST" });
            }
          };
          const exec = keyMap2[getEventKey(event)];
          if (exec) {
            exec(event);
            if (event.key !== "Tab") event.preventDefault();
          }
        }
      });
    }
  };
}
var { not: not13, and: and12 } = createGuards();
var machine40 = createMachine({
  props({ props: props210 }) {
    return {
      defaultValue: [],
      orientation: "horizontal",
      rovingFocus: true,
      loopFocus: true,
      deselectable: true,
      ...props210
    };
  },
  initialState() {
    return "idle";
  },
  context({ prop, bindable }) {
    return {
      value: bindable(() => ({
        defaultValue: prop("defaultValue"),
        value: prop("value"),
        onChange(value) {
          var _a8;
          (_a8 = prop("onValueChange")) == null ? void 0 : _a8({ value });
        }
      })),
      focusedId: bindable(() => ({
        defaultValue: null
      })),
      isTabbingBackward: bindable(() => ({
        defaultValue: false
      })),
      isClickFocus: bindable(() => ({
        defaultValue: false
      })),
      isWithinToolbar: bindable(() => ({
        defaultValue: false
      }))
    };
  },
  computed: {
    currentLoopFocus: ({ context, prop }) => prop("loopFocus") && !context.get("isWithinToolbar")
  },
  entry: ["checkIfWithinToolbar"],
  on: {
    "VALUE.SET": {
      actions: ["setValue"]
    },
    "TOGGLE.CLICK": {
      actions: ["setValue"]
    },
    "ROOT.MOUSE_DOWN": {
      actions: ["setClickFocus"]
    }
  },
  states: {
    idle: {
      on: {
        "ROOT.FOCUS": {
          target: "focused",
          guard: not13(and12("isClickFocus", "isTabbingBackward")),
          actions: ["focusFirstToggle", "clearClickFocus"]
        },
        "TOGGLE.FOCUS": {
          target: "focused",
          actions: ["setFocusedId"]
        }
      }
    },
    focused: {
      on: {
        "ROOT.BLUR": {
          target: "idle",
          actions: ["clearIsTabbingBackward", "clearFocusedId", "clearClickFocus"]
        },
        "TOGGLE.FOCUS": {
          actions: ["setFocusedId"]
        },
        "TOGGLE.FOCUS_NEXT": {
          actions: ["focusNextToggle"]
        },
        "TOGGLE.FOCUS_PREV": {
          actions: ["focusPrevToggle"]
        },
        "TOGGLE.FOCUS_FIRST": {
          actions: ["focusFirstToggle"]
        },
        "TOGGLE.FOCUS_LAST": {
          actions: ["focusLastToggle"]
        },
        "TOGGLE.SHIFT_TAB": [
          {
            guard: not13("isFirstToggleFocused"),
            target: "idle",
            actions: ["setIsTabbingBackward"]
          },
          {
            actions: ["setIsTabbingBackward"]
          }
        ]
      }
    }
  },
  implementations: {
    guards: {
      isClickFocus: ({ context }) => context.get("isClickFocus"),
      isTabbingBackward: ({ context }) => context.get("isTabbingBackward"),
      isFirstToggleFocused: ({ context, scope }) => {
        var _a8;
        return context.get("focusedId") === ((_a8 = getFirstEl3(scope)) == null ? void 0 : _a8.id);
      }
    },
    actions: {
      setIsTabbingBackward({ context }) {
        context.set("isTabbingBackward", true);
      },
      clearIsTabbingBackward({ context }) {
        context.set("isTabbingBackward", false);
      },
      setClickFocus({ context }) {
        context.set("isClickFocus", true);
      },
      clearClickFocus({ context }) {
        context.set("isClickFocus", false);
      },
      checkIfWithinToolbar({ context, scope }) {
        var _a8;
        const closestToolbar = (_a8 = getRootEl12(scope)) == null ? void 0 : _a8.closest("[role=toolbar]");
        context.set("isWithinToolbar", !!closestToolbar);
      },
      setFocusedId({ context, event }) {
        context.set("focusedId", event.id);
      },
      clearFocusedId({ context }) {
        context.set("focusedId", null);
      },
      setValue({ context, event, prop }) {
        ensureProps(event, ["value"]);
        let next2 = context.get("value");
        if (isArray(event.value)) {
          next2 = event.value;
        } else if (prop("multiple")) {
          next2 = addOrRemove(next2, event.value);
        } else {
          const isSelected = isEqual(next2, [event.value]);
          next2 = isSelected && prop("deselectable") ? [] : [event.value];
        }
        context.set("value", next2);
      },
      focusNextToggle({ context, scope, prop }) {
        raf(() => {
          var _a8;
          const focusedId = context.get("focusedId");
          if (!focusedId) return;
          (_a8 = getNextEl3(scope, focusedId, prop("loopFocus"))) == null ? void 0 : _a8.focus({ preventScroll: true });
        });
      },
      focusPrevToggle({ context, scope, prop }) {
        raf(() => {
          var _a8;
          const focusedId = context.get("focusedId");
          if (!focusedId) return;
          (_a8 = getPrevEl3(scope, focusedId, prop("loopFocus"))) == null ? void 0 : _a8.focus({ preventScroll: true });
        });
      },
      focusFirstToggle({ scope }) {
        raf(() => {
          var _a8;
          (_a8 = getFirstEl3(scope)) == null ? void 0 : _a8.focus({ preventScroll: true });
        });
      },
      focusLastToggle({ scope }) {
        raf(() => {
          var _a8;
          (_a8 = getLastEl3(scope)) == null ? void 0 : _a8.focus({ preventScroll: true });
        });
      }
    }
  }
});
var props39 = createProps()([
  "dir",
  "disabled",
  "getRootNode",
  "id",
  "ids",
  "loopFocus",
  "multiple",
  "onValueChange",
  "orientation",
  "rovingFocus",
  "value",
  "defaultValue",
  "deselectable"
]);
var splitProps39 = createSplitProps(props39);
var itemProps12 = createProps()(["value", "disabled"]);
var splitItemProps12 = createSplitProps(itemProps12);

// node_modules/@ark-ui/react/dist/components/toggle-group/use-toggle-group.js
var import_react898 = __toESM(require_react(), 1);
var useToggleGroup = (props43) => {
  const id = (0, import_react898.useId)();
  const { getRootNode } = useEnvironmentContext();
  const { dir } = useLocaleContext();
  const machineProps = {
    id,
    dir,
    getRootNode,
    ...props43
  };
  const service = useMachine(machine40, machineProps);
  return connect40(service, normalizeProps);
};

// node_modules/@ark-ui/react/dist/components/toggle-group/toggle-group-root.js
var ToggleGroupRoot = (0, import_react900.forwardRef)((props43, ref) => {
  const [useToggleGroupProps, localProps] = createSplitProps2()(props43, [
    "defaultValue",
    "deselectable",
    "disabled",
    "id",
    "ids",
    "loopFocus",
    "multiple",
    "onValueChange",
    "orientation",
    "rovingFocus",
    "value"
  ]);
  const togglegroup = useToggleGroup(useToggleGroupProps);
  const mergedProps = mergeProps2(togglegroup.getRootProps(), localProps);
  return (0, import_jsx_runtime416.jsx)(ToggleGroupProvider, { value: togglegroup, children: (0, import_jsx_runtime416.jsx)(ark.div, { ...mergedProps, ref }) });
});
ToggleGroupRoot.displayName = "ToggleGroupRoot";

// node_modules/@ark-ui/react/dist/components/toggle-group/toggle-group-root-provider.js
var import_jsx_runtime417 = __toESM(require_jsx_runtime(), 1);
var import_react902 = __toESM(require_react(), 1);
var ToggleGroupRootProvider = (0, import_react902.forwardRef)((props43, ref) => {
  const [{ value: toggleGroup }, localProps] = createSplitProps2()(props43, ["value"]);
  const mergedProps = mergeProps2(toggleGroup.getRootProps(), localProps);
  return (0, import_jsx_runtime417.jsx)(ToggleGroupProvider, { value: toggleGroup, children: (0, import_jsx_runtime417.jsx)(ark.div, { ...mergedProps, ref }) });
});
ToggleGroupRootProvider.displayName = "ToggleGroupRootProvider";

// node_modules/@ark-ui/react/dist/components/tooltip/tooltip-arrow.js
var import_jsx_runtime418 = __toESM(require_jsx_runtime(), 1);
var import_react904 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/tooltip/use-tooltip-context.js
var [TooltipProvider, useTooltipContext] = createContext3({
  name: "TooltipContext",
  hookName: "useTooltipContext",
  providerName: "<TooltipProvider />"
});

// node_modules/@ark-ui/react/dist/components/tooltip/tooltip-arrow.js
var TooltipArrow = (0, import_react904.forwardRef)((props43, ref) => {
  const tooltip = useTooltipContext();
  const mergedProps = mergeProps2(tooltip.getArrowProps(), props43);
  return (0, import_jsx_runtime418.jsx)(ark.div, { ...mergedProps, ref });
});
TooltipArrow.displayName = "TooltipArrow";

// node_modules/@ark-ui/react/dist/components/tooltip/tooltip-arrow-tip.js
var import_jsx_runtime419 = __toESM(require_jsx_runtime(), 1);
var import_react906 = __toESM(require_react(), 1);
var TooltipArrowTip = (0, import_react906.forwardRef)((props43, ref) => {
  const tooltip = useTooltipContext();
  const mergedProps = mergeProps2(tooltip.getArrowTipProps(), props43);
  return (0, import_jsx_runtime419.jsx)(ark.div, { ...mergedProps, ref });
});
TooltipArrowTip.displayName = "TooltipArrowTip";

// node_modules/@ark-ui/react/dist/components/tooltip/tooltip-content.js
var import_jsx_runtime420 = __toESM(require_jsx_runtime(), 1);
var import_react908 = __toESM(require_react(), 1);
var TooltipContent = (0, import_react908.forwardRef)((props43, ref) => {
  const tooltip = useTooltipContext();
  const presence = usePresenceContext();
  const mergedProps = mergeProps2(tooltip.getContentProps(), presence.getPresenceProps(), props43);
  if (presence.unmounted) {
    return null;
  }
  return (0, import_jsx_runtime420.jsx)(ark.div, { ...mergedProps, ref: composeRefs(presence.ref, ref) });
});
TooltipContent.displayName = "TooltipContent";

// node_modules/@ark-ui/react/dist/components/tooltip/tooltip-context.js
var TooltipContext = (props43) => props43.children(useTooltipContext());

// node_modules/@ark-ui/react/dist/components/tooltip/tooltip-positioner.js
var import_jsx_runtime421 = __toESM(require_jsx_runtime(), 1);
var import_react910 = __toESM(require_react(), 1);
var TooltipPositioner = (0, import_react910.forwardRef)((props43, ref) => {
  const tooltip = useTooltipContext();
  const mergedProps = mergeProps2(tooltip.getPositionerProps(), props43);
  const presence = usePresenceContext();
  if (presence.unmounted) {
    return null;
  }
  return (0, import_jsx_runtime421.jsx)(ark.div, { ...mergedProps, ref });
});
TooltipPositioner.displayName = "TooltipPositioner";

// node_modules/@ark-ui/react/dist/components/tooltip/tooltip-root.js
var import_jsx_runtime422 = __toESM(require_jsx_runtime(), 1);

// node_modules/@zag-js/tooltip/dist/index.mjs
var anatomy40 = createAnatomy("tooltip").parts("trigger", "arrow", "arrowTip", "positioner", "content");
var parts43 = anatomy40.build();
var getTriggerId15 = (scope) => {
  var _a8;
  return ((_a8 = scope.ids) == null ? void 0 : _a8.trigger) ?? `tooltip:${scope.id}:trigger`;
};
var getContentId15 = (scope) => {
  var _a8;
  return ((_a8 = scope.ids) == null ? void 0 : _a8.content) ?? `tooltip:${scope.id}:content`;
};
var getArrowId4 = (scope) => {
  var _a8;
  return ((_a8 = scope.ids) == null ? void 0 : _a8.arrow) ?? `tooltip:${scope.id}:arrow`;
};
var getPositionerId11 = (scope) => {
  var _a8;
  return ((_a8 = scope.ids) == null ? void 0 : _a8.positioner) ?? `tooltip:${scope.id}:popper`;
};
var getTriggerEl12 = (scope) => scope.getById(getTriggerId15(scope));
var getPositionerEl11 = (scope) => scope.getById(getPositionerId11(scope));
var store = proxy({ id: null });
function connect41(service, normalize4) {
  const { state: state2, context, send, scope, prop, event: _event } = service;
  const id = prop("id");
  const hasAriaLabel = !!prop("aria-label");
  const open = state2.matches("open", "closing");
  const triggerId = getTriggerId15(scope);
  const contentId = getContentId15(scope);
  const disabled = prop("disabled");
  const popperStyles = getPlacementStyles({
    ...prop("positioning"),
    placement: context.get("currentPlacement")
  });
  return {
    open,
    setOpen(nextOpen) {
      const open2 = state2.matches("open", "closing");
      if (open2 === nextOpen) return;
      send({ type: nextOpen ? "open" : "close" });
    },
    reposition(options = {}) {
      send({ type: "positioning.set", options });
    },
    getTriggerProps() {
      return normalize4.button({
        ...parts43.trigger.attrs,
        id: triggerId,
        dir: prop("dir"),
        "data-expanded": dataAttr(open),
        "data-state": open ? "open" : "closed",
        "aria-describedby": open ? contentId : void 0,
        onClick(event) {
          if (event.defaultPrevented) return;
          if (disabled) return;
          if (!prop("closeOnClick")) return;
          send({ type: "close", src: "trigger.click" });
        },
        onFocus(event) {
          queueMicrotask(() => {
            if (event.defaultPrevented) return;
            if (disabled) return;
            if (_event.src === "trigger.pointerdown") return;
            if (!isFocusVisible()) return;
            send({ type: "open", src: "trigger.focus" });
          });
        },
        onBlur(event) {
          if (event.defaultPrevented) return;
          if (disabled) return;
          if (id === store.id) {
            send({ type: "close", src: "trigger.blur" });
          }
        },
        onPointerDown(event) {
          if (event.defaultPrevented) return;
          if (disabled) return;
          if (!prop("closeOnPointerDown")) return;
          if (id === store.id) {
            send({ type: "close", src: "trigger.pointerdown" });
          }
        },
        onPointerMove(event) {
          if (event.defaultPrevented) return;
          if (disabled) return;
          if (event.pointerType === "touch") return;
          send({ type: "pointer.move" });
        },
        onPointerLeave() {
          if (disabled) return;
          send({ type: "pointer.leave" });
        },
        onPointerCancel() {
          if (disabled) return;
          send({ type: "pointer.leave" });
        }
      });
    },
    getArrowProps() {
      return normalize4.element({
        id: getArrowId4(scope),
        ...parts43.arrow.attrs,
        dir: prop("dir"),
        style: popperStyles.arrow
      });
    },
    getArrowTipProps() {
      return normalize4.element({
        ...parts43.arrowTip.attrs,
        dir: prop("dir"),
        style: popperStyles.arrowTip
      });
    },
    getPositionerProps() {
      return normalize4.element({
        id: getPositionerId11(scope),
        ...parts43.positioner.attrs,
        dir: prop("dir"),
        style: popperStyles.floating
      });
    },
    getContentProps() {
      return normalize4.element({
        ...parts43.content.attrs,
        dir: prop("dir"),
        hidden: !open,
        "data-state": open ? "open" : "closed",
        role: hasAriaLabel ? void 0 : "tooltip",
        id: hasAriaLabel ? void 0 : contentId,
        "data-placement": context.get("currentPlacement"),
        onPointerEnter() {
          send({ type: "content.pointer.move" });
        },
        onPointerLeave() {
          send({ type: "content.pointer.leave" });
        },
        style: {
          pointerEvents: prop("interactive") ? "auto" : "none"
        }
      });
    }
  };
}
var { and: and13, not: not14 } = createGuards();
var machine41 = createMachine({
  initialState: ({ prop }) => {
    const open = prop("open") || prop("defaultOpen");
    return open ? "open" : "closed";
  },
  props({ props: props210 }) {
    return {
      id: "x",
      openDelay: 1e3,
      closeDelay: 500,
      closeOnPointerDown: true,
      closeOnEscape: true,
      interactive: false,
      closeOnScroll: true,
      closeOnClick: true,
      disabled: false,
      ...props210,
      positioning: {
        placement: "bottom",
        ...props210.positioning
      }
    };
  },
  effects: ["trackFocusVisible", "trackStore"],
  context: ({ bindable }) => ({
    currentPlacement: bindable(() => ({ defaultValue: void 0 })),
    hasPointerMoveOpened: bindable(() => ({ defaultValue: false }))
  }),
  watch({ track, action, prop }) {
    track([() => prop("disabled")], () => {
      action(["closeIfDisabled"]);
    });
    track([() => prop("open")], () => {
      action(["toggleVisibility"]);
    });
  },
  states: {
    closed: {
      entry: ["clearGlobalId"],
      on: {
        "controlled.open": {
          target: "open"
        },
        open: [
          {
            guard: "isOpenControlled",
            actions: ["invokeOnOpen"]
          },
          {
            target: "open",
            actions: ["invokeOnOpen"]
          }
        ],
        "pointer.leave": {
          actions: ["clearPointerMoveOpened"]
        },
        "pointer.move": [
          {
            guard: and13("noVisibleTooltip", not14("hasPointerMoveOpened")),
            target: "opening"
          },
          {
            guard: not14("hasPointerMoveOpened"),
            target: "open",
            actions: ["setPointerMoveOpened", "invokeOnOpen"]
          }
        ]
      }
    },
    opening: {
      effects: ["trackScroll", "trackPointerlockChange", "waitForOpenDelay"],
      on: {
        "after.openDelay": [
          {
            guard: "isOpenControlled",
            actions: ["setPointerMoveOpened", "invokeOnOpen"]
          },
          {
            target: "open",
            actions: ["setPointerMoveOpened", "invokeOnOpen"]
          }
        ],
        "controlled.open": {
          target: "open"
        },
        "controlled.close": {
          target: "closed"
        },
        open: [
          {
            guard: "isOpenControlled",
            actions: ["invokeOnOpen"]
          },
          {
            target: "open",
            actions: ["invokeOnOpen"]
          }
        ],
        "pointer.leave": [
          {
            guard: "isOpenControlled",
            // We trigger toggleVisibility manually since the `ctx.open` has not changed yet (at this point)
            actions: ["clearPointerMoveOpened", "invokeOnClose", "toggleVisibility"]
          },
          {
            target: "closed",
            actions: ["clearPointerMoveOpened", "invokeOnClose"]
          }
        ],
        close: [
          {
            guard: "isOpenControlled",
            // We trigger toggleVisibility manually since the `ctx.open` has not changed yet (at this point)
            actions: ["invokeOnClose", "toggleVisibility"]
          },
          {
            target: "closed",
            actions: ["invokeOnClose"]
          }
        ]
      }
    },
    open: {
      effects: ["trackEscapeKey", "trackScroll", "trackPointerlockChange", "trackPositioning"],
      entry: ["setGlobalId"],
      on: {
        "controlled.close": {
          target: "closed"
        },
        close: [
          {
            guard: "isOpenControlled",
            actions: ["invokeOnClose"]
          },
          {
            target: "closed",
            actions: ["invokeOnClose"]
          }
        ],
        "pointer.leave": [
          {
            guard: "isVisible",
            target: "closing",
            actions: ["clearPointerMoveOpened"]
          },
          // == group ==
          {
            guard: "isOpenControlled",
            actions: ["clearPointerMoveOpened", "invokeOnClose"]
          },
          {
            target: "closed",
            actions: ["clearPointerMoveOpened", "invokeOnClose"]
          }
        ],
        "content.pointer.leave": {
          guard: "isInteractive",
          target: "closing"
        },
        "positioning.set": {
          actions: ["reposition"]
        }
      }
    },
    closing: {
      effects: ["trackPositioning", "waitForCloseDelay"],
      on: {
        "after.closeDelay": [
          {
            guard: "isOpenControlled",
            actions: ["invokeOnClose"]
          },
          {
            target: "closed",
            actions: ["invokeOnClose"]
          }
        ],
        "controlled.close": {
          target: "closed"
        },
        "controlled.open": {
          target: "open"
        },
        close: [
          {
            guard: "isOpenControlled",
            actions: ["invokeOnClose"]
          },
          {
            target: "closed",
            actions: ["invokeOnClose"]
          }
        ],
        "pointer.move": [
          {
            guard: "isOpenControlled",
            // We trigger toggleVisibility manually since the `ctx.open` has not changed yet (at this point)
            actions: ["setPointerMoveOpened", "invokeOnOpen", "toggleVisibility"]
          },
          {
            target: "open",
            actions: ["setPointerMoveOpened", "invokeOnOpen"]
          }
        ],
        "content.pointer.move": {
          guard: "isInteractive",
          target: "open"
        },
        "positioning.set": {
          actions: ["reposition"]
        }
      }
    }
  },
  implementations: {
    guards: {
      noVisibleTooltip: () => store.id === null,
      isVisible: ({ prop }) => prop("id") === store.id,
      isInteractive: ({ prop }) => !!prop("interactive"),
      hasPointerMoveOpened: ({ context }) => context.get("hasPointerMoveOpened"),
      isOpenControlled: ({ prop }) => prop("open") !== void 0
    },
    actions: {
      setGlobalId: ({ prop }) => {
        store.id = prop("id");
      },
      clearGlobalId: ({ prop }) => {
        if (prop("id") === store.id) {
          store.id = null;
        }
      },
      invokeOnOpen: ({ prop }) => {
        var _a8;
        (_a8 = prop("onOpenChange")) == null ? void 0 : _a8({ open: true });
      },
      invokeOnClose: ({ prop }) => {
        var _a8;
        (_a8 = prop("onOpenChange")) == null ? void 0 : _a8({ open: false });
      },
      closeIfDisabled: ({ prop, send }) => {
        if (!prop("disabled")) return;
        send({ type: "close", src: "disabled.change" });
      },
      reposition: ({ context, event, prop, scope }) => {
        if (event.type !== "positioning.set") return;
        const getPositionerEl22 = () => getPositionerEl11(scope);
        return getPlacement(getTriggerEl12(scope), getPositionerEl22, {
          ...prop("positioning"),
          ...event.options,
          defer: true,
          listeners: false,
          onComplete(data) {
            context.set("currentPlacement", data.placement);
          }
        });
      },
      toggleVisibility: ({ prop, event, send }) => {
        queueMicrotask(() => {
          send({
            type: prop("open") ? "controlled.open" : "controlled.close",
            previousEvent: event
          });
        });
      },
      setPointerMoveOpened: ({ context }) => {
        context.set("hasPointerMoveOpened", true);
      },
      clearPointerMoveOpened: ({ context }) => {
        context.set("hasPointerMoveOpened", false);
      }
    },
    effects: {
      trackFocusVisible: ({ scope }) => {
        var _a8;
        return trackFocusVisible({ root: (_a8 = scope.getRootNode) == null ? void 0 : _a8.call(scope) });
      },
      trackPositioning: ({ context, prop, scope }) => {
        if (!context.get("currentPlacement")) {
          context.set("currentPlacement", prop("positioning").placement);
        }
        const getPositionerEl22 = () => getPositionerEl11(scope);
        return getPlacement(getTriggerEl12(scope), getPositionerEl22, {
          ...prop("positioning"),
          defer: true,
          onComplete(data) {
            context.set("currentPlacement", data.placement);
          }
        });
      },
      trackPointerlockChange: ({ send, scope }) => {
        const doc = scope.getDoc();
        const onChange = () => send({ type: "close", src: "pointerlock:change" });
        return addDomEvent(doc, "pointerlockchange", onChange, false);
      },
      trackScroll: ({ send, prop, scope }) => {
        if (!prop("closeOnScroll")) return;
        const triggerEl = getTriggerEl12(scope);
        if (!triggerEl) return;
        const overflowParents = getOverflowAncestors(triggerEl);
        const cleanups = overflowParents.map((overflowParent) => {
          const onScroll = () => {
            send({ type: "close", src: "scroll" });
          };
          return addDomEvent(overflowParent, "scroll", onScroll, {
            passive: true,
            capture: true
          });
        });
        return () => {
          cleanups.forEach((fn) => fn == null ? void 0 : fn());
        };
      },
      trackStore: ({ prop, send }) => {
        let cleanup;
        queueMicrotask(() => {
          cleanup = subscribe(store, () => {
            if (store.id !== prop("id")) {
              send({ type: "close", src: "id.change" });
            }
          });
        });
        return () => cleanup == null ? void 0 : cleanup();
      },
      trackEscapeKey: ({ send, prop }) => {
        if (!prop("closeOnEscape")) return;
        const onKeyDown = (event) => {
          if (isComposingEvent(event)) return;
          if (event.key !== "Escape") return;
          event.stopPropagation();
          send({ type: "close", src: "keydown.escape" });
        };
        return addDomEvent(document, "keydown", onKeyDown, true);
      },
      waitForOpenDelay: ({ send, prop }) => {
        const id = setTimeout(() => {
          send({ type: "after.openDelay" });
        }, prop("openDelay"));
        return () => clearTimeout(id);
      },
      waitForCloseDelay: ({ send, prop }) => {
        const id = setTimeout(() => {
          send({ type: "after.closeDelay" });
        }, prop("closeDelay"));
        return () => clearTimeout(id);
      }
    }
  }
});
var props40 = createProps()([
  "aria-label",
  "closeDelay",
  "closeOnEscape",
  "closeOnPointerDown",
  "closeOnScroll",
  "closeOnClick",
  "dir",
  "disabled",
  "getRootNode",
  "id",
  "ids",
  "interactive",
  "onOpenChange",
  "defaultOpen",
  "open",
  "openDelay",
  "positioning"
]);
var splitProps40 = createSplitProps(props40);

// node_modules/@ark-ui/react/dist/components/tooltip/use-tooltip.js
var import_react912 = __toESM(require_react(), 1);
var useTooltip = (props43) => {
  const id = (0, import_react912.useId)();
  const { getRootNode } = useEnvironmentContext();
  const { dir } = useLocaleContext();
  const machineProps = {
    id,
    dir,
    getRootNode,
    ...props43
  };
  const service = useMachine(machine41, machineProps);
  return connect41(service, normalizeProps);
};

// node_modules/@ark-ui/react/dist/components/tooltip/tooltip-root.js
var TooltipRoot = (props43) => {
  const [presenceProps, { children, ...localProps }] = splitPresenceProps(props43);
  const tooltip = useTooltip(localProps);
  const presence = usePresence(mergeProps2({ present: tooltip.open }, presenceProps));
  return (0, import_jsx_runtime422.jsx)(TooltipProvider, { value: tooltip, children: (0, import_jsx_runtime422.jsx)(PresenceProvider, { value: presence, children }) });
};

// node_modules/@ark-ui/react/dist/components/tooltip/tooltip-root-provider.js
var import_jsx_runtime423 = __toESM(require_jsx_runtime(), 1);
var TooltipRootProvider = (props43) => {
  const [presenceProps, { value: tooltip, children }] = splitPresenceProps(props43);
  const presence = usePresence(mergeProps2({ present: tooltip.open }, presenceProps));
  return (0, import_jsx_runtime423.jsx)(TooltipProvider, { value: tooltip, children: (0, import_jsx_runtime423.jsx)(PresenceProvider, { value: presence, children }) });
};

// node_modules/@ark-ui/react/dist/components/tooltip/tooltip-trigger.js
var import_jsx_runtime424 = __toESM(require_jsx_runtime(), 1);
var import_react916 = __toESM(require_react(), 1);
var TooltipTrigger = (0, import_react916.forwardRef)((props43, ref) => {
  const tooltip = useTooltipContext();
  const mergedProps = mergeProps2(tooltip.getTriggerProps(), props43);
  return (0, import_jsx_runtime424.jsx)(ark.button, { ...mergedProps, ref });
});
TooltipTrigger.displayName = "TooltipTrigger";

// node_modules/@ark-ui/react/dist/components/tooltip/tooltip.js
var tooltip_exports = {};
__export(tooltip_exports, {
  Arrow: () => TooltipArrow,
  ArrowTip: () => TooltipArrowTip,
  Content: () => TooltipContent,
  Context: () => TooltipContext,
  Positioner: () => TooltipPositioner,
  Root: () => TooltipRoot,
  RootProvider: () => TooltipRootProvider,
  Trigger: () => TooltipTrigger
});

// node_modules/@ark-ui/react/dist/components/tour/tour-action-trigger.js
var import_jsx_runtime425 = __toESM(require_jsx_runtime(), 1);
var import_react918 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/tour/use-tour-context.js
var [TourProvider, useTourContext] = createContext3({
  name: "TourContext",
  hookName: "useTourContext",
  providerName: "<TourProvider />"
});

// node_modules/@ark-ui/react/dist/components/tour/tour-action-trigger.js
var TourActionTrigger = (0, import_react918.forwardRef)((props43, ref) => {
  const [actionTriggerProps, localProps] = createSplitProps2()(props43, ["action"]);
  const tour = useTourContext();
  const mergedProps = mergeProps2(tour.getActionTriggerProps(actionTriggerProps), localProps);
  return (0, import_jsx_runtime425.jsx)(ark.button, { ...mergedProps, ref, children: mergedProps.children || actionTriggerProps.action.label });
});
TourActionTrigger.displayName = "TourActionTrigger";

// node_modules/@ark-ui/react/dist/components/tour/tour-arrow.js
var import_jsx_runtime426 = __toESM(require_jsx_runtime(), 1);
var import_react920 = __toESM(require_react(), 1);
var TourArrow = (0, import_react920.forwardRef)((props43, ref) => {
  var _a8;
  const tour = useTourContext();
  const mergedProps = mergeProps2(tour.getArrowProps(), props43);
  return ((_a8 = tour.step) == null ? void 0 : _a8.arrow) ? (0, import_jsx_runtime426.jsx)(ark.div, { ...mergedProps, ref }) : null;
});
TourArrow.displayName = "TourArrow";

// node_modules/@ark-ui/react/dist/components/tour/tour-arrow-tip.js
var import_jsx_runtime427 = __toESM(require_jsx_runtime(), 1);
var import_react922 = __toESM(require_react(), 1);
var TourArrowTip = (0, import_react922.forwardRef)((props43, ref) => {
  const tour = useTourContext();
  const mergedProps = mergeProps2(tour.getArrowTipProps(), props43);
  return (0, import_jsx_runtime427.jsx)(ark.div, { ...mergedProps, ref });
});
TourArrowTip.displayName = "TourArrowTip";

// node_modules/@ark-ui/react/dist/components/tour/tour-backdrop.js
var import_jsx_runtime428 = __toESM(require_jsx_runtime(), 1);
var import_react924 = __toESM(require_react(), 1);
var TourBackdrop = (0, import_react924.forwardRef)((props43, ref) => {
  var _a8;
  const tour = useTourContext();
  const renderStrategyProps = useRenderStrategyPropsContext();
  const presence = usePresence({
    ...renderStrategyProps,
    present: tour.open
  });
  const mergedProps = mergeProps2(tour.getBackdropProps(), presence.getPresenceProps(), props43);
  if (presence.unmounted) {
    return null;
  }
  return (0, import_jsx_runtime428.jsx)(ark.div, { ...mergedProps, ref: composeRefs(presence.ref, ref), hidden: !((_a8 = tour.step) == null ? void 0 : _a8.backdrop) });
});
TourBackdrop.displayName = "TourBackdrop";

// node_modules/@ark-ui/react/dist/components/tour/tour-close-trigger.js
var import_jsx_runtime429 = __toESM(require_jsx_runtime(), 1);
var import_react926 = __toESM(require_react(), 1);
var TourCloseTrigger = (0, import_react926.forwardRef)((props43, ref) => {
  const tour = useTourContext();
  const mergedProps = mergeProps2(tour.getCloseTriggerProps(), props43);
  return (0, import_jsx_runtime429.jsx)(ark.button, { ...mergedProps, ref });
});
TourCloseTrigger.displayName = "TourCloseTrigger";

// node_modules/@ark-ui/react/dist/components/tour/tour-content.js
var import_jsx_runtime430 = __toESM(require_jsx_runtime(), 1);
var import_react928 = __toESM(require_react(), 1);
var TourContent = (0, import_react928.forwardRef)((props43, ref) => {
  const tour = useTourContext();
  const presence = usePresenceContext();
  const mergedProps = mergeProps2(tour.getContentProps(), presence.getPresenceProps(), props43);
  if (presence.unmounted) {
    return null;
  }
  return (0, import_jsx_runtime430.jsx)(ark.div, { ...mergedProps, ref: composeRefs(presence.ref, ref) });
});
TourContent.displayName = "TourContent";

// node_modules/@ark-ui/react/dist/components/tour/tour-control.js
var import_jsx_runtime431 = __toESM(require_jsx_runtime(), 1);
var import_react929 = __toESM(require_react(), 1);

// node_modules/@zag-js/tour/dist/index.mjs
var anatomy41 = createAnatomy("tour").parts(
  "content",
  "actionTrigger",
  "closeTrigger",
  "progressText",
  "title",
  "description",
  "positioner",
  "arrow",
  "arrowTip",
  "backdrop",
  "spotlight"
);
var parts44 = anatomy41.build();
var getPositionerId12 = (ctx) => {
  var _a8;
  return ((_a8 = ctx.ids) == null ? void 0 : _a8.positioner) ?? `tour-positioner-${ctx.id}`;
};
var getContentId16 = (ctx) => {
  var _a8;
  return ((_a8 = ctx.ids) == null ? void 0 : _a8.content) ?? `tour-content-${ctx.id}`;
};
var getBackdropId2 = (ctx) => {
  var _a8;
  return ((_a8 = ctx.ids) == null ? void 0 : _a8.backdrop) ?? `tour-backdrop-${ctx.id}`;
};
var getContentEl14 = (ctx) => ctx.getById(getContentId16(ctx));
var getPositionerEl12 = (ctx) => ctx.getById(getPositionerId12(ctx));
var getBackdropEl2 = (ctx) => ctx.getById(getBackdropId2(ctx));
var isTooltipStep = (step) => {
  return (step == null ? void 0 : step.type) === "tooltip";
};
var isDialogStep = (step) => {
  return (step == null ? void 0 : step.type) === "dialog";
};
var normalizeStep = (step) => {
  if (step.type === "floating") {
    return { backdrop: false, arrow: false, placement: "bottom-end", ...step };
  }
  if (step.target == null || step.type === "dialog") {
    return { type: "dialog", placement: "center", backdrop: true, ...step };
  }
  if (!step.type || step.type === "tooltip") {
    return { type: "tooltip", arrow: true, backdrop: true, ...step };
  }
  return step;
};
var findStep = (steps, id) => {
  const res = id != null ? steps.find((step) => step.id === id) : null;
  return res ? normalizeStep(res) : null;
};
var findStepIndex = (steps, id) => {
  return id != null ? steps.findIndex((step) => step.id === id) : -1;
};
function getFrameElement2(win) {
  return win.parent && Object.getPrototypeOf(win.parent) ? win.frameElement : null;
}
var normalizeEventPoint = (event) => {
  let clientX = event.clientX;
  let clientY = event.clientY;
  let win = event.view || window;
  let frame = getFrameElement2(win);
  while (frame) {
    const iframeRect = frame.getBoundingClientRect();
    const css2 = getComputedStyle(frame);
    const left = iframeRect.left + (frame.clientLeft + parseFloat(css2.paddingLeft));
    const top = iframeRect.top + (frame.clientTop + parseFloat(css2.paddingTop));
    clientX += left;
    clientY += top;
    win = getWindow(frame);
    frame = getFrameElement2(win);
  }
  return { clientX, clientY };
};
function isEventInRect(rect, event) {
  const { clientX, clientY } = normalizeEventPoint(event);
  return rect.y <= clientY && clientY <= rect.y + rect.height && rect.x <= clientX && clientX <= rect.x + rect.width;
}
function offset3(r, i) {
  const dx = i.x || 0;
  const dy = i.y || 0;
  return {
    x: r.x - dx,
    y: r.y - dy,
    width: r.width + dx + dx,
    height: r.height + dy + dy
  };
}
var { and: and14 } = createGuards();
var getEffectiveSteps = (steps) => steps.filter((step) => step.type !== "wait");
var getProgress = (steps, stepIndex) => {
  const effectiveLength = getEffectiveSteps(steps).length;
  return (stepIndex + 1) / effectiveLength;
};
var machine42 = createMachine({
  props({ props: props210 }) {
    return {
      preventInteraction: false,
      closeOnInteractOutside: true,
      closeOnEscape: true,
      keyboardNavigation: true,
      spotlightOffset: { x: 10, y: 10 },
      spotlightRadius: 4,
      ...props210,
      translations: {
        nextStep: "next step",
        prevStep: "previous step",
        close: "close tour",
        progressText: ({ current, total }) => `${current + 1} of ${total}`,
        skip: "skip tour",
        ...props210.translations
      }
    };
  },
  initialState() {
    return "tour.inactive";
  },
  context({ prop, bindable, getContext }) {
    return {
      steps: bindable(() => ({
        defaultValue: prop("steps") ?? [],
        onChange(value) {
          var _a8;
          (_a8 = prop("onStepsChange")) == null ? void 0 : _a8({ steps: value });
        }
      })),
      stepId: bindable(() => ({
        defaultValue: prop("stepId"),
        sync: true,
        onChange(value) {
          var _a8;
          const context = getContext();
          const steps = context.get("steps");
          const stepIndex = findStepIndex(steps, value);
          const progress = getProgress(steps, stepIndex);
          const complete = stepIndex == steps.length - 1;
          (_a8 = prop("onStepChange")) == null ? void 0 : _a8({ stepId: value, stepIndex, totalSteps: steps.length, complete, progress });
        }
      })),
      resolvedTarget: bindable(() => ({
        sync: true,
        defaultValue: null
      })),
      targetRect: bindable(() => ({
        defaultValue: { width: 0, height: 0, x: 0, y: 0 }
      })),
      boundarySize: bindable(() => ({
        defaultValue: { width: 0, height: 0 }
      })),
      currentPlacement: bindable(() => ({
        defaultValue: void 0
      }))
    };
  },
  computed: {
    stepIndex: ({ context }) => findStepIndex(context.get("steps"), context.get("stepId")),
    step: ({ context }) => findStep(context.get("steps"), context.get("stepId")),
    hasNextStep: ({ context, computed }) => computed("stepIndex") < context.get("steps").length - 1,
    hasPrevStep: ({ computed }) => computed("stepIndex") > 0,
    isFirstStep: ({ computed }) => computed("stepIndex") === 0,
    isLastStep: ({ context, computed }) => computed("stepIndex") === context.get("steps").length - 1,
    progress: ({ context, computed }) => {
      const effectiveLength = getEffectiveSteps(context.get("steps")).length;
      return (computed("stepIndex") + 1) / effectiveLength;
    }
  },
  watch({ track, context, action }) {
    track([() => context.get("stepId")], () => {
      queueMicrotask(() => {
        action(["setResolvedTarget", "raiseStepChange", "syncTargetAttrs"]);
      });
    });
  },
  effects: ["trackBoundarySize"],
  exit: ["cleanupRefs"],
  on: {
    "STEPS.SET": {
      actions: ["setSteps"]
    },
    "STEP.SET": {
      actions: ["setStep"]
    },
    "STEP.NEXT": {
      actions: ["setNextStep"]
    },
    "STEP.PREV": {
      actions: ["setPrevStep"]
    },
    "STEP.CHANGED": [
      {
        guard: and14("isValidStep", "hasResolvedTarget"),
        target: "target.scrolling",
        actions: ["cleanupRefs"]
      },
      {
        guard: and14("isValidStep", "hasTarget"),
        target: "target.resolving",
        actions: ["cleanupRefs"]
      },
      {
        guard: and14("isValidStep", "isWaitingStep"),
        target: "step.waiting",
        actions: ["cleanupRefs"]
      },
      {
        guard: "isValidStep",
        target: "tour.active",
        actions: ["cleanupRefs"]
      }
    ],
    DISMISS: [
      {
        guard: "isLastStep",
        target: "tour.inactive",
        actions: ["invokeOnDismiss", "invokeOnComplete", "clearStep"]
      },
      {
        target: "tour.inactive",
        actions: ["invokeOnDismiss", "clearStep"]
      }
    ]
  },
  states: {
    "tour.inactive": {
      tags: ["closed"],
      on: {
        START: {
          actions: ["setInitialStep", "invokeOnStart"]
        }
      }
    },
    "target.resolving": {
      tags: ["closed"],
      effects: ["waitForTarget", "waitForTargetTimeout"],
      on: {
        "TARGET.NOT_FOUND": {
          target: "tour.inactive",
          actions: ["invokeOnNotFound", "clearStep"]
        },
        "TARGET.RESOLVED": {
          target: "target.scrolling",
          actions: ["setResolvedTarget"]
        }
      }
    },
    "target.scrolling": {
      tags: ["open"],
      entry: ["scrollToTarget"],
      effects: [
        "waitForScrollEnd",
        "trapFocus",
        "trackPlacement",
        "trackDismissableBranch",
        "trackInteractOutside",
        "trackEscapeKeydown"
      ],
      on: {
        "SCROLL.END": {
          target: "tour.active"
        }
      }
    },
    "step.waiting": {
      tags: ["closed"]
    },
    "tour.active": {
      tags: ["open"],
      effects: ["trapFocus", "trackPlacement", "trackDismissableBranch", "trackInteractOutside", "trackEscapeKeydown"]
    }
  },
  implementations: {
    guards: {
      isLastStep: ({ computed, context }) => computed("stepIndex") === context.get("steps").length - 1,
      isValidStep: ({ context }) => context.get("stepId") != null,
      hasTarget: ({ computed }) => {
        var _a8;
        return ((_a8 = computed("step")) == null ? void 0 : _a8.target) != null;
      },
      hasResolvedTarget: ({ context }) => context.get("resolvedTarget") != null,
      isWaitingStep: ({ computed }) => {
        var _a8;
        return ((_a8 = computed("step")) == null ? void 0 : _a8.type) === "wait";
      }
    },
    actions: {
      scrollToTarget({ context }) {
        const node = context.get("resolvedTarget");
        node == null ? void 0 : node.scrollIntoView({ behavior: "instant", block: "center", inline: "center" });
      },
      setStep(params) {
        const { event } = params;
        setStep(params, event.value);
      },
      clearStep(params) {
        const { context } = params;
        context.set("targetRect", { width: 0, height: 0, x: 0, y: 0 });
        setStep(params, -1);
      },
      setInitialStep(params) {
        const { context, event } = params;
        const steps = context.get("steps");
        if (steps.length === 0) return;
        if (isString2(event.value)) {
          const idx = findStepIndex(steps, event.value);
          setStep(params, idx);
          return;
        }
        setStep(params, 0);
      },
      setNextStep(params) {
        const { context, computed } = params;
        const steps = context.get("steps");
        const idx = nextIndex(steps, computed("stepIndex"));
        setStep(params, idx);
      },
      setPrevStep(params) {
        const { context, computed } = params;
        const steps = context.get("steps");
        const idx = prevIndex(steps, computed("stepIndex"));
        setStep(params, idx);
      },
      invokeOnStart({ prop, context, computed }) {
        var _a8;
        (_a8 = prop("onStatusChange")) == null ? void 0 : _a8({
          status: "started",
          stepId: context.get("stepId"),
          stepIndex: computed("stepIndex")
        });
      },
      invokeOnDismiss({ prop, context, computed }) {
        var _a8;
        (_a8 = prop("onStatusChange")) == null ? void 0 : _a8({
          status: "dismissed",
          stepId: context.get("stepId"),
          stepIndex: computed("stepIndex")
        });
      },
      invokeOnComplete({ prop, context, computed }) {
        var _a8;
        (_a8 = prop("onStatusChange")) == null ? void 0 : _a8({
          status: "completed",
          stepId: context.get("stepId"),
          stepIndex: computed("stepIndex")
        });
      },
      invokeOnSkip({ prop, context, computed }) {
        var _a8;
        (_a8 = prop("onStatusChange")) == null ? void 0 : _a8({
          status: "skipped",
          stepId: context.get("stepId"),
          stepIndex: computed("stepIndex")
        });
      },
      invokeOnNotFound({ prop, context, computed }) {
        var _a8;
        (_a8 = prop("onStatusChange")) == null ? void 0 : _a8({
          status: "not-found",
          stepId: context.get("stepId"),
          stepIndex: computed("stepIndex")
        });
      },
      raiseStepChange({ send }) {
        send({ type: "STEP.CHANGED" });
      },
      setResolvedTarget({ context, event, computed }) {
        var _a8, _b7;
        const node = event.node ?? ((_b7 = (_a8 = computed("step")) == null ? void 0 : _a8.target) == null ? void 0 : _b7.call(_a8));
        context.set("resolvedTarget", node ?? null);
      },
      syncTargetAttrs({ context, refs, prop }) {
        var _a8;
        (_a8 = refs.get("_targetCleanup")) == null ? void 0 : _a8();
        refs.set("_targetCleanup", void 0);
        const targetEl = context.get("resolvedTarget");
        if (!targetEl) return;
        if (prop("preventInteraction")) targetEl.inert = true;
        targetEl.setAttribute("data-tour-highlighted", "");
        refs.set("_targetCleanup", () => {
          if (prop("preventInteraction")) targetEl.inert = false;
          targetEl.removeAttribute("data-tour-highlighted");
        });
      },
      cleanupRefs({ refs }) {
        var _a8, _b7;
        (_a8 = refs.get("_targetCleanup")) == null ? void 0 : _a8();
        refs.set("_targetCleanup", void 0);
        (_b7 = refs.get("_effectCleanup")) == null ? void 0 : _b7();
        refs.set("_effectCleanup", void 0);
      },
      validateSteps({ context }) {
        const ids = /* @__PURE__ */ new Set();
        context.get("steps").forEach((step) => {
          if (ids.has(step.id)) {
            throw new Error(`[zag-js/tour] Duplicate step id: ${step.id}`);
          }
          if (step.target == null && step.type == null) {
            throw new Error(`[zag-js/tour] Step ${step.id} has no target or type. At least one of those is required.`);
          }
          ids.add(step.id);
        });
      }
    },
    effects: {
      waitForScrollEnd({ send }) {
        const id = setTimeout(() => {
          send({ type: "SCROLL.END" });
        }, 100);
        return () => clearTimeout(id);
      },
      waitForTargetTimeout({ send }) {
        const id = setTimeout(() => {
          send({ type: "TARGET.NOT_FOUND" });
        }, 3e3);
        return () => clearTimeout(id);
      },
      waitForTarget({ scope, computed, send }) {
        const step = computed("step");
        if (!step) return;
        const targetEl = step.target;
        const win = scope.getWin();
        const rootNode = scope.getRootNode();
        const observer = new win.MutationObserver(() => {
          const node = targetEl == null ? void 0 : targetEl();
          if (node) {
            send({ type: "TARGET.RESOLVED", node });
            observer.disconnect();
          }
        });
        observer.observe(rootNode, {
          childList: true,
          subtree: true,
          characterData: true
        });
        return () => {
          observer.disconnect();
        };
      },
      trackBoundarySize({ context, scope }) {
        const win = scope.getWin();
        const doc = scope.getDoc();
        const onResize = () => {
          const width = (visualViewport == null ? void 0 : visualViewport.width) ?? win.innerWidth;
          const height = doc.documentElement.scrollHeight;
          context.set("boundarySize", { width, height });
        };
        onResize();
        const viewport = win.visualViewport ?? win;
        viewport.addEventListener("resize", onResize);
        return () => viewport.removeEventListener("resize", onResize);
      },
      trackEscapeKeydown({ scope, send, prop }) {
        if (!prop("closeOnEscape")) return;
        const doc = scope.getDoc();
        const onKeyDown = (event) => {
          if (event.key === "Escape") {
            event.preventDefault();
            event.stopPropagation();
            send({ type: "DISMISS", src: "esc" });
          }
        };
        doc.addEventListener("keydown", onKeyDown, true);
        return () => {
          doc.removeEventListener("keydown", onKeyDown, true);
        };
      },
      trackInteractOutside({ context, computed, scope, send, prop }) {
        const step = computed("step");
        if (step == null) return;
        const contentEl = () => getContentEl14(scope);
        return trackInteractOutside(contentEl, {
          defer: true,
          exclude(target) {
            var _a8;
            return contains((_a8 = step.target) == null ? void 0 : _a8.call(step), target);
          },
          onFocusOutside(event) {
            var _a8;
            (_a8 = prop("onFocusOutside")) == null ? void 0 : _a8(event);
            if (!prop("closeOnInteractOutside")) {
              event.preventDefault();
            }
          },
          onPointerDownOutside(event) {
            var _a8;
            (_a8 = prop("onPointerDownOutside")) == null ? void 0 : _a8(event);
            const isWithin = isEventInRect(context.get("targetRect"), event.detail.originalEvent);
            if (isWithin) {
              event.preventDefault();
              return;
            }
            if (!prop("closeOnInteractOutside")) {
              event.preventDefault();
            }
          },
          onInteractOutside(event) {
            var _a8;
            (_a8 = prop("onInteractOutside")) == null ? void 0 : _a8(event);
            if (event.defaultPrevented) return;
            send({ type: "DISMISS", src: "interact-outside" });
          }
        });
      },
      trackDismissableBranch({ computed, scope }) {
        const step = computed("step");
        if (step == null) return;
        const contentEl = () => getContentEl14(scope);
        return trackDismissableBranch(contentEl, { defer: !contentEl() });
      },
      trapFocus({ computed, scope }) {
        const step = computed("step");
        if (step == null) return;
        const contentEl = () => getContentEl14(scope);
        return trapFocus(contentEl, {
          escapeDeactivates: false,
          allowOutsideClick: true,
          preventScroll: true,
          returnFocusOnDeactivate: false
        });
      },
      trackPlacement({ context, computed, scope, prop }) {
        const step = computed("step");
        if (step == null) return;
        context.set("currentPlacement", step.placement ?? "bottom");
        if (isDialogStep(step)) {
          return syncZIndex(scope);
        }
        if (!isTooltipStep(step)) {
          return;
        }
        const positionerEl = () => getPositionerEl12(scope);
        return getPlacement(context.get("resolvedTarget"), positionerEl, {
          defer: true,
          placement: step.placement ?? "bottom",
          strategy: "absolute",
          gutter: 10,
          offset: step.offset,
          getAnchorRect(el) {
            if (!isHTMLElement(el)) return null;
            const rect = el.getBoundingClientRect();
            return offset3(rect, prop("spotlightOffset"));
          },
          onComplete(data) {
            const { rects } = data.middlewareData;
            context.set("currentPlacement", data.placement);
            context.set("targetRect", rects.reference);
          }
        });
      }
    }
  }
});
function syncZIndex(scope) {
  return raf(() => {
    const contentEl = getContentEl14(scope);
    if (!contentEl) return;
    const styles = getComputedStyle2(contentEl);
    const positionerEl = getPositionerEl12(scope);
    const backdropEl = getBackdropEl2(scope);
    if (positionerEl) {
      positionerEl.style.setProperty("--z-index", styles.zIndex);
      positionerEl.style.setProperty("z-index", "var(--z-index)");
    }
    if (backdropEl) {
      backdropEl.style.setProperty("--z-index", styles.zIndex);
    }
  });
}
function setStep(params, idx) {
  const { context, refs, computed, prop } = params;
  const steps = context.get("steps");
  const step = steps[idx];
  if (!step) {
    context.set("stepId", null);
    return;
  }
  if (isEqual(context.get("stepId"), step.id)) return;
  const update = (data) => {
    context.set("steps", (prev2) => prev2.map((s, i) => i === idx ? { ...s, ...data } : s));
  };
  const next2 = () => {
    const idx2 = nextIndex(steps, computed("stepIndex"));
    context.set("stepId", steps[idx2].id);
  };
  const goto = (id) => {
    const step2 = findStep(steps, id);
    if (!step2) return;
    context.set("stepId", step2.id);
  };
  const dismiss = () => {
    var _a8;
    context.set("stepId", null);
    (_a8 = prop("onStatusChange")) == null ? void 0 : _a8({ status: "dismissed", stepId: null, stepIndex: -1 });
  };
  const show = () => {
    context.set("stepId", step.id);
  };
  if (!step.effect) {
    show();
    return;
  }
  const cleanup = step.effect({
    show,
    next: next2,
    update,
    target: step.target,
    dismiss,
    goto
  });
  refs.set("_effectCleanup", cleanup);
}
var props41 = createProps()([
  "closeOnEscape",
  "closeOnInteractOutside",
  "dir",
  "getRootNode",
  "id",
  "ids",
  "keyboardNavigation",
  "onFocusOutside",
  "onInteractOutside",
  "onPointerDownOutside",
  "onStatusChange",
  "onStepChange",
  "onStepsChange",
  "preventInteraction",
  "spotlightOffset",
  "spotlightRadius",
  "stepId",
  "steps",
  "translations"
]);
var splitProps41 = createSplitProps(props41);

// node_modules/@ark-ui/react/dist/components/tour/tour.anatomy.js
var tourAnatomy = anatomy41.extendWith("control");

// node_modules/@ark-ui/react/dist/components/tour/tour-control.js
var TourControl = (0, import_react929.forwardRef)((props43, ref) => (0, import_jsx_runtime431.jsx)(ark.div, { ...tourAnatomy.build().control.attrs, ...props43, ref }));
TourControl.displayName = "TourControl";

// node_modules/@ark-ui/react/dist/components/tour/tour-description.js
var import_jsx_runtime432 = __toESM(require_jsx_runtime(), 1);
var import_react931 = __toESM(require_react(), 1);
var TourDescription = (0, import_react931.forwardRef)((props43, ref) => {
  var _a8;
  const tour = useTourContext();
  const mergedProps = mergeProps2(tour.getDescriptionProps(), props43);
  return (0, import_jsx_runtime432.jsx)(ark.div, { ...mergedProps, ref, children: mergedProps.children || ((_a8 = tour.step) == null ? void 0 : _a8.description) });
});
TourDescription.displayName = "TourDescription";

// node_modules/@ark-ui/react/dist/components/tour/tour-positioner.js
var import_jsx_runtime433 = __toESM(require_jsx_runtime(), 1);
var import_react933 = __toESM(require_react(), 1);
var TourPositioner = (0, import_react933.forwardRef)((props43, ref) => {
  const tour = useTourContext();
  const mergedProps = mergeProps2(tour.getPositionerProps(), props43);
  const presence = usePresenceContext();
  if (presence.unmounted) {
    return null;
  }
  return (0, import_jsx_runtime433.jsx)(ark.div, { ...mergedProps, ref });
});
TourPositioner.displayName = "TourPositioner";

// node_modules/@ark-ui/react/dist/components/tour/tour-progress-text.js
var import_jsx_runtime434 = __toESM(require_jsx_runtime(), 1);
var import_react935 = __toESM(require_react(), 1);
var TourProgressText = (0, import_react935.forwardRef)((props43, ref) => {
  const tour = useTourContext();
  const mergedProps = mergeProps2(tour.getProgressTextProps(), props43);
  return (0, import_jsx_runtime434.jsx)(ark.div, { ...mergedProps, ref, children: mergedProps.children || tour.getProgressText() });
});
TourProgressText.displayName = "TourProgressText";

// node_modules/@ark-ui/react/dist/components/tour/tour-root.js
var import_jsx_runtime435 = __toESM(require_jsx_runtime(), 1);

// node_modules/@ark-ui/react/dist/components/tour/tour-spotlight.js
var import_jsx_runtime436 = __toESM(require_jsx_runtime(), 1);
var import_react938 = __toESM(require_react(), 1);
var TourSpotlight = (0, import_react938.forwardRef)((props43, ref) => {
  var _a8, _b7;
  const tour = useTourContext();
  const renderStrategyProps = useRenderStrategyPropsContext();
  const presence = usePresence({
    ...renderStrategyProps,
    present: tour.open
  });
  const mergedProps = mergeProps2(tour.getSpotlightProps(), presence.getPresenceProps(), props43);
  const hidden = !tour.open || !((_b7 = (_a8 = tour.step) == null ? void 0 : _a8.target) == null ? void 0 : _b7.call(_a8));
  if (presence.unmounted) {
    return null;
  }
  return (0, import_jsx_runtime436.jsx)(ark.div, { ...mergedProps, ref: composeRefs(presence.ref, ref), hidden });
});
TourSpotlight.displayName = "TourSpotlight";

// node_modules/@ark-ui/react/dist/components/tour/tour-title.js
var import_jsx_runtime437 = __toESM(require_jsx_runtime(), 1);
var import_react940 = __toESM(require_react(), 1);
var TourTitle = (0, import_react940.forwardRef)((props43, ref) => {
  var _a8;
  const tour = useTourContext();
  const mergedProps = mergeProps2(tour.getTitleProps(), props43);
  return (0, import_jsx_runtime437.jsx)(ark.h2, { ...mergedProps, ref, children: mergedProps.children || ((_a8 = tour.step) == null ? void 0 : _a8.title) });
});
TourTitle.displayName = "TourTitle";

// node_modules/@ark-ui/react/dist/components/tour/use-tour.js
var import_react942 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/tree-view/tree-view-branch.js
var import_jsx_runtime438 = __toESM(require_jsx_runtime(), 1);
var import_react944 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/tree-view/use-tree-view-context.js
var [TreeViewProvider, useTreeViewContext] = createContext3({
  name: "TreeViewContext",
  hookName: "useTreeViewContext",
  providerName: "<TreeViewProvider />"
});

// node_modules/@ark-ui/react/dist/components/tree-view/use-tree-view-node-context.js
var [TreeViewNodeStateProvider, useTreeViewNodeContext] = createContext3({
  name: "TreeViewNodeContext",
  hookName: "useTreeViewNodeContext",
  providerName: "<TreeViewNodeProvider />"
});

// node_modules/@ark-ui/react/dist/components/tree-view/use-tree-view-node-props-context.js
var [TreeViewNodePropsProvider, useTreeViewNodePropsContext] = createContext3({
  name: "TreeViewNodePropsContext",
  hookName: "useTreeViewNodePropsContext",
  providerName: "<TreeViewItemProvider />"
});

// node_modules/@ark-ui/react/dist/components/tree-view/tree-view-branch.js
var TreeViewBranch = (0, import_react944.forwardRef)((props43, ref) => {
  const treeView = useTreeViewContext();
  const nodeProps = useTreeViewNodePropsContext();
  const nodeState = useTreeViewNodeContext();
  const renderStrategyProps = useRenderStrategyPropsContext();
  const mergedProps = mergeProps2(treeView.getBranchProps(nodeProps), props43);
  const branchContentProps = treeView.getBranchContentProps(nodeProps);
  return (0, import_jsx_runtime438.jsx)(
    CollapsibleRoot,
    {
      ref,
      open: nodeState.expanded,
      ids: { content: branchContentProps.id },
      ...renderStrategyProps,
      ...mergedProps
    }
  );
});
TreeViewBranch.displayName = "TreeViewBranch";

// node_modules/@ark-ui/react/dist/components/tree-view/tree-view-branch-content.js
var import_jsx_runtime439 = __toESM(require_jsx_runtime(), 1);
var import_react946 = __toESM(require_react(), 1);
var splitVisibilityProps2 = createSplitProps2();
var TreeViewBranchContent = (0, import_react946.forwardRef)((props43, ref) => {
  const treeView = useTreeViewContext();
  const nodeProps = useTreeViewNodePropsContext();
  const contentProps2 = treeView.getBranchContentProps(nodeProps);
  const [, branchContentProps] = splitVisibilityProps2(contentProps2, ["hidden", "data-state"]);
  const mergedProps = mergeProps2(branchContentProps, props43);
  return (0, import_jsx_runtime439.jsx)(CollapsibleContent, { ref, ...mergedProps });
});
TreeViewBranchContent.displayName = "TreeViewBranchContent";

// node_modules/@ark-ui/react/dist/components/tree-view/tree-view-branch-control.js
var import_jsx_runtime440 = __toESM(require_jsx_runtime(), 1);
var import_react948 = __toESM(require_react(), 1);
var TreeViewBranchControl = (0, import_react948.forwardRef)((props43, ref) => {
  const treeView = useTreeViewContext();
  const nodeProps = useTreeViewNodePropsContext();
  const mergedProps = mergeProps2(treeView.getBranchControlProps(nodeProps), props43);
  return (0, import_jsx_runtime440.jsx)(ark.div, { ...mergedProps, ref });
});
TreeViewBranchControl.displayName = "TreeViewBranchControl";

// node_modules/@ark-ui/react/dist/components/tree-view/tree-view-branch-indent-guide.js
var import_jsx_runtime441 = __toESM(require_jsx_runtime(), 1);
var import_react950 = __toESM(require_react(), 1);
var TreeViewBranchIndentGuide = (0, import_react950.forwardRef)((props43, ref) => {
  const treeView = useTreeViewContext();
  const nodeProps = useTreeViewNodePropsContext();
  const mergedProps = mergeProps2(treeView.getBranchIndentGuideProps(nodeProps), props43);
  return (0, import_jsx_runtime441.jsx)(ark.div, { ...mergedProps, ref });
});
TreeViewBranchIndentGuide.displayName = "TreeViewBranchIndentGuide";

// node_modules/@ark-ui/react/dist/components/tree-view/tree-view-branch-indicator.js
var import_jsx_runtime442 = __toESM(require_jsx_runtime(), 1);
var import_react952 = __toESM(require_react(), 1);
var TreeViewBranchIndicator = (0, import_react952.forwardRef)((props43, ref) => {
  const treeView = useTreeViewContext();
  const nodeProps = useTreeViewNodePropsContext();
  const mergedProps = mergeProps2(treeView.getBranchIndicatorProps(nodeProps), props43);
  return (0, import_jsx_runtime442.jsx)(ark.div, { ...mergedProps, ref });
});
TreeViewBranchIndicator.displayName = "TreeViewBranchIndicator";

// node_modules/@ark-ui/react/dist/components/tree-view/tree-view-branch-text.js
var import_jsx_runtime443 = __toESM(require_jsx_runtime(), 1);
var import_react954 = __toESM(require_react(), 1);
var TreeViewBranchText = (0, import_react954.forwardRef)((props43, ref) => {
  const treeView = useTreeViewContext();
  const nodeProps = useTreeViewNodePropsContext();
  const mergedProps = mergeProps2(treeView.getBranchTextProps(nodeProps), props43);
  return (0, import_jsx_runtime443.jsx)(ark.span, { ...mergedProps, ref });
});
TreeViewBranchText.displayName = "TreeViewBranchText";

// node_modules/@ark-ui/react/dist/components/tree-view/tree-view-branch-trigger.js
var import_jsx_runtime444 = __toESM(require_jsx_runtime(), 1);
var import_react956 = __toESM(require_react(), 1);
var TreeViewBranchTrigger = (0, import_react956.forwardRef)((props43, ref) => {
  const treeView = useTreeViewContext();
  const nodeProps = useTreeViewNodePropsContext();
  const mergedProps = mergeProps2(treeView.getBranchTriggerProps(nodeProps), props43);
  return (0, import_jsx_runtime444.jsx)(ark.div, { ...mergedProps, ref });
});
TreeViewBranchTrigger.displayName = "TreeViewBranchTrigger";

// node_modules/@ark-ui/react/dist/components/tree-view/tree-view-item.js
var import_jsx_runtime445 = __toESM(require_jsx_runtime(), 1);
var import_react958 = __toESM(require_react(), 1);
var TreeViewItem = (0, import_react958.forwardRef)((props43, ref) => {
  const treeView = useTreeViewContext();
  const nodeProps = useTreeViewNodePropsContext();
  const mergedProps = mergeProps2(treeView.getItemProps(nodeProps), props43);
  return (0, import_jsx_runtime445.jsx)(ark.div, { ...mergedProps, ref });
});
TreeViewItem.displayName = "TreeViewItem";

// node_modules/@ark-ui/react/dist/components/tree-view/tree-view-item-indicator.js
var import_jsx_runtime446 = __toESM(require_jsx_runtime(), 1);
var import_react960 = __toESM(require_react(), 1);
var TreeViewItemIndicator = (0, import_react960.forwardRef)((props43, ref) => {
  const treeView = useTreeViewContext();
  const nodeProps = useTreeViewNodePropsContext();
  const mergedProps = mergeProps2(treeView.getItemIndicatorProps(nodeProps), props43);
  return (0, import_jsx_runtime446.jsx)(ark.div, { ...mergedProps, ref });
});
TreeViewItemIndicator.displayName = "TreeViewItemIndicator";

// node_modules/@ark-ui/react/dist/components/tree-view/tree-view-item-text.js
var import_jsx_runtime447 = __toESM(require_jsx_runtime(), 1);
var import_react962 = __toESM(require_react(), 1);
var TreeViewItemText = (0, import_react962.forwardRef)((props43, ref) => {
  const treeView = useTreeViewContext();
  const nodeProps = useTreeViewNodePropsContext();
  const mergedProps = mergeProps2(treeView.getItemTextProps(nodeProps), props43);
  return (0, import_jsx_runtime447.jsx)(ark.span, { ...mergedProps, ref });
});
TreeViewItemText.displayName = "TreeViewItemText";

// node_modules/@ark-ui/react/dist/components/tree-view/tree-view-label.js
var import_jsx_runtime448 = __toESM(require_jsx_runtime(), 1);
var import_react964 = __toESM(require_react(), 1);
var TreeViewLabel = (0, import_react964.forwardRef)((props43, ref) => {
  const treeView = useTreeViewContext();
  const mergedProps = mergeProps2(treeView.getLabelProps(), props43);
  return (0, import_jsx_runtime448.jsx)(ark.label, { ...mergedProps, ref });
});
TreeViewLabel.displayName = "TreeViewLabel";

// node_modules/@ark-ui/react/dist/components/tree-view/tree-view-node-provider.js
var import_jsx_runtime449 = __toESM(require_jsx_runtime(), 1);

// node_modules/@ark-ui/react/dist/components/tree-view/tree-view-root.js
var import_jsx_runtime450 = __toESM(require_jsx_runtime(), 1);
var import_react968 = __toESM(require_react(), 1);

// node_modules/@zag-js/tree-view/dist/index.mjs
var anatomy42 = createAnatomy("tree-view").parts(
  "root",
  "label",
  "tree",
  "item",
  "itemIndicator",
  "itemText",
  "branch",
  "branchControl",
  "branchTrigger",
  "branchContent",
  "branchText",
  "branchIndicator",
  "branchIndentGuide"
);
var parts45 = anatomy42.build();
var collection4 = (options) => {
  return new TreeCollection(options);
};
collection4.empty = () => {
  return new TreeCollection({ rootNode: { children: [] } });
};
var getRootId32 = (ctx) => {
  var _a8;
  return ((_a8 = ctx.ids) == null ? void 0 : _a8.root) ?? `tree:${ctx.id}:root`;
};
var getLabelId19 = (ctx) => {
  var _a8;
  return ((_a8 = ctx.ids) == null ? void 0 : _a8.label) ?? `tree:${ctx.id}:label`;
};
var getNodeId = (ctx, value) => {
  var _a8, _b7;
  return ((_b7 = (_a8 = ctx.ids) == null ? void 0 : _a8.node) == null ? void 0 : _b7.call(_a8, value)) ?? `tree:${ctx.id}:node:${value}`;
};
var getTreeId = (ctx) => {
  var _a8;
  return ((_a8 = ctx.ids) == null ? void 0 : _a8.tree) ?? `tree:${ctx.id}:tree`;
};
var focusNode = (ctx, value) => {
  var _a8;
  if (value == null) return;
  const nodeId = getNodeId(ctx, value);
  (_a8 = ctx.getById(nodeId)) == null ? void 0 : _a8.focus({ preventScroll: true });
};
function connect43(service, normalize4) {
  const { context, scope, computed, prop, send } = service;
  const collection22 = prop("collection");
  const expandedValue = Array.from(context.get("expandedValue"));
  const selectedValue = Array.from(context.get("selectedValue"));
  const isTypingAhead = computed("isTypingAhead");
  const focusedValue = context.get("focusedValue");
  const loadingStatus = context.get("loadingStatus");
  function getNodeState(props210) {
    const { node, indexPath } = props210;
    const value = collection22.getNodeValue(node);
    return {
      value,
      indexPath,
      valuePath: collection22.getValuePath(indexPath),
      disabled: Boolean(node.disabled),
      focused: focusedValue == null ? isEqual(indexPath, [0]) : focusedValue === value,
      selected: selectedValue.includes(value),
      expanded: expandedValue.includes(value),
      loading: loadingStatus[value] === "loading",
      depth: indexPath.length,
      isBranch: collection22.isBranchNode(node)
    };
  }
  return {
    collection: collection22,
    expandedValue,
    selectedValue,
    expand(value) {
      send({ type: value ? "BRANCH.EXPAND" : "EXPANDED.ALL", value });
    },
    collapse(value) {
      send({ type: value ? "BRANCH.COLLAPSE" : "EXPANDED.SET", value });
    },
    deselect(value) {
      send({ type: value ? "NODE.DESELECT" : "SELECTED.SET", value });
    },
    select(value) {
      send({ type: value ? "NODE.SELECT" : "SELECTED.ALL", value });
    },
    getVisibleNodes() {
      return computed("visibleNodes").map(({ node }) => node);
    },
    focus(value) {
      focusNode(scope, value);
    },
    selectParent(value) {
      const parentNode = collection22.getParentNode(value);
      if (!parentNode) return;
      const _selectedValue = add(selectedValue, collection22.getNodeValue(parentNode));
      send({ type: "SELECTED.SET", value: _selectedValue, src: "select.parent" });
    },
    expandParent(value) {
      const parentNode = collection22.getParentNode(value);
      if (!parentNode) return;
      const _expandedValue = add(expandedValue, collection22.getNodeValue(parentNode));
      send({ type: "EXPANDED.SET", value: _expandedValue, src: "expand.parent" });
    },
    setExpandedValue(value) {
      const _expandedValue = uniq2(value);
      send({ type: "EXPANDED.SET", value: _expandedValue });
    },
    setSelectedValue(value) {
      const _selectedValue = uniq2(value);
      send({ type: "SELECTED.SET", value: _selectedValue });
    },
    getRootProps() {
      return normalize4.element({
        ...parts45.root.attrs,
        id: getRootId32(scope),
        dir: prop("dir")
      });
    },
    getLabelProps() {
      return normalize4.element({
        ...parts45.label.attrs,
        id: getLabelId19(scope),
        dir: prop("dir")
      });
    },
    getTreeProps() {
      return normalize4.element({
        ...parts45.tree.attrs,
        id: getTreeId(scope),
        dir: prop("dir"),
        role: "tree",
        "aria-label": "Tree View",
        "aria-labelledby": getLabelId19(scope),
        "aria-multiselectable": prop("selectionMode") === "multiple" || void 0,
        tabIndex: -1,
        onKeyDown(event) {
          if (event.defaultPrevented) return;
          if (isComposingEvent(event)) return;
          const target = getEventTarget(event);
          if (isEditableElement(target)) return;
          const node = target == null ? void 0 : target.closest("[data-part=branch-control], [data-part=item]");
          if (!node) return;
          const nodeId = node.dataset.value;
          if (nodeId == null) {
            console.warn(`[zag-js/tree-view] Node id not found for node`, node);
            return;
          }
          const isBranchNode = node.matches("[data-part=branch-control]");
          const keyMap2 = {
            ArrowDown(event2) {
              if (isModifierKey(event2)) return;
              event2.preventDefault();
              send({ type: "NODE.ARROW_DOWN", id: nodeId, shiftKey: event2.shiftKey });
            },
            ArrowUp(event2) {
              if (isModifierKey(event2)) return;
              event2.preventDefault();
              send({ type: "NODE.ARROW_UP", id: nodeId, shiftKey: event2.shiftKey });
            },
            ArrowLeft(event2) {
              if (isModifierKey(event2) || node.dataset.disabled) return;
              event2.preventDefault();
              send({ type: isBranchNode ? "BRANCH_NODE.ARROW_LEFT" : "NODE.ARROW_LEFT", id: nodeId });
            },
            ArrowRight(event2) {
              if (!isBranchNode || node.dataset.disabled) return;
              event2.preventDefault();
              send({ type: "BRANCH_NODE.ARROW_RIGHT", id: nodeId });
            },
            Home(event2) {
              if (isModifierKey(event2)) return;
              event2.preventDefault();
              send({ type: "NODE.HOME", id: nodeId, shiftKey: event2.shiftKey });
            },
            End(event2) {
              if (isModifierKey(event2)) return;
              event2.preventDefault();
              send({ type: "NODE.END", id: nodeId, shiftKey: event2.shiftKey });
            },
            Space(event2) {
              var _a8;
              if (node.dataset.disabled) return;
              if (isTypingAhead) {
                send({ type: "TREE.TYPEAHEAD", key: event2.key });
              } else {
                (_a8 = keyMap2.Enter) == null ? void 0 : _a8.call(keyMap2, event2);
              }
            },
            Enter(event2) {
              if (node.dataset.disabled) return;
              const isLink = target == null ? void 0 : target.closest("a[href]");
              if (!isLink) event2.preventDefault();
              send({ type: isBranchNode ? "BRANCH_NODE.CLICK" : "NODE.CLICK", id: nodeId, src: "keyboard" });
            },
            "*"(event2) {
              if (node.dataset.disabled) return;
              event2.preventDefault();
              send({ type: "SIBLINGS.EXPAND", id: nodeId });
            },
            a(event2) {
              if (!event2.metaKey || node.dataset.disabled) return;
              event2.preventDefault();
              send({ type: "SELECTED.ALL", moveFocus: true });
            }
          };
          const key = getEventKey(event, { dir: prop("dir") });
          const exec = keyMap2[key];
          if (exec) {
            exec(event);
            return;
          }
          if (!isTypingAhead) return;
          const isValidTypeahead = event.key.length === 1 && !isModifierKey(event);
          if (!isValidTypeahead) return;
          send({ type: "TREE.TYPEAHEAD", key: event.key, id: nodeId });
          event.preventDefault();
        }
      });
    },
    getNodeState,
    getItemProps(props210) {
      const itemState = getNodeState(props210);
      return normalize4.element({
        ...parts45.item.attrs,
        id: getNodeId(scope, itemState.value),
        dir: prop("dir"),
        "data-ownedby": getTreeId(scope),
        "data-path": props210.indexPath.join("/"),
        "data-value": itemState.value,
        tabIndex: itemState.focused ? 0 : -1,
        "data-focus": dataAttr(itemState.focused),
        role: "treeitem",
        "aria-current": itemState.selected ? "true" : void 0,
        "aria-selected": itemState.disabled ? void 0 : itemState.selected,
        "data-selected": dataAttr(itemState.selected),
        "aria-disabled": itemState.disabled,
        "data-disabled": dataAttr(itemState.disabled),
        "aria-level": itemState.depth,
        "data-depth": itemState.depth,
        style: {
          "--depth": itemState.depth
        },
        onFocus(event) {
          event.stopPropagation();
          send({ type: "NODE.FOCUS", id: itemState.value });
        },
        onClick(event) {
          if (itemState.disabled) return;
          const isMetaKey = event.metaKey || event.ctrlKey;
          send({ type: "NODE.CLICK", id: itemState.value, shiftKey: event.shiftKey, ctrlKey: isMetaKey });
          event.stopPropagation();
          const isLink = event.currentTarget.matches("a[href]");
          if (!isLink) event.preventDefault();
        }
      });
    },
    getItemTextProps(props210) {
      const itemState = getNodeState(props210);
      return normalize4.element({
        ...parts45.itemText.attrs,
        "data-disabled": dataAttr(itemState.disabled),
        "data-selected": dataAttr(itemState.selected),
        "data-focus": dataAttr(itemState.focused)
      });
    },
    getItemIndicatorProps(props210) {
      const itemState = getNodeState(props210);
      return normalize4.element({
        ...parts45.itemIndicator.attrs,
        "aria-hidden": true,
        "data-disabled": dataAttr(itemState.disabled),
        "data-selected": dataAttr(itemState.selected),
        "data-focus": dataAttr(itemState.focused),
        hidden: !itemState.selected
      });
    },
    getBranchProps(props210) {
      const nodeState = getNodeState(props210);
      return normalize4.element({
        ...parts45.branch.attrs,
        "data-depth": nodeState.depth,
        dir: prop("dir"),
        "data-branch": nodeState.value,
        role: "treeitem",
        "data-ownedby": getTreeId(scope),
        "data-value": nodeState.value,
        "aria-level": nodeState.depth,
        "aria-selected": nodeState.disabled ? void 0 : nodeState.selected,
        "data-path": props210.indexPath.join("/"),
        "data-selected": dataAttr(nodeState.selected),
        "aria-expanded": nodeState.expanded,
        "data-state": nodeState.expanded ? "open" : "closed",
        "aria-disabled": nodeState.disabled,
        "data-disabled": dataAttr(nodeState.disabled),
        "data-loading": dataAttr(nodeState.loading),
        "aria-busy": nodeState.loading,
        style: {
          "--depth": nodeState.depth
        }
      });
    },
    getBranchIndicatorProps(props210) {
      const nodeState = getNodeState(props210);
      return normalize4.element({
        ...parts45.branchIndicator.attrs,
        "aria-hidden": true,
        "data-state": nodeState.expanded ? "open" : "closed",
        "data-disabled": dataAttr(nodeState.disabled),
        "data-selected": dataAttr(nodeState.selected),
        "data-focus": dataAttr(nodeState.focused),
        "data-loading": dataAttr(nodeState.loading)
      });
    },
    getBranchTriggerProps(props210) {
      const nodeState = getNodeState(props210);
      return normalize4.element({
        ...parts45.branchTrigger.attrs,
        role: "button",
        dir: prop("dir"),
        "data-disabled": dataAttr(nodeState.disabled),
        "data-state": nodeState.expanded ? "open" : "closed",
        "data-value": nodeState.value,
        "data-loading": dataAttr(nodeState.loading),
        disabled: nodeState.loading,
        onClick(event) {
          if (nodeState.disabled || nodeState.loading) return;
          send({ type: "BRANCH_TOGGLE.CLICK", id: nodeState.value });
          event.stopPropagation();
        }
      });
    },
    getBranchControlProps(props210) {
      const nodeState = getNodeState(props210);
      return normalize4.element({
        ...parts45.branchControl.attrs,
        role: "button",
        id: getNodeId(scope, nodeState.value),
        dir: prop("dir"),
        tabIndex: nodeState.focused ? 0 : -1,
        "data-path": props210.indexPath.join("/"),
        "data-state": nodeState.expanded ? "open" : "closed",
        "data-disabled": dataAttr(nodeState.disabled),
        "data-selected": dataAttr(nodeState.selected),
        "data-focus": dataAttr(nodeState.focused),
        "data-value": nodeState.value,
        "data-depth": nodeState.depth,
        "data-loading": dataAttr(nodeState.loading),
        "aria-busy": nodeState.loading,
        onFocus(event) {
          send({ type: "NODE.FOCUS", id: nodeState.value });
          event.stopPropagation();
        },
        onClick(event) {
          if (nodeState.disabled || nodeState.loading) return;
          const isMetaKey = event.metaKey || event.ctrlKey;
          send({ type: "BRANCH_NODE.CLICK", id: nodeState.value, shiftKey: event.shiftKey, ctrlKey: isMetaKey });
          event.stopPropagation();
        }
      });
    },
    getBranchTextProps(props210) {
      const nodeState = getNodeState(props210);
      return normalize4.element({
        ...parts45.branchText.attrs,
        dir: prop("dir"),
        "data-disabled": dataAttr(nodeState.disabled),
        "data-state": nodeState.expanded ? "open" : "closed",
        "data-loading": dataAttr(nodeState.loading)
      });
    },
    getBranchContentProps(props210) {
      const nodeState = getNodeState(props210);
      return normalize4.element({
        ...parts45.branchContent.attrs,
        role: "group",
        dir: prop("dir"),
        "data-state": nodeState.expanded ? "open" : "closed",
        "data-depth": nodeState.depth,
        "data-path": props210.indexPath.join("/"),
        "data-value": nodeState.value,
        hidden: !nodeState.expanded
      });
    },
    getBranchIndentGuideProps(props210) {
      const nodeState = getNodeState(props210);
      return normalize4.element({
        ...parts45.branchIndentGuide.attrs,
        "data-depth": nodeState.depth
      });
    }
  };
}
var { and: and15 } = createGuards();
var machine43 = createMachine({
  props({ props: props210 }) {
    return {
      selectionMode: "single",
      collection: collection4.empty(),
      typeahead: true,
      expandOnClick: true,
      defaultExpandedValue: [],
      defaultSelectedValue: [],
      ...props210
    };
  },
  initialState() {
    return "idle";
  },
  context({ prop, bindable, getContext }) {
    return {
      expandedValue: bindable(() => ({
        defaultValue: prop("defaultExpandedValue"),
        value: prop("expandedValue"),
        isEqual,
        onChange(value) {
          var _a8;
          const ctx = getContext();
          const focusedValue = ctx.get("focusedValue");
          (_a8 = prop("onExpandedChange")) == null ? void 0 : _a8({ expandedValue: value, focusedValue });
        }
      })),
      selectedValue: bindable(() => ({
        defaultValue: prop("defaultSelectedValue"),
        value: prop("selectedValue"),
        isEqual,
        onChange(value) {
          var _a8;
          const ctx = getContext();
          const focusedValue = ctx.get("focusedValue");
          (_a8 = prop("onSelectionChange")) == null ? void 0 : _a8({ selectedValue: value, focusedValue });
        }
      })),
      focusedValue: bindable(() => ({
        defaultValue: prop("focusedValue"),
        onChange(value) {
          var _a8;
          (_a8 = prop("onFocusChange")) == null ? void 0 : _a8({ focusedValue: value });
        }
      })),
      loadingStatus: bindable(() => ({
        defaultValue: {}
      }))
    };
  },
  refs() {
    return {
      typeaheadState: { ...getByTypeahead.defaultOptions },
      pendingAborts: /* @__PURE__ */ new Map()
    };
  },
  computed: {
    isMultipleSelection: ({ prop }) => prop("selectionMode") === "multiple",
    isTypingAhead: ({ refs }) => refs.get("typeaheadState").keysSoFar.length > 0,
    visibleNodes: ({ prop, context }) => {
      const nodes = [];
      prop("collection").visit({
        skip: skipFn({ prop, context }),
        onEnter: (node, indexPath) => {
          nodes.push({ node, indexPath });
        }
      });
      return nodes;
    }
  },
  on: {
    "EXPANDED.SET": {
      actions: ["setExpanded"]
    },
    "EXPANDED.ALL": {
      actions: ["expandAllBranches"]
    },
    "BRANCH.EXPAND": {
      actions: ["expandBranches"]
    },
    "BRANCH.COLLAPSE": {
      actions: ["collapseBranches"]
    },
    "SELECTED.SET": {
      actions: ["setSelected"]
    },
    "SELECTED.ALL": [
      {
        guard: and15("isMultipleSelection", "moveFocus"),
        actions: ["selectAllNodes", "focusTreeLastNode"]
      },
      {
        guard: "isMultipleSelection",
        actions: ["selectAllNodes"]
      }
    ],
    "NODE.SELECT": {
      actions: ["selectNode"]
    },
    "NODE.DESELECT": {
      actions: ["deselectNode"]
    }
  },
  exit: ["clearPendingAborts"],
  states: {
    idle: {
      on: {
        "NODE.FOCUS": {
          actions: ["setFocusedNode"]
        },
        "NODE.ARROW_DOWN": [
          {
            guard: and15("isShiftKey", "isMultipleSelection"),
            actions: ["focusTreeNextNode", "extendSelectionToNextNode"]
          },
          {
            actions: ["focusTreeNextNode"]
          }
        ],
        "NODE.ARROW_UP": [
          {
            guard: and15("isShiftKey", "isMultipleSelection"),
            actions: ["focusTreePrevNode", "extendSelectionToPrevNode"]
          },
          {
            actions: ["focusTreePrevNode"]
          }
        ],
        "NODE.ARROW_LEFT": {
          actions: ["focusBranchNode"]
        },
        "BRANCH_NODE.ARROW_LEFT": [
          {
            guard: "isBranchExpanded",
            actions: ["collapseBranch"]
          },
          {
            actions: ["focusBranchNode"]
          }
        ],
        "BRANCH_NODE.ARROW_RIGHT": [
          {
            guard: and15("isBranchFocused", "isBranchExpanded"),
            actions: ["focusBranchFirstNode"]
          },
          {
            actions: ["expandBranch"]
          }
        ],
        "SIBLINGS.EXPAND": {
          actions: ["expandSiblingBranches"]
        },
        "NODE.HOME": [
          {
            guard: and15("isShiftKey", "isMultipleSelection"),
            actions: ["extendSelectionToFirstNode", "focusTreeFirstNode"]
          },
          {
            actions: ["focusTreeFirstNode"]
          }
        ],
        "NODE.END": [
          {
            guard: and15("isShiftKey", "isMultipleSelection"),
            actions: ["extendSelectionToLastNode", "focusTreeLastNode"]
          },
          {
            actions: ["focusTreeLastNode"]
          }
        ],
        "NODE.CLICK": [
          {
            guard: and15("isCtrlKey", "isMultipleSelection"),
            actions: ["toggleNodeSelection"]
          },
          {
            guard: and15("isShiftKey", "isMultipleSelection"),
            actions: ["extendSelectionToNode"]
          },
          {
            actions: ["selectNode"]
          }
        ],
        "BRANCH_NODE.CLICK": [
          {
            guard: and15("isCtrlKey", "isMultipleSelection"),
            actions: ["toggleNodeSelection"]
          },
          {
            guard: and15("isShiftKey", "isMultipleSelection"),
            actions: ["extendSelectionToNode"]
          },
          {
            guard: "openOnClick",
            actions: ["selectNode", "toggleBranchNode"]
          },
          {
            actions: ["selectNode"]
          }
        ],
        "BRANCH_TOGGLE.CLICK": {
          actions: ["toggleBranchNode"]
        },
        "TREE.TYPEAHEAD": {
          actions: ["focusMatchedNode"]
        }
      }
    }
  },
  implementations: {
    guards: {
      isBranchFocused: ({ context, event }) => context.get("focusedValue") === event.id,
      isBranchExpanded: ({ context, event }) => context.get("expandedValue").includes(event.id),
      isShiftKey: ({ event }) => event.shiftKey,
      isCtrlKey: ({ event }) => event.ctrlKey,
      hasSelectedItems: ({ context }) => context.get("selectedValue").length > 0,
      isMultipleSelection: ({ prop }) => prop("selectionMode") === "multiple",
      moveFocus: ({ event }) => !!event.moveFocus,
      openOnClick: ({ prop }) => !!prop("expandOnClick")
    },
    actions: {
      selectNode({ context, event, prop }) {
        const value = toArray2(event.id || event.value);
        context.set("selectedValue", (prev2) => {
          if (prop("selectionMode") === "single") {
            return [last(value)].filter(Boolean);
          } else {
            return uniq2([...prev2, ...value]);
          }
        });
      },
      deselectNode({ context, event }) {
        const value = toArray2(event.id || event.value);
        context.set("selectedValue", (prev2) => remove(prev2, ...value));
      },
      setFocusedNode({ context, event }) {
        context.set("focusedValue", event.id);
      },
      clearFocusedNode({ context }) {
        context.set("focusedValue", null);
      },
      clearSelectedItem({ context }) {
        context.set("selectedValue", []);
      },
      toggleBranchNode({ context, event, action }) {
        const isExpanded = context.get("expandedValue").includes(event.id);
        action(isExpanded ? ["collapseBranch"] : ["expandBranch"]);
      },
      expandBranch(params) {
        const { event } = params;
        expandBranches(params, [event.id]);
      },
      expandBranches(params) {
        const { context, event } = params;
        const valuesToExpand = toArray2(event.value);
        expandBranches(params, diff(valuesToExpand, context.get("expandedValue")));
      },
      collapseBranch({ context, event }) {
        context.set("expandedValue", (prev2) => remove(prev2, event.id));
      },
      collapseBranches(params) {
        const { context, event } = params;
        const value = toArray2(event.value);
        context.set("expandedValue", (prev2) => remove(prev2, ...value));
      },
      setExpanded({ context, event }) {
        context.set("expandedValue", event.value);
      },
      setSelected({ context, event }) {
        context.set("selectedValue", event.value);
      },
      focusTreeFirstNode({ prop, scope }) {
        const collection22 = prop("collection");
        const firstNode = collection22.getFirstNode();
        const firstValue = collection22.getNodeValue(firstNode);
        focusNode(scope, firstValue);
      },
      focusTreeLastNode({ prop, scope }) {
        const collection22 = prop("collection");
        const lastNode = collection22.getLastNode();
        const lastValue = collection22.getNodeValue(lastNode);
        focusNode(scope, lastValue);
      },
      focusBranchFirstNode({ event, prop, scope }) {
        const collection22 = prop("collection");
        const branchNode = collection22.findNode(event.id);
        const firstNode = collection22.getFirstNode(branchNode);
        const firstValue = collection22.getNodeValue(firstNode);
        focusNode(scope, firstValue);
      },
      focusTreeNextNode(params) {
        const { event, prop, scope } = params;
        const collection22 = prop("collection");
        const nextNode = collection22.getNextNode(event.id, { skip: skipFn(params) });
        if (!nextNode) return;
        const nextValue = collection22.getNodeValue(nextNode);
        focusNode(scope, nextValue);
      },
      focusTreePrevNode(params) {
        const { event, prop, scope } = params;
        const collection22 = prop("collection");
        const prevNode = collection22.getPreviousNode(event.id, { skip: skipFn(params) });
        if (!prevNode) return;
        const prevValue = collection22.getNodeValue(prevNode);
        focusNode(scope, prevValue);
      },
      focusBranchNode({ event, prop, scope }) {
        const collection22 = prop("collection");
        const parentNode = collection22.getParentNode(event.id);
        const parentValue = parentNode ? collection22.getNodeValue(parentNode) : void 0;
        focusNode(scope, parentValue);
      },
      selectAllNodes({ context, prop }) {
        context.set("selectedValue", prop("collection").getValues());
      },
      focusMatchedNode(params) {
        const { context, prop, refs, event, scope, computed } = params;
        const nodes = computed("visibleNodes");
        const elements = nodes.map(({ node: node2 }) => ({
          textContent: prop("collection").stringifyNode(node2),
          id: prop("collection").getNodeValue(node2)
        }));
        const node = getByTypeahead(elements, {
          state: refs.get("typeaheadState"),
          activeId: context.get("focusedValue"),
          key: event.key
        });
        focusNode(scope, node == null ? void 0 : node.id);
      },
      toggleNodeSelection({ context, event }) {
        const selectedValue = addOrRemove(context.get("selectedValue"), event.id);
        context.set("selectedValue", selectedValue);
      },
      expandAllBranches(params) {
        const { context, prop } = params;
        const branchValues = prop("collection").getBranchValues();
        const valuesToExpand = diff(branchValues, context.get("expandedValue"));
        expandBranches(params, valuesToExpand);
      },
      expandSiblingBranches(params) {
        const { context, event, prop } = params;
        const collection22 = prop("collection");
        const indexPath = collection22.getIndexPath(event.id);
        if (!indexPath) return;
        const nodes = collection22.getSiblingNodes(indexPath);
        const values = nodes.map((node) => collection22.getNodeValue(node));
        const valuesToExpand = diff(values, context.get("expandedValue"));
        expandBranches(params, valuesToExpand);
      },
      extendSelectionToNode(params) {
        const { context, event, prop, computed } = params;
        const collection22 = prop("collection");
        const anchorValue = first(context.get("selectedValue")) || collection22.getNodeValue(collection22.getFirstNode());
        const targetValue = event.id;
        let values = [anchorValue, targetValue];
        let hits = 0;
        const visibleNodes = computed("visibleNodes");
        visibleNodes.forEach(({ node }) => {
          const nodeValue = collection22.getNodeValue(node);
          if (hits === 1) values.push(nodeValue);
          if (nodeValue === anchorValue || nodeValue === targetValue) hits++;
        });
        context.set("selectedValue", uniq2(values));
      },
      extendSelectionToNextNode(params) {
        const { context, event, prop } = params;
        const collection22 = prop("collection");
        const nextNode = collection22.getNextNode(event.id, { skip: skipFn(params) });
        if (!nextNode) return;
        const values = new Set(context.get("selectedValue"));
        const nextValue = collection22.getNodeValue(nextNode);
        if (nextValue == null) return;
        if (values.has(event.id) && values.has(nextValue)) {
          values.delete(event.id);
        } else if (!values.has(nextValue)) {
          values.add(nextValue);
        }
        context.set("selectedValue", Array.from(values));
      },
      extendSelectionToPrevNode(params) {
        const { context, event, prop } = params;
        const collection22 = prop("collection");
        const prevNode = collection22.getPreviousNode(event.id, { skip: skipFn(params) });
        if (!prevNode) return;
        const values = new Set(context.get("selectedValue"));
        const prevValue = collection22.getNodeValue(prevNode);
        if (prevValue == null) return;
        if (values.has(event.id) && values.has(prevValue)) {
          values.delete(event.id);
        } else if (!values.has(prevValue)) {
          values.add(prevValue);
        }
        context.set("selectedValue", Array.from(values));
      },
      extendSelectionToFirstNode(params) {
        const { context, prop } = params;
        const collection22 = prop("collection");
        const currentSelection = first(context.get("selectedValue"));
        const values = [];
        collection22.visit({
          skip: skipFn(params),
          onEnter: (node) => {
            const nodeValue = collection22.getNodeValue(node);
            values.push(nodeValue);
            if (nodeValue === currentSelection) {
              return "stop";
            }
          }
        });
        context.set("selectedValue", values);
      },
      extendSelectionToLastNode(params) {
        const { context, prop } = params;
        const collection22 = prop("collection");
        const currentSelection = first(context.get("selectedValue"));
        const values = [];
        let current = false;
        collection22.visit({
          skip: skipFn(params),
          onEnter: (node) => {
            const nodeValue = collection22.getNodeValue(node);
            if (nodeValue === currentSelection) current = true;
            if (current) values.push(nodeValue);
          }
        });
        context.set("selectedValue", values);
      },
      clearPendingAborts({ refs }) {
        const aborts = refs.get("pendingAborts");
        aborts.forEach((abort) => abort.abort());
        aborts.clear();
      }
    }
  }
});
function skipFn(params) {
  const { prop, context } = params;
  return function skip({ indexPath }) {
    const paths = prop("collection").getValuePath(indexPath).slice(0, -1);
    return paths.some((value) => !context.get("expandedValue").includes(value));
  };
}
function partition(array, predicate) {
  const pass = [];
  const fail = [];
  array.forEach((value) => {
    if (predicate(value)) pass.push(value);
    else fail.push(value);
  });
  return [pass, fail];
}
function expandBranches(params, ids) {
  const { context, prop, refs } = params;
  if (!prop("loadChildren")) {
    context.set("expandedValue", (prev2) => uniq2(add(prev2, ...ids)));
    return;
  }
  const [loadedValues, loadingValues] = partition(ids, (id) => context.get("loadingStatus")[id] === "loaded");
  if (loadedValues.length > 0) {
    context.set("expandedValue", (prev2) => uniq2(add(prev2, ...loadedValues)));
  }
  if (loadingValues.length === 0) return;
  const collection22 = prop("collection");
  const [nodeWithChildren, nodeWithoutChildren] = partition(loadingValues, (id) => {
    const node = collection22.findNode(id);
    return collection22.getNodeChildren(node).length > 0;
  });
  if (nodeWithChildren.length > 0) {
    context.set("expandedValue", (prev2) => uniq2(add(prev2, ...nodeWithChildren)));
  }
  if (nodeWithoutChildren.length === 0) return;
  context.set("loadingStatus", (prev2) => ({
    ...prev2,
    ...nodeWithoutChildren.reduce((acc, id) => ({ ...acc, [id]: "loading" }), {})
  }));
  const nodesToLoad = nodeWithoutChildren.map((id) => {
    const indexPath = collection22.getIndexPath(id);
    const valuePath = collection22.getValuePath(indexPath);
    const node = collection22.findNode(id);
    return { id, indexPath, valuePath, node };
  });
  const pendingAborts = refs.get("pendingAborts");
  const loadChildren = prop("loadChildren");
  ensure(loadChildren, () => "[zag-js/tree-view] `loadChildren` is required for async expansion");
  const proms = nodesToLoad.map(({ id, indexPath, valuePath, node }) => {
    const existingAbort = pendingAborts.get(id);
    if (existingAbort) {
      existingAbort.abort();
      pendingAborts.delete(id);
    }
    const abortController = new AbortController();
    pendingAborts.set(id, abortController);
    return loadChildren({
      valuePath,
      indexPath,
      node,
      signal: abortController.signal
    });
  });
  Promise.allSettled(proms).then((results) => {
    var _a8;
    const loadedValues2 = [];
    const nextLoadingStatus = context.get("loadingStatus");
    let collection32 = prop("collection");
    results.forEach((result, index) => {
      const { id, indexPath, node } = nodesToLoad[index];
      if (result.status === "fulfilled") {
        nextLoadingStatus[id] = "loaded";
        loadedValues2.push(id);
        collection32 = collection32.replace(indexPath, { ...node, children: result.value });
      } else {
        pendingAborts.delete(id);
        Reflect.deleteProperty(nextLoadingStatus, id);
      }
    });
    context.set("loadingStatus", nextLoadingStatus);
    if (loadedValues2.length) {
      context.set("expandedValue", (prev2) => uniq2(add(prev2, ...loadedValues2)));
      (_a8 = prop("onLoadChildrenComplete")) == null ? void 0 : _a8({ collection: collection32 });
    }
  });
}
var props42 = createProps()([
  "ids",
  "collection",
  "dir",
  "expandedValue",
  "expandOnClick",
  "focusedValue",
  "getRootNode",
  "id",
  "onExpandedChange",
  "onFocusChange",
  "onSelectionChange",
  "selectedValue",
  "selectionMode",
  "typeahead",
  "defaultExpandedValue",
  "defaultSelectedValue",
  "onLoadChildrenComplete",
  "loadChildren"
]);
var splitProps42 = createSplitProps(props42);
var itemProps13 = createProps()(["node", "indexPath"]);
var splitItemProps13 = createSplitProps(itemProps13);

// node_modules/@ark-ui/react/dist/components/tree-view/use-tree-view.js
var import_react966 = __toESM(require_react(), 1);
var useTreeView = (props43) => {
  const id = (0, import_react966.useId)();
  const { dir } = useLocaleContext();
  const { getRootNode } = useEnvironmentContext();
  const machineProps = {
    id,
    dir,
    getRootNode,
    ...props43
  };
  const service = useMachine(machine43, machineProps);
  return connect43(service, normalizeProps);
};

// node_modules/@ark-ui/react/dist/components/tree-view/tree-view-root.js
var TreeViewImpl = (props43, ref) => {
  const [renderStrategyProps, treeViewProps] = splitRenderStrategyProps(props43);
  const [useTreeViewProps, localProps] = createSplitProps2()(treeViewProps, [
    "collection",
    "defaultExpandedValue",
    "defaultSelectedValue",
    "expandedValue",
    "expandOnClick",
    "focusedValue",
    "id",
    "ids",
    "onExpandedChange",
    "onFocusChange",
    "onSelectionChange",
    "selectedValue",
    "selectionMode",
    "typeahead",
    "loadChildren",
    "onLoadChildrenComplete"
  ]);
  const treeView = useTreeView(useTreeViewProps);
  const mergedProps = mergeProps2(treeView.getRootProps(), localProps);
  return (0, import_jsx_runtime450.jsx)(TreeViewProvider, { value: treeView, children: (0, import_jsx_runtime450.jsx)(RenderStrategyPropsProvider, { value: renderStrategyProps, children: (0, import_jsx_runtime450.jsx)(ark.div, { ...mergedProps, ref }) }) });
};
var TreeViewRoot = (0, import_react968.forwardRef)(TreeViewImpl);

// node_modules/@ark-ui/react/dist/components/tree-view/tree-view-root-provider.js
var import_jsx_runtime451 = __toESM(require_jsx_runtime(), 1);
var import_react970 = __toESM(require_react(), 1);
var TreeViewImpl2 = (props43, ref) => {
  const [renderStrategyProps, treeViewProps] = splitRenderStrategyProps(props43);
  const [{ value: treeView }, localProps] = createSplitProps2()(treeViewProps, ["value"]);
  const mergedProps = mergeProps2(treeView.getRootProps(), localProps);
  return (0, import_jsx_runtime451.jsx)(TreeViewProvider, { value: treeView, children: (0, import_jsx_runtime451.jsx)(RenderStrategyPropsProvider, { value: renderStrategyProps, children: (0, import_jsx_runtime451.jsx)(ark.div, { ...mergedProps, ref }) }) });
};
var TreeViewRootProvider = (0, import_react970.forwardRef)(TreeViewImpl2);

// node_modules/@ark-ui/react/dist/components/tree-view/tree-view-tree.js
var import_jsx_runtime452 = __toESM(require_jsx_runtime(), 1);
var import_react972 = __toESM(require_react(), 1);
var TreeViewTree = (0, import_react972.forwardRef)((props43, ref) => {
  const treeView = useTreeViewContext();
  const mergedProps = mergeProps2(treeView.getTreeProps(), props43);
  return (0, import_jsx_runtime452.jsx)(ark.div, { ...mergedProps, ref });
});
TreeViewTree.displayName = "TreeViewTree";

// node_modules/@ark-ui/react/dist/providers/locale/locale-provider.js
var import_jsx_runtime453 = __toESM(require_jsx_runtime(), 1);
var LocaleProvider = (props43) => {
  const { children, locale } = props43;
  const context = {
    locale,
    dir: isRTL(locale) ? "rtl" : "ltr"
  };
  return (0, import_jsx_runtime453.jsx)(LocaleContextProvider, { value: context, children });
};

// node_modules/@ark-ui/react/dist/providers/locale/use-filter.js
var import_react973 = __toESM(require_react(), 1);
function useFilter(props43) {
  const env = useLocaleContext();
  const locale = props43.locale ?? env.locale;
  return (0, import_react973.useMemo)(() => createFilter({ ...props43, locale }), [locale, props43]);
}

// node_modules/@chakra-ui/react/dist/esm/hooks/use-element-rect.js
var import_react975 = __toESM(require_react(), 1);
function useElementRect() {
  const ref = (0, import_react975.useRef)(null);
  const [rect, setRect] = (0, import_react975.useState)(null);
  const env = useEnvironmentContext();
  (0, import_react975.useEffect)(() => {
    const node = ref.current;
    if (!node) return;
    const handleResize = () => {
      setRect(node.getBoundingClientRect());
    };
    const win = env.getWindow();
    if (!win) return;
    const observer = new win.ResizeObserver(handleResize);
    observer.observe(node);
    return () => observer.disconnect();
  }, [env]);
  return { ref, rect };
}

// node_modules/@chakra-ui/react/dist/esm/hooks/use-force-update.js
var import_react976 = __toESM(require_react(), 1);
function useForceUpdate() {
  return (0, import_react976.useReducer)((x) => x + 1, 0)[1];
}

// node_modules/@chakra-ui/react/dist/esm/hooks/use-list-collection.js
var import_react977 = __toESM(require_react(), 1);
function useListCollection2(props43) {
  const { initialItems = [], filter, limit, ...collectionOptions } = props43;
  const create = (items) => {
    return createListCollection({ ...collectionOptions, items });
  };
  const [collection5, setCollectionImpl] = (0, import_react977.useState)(
    () => create(limit != null ? initialItems.slice(0, limit) : initialItems)
  );
  const setCollection = useCallbackRef((collection22) => {
    setCollectionImpl(
      limit == null ? collection22 : collection22.copy(collection22.items.slice(0, limit))
    );
  });
  return {
    collection: collection5,
    filter: (inputValue) => {
      if (!filter) return;
      let filtered = create(initialItems).filter(
        (itemString) => filter(itemString, inputValue)
      );
      setCollection(filtered);
    },
    set: useCallbackRef((items) => {
      setCollection(create(items));
    }),
    reset: useCallbackRef(() => {
      setCollection(create(initialItems));
    }),
    clear: useCallbackRef(() => {
      setCollection(create([]));
    }),
    insert: useCallbackRef((index, ...items) => {
      setCollection(collection5.insert(index, ...items));
    }),
    insertBefore: useCallbackRef((value, ...items) => {
      setCollection(collection5.insertBefore(value, ...items));
    }),
    insertAfter: useCallbackRef((value, ...items) => {
      setCollection(collection5.insertAfter(value, ...items));
    }),
    remove: useCallbackRef((...itemOrValues) => {
      setCollection(collection5.remove(...itemOrValues));
    }),
    move: useCallbackRef((value, to) => {
      setCollection(collection5.move(value, to));
    }),
    moveBefore: useCallbackRef((value, ...values) => {
      setCollection(collection5.moveBefore(value, ...values));
    }),
    moveAfter: useCallbackRef((value, ...values) => {
      setCollection(collection5.moveAfter(value, ...values));
    }),
    reorder: useCallbackRef((from, to) => {
      setCollection(collection5.reorder(from, to));
    }),
    append: useCallbackRef((...items) => {
      setCollection(collection5.append(...items));
    }),
    prepend: useCallbackRef((...items) => {
      setCollection(collection5.prepend(...items));
    }),
    update: useCallbackRef((value, item) => {
      setCollection(collection5.update(value, item));
    })
  };
}

// node_modules/@chakra-ui/react/dist/esm/hooks/use-live-ref.js
var import_react978 = __toESM(require_react(), 1);
function useLiveRef2(value) {
  const ref = (0, import_react978.useRef)(value);
  ref.current = value;
  return ref;
}

// node_modules/@chakra-ui/react/dist/esm/hooks/use-overlay.js
var import_jsx_runtime454 = __toESM(require_jsx_runtime(), 1);
var React7 = __toESM(require_react(), 1);

// node_modules/@chakra-ui/react/dist/esm/utils/omit.js
function omit(object, keysToOmit = []) {
  const clone2 = Object.assign({}, object);
  for (const key of keysToOmit) {
    if (key in clone2) {
      delete clone2[key];
    }
  }
  return clone2;
}

// node_modules/@chakra-ui/react/dist/esm/hooks/use-overlay.js
var shallowEqual = (a2, b2) => {
  if (a2.length !== b2.length) return false;
  for (let i = 0; i < a2.length; i++) {
    const aKeys = Object.keys(a2[i]);
    const bKeys = Object.keys(b2[i]);
    if (aKeys.length !== bKeys.length) return false;
    for (const key of aKeys) {
      if (!Object.is(a2[i][key], b2[i][key])) return false;
    }
  }
  return true;
};
function createOverlay(Component, options) {
  const map2 = /* @__PURE__ */ new Map();
  const exitPromises = /* @__PURE__ */ new Map();
  const subscribers = /* @__PURE__ */ new Set();
  const subscribe3 = (callback) => {
    subscribers.add(callback);
    return () => subscribers.delete(callback);
  };
  const publish = () => {
    for (const callback of subscribers) {
      callback(getSnapshot());
    }
  };
  let lastSnapshot = [];
  const getSnapshot = () => {
    const nextSnapshot = Array.from(map2.values());
    if (shallowEqual(lastSnapshot, nextSnapshot)) return lastSnapshot;
    lastSnapshot = nextSnapshot;
    return lastSnapshot;
  };
  const waitForExit = (id) => {
    return exitPromises.get(id) || Promise.resolve();
  };
  const open = (id, props43) => {
    const overlayProps = {
      ...options == null ? void 0 : options.props,
      ...props43,
      open: true,
      onOpenChange: (e) => {
        if (!e.open) close(id);
      },
      onExitComplete: () => {
        const overlay = get(id);
        if (overlay.setExitComplete) {
          overlay.setExitComplete();
          overlay.setExitComplete = void 0;
        }
        remove3(id);
      },
      setReturnValue: void 0,
      setExitComplete: void 0
    };
    map2.set(id, overlayProps);
    const prom = new Promise((resolve) => {
      map2.set(id, {
        ...overlayProps,
        setReturnValue: resolve
      });
    });
    publish();
    return prom;
  };
  const close = (id, value) => {
    const prevProps = get(id);
    map2.set(id, { ...prevProps, open: false });
    if (prevProps.setReturnValue) {
      prevProps.setReturnValue(value);
      prevProps.setReturnValue = void 0;
    }
    publish();
    const exitPromise = new Promise((resolve) => {
      const overlay = get(id);
      map2.set(id, {
        ...overlay,
        setExitComplete: resolve
      });
    });
    exitPromises.set(id, exitPromise);
    return exitPromise;
  };
  const remove3 = (id) => {
    map2.delete(id);
    exitPromises.delete(id);
    publish();
  };
  const update = (id, props43) => {
    const prevProps = get(id);
    map2.set(id, {
      ...prevProps,
      ...omit(props43, ["open", "onOpenChange", "onExitComplete"])
    });
    publish();
  };
  const get = (id) => {
    const overlay = map2.get(id);
    if (!overlay) {
      throw new Error(`[chakra-ui] Overlay with id ${id} not found`);
    }
    return overlay;
  };
  const removeAll = () => {
    map2.clear();
    exitPromises.clear();
    publish();
  };
  function Viewport() {
    const overlays = React7.useSyncExternalStore(
      subscribe3,
      getSnapshot,
      getSnapshot
    );
    return (0, import_jsx_runtime454.jsx)(import_jsx_runtime454.Fragment, { children: overlays.map((props43, index) => (
      // @ts-expect-error - TODO: fix this
      (0, import_jsx_runtime454.jsx)(Component, { ...props43 }, index)
    )) });
  }
  return {
    Viewport,
    open,
    close,
    update,
    remove: remove3,
    removeAll,
    get,
    getSnapshot,
    waitForExit
  };
}

// node_modules/@chakra-ui/react/dist/esm/hooks/use-previous.js
var import_react979 = __toESM(require_react(), 1);
function usePrevious(value) {
  const ref = (0, import_react979.useRef)(void 0);
  (0, import_react979.useEffect)(() => {
    ref.current = value;
  }, [value]);
  return ref.current;
}

// node_modules/@chakra-ui/react/dist/esm/hooks/use-safe-layout-effect.js
var import_react980 = __toESM(require_react(), 1);
var useSafeLayoutEffect3 = typeof (globalThis == null ? void 0 : globalThis.document) !== "undefined" ? import_react980.useLayoutEffect : import_react980.useEffect;

// node_modules/@chakra-ui/react/dist/esm/hooks/use-update-effect.js
var import_react981 = __toESM(require_react(), 1);
var useUpdateEffect = (effect, deps) => {
  const renderCycleRef = (0, import_react981.useRef)(false);
  const effectCycleRef = (0, import_react981.useRef)(false);
  (0, import_react981.useEffect)(() => {
    const isMounted = renderCycleRef.current;
    const shouldRun = isMounted && effectCycleRef.current;
    if (shouldRun) {
      return effect();
    }
    effectCycleRef.current = true;
  }, deps);
  (0, import_react981.useEffect)(() => {
    renderCycleRef.current = true;
    return () => {
      renderCycleRef.current = false;
    };
  }, []);
};

// node_modules/@chakra-ui/react/dist/esm/styled-system/color-mix.js
var colorMix = (value, token) => {
  var _a8;
  if (!value || typeof value !== "string") {
    return { invalid: true, value };
  }
  const [rawColor, rawOpacity] = value.split("/");
  if (!rawColor || !rawOpacity || rawColor === "currentBg") {
    return { invalid: true, value: rawColor };
  }
  const colorToken = token(`colors.${rawColor}`);
  const opacityToken = (_a8 = token.raw(`opacity.${rawOpacity}`)) == null ? void 0 : _a8.value;
  if (!opacityToken && isNaN(Number(rawOpacity))) {
    return { invalid: true, value: rawColor };
  }
  const percent = opacityToken ? Number(opacityToken) * 100 + "%" : `${rawOpacity}%`;
  const color = colorToken ?? rawColor;
  return {
    invalid: false,
    color,
    value: `color-mix(in srgb, ${color} ${percent}, transparent)`
  };
};
var createColorMixTransform = (prop) => (value, args) => {
  const mix = args.utils.colorMix(value);
  if (mix.invalid) return { [prop]: value };
  const cssVar2 = "--mix-" + prop;
  return {
    [cssVar2]: mix.value,
    [prop]: `var(${cssVar2}, ${mix.color})`
  };
};

// node_modules/@chakra-ui/react/dist/esm/utils/clone.js
function clone(obj) {
  if (obj === null || typeof obj !== "object") return obj;
  if (Array.isArray(obj)) return obj.map((prop) => clone(prop));
  const _clone = Object.create(Object.getPrototypeOf(obj));
  for (const key of Object.keys(obj)) {
    _clone[key] = clone(obj[key]);
  }
  return _clone;
}

// node_modules/@chakra-ui/react/dist/esm/utils/merge.js
function merge2(target, source) {
  if (source == null) return target;
  for (const key of Object.keys(source)) {
    if (source[key] === void 0 || key === "__proto__") continue;
    if (!isObject(target[key]) && isObject(source[key])) {
      Object.assign(target, { [key]: source[key] });
    } else if (target[key] && isObject(source[key])) {
      merge2(target[key], source[key]);
    } else if (Array.isArray(source[key]) && Array.isArray(target[key])) {
      let i = 0;
      for (; i < source[key].length; i++) {
        if (isObject(target[key][i]) && isObject(source[key][i])) {
          merge2(target[key][i], source[key][i]);
        } else {
          target[key][i] = source[key][i];
        }
      }
    } else {
      Object.assign(target, { [key]: source[key] });
    }
  }
  return target;
}
function mergeWith(target, ...sources) {
  for (const source of sources) {
    merge2(target, source);
  }
  return target;
}

// node_modules/@chakra-ui/react/dist/esm/styled-system/config.js
var defineConditions = (v) => v;
var defineRecipe = (v) => v;
var defineSlotRecipe = (v) => v;
var defineKeyframes = (v) => v;
var defineGlobalStyles = (v) => v;
var defineStyle = (v) => v;
var defineTextStyles = (v) => v;
var defineAnimationStyles = (v) => v;
var defineLayerStyles = (v) => v;
function createProxy() {
  const identity2 = (v) => v;
  return new Proxy(identity2, {
    get() {
      return identity2;
    }
  });
}
var defineTokens = createProxy();
var defineSemanticTokens = createProxy();
var defineConfig = (v) => v;
var mergeConfigs = (...configs) => {
  return mergeWith({}, ...configs.map(clone));
};

// node_modules/@chakra-ui/react/dist/esm/styled-system/css-var.js
var escRegex = /[^a-zA-Z0-9_\u0081-\uffff-]/g;
function esc(string) {
  return `${string}`.replace(escRegex, (s) => `\\${s}`);
}
var dashCaseRegex = /[A-Z]/g;
function dashCase(string) {
  return string.replace(dashCaseRegex, (match4) => `-${match4.toLowerCase()}`);
}
function cssVar(name, options = {}) {
  const { fallback: fallback4 = "", prefix = "" } = options;
  const variable = dashCase(["-", prefix, esc(name)].filter(Boolean).join("-"));
  return {
    var: variable,
    ref: `var(${variable}${fallback4 ? `, ${fallback4}` : ""})`
  };
}

// node_modules/@chakra-ui/react/dist/esm/preset-base.js
var isCssVar2 = (v) => /^var\(--.+\)$/.test(v);
var wrap4 = (str, v) => v != null ? `${str}(${v})` : v;
var deg = (v) => {
  if (isCssVar2(v) || v == null) return v;
  const unitless = typeof v === "string" && !v.endsWith("deg");
  return typeof v === "number" || unitless ? `${v}deg` : v;
};
var createFocusRing = (selector) => {
  return {
    values: ["outside", "inside", "mixed", "none"],
    transform(value, { token }) {
      const focusRingColor = token("colors.colorPalette.focusRing");
      const styles = {
        inside: {
          "--focus-ring-color": focusRingColor,
          [selector]: {
            outlineOffset: "0px",
            outlineWidth: "var(--focus-ring-width, 1px)",
            outlineColor: "var(--focus-ring-color)",
            outlineStyle: "var(--focus-ring-style, solid)",
            borderColor: "var(--focus-ring-color)"
          }
        },
        outside: {
          "--focus-ring-color": focusRingColor,
          [selector]: {
            outlineWidth: "var(--focus-ring-width, 2px)",
            outlineOffset: "var(--focus-ring-offset, 2px)",
            outlineStyle: "var(--focus-ring-style, solid)",
            outlineColor: "var(--focus-ring-color)"
          }
        },
        mixed: {
          "--focus-ring-color": focusRingColor,
          [selector]: {
            outlineWidth: "var(--focus-ring-width, 3px)",
            outlineStyle: "var(--focus-ring-style, solid)",
            outlineColor: "color-mix(in srgb, var(--focus-ring-color), transparent 60%)",
            borderColor: "var(--focus-ring-color)"
          }
        },
        none: {
          "--focus-ring-color": focusRingColor,
          [selector]: {
            outline: "none"
          }
        }
      };
      return styles[value] ?? {};
    }
  };
};
var divideColor = createColorMixTransform("borderColor");
var createTransition = (value) => {
  return {
    transition: value,
    transitionTimingFunction: "cubic-bezier(0.4, 0, 0.2, 1)",
    transitionDuration: "150ms"
  };
};
var defaultConditions = defineConditions({
  hover: [
    "@media (hover: hover)",
    "&:is(:hover, [data-hover]):not(:disabled, [data-disabled])"
  ],
  active: "&:is(:active, [data-active]):not(:disabled, [data-disabled], [data-state=open])",
  focus: "&:is(:focus, [data-focus])",
  focusWithin: "&:is(:focus-within, [data-focus-within])",
  focusVisible: "&:is(:focus-visible, [data-focus-visible])",
  disabled: "&:is(:disabled, [disabled], [data-disabled], [aria-disabled=true])",
  visited: "&:visited",
  target: "&:target",
  readOnly: "&:is([data-readonly], [aria-readonly=true], [readonly])",
  readWrite: "&:read-write",
  empty: "&:is(:empty, [data-empty])",
  checked: "&:is(:checked, [data-checked], [aria-checked=true], [data-state=checked])",
  enabled: "&:enabled",
  expanded: "&:is([aria-expanded=true], [data-expanded], [data-state=expanded])",
  highlighted: "&[data-highlighted]",
  complete: "&[data-complete]",
  incomplete: "&[data-incomplete]",
  dragging: "&[data-dragging]",
  before: "&::before",
  after: "&::after",
  firstLetter: "&::first-letter",
  firstLine: "&::first-line",
  marker: "&::marker",
  selection: "&::selection",
  file: "&::file-selector-button",
  backdrop: "&::backdrop",
  first: "&:first-of-type",
  last: "&:last-of-type",
  notFirst: "&:not(:first-of-type)",
  notLast: "&:not(:last-of-type)",
  only: "&:only-child",
  even: "&:nth-of-type(even)",
  odd: "&:nth-of-type(odd)",
  peerFocus: ".peer:is(:focus, [data-focus]) ~ &",
  peerHover: ".peer:is(:hover, [data-hover]):not(:disabled, [data-disabled]) ~ &",
  peerActive: ".peer:is(:active, [data-active]):not(:disabled, [data-disabled]) ~ &",
  peerFocusWithin: ".peer:focus-within ~ &",
  peerFocusVisible: ".peer:is(:focus-visible, [data-focus-visible]) ~ &",
  peerDisabled: ".peer:is(:disabled, [disabled], [data-disabled]) ~ &",
  peerChecked: ".peer:is(:checked, [data-checked], [aria-checked=true], [data-state=checked]) ~ &",
  peerInvalid: ".peer:is(:invalid, [data-invalid], [aria-invalid=true]) ~ &",
  peerExpanded: ".peer:is([aria-expanded=true], [data-expanded], [data-state=expanded]) ~ &",
  peerPlaceholderShown: ".peer:placeholder-shown ~ &",
  groupFocus: ".group:is(:focus, [data-focus]) &",
  groupHover: ".group:is(:hover, [data-hover]):not(:disabled, [data-disabled]) &",
  groupActive: ".group:is(:active, [data-active]):not(:disabled, [data-disabled]) &",
  groupFocusWithin: ".group:focus-within &",
  groupFocusVisible: ".group:is(:focus-visible, [data-focus-visible]) &",
  groupDisabled: ".group:is(:disabled, [disabled], [data-disabled]) &",
  groupChecked: ".group:is(:checked, [data-checked], [aria-checked=true], [data-state=checked]) &",
  groupExpanded: ".group:is([aria-expanded=true], [data-expanded], [data-state=expanded]) &",
  groupInvalid: ".group:invalid &",
  indeterminate: "&:is(:indeterminate, [data-indeterminate], [aria-checked=mixed], [data-state=indeterminate])",
  required: "&:is([data-required], [aria-required=true])",
  valid: "&:is([data-valid], [data-state=valid])",
  invalid: "&:is([data-invalid], [aria-invalid=true], [data-state=invalid])",
  autofill: "&:autofill",
  inRange: "&:is(:in-range, [data-in-range])",
  outOfRange: "&:is(:out-of-range, [data-outside-range])",
  placeholder: "&::placeholder, &[data-placeholder]",
  placeholderShown: "&:is(:placeholder-shown, [data-placeholder-shown])",
  pressed: "&:is([aria-pressed=true], [data-pressed])",
  selected: "&:is([aria-selected=true], [data-selected])",
  grabbed: "&:is([aria-grabbed=true], [data-grabbed])",
  underValue: "&[data-state=under-value]",
  overValue: "&[data-state=over-value]",
  atValue: "&[data-state=at-value]",
  default: "&:default",
  optional: "&:optional",
  open: "&:is([open], [data-open], [data-state=open])",
  closed: "&:is([closed], [data-closed], [data-state=closed])",
  fullscreen: "&is(:fullscreen, [data-fullscreen])",
  loading: "&:is([data-loading], [aria-busy=true])",
  hidden: "&:is([hidden], [data-hidden])",
  current: "&[data-current]",
  currentPage: "&[aria-current=page]",
  currentStep: "&[aria-current=step]",
  today: "&[data-today]",
  unavailable: "&[data-unavailable]",
  rangeStart: "&[data-range-start]",
  rangeEnd: "&[data-range-end]",
  now: "&[data-now]",
  topmost: "&[data-topmost]",
  motionReduce: "@media (prefers-reduced-motion: reduce)",
  motionSafe: "@media (prefers-reduced-motion: no-preference)",
  print: "@media print",
  landscape: "@media (orientation: landscape)",
  portrait: "@media (orientation: portrait)",
  dark: ".dark &, .dark .chakra-theme:not(.light) &",
  light: ":root &, .light &",
  osDark: "@media (prefers-color-scheme: dark)",
  osLight: "@media (prefers-color-scheme: light)",
  highContrast: "@media (forced-colors: active)",
  lessContrast: "@media (prefers-contrast: less)",
  moreContrast: "@media (prefers-contrast: more)",
  ltr: "[dir=ltr] &",
  rtl: "[dir=rtl] &",
  scrollbar: "&::-webkit-scrollbar",
  scrollbarThumb: "&::-webkit-scrollbar-thumb",
  scrollbarTrack: "&::-webkit-scrollbar-track",
  horizontal: "&[data-orientation=horizontal]",
  vertical: "&[data-orientation=vertical]",
  icon: "& :where(svg)",
  starting: "@starting-style"
});
var currentBgVar = cssVar("bg-currentcolor");
var isCurrentBgVar = (value) => value === currentBgVar.ref || value === "currentBg";
var colorValues = (theme) => ({
  ...theme("colors"),
  currentBg: currentBgVar
});
var defaultBaseConfig = defineConfig({
  conditions: defaultConditions,
  utilities: {
    // background
    background: {
      values: colorValues,
      shorthand: ["bg"],
      transform(value, args) {
        if (isCurrentBgVar(args.raw)) return { background: currentBgVar.ref };
        const styleObj = createColorMixTransform("background")(value, args);
        return { ...styleObj, [currentBgVar.var]: styleObj == null ? void 0 : styleObj.background };
      }
    },
    backgroundColor: {
      values: colorValues,
      shorthand: ["bgColor"],
      transform(value, args) {
        if (isCurrentBgVar(args.raw))
          return { backgroundColor: currentBgVar.ref };
        const styleObj = createColorMixTransform("backgroundColor")(value, args);
        return {
          ...styleObj,
          [currentBgVar.var]: styleObj == null ? void 0 : styleObj.backgroundColor
        };
      }
    },
    backgroundSize: { shorthand: ["bgSize"] },
    backgroundPosition: { shorthand: ["bgPos"] },
    backgroundRepeat: { shorthand: ["bgRepeat"] },
    backgroundAttachment: { shorthand: ["bgAttachment"] },
    backgroundClip: {
      shorthand: ["bgClip"],
      values: ["text"],
      transform(value) {
        return value === "text" ? { color: "transparent", backgroundClip: "text" } : { backgroundClip: value };
      }
    },
    backgroundGradient: {
      shorthand: ["bgGradient"],
      values(theme) {
        return {
          ...theme("gradients"),
          "to-t": "linear-gradient(to top, var(--gradient))",
          "to-tr": "linear-gradient(to top right, var(--gradient))",
          "to-r": "linear-gradient(to right, var(--gradient))",
          "to-br": "linear-gradient(to bottom right, var(--gradient))",
          "to-b": "linear-gradient(to bottom, var(--gradient))",
          "to-bl": "linear-gradient(to bottom left, var(--gradient))",
          "to-l": "linear-gradient(to left, var(--gradient))",
          "to-tl": "linear-gradient(to top left, var(--gradient))"
        };
      },
      transform(value) {
        return {
          "--gradient-stops": "var(--gradient-from), var(--gradient-to)",
          "--gradient": "var(--gradient-via-stops, var(--gradient-stops))",
          backgroundImage: value
        };
      }
    },
    gradientFrom: {
      values: colorValues,
      transform: createColorMixTransform("--gradient-from")
    },
    gradientTo: {
      values: colorValues,
      transform: createColorMixTransform("--gradient-to")
    },
    gradientVia: {
      values: colorValues,
      transform(value, args) {
        const styles = createColorMixTransform("--gradient-via")(value, args);
        return {
          ...styles,
          "--gradient-via-stops": "var(--gradient-from), var(--gradient-via), var(--gradient-to)"
        };
      }
    },
    backgroundImage: {
      values(theme) {
        return { ...theme("gradients"), ...theme("assets") };
      },
      shorthand: ["bgImg", "bgImage"]
    },
    // border
    border: { values: "borders" },
    borderTop: { values: "borders" },
    borderLeft: { values: "borders" },
    borderBlockStart: { values: "borders" },
    borderRight: { values: "borders" },
    borderBottom: { values: "borders" },
    borderBlockEnd: { values: "borders" },
    borderInlineStart: { values: "borders", shorthand: ["borderStart"] },
    borderInlineEnd: { values: "borders", shorthand: ["borderEnd"] },
    borderInline: { values: "borders", shorthand: ["borderX"] },
    borderBlock: { values: "borders", shorthand: ["borderY"] },
    // border colors
    borderColor: {
      values: colorValues,
      transform: createColorMixTransform("borderColor")
    },
    borderTopColor: {
      values: colorValues,
      transform: createColorMixTransform("borderTopColor")
    },
    borderBlockStartColor: {
      values: colorValues,
      transform: createColorMixTransform("borderBlockStartColor")
    },
    borderBottomColor: {
      values: colorValues,
      transform: createColorMixTransform("borderBottomColor")
    },
    borderBlockEndColor: {
      values: colorValues,
      transform: createColorMixTransform("borderBlockEndColor")
    },
    borderLeftColor: {
      values: colorValues,
      transform: createColorMixTransform("borderLeftColor")
    },
    borderInlineStartColor: {
      values: colorValues,
      shorthand: ["borderStartColor"],
      transform: createColorMixTransform("borderInlineStartColor")
    },
    borderRightColor: {
      values: colorValues,
      transform: createColorMixTransform("borderRightColor")
    },
    borderInlineEndColor: {
      values: colorValues,
      shorthand: ["borderEndColor"],
      transform: createColorMixTransform("borderInlineEndColor")
    },
    // border styles
    borderStyle: { values: "borderStyles" },
    borderTopStyle: { values: "borderStyles" },
    borderBlockStartStyle: { values: "borderStyles" },
    borderBottomStyle: { values: "borderStyles" },
    borderBlockEndStyle: {
      values: "borderStyles"
    },
    borderInlineStartStyle: {
      values: "borderStyles",
      shorthand: ["borderStartStyle"]
    },
    borderInlineEndStyle: {
      values: "borderStyles",
      shorthand: ["borderEndStyle"]
    },
    borderLeftStyle: { values: "borderStyles" },
    borderRightStyle: { values: "borderStyles" },
    // border radius
    borderRadius: { values: "radii", shorthand: ["rounded"] },
    borderTopLeftRadius: { values: "radii", shorthand: ["roundedTopLeft"] },
    borderStartStartRadius: {
      values: "radii",
      shorthand: ["roundedStartStart", "borderTopStartRadius"]
    },
    borderEndStartRadius: {
      values: "radii",
      shorthand: ["roundedEndStart", "borderBottomStartRadius"]
    },
    borderTopRightRadius: {
      values: "radii",
      shorthand: ["roundedTopRight"]
    },
    borderStartEndRadius: {
      values: "radii",
      shorthand: ["roundedStartEnd", "borderTopEndRadius"]
    },
    borderEndEndRadius: {
      values: "radii",
      shorthand: ["roundedEndEnd", "borderBottomEndRadius"]
    },
    borderBottomLeftRadius: {
      values: "radii",
      shorthand: ["roundedBottomLeft"]
    },
    borderBottomRightRadius: {
      values: "radii",
      shorthand: ["roundedBottomRight"]
    },
    borderInlineStartRadius: {
      values: "radii",
      property: "borderRadius",
      shorthand: ["roundedStart", "borderStartRadius"],
      transform: (value) => ({
        borderStartStartRadius: value,
        borderEndStartRadius: value
      })
    },
    borderInlineEndRadius: {
      values: "radii",
      property: "borderRadius",
      shorthand: ["roundedEnd", "borderEndRadius"],
      transform: (value) => ({
        borderStartEndRadius: value,
        borderEndEndRadius: value
      })
    },
    borderTopRadius: {
      values: "radii",
      property: "borderRadius",
      shorthand: ["roundedTop"],
      transform: (value) => ({
        borderTopLeftRadius: value,
        borderTopRightRadius: value
      })
    },
    borderBottomRadius: {
      values: "radii",
      property: "borderRadius",
      shorthand: ["roundedBottom"],
      transform: (value) => ({
        borderBottomLeftRadius: value,
        borderBottomRightRadius: value
      })
    },
    borderLeftRadius: {
      values: "radii",
      property: "borderRadius",
      shorthand: ["roundedLeft"],
      transform: (value) => ({
        borderTopLeftRadius: value,
        borderBottomLeftRadius: value
      })
    },
    borderRightRadius: {
      values: "radii",
      property: "borderRadius",
      shorthand: ["roundedRight"],
      transform: (value) => ({
        borderTopRightRadius: value,
        borderBottomRightRadius: value
      })
    },
    borderWidth: { values: "borderWidths" },
    borderBlockStartWidth: { values: "borderWidths" },
    borderTopWidth: { values: "borderWidths" },
    borderBottomWidth: { values: "borderWidths" },
    borderBlockEndWidth: { values: "borderWidths" },
    borderRightWidth: { values: "borderWidths" },
    borderInlineWidth: {
      values: "borderWidths",
      shorthand: ["borderXWidth"]
    },
    borderInlineStartWidth: {
      values: "borderWidths",
      shorthand: ["borderStartWidth"]
    },
    borderInlineEndWidth: {
      values: "borderWidths",
      shorthand: ["borderEndWidth"]
    },
    borderLeftWidth: { values: "borderWidths" },
    borderBlockWidth: {
      values: "borderWidths",
      shorthand: ["borderYWidth"]
    },
    // colors
    color: {
      values: colorValues,
      transform: createColorMixTransform("color")
    },
    fill: {
      values: colorValues,
      transform: createColorMixTransform("fill")
    },
    stroke: {
      values: colorValues,
      transform: createColorMixTransform("stroke")
    },
    accentColor: {
      values: colorValues,
      transform: createColorMixTransform("accentColor")
    },
    // divide
    divideX: {
      values: { type: "string" },
      transform(value) {
        return {
          "& > :not(style, [hidden]) ~ :not(style, [hidden])": {
            borderInlineStartWidth: value,
            borderInlineEndWidth: "0px"
          }
        };
      }
    },
    divideY: {
      values: { type: "string" },
      transform(value) {
        return {
          "& > :not(style, [hidden]) ~ :not(style, [hidden])": {
            borderTopWidth: value,
            borderBottomWidth: "0px"
          }
        };
      }
    },
    divideColor: {
      values: colorValues,
      transform(value, args) {
        return {
          "& > :not(style, [hidden]) ~ :not(style, [hidden])": divideColor(
            value,
            args
          )
        };
      }
    },
    divideStyle: {
      property: "borderStyle",
      transform(value) {
        return {
          "& > :not(style, [hidden]) ~ :not(style, [hidden])": {
            borderStyle: value
          }
        };
      }
    },
    // effects
    boxShadow: { values: "shadows", shorthand: ["shadow"] },
    boxShadowColor: {
      values: colorValues,
      transform: createColorMixTransform("--shadow-color"),
      shorthand: ["shadowColor"]
    },
    mixBlendMode: { shorthand: ["blendMode"] },
    backgroundBlendMode: { shorthand: ["bgBlendMode"] },
    opacity: { values: "opacity" },
    // filters
    filter: {
      transform(v) {
        if (v !== "auto") {
          return { filter: v };
        }
        return {
          filter: `var(--blur) var(--brightness) var(--contrast) var(--grayscale) var(--hue-rotate) var(--invert) var(--saturate) var(--sepia) var(--drop-shadow)`
        };
      }
    },
    blur: {
      values: "blurs",
      transform: (v) => ({ "--blur": wrap4("blur", v) })
    },
    brightness: {
      transform: (v) => ({ "--brightness": wrap4("brightness", v) })
    },
    contrast: {
      transform: (v) => ({ "--contrast": wrap4("contrast", v) })
    },
    grayscale: {
      transform: (v) => ({ "--grayscale": wrap4("grayscale", v) })
    },
    hueRotate: {
      transform: (v) => ({ "--hue-rotate": wrap4("hue-rotate", deg(v)) })
    },
    invert: { transform: (v) => ({ "--invert": wrap4("invert", v) }) },
    saturate: {
      transform: (v) => ({ "--saturate": wrap4("saturate", v) })
    },
    sepia: { transform: (v) => ({ "--sepia": wrap4("sepia", v) }) },
    dropShadow: {
      transform: (v) => ({ "--drop-shadow": wrap4("drop-shadow", v) })
    },
    // backdrop filters
    backdropFilter: {
      transform(v) {
        if (v !== "auto") {
          return { backdropFilter: v };
        }
        return {
          backdropFilter: `var(--backdrop-blur) var(--backdrop-brightness) var(--backdrop-contrast) var(--backdrop-grayscale) var(--backdrop-hue-rotate) var(--backdrop-invert) var(--backdrop-opacity) var(--backdrop-saturate) var(--backdrop-sepia)`
        };
      }
    },
    backdropBlur: {
      values: "blurs",
      transform: (v) => ({ "--backdrop-blur": wrap4("blur", v) })
    },
    backdropBrightness: {
      transform: (v) => ({
        "--backdrop-brightness": wrap4("brightness", v)
      })
    },
    backdropContrast: {
      transform: (v) => ({ "--backdrop-contrast": wrap4("contrast", v) })
    },
    backdropGrayscale: {
      transform: (v) => ({
        "--backdrop-grayscale": wrap4("grayscale", v)
      })
    },
    backdropHueRotate: {
      transform: (v) => ({
        "--backdrop-hue-rotate": wrap4("hue-rotate", deg(v))
      })
    },
    backdropInvert: {
      transform: (v) => ({ "--backdrop-invert": wrap4("invert", v) })
    },
    backdropOpacity: {
      transform: (v) => ({ "--backdrop-opacity": wrap4("opacity", v) })
    },
    backdropSaturate: {
      transform: (v) => ({ "--backdrop-saturate": wrap4("saturate", v) })
    },
    backdropSepia: {
      transform: (v) => ({ "--backdrop-sepia": wrap4("sepia", v) })
    },
    // flexbox
    flexBasis: { values: "sizes" },
    gap: { values: "spacing" },
    rowGap: { values: "spacing", shorthand: ["gapY"] },
    columnGap: { values: "spacing", shorthand: ["gapX"] },
    flexDirection: { shorthand: ["flexDir"] },
    // grid
    gridGap: { values: "spacing" },
    gridColumnGap: { values: "spacing" },
    gridRowGap: { values: "spacing" },
    // interactivity
    outlineColor: {
      values: colorValues,
      transform: createColorMixTransform("outlineColor")
    },
    focusRing: createFocusRing("&:is(:focus, [data-focus])"),
    focusVisibleRing: createFocusRing(
      "&:is(:focus-visible, [data-focus-visible])"
    ),
    focusRingColor: {
      values: colorValues,
      transform: createColorMixTransform("--focus-ring-color")
    },
    focusRingOffset: {
      values: "spacing",
      transform: (v) => ({ "--focus-ring-offset": v })
    },
    focusRingWidth: {
      values: "borderWidths",
      property: "outlineWidth",
      transform: (v) => ({ "--focus-ring-width": v })
    },
    focusRingStyle: {
      values: "borderStyles",
      property: "outlineStyle",
      transform: (v) => ({ "--focus-ring-style": v })
    },
    // layout
    aspectRatio: { values: "aspectRatios" },
    width: { values: "sizes", shorthand: ["w"] },
    inlineSize: { values: "sizes" },
    height: { values: "sizes", shorthand: ["h"] },
    blockSize: { values: "sizes" },
    boxSize: {
      values: "sizes",
      property: "width",
      transform: (v) => ({ width: v, height: v })
    },
    minWidth: { values: "sizes", shorthand: ["minW"] },
    minInlineSize: { values: "sizes" },
    minHeight: { values: "sizes", shorthand: ["minH"] },
    minBlockSize: { values: "sizes" },
    maxWidth: { values: "sizes", shorthand: ["maxW"] },
    maxInlineSize: { values: "sizes" },
    maxHeight: { values: "sizes", shorthand: ["maxH"] },
    maxBlockSize: { values: "sizes" },
    hideFrom: {
      values: "breakpoints",
      //@ts-ignore
      transform: (value, { raw, token }) => {
        const bp = token.raw(`breakpoints.${raw}`);
        const media = bp ? `@breakpoint ${raw}` : `@media screen and (min-width: ${value})`;
        return {
          [media]: { display: "none" }
        };
      }
    },
    hideBelow: {
      values: "breakpoints",
      //@ts-ignore
      transform(value, { raw, token }) {
        const bp = token.raw(`breakpoints.${raw}`);
        const media = bp ? `@breakpoint ${raw}Down` : `@media screen and (max-width: ${value})`;
        return {
          [media]: {
            display: "none"
          }
        };
      }
    },
    // scroll
    overscrollBehavior: { shorthand: ["overscroll"] },
    overscrollBehaviorX: { shorthand: ["overscrollX"] },
    overscrollBehaviorY: { shorthand: ["overscrollY"] },
    scrollbar: {
      values: ["visible", "hidden"],
      transform(v) {
        switch (v) {
          case "visible":
            return {
              msOverflowStyle: "auto",
              scrollbarWidth: "auto",
              "&::-webkit-scrollbar": { display: "block" }
            };
          case "hidden":
            return {
              msOverflowStyle: "none",
              scrollbarWidth: "none",
              "&::-webkit-scrollbar": { display: "none" }
            };
          default:
            return {};
        }
      }
    },
    scrollbarColor: {
      values: colorValues,
      transform: createColorMixTransform("scrollbarColor")
    },
    scrollbarGutter: { values: "spacing" },
    scrollbarWidth: { values: "sizes" },
    // scroll margin
    scrollMargin: { values: "spacing" },
    scrollMarginTop: { values: "spacing" },
    scrollMarginBottom: { values: "spacing" },
    scrollMarginLeft: { values: "spacing" },
    scrollMarginRight: { values: "spacing" },
    scrollMarginX: {
      values: "spacing",
      transform: (v) => ({ scrollMarginLeft: v, scrollMarginRight: v })
    },
    scrollMarginY: {
      values: "spacing",
      transform: (v) => ({ scrollMarginTop: v, scrollMarginBottom: v })
    },
    // scroll padding
    scrollPadding: { values: "spacing" },
    scrollPaddingTop: { values: "spacing" },
    scrollPaddingBottom: { values: "spacing" },
    scrollPaddingLeft: { values: "spacing" },
    scrollPaddingRight: { values: "spacing" },
    scrollPaddingInline: { values: "spacing", shorthand: ["scrollPaddingX"] },
    scrollPaddingBlock: { values: "spacing", shorthand: ["scrollPaddingY"] },
    // scroll snap
    scrollSnapType: {
      values: {
        none: "none",
        x: "x var(--scroll-snap-strictness)",
        y: "y var(--scroll-snap-strictness)",
        both: "both var(--scroll-snap-strictness)"
      }
    },
    scrollSnapStrictness: {
      values: ["mandatory", "proximity"],
      transform: (v) => ({ "--scroll-snap-strictness": v })
    },
    scrollSnapMargin: { values: "spacing" },
    scrollSnapMarginTop: { values: "spacing" },
    scrollSnapMarginBottom: { values: "spacing" },
    scrollSnapMarginLeft: { values: "spacing" },
    scrollSnapMarginRight: { values: "spacing" },
    // list
    listStylePosition: { shorthand: ["listStylePos"] },
    listStyleImage: { values: "assets", shorthand: ["listStyleImg"] },
    // position
    position: { shorthand: ["pos"] },
    zIndex: { values: "zIndex" },
    inset: { values: "spacing" },
    insetInline: { values: "spacing", shorthand: ["insetX"] },
    insetBlock: { values: "spacing", shorthand: ["insetY"] },
    top: { values: "spacing" },
    insetBlockStart: { values: "spacing" },
    bottom: { values: "spacing" },
    insetBlockEnd: { values: "spacing" },
    left: { values: "spacing" },
    right: { values: "spacing" },
    insetInlineStart: {
      values: "spacing",
      shorthand: ["insetStart"]
    },
    insetInlineEnd: {
      values: "spacing",
      shorthand: ["insetEnd"]
    },
    // shadow / ring
    ring: {
      transform(value) {
        return {
          "--ring-offset-shadow": `var(--ring-inset) 0 0 0 var(--ring-offset-width) var(--ring-offset-color)`,
          "--ring-shadow": `var(--ring-inset) 0 0 0 calc(var(--ring-width) + var(--ring-offset-width)) var(--ring-color)`,
          "--ring-width": value,
          boxShadow: "var(--ring-offset-shadow), var(--ring-shadow), var(--shadow, 0 0 #0000)"
        };
      }
    },
    ringColor: {
      values: colorValues,
      transform: createColorMixTransform("--ring-color")
    },
    ringOffset: {
      transform: (value) => ({ "--ring-offset-width": value })
    },
    ringOffsetColor: {
      values: colorValues,
      transform: createColorMixTransform("--ring-offset-color")
    },
    ringInset: {
      transform: (v) => ({ "--ring-inset": v })
    },
    // margin
    margin: { values: "spacing", shorthand: ["m"] },
    marginTop: { values: "spacing", shorthand: ["mt"] },
    marginBlockStart: { values: "spacing" },
    marginRight: { values: "spacing", shorthand: ["mr"] },
    marginBottom: { values: "spacing", shorthand: ["mb"] },
    marginBlockEnd: { values: "spacing" },
    marginLeft: { values: "spacing", shorthand: ["ml"] },
    marginInlineStart: { values: "spacing", shorthand: ["ms", "marginStart"] },
    marginInlineEnd: { values: "spacing", shorthand: ["me", "marginEnd"] },
    marginInline: { values: "spacing", shorthand: ["mx", "marginX"] },
    marginBlock: { values: "spacing", shorthand: ["my", "marginY"] },
    // padding
    padding: { values: "spacing", shorthand: ["p"] },
    paddingTop: { values: "spacing", shorthand: ["pt"] },
    paddingRight: { values: "spacing", shorthand: ["pr"] },
    paddingBottom: { values: "spacing", shorthand: ["pb"] },
    paddingBlockStart: { values: "spacing" },
    paddingBlockEnd: { values: "spacing" },
    paddingLeft: { values: "spacing", shorthand: ["pl"] },
    paddingInlineStart: {
      values: "spacing",
      shorthand: ["ps", "paddingStart"]
    },
    paddingInlineEnd: { values: "spacing", shorthand: ["pe", "paddingEnd"] },
    paddingInline: { values: "spacing", shorthand: ["px", "paddingX"] },
    paddingBlock: { values: "spacing", shorthand: ["py", "paddingY"] },
    // text decoration
    textDecoration: { shorthand: ["textDecor"] },
    textDecorationColor: {
      values: colorValues,
      transform: createColorMixTransform("textDecorationColor")
    },
    textShadow: { values: "shadows" },
    // transform
    transform: {
      transform: (value) => {
        let v = value;
        if (value === "auto") {
          v = `translateX(var(--translate-x, 0)) translateY(var(--translate-y, 0)) rotate(var(--rotate, 0)) scaleX(var(--scale-x, 1)) scaleY(var(--scale-y, 1)) skewX(var(--skew-x, 0)) skewY(var(--skew-y, 0))`;
        }
        if (value === "auto-gpu") {
          v = `translate3d(var(--translate-x, 0), var(--translate-y, 0), 0) rotate(var(--rotate, 0)) scaleX(var(--scale-x, 1)) scaleY(var(--scale-y, 1)) skewX(var(--skew-x, 0)) skewY(var(--skew-y, 0))`;
        }
        return { transform: v };
      }
    },
    skewX: { transform: (v) => ({ "--skew-x": deg(v) }) },
    skewY: { transform: (v) => ({ "--skew-y": deg(v) }) },
    scaleX: { transform: (v) => ({ "--scale-x": v }) },
    scaleY: { transform: (v) => ({ "--scale-y": v }) },
    scale: {
      transform(value) {
        if (value !== "auto") return { scale: value };
        return {
          scale: `var(--scale-x, 1) var(--scale-y, 1)`
        };
      }
    },
    spaceXReverse: {
      values: { type: "boolean" },
      transform(value) {
        return {
          "& > :not(style, [hidden]) ~ :not(style, [hidden])": {
            "--space-x-reverse": value ? "1" : void 0
          }
        };
      }
    },
    spaceX: {
      property: "marginInlineStart",
      values: "spacing",
      transform: (v) => ({
        "& > :not(style, [hidden]) ~ :not(style, [hidden])": {
          "--space-x-reverse": "0",
          marginInlineStart: `calc(${v} * calc(1 - var(--space-x-reverse)))`,
          marginInlineEnd: `calc(${v} * var(--space-x-reverse))`
        }
      })
    },
    spaceYReverse: {
      values: { type: "boolean" },
      transform(value) {
        return {
          "& > :not(style, [hidden]) ~ :not(style, [hidden])": {
            "--space-y-reverse": value ? "1" : void 0
          }
        };
      }
    },
    spaceY: {
      property: "marginTop",
      values: "spacing",
      transform: (v) => ({
        "& > :not(style, [hidden]) ~ :not(style, [hidden])": {
          "--space-y-reverse": "0",
          marginTop: `calc(${v} * calc(1 - var(--space-y-reverse)))`,
          marginBottom: `calc(${v} * var(--space-y-reverse))`
        }
      })
    },
    rotate: {
      transform(value) {
        if (value !== "auto") return { rotate: deg(value) };
        return {
          rotate: `var(--rotate-x, 0) var(--rotate-y, 0) var(--rotate-z, 0)`
        };
      }
    },
    rotateX: {
      transform(value) {
        return { "--rotate-x": deg(value) };
      }
    },
    rotateY: {
      transform(value) {
        return { "--rotate-y": deg(value) };
      }
    },
    // transform / translate
    translate: {
      transform(value) {
        if (value !== "auto") return { translate: value };
        return {
          translate: `var(--translate-x) var(--translate-y)`
        };
      }
    },
    translateX: {
      values: "spacing",
      transform: (v) => ({ "--translate-x": v })
    },
    translateY: {
      values: "spacing",
      transform: (v) => ({ "--translate-y": v })
    },
    // transition
    transition: {
      values: [
        "all",
        "common",
        "colors",
        "opacity",
        "position",
        "backgrounds",
        "size",
        "shadow",
        "transform"
      ],
      transform(value) {
        switch (value) {
          case "all":
            return createTransition("all");
          case "position":
            return createTransition(
              "left, right, top, bottom, inset-inline, inset-block"
            );
          case "colors":
            return createTransition(
              "color, background-color, border-color, text-decoration-color, fill, stroke"
            );
          case "opacity":
            return createTransition("opacity");
          case "shadow":
            return createTransition("box-shadow");
          case "transform":
            return createTransition("transform");
          case "size":
            return createTransition("width, height");
          case "backgrounds":
            return createTransition(
              "background, background-color, background-image, background-position"
            );
          case "common":
            return createTransition(
              "color, background-color, border-color, text-decoration-color, fill, stroke, opacity, box-shadow, transform, filter, backdrop-filter"
            );
          default:
            return { transition: value };
        }
      }
    },
    transitionDuration: { values: "durations" },
    transitionProperty: {
      values: {
        common: "background-color, border-color, color, fill, stroke, opacity, box-shadow, translate, transform",
        colors: "background-color, border-color, color, fill, stroke",
        size: "width, height",
        position: "left, right, top, bottom, inset-inline, inset-block",
        background: "background, background-color, background-image, background-position"
      }
    },
    transitionTimingFunction: { values: "easings" },
    // animation
    animation: { values: "animations" },
    animationDuration: { values: "durations" },
    animationDelay: { values: "durations" },
    animationTimingFunction: { values: "easings" },
    // typography
    fontFamily: { values: "fonts" },
    fontSize: { values: "fontSizes" },
    fontWeight: { values: "fontWeights" },
    lineHeight: { values: "lineHeights" },
    letterSpacing: { values: "letterSpacings" },
    textIndent: { values: "spacing" },
    truncate: {
      values: { type: "boolean" },
      transform(value) {
        if (value === true) {
          return {
            overflow: "hidden",
            textOverflow: "ellipsis",
            whiteSpace: "nowrap"
          };
        }
        return {};
      }
    },
    lineClamp: {
      transform(value) {
        if (value === "none") {
          return {
            WebkitLineClamp: "unset"
          };
        }
        return {
          overflow: "hidden",
          display: "-webkit-box",
          WebkitLineClamp: value,
          WebkitBoxOrient: "vertical",
          textWrap: "wrap"
        };
      }
    },
    // helpers
    srOnly: {
      values: { type: "boolean" },
      transform(value) {
        return srMapping[value] || {};
      }
    },
    debug: {
      values: { type: "boolean" },
      transform(value) {
        if (!value) return {};
        return {
          outline: "1px solid blue !important",
          "& > *": {
            outline: "1px solid red !important"
          }
        };
      }
    },
    caretColor: {
      values: colorValues,
      transform: createColorMixTransform("caretColor")
    },
    cursor: { values: "cursor" }
  }
});
var srMapping = {
  true: {
    position: "absolute",
    width: "1px",
    height: "1px",
    padding: "0",
    margin: "-1px",
    overflow: "hidden",
    clip: "rect(0, 0, 0, 0)",
    whiteSpace: "nowrap",
    borderWidth: "0"
  },
  false: {
    position: "static",
    width: "auto",
    height: "auto",
    padding: "0",
    margin: "0",
    overflow: "visible",
    clip: "auto",
    whiteSpace: "normal"
  }
};

// node_modules/@pandacss/is-valid-prop/dist/index.mjs
var userGeneratedStr = "";
var userGenerated = userGeneratedStr.split(",");
var cssPropertiesStr = "WebkitAppearance,WebkitBorderBefore,WebkitBorderBeforeColor,WebkitBorderBeforeStyle,WebkitBorderBeforeWidth,WebkitBoxReflect,WebkitLineClamp,WebkitMask,WebkitMaskAttachment,WebkitMaskClip,WebkitMaskComposite,WebkitMaskImage,WebkitMaskOrigin,WebkitMaskPosition,WebkitMaskPositionX,WebkitMaskPositionY,WebkitMaskRepeat,WebkitMaskRepeatX,WebkitMaskRepeatY,WebkitMaskSize,WebkitOverflowScrolling,WebkitTapHighlightColor,WebkitTextFillColor,WebkitTextStroke,WebkitTextStrokeColor,WebkitTextStrokeWidth,WebkitTouchCallout,WebkitUserModify,WebkitUserSelect,accentColor,alignContent,alignItems,alignSelf,alignTracks,all,anchorName,anchorScope,animation,animationComposition,animationDelay,animationDirection,animationDuration,animationFillMode,animationIterationCount,animationName,animationPlayState,animationRange,animationRangeEnd,animationRangeStart,animationTimeline,animationTimingFunction,appearance,aspectRatio,backdropFilter,backfaceVisibility,background,backgroundAttachment,backgroundBlendMode,backgroundClip,backgroundColor,backgroundImage,backgroundOrigin,backgroundPosition,backgroundPositionX,backgroundPositionY,backgroundRepeat,backgroundSize,blockSize,border,borderBlock,borderBlockColor,borderBlockEnd,borderBlockEndColor,borderBlockEndStyle,borderBlockEndWidth,borderBlockStart,borderBlockStartColor,borderBlockStartStyle,borderBlockStartWidth,borderBlockStyle,borderBlockWidth,borderBottom,borderBottomColor,borderBottomLeftRadius,borderBottomRightRadius,borderBottomStyle,borderBottomWidth,borderCollapse,borderColor,borderEndEndRadius,borderEndStartRadius,borderImage,borderImageOutset,borderImageRepeat,borderImageSlice,borderImageSource,borderImageWidth,borderInline,borderInlineColor,borderInlineEnd,borderInlineEndColor,borderInlineEndStyle,borderInlineEndWidth,borderInlineStart,borderInlineStartColor,borderInlineStartStyle,borderInlineStartWidth,borderInlineStyle,borderInlineWidth,borderLeft,borderLeftColor,borderLeftStyle,borderLeftWidth,borderRadius,borderRight,borderRightColor,borderRightStyle,borderRightWidth,borderSpacing,borderStartEndRadius,borderStartStartRadius,borderStyle,borderTop,borderTopColor,borderTopLeftRadius,borderTopRightRadius,borderTopStyle,borderTopWidth,borderWidth,bottom,boxAlign,boxDecorationBreak,boxDirection,boxFlex,boxFlexGroup,boxLines,boxOrdinalGroup,boxOrient,boxPack,boxShadow,boxSizing,breakAfter,breakBefore,breakInside,captionSide,caret,caretColor,caretShape,clear,clip,clipPath,clipRule,color,colorInterpolationFilters,colorScheme,columnCount,columnFill,columnGap,columnRule,columnRuleColor,columnRuleStyle,columnRuleWidth,columnSpan,columnWidth,columns,contain,containIntrinsicBlockSize,containIntrinsicHeight,containIntrinsicInlineSize,containIntrinsicSize,containIntrinsicWidth,container,containerName,containerType,content,contentVisibility,counterIncrement,counterReset,counterSet,cursor,cx,cy,d,direction,display,dominantBaseline,emptyCells,fieldSizing,fill,fillOpacity,fillRule,filter,flex,flexBasis,flexDirection,flexFlow,flexGrow,flexShrink,flexWrap,float,floodColor,floodOpacity,font,fontFamily,fontFeatureSettings,fontKerning,fontLanguageOverride,fontOpticalSizing,fontPalette,fontSize,fontSizeAdjust,fontSmooth,fontStretch,fontStyle,fontSynthesis,fontSynthesisPosition,fontSynthesisSmallCaps,fontSynthesisStyle,fontSynthesisWeight,fontVariant,fontVariantAlternates,fontVariantCaps,fontVariantEastAsian,fontVariantEmoji,fontVariantLigatures,fontVariantNumeric,fontVariantPosition,fontVariationSettings,fontWeight,forcedColorAdjust,gap,grid,gridArea,gridAutoColumns,gridAutoFlow,gridAutoRows,gridColumn,gridColumnEnd,gridColumnGap,gridColumnStart,gridGap,gridRow,gridRowEnd,gridRowGap,gridRowStart,gridTemplate,gridTemplateAreas,gridTemplateColumns,gridTemplateRows,hangingPunctuation,height,hyphenateCharacter,hyphenateLimitChars,hyphens,imageOrientation,imageRendering,imageResolution,imeMode,initialLetter,initialLetterAlign,inlineSize,inset,insetBlock,insetBlockEnd,insetBlockStart,insetInline,insetInlineEnd,insetInlineStart,interpolateSize,isolation,justifyContent,justifyItems,justifySelf,justifyTracks,left,letterSpacing,lightingColor,lineBreak,lineClamp,lineHeight,lineHeightStep,listStyle,listStyleImage,listStylePosition,listStyleType,margin,marginBlock,marginBlockEnd,marginBlockStart,marginBottom,marginInline,marginInlineEnd,marginInlineStart,marginLeft,marginRight,marginTop,marginTrim,marker,markerEnd,markerMid,markerStart,mask,maskBorder,maskBorderMode,maskBorderOutset,maskBorderRepeat,maskBorderSlice,maskBorderSource,maskBorderWidth,maskClip,maskComposite,maskImage,maskMode,maskOrigin,maskPosition,maskRepeat,maskSize,maskType,masonryAutoFlow,mathDepth,mathShift,mathStyle,maxBlockSize,maxHeight,maxInlineSize,maxLines,maxWidth,minBlockSize,minHeight,minInlineSize,minWidth,mixBlendMode,objectFit,objectPosition,offset,offsetAnchor,offsetDistance,offsetPath,offsetPosition,offsetRotate,opacity,order,orphans,outline,outlineColor,outlineOffset,outlineStyle,outlineWidth,overflow,overflowAnchor,overflowBlock,overflowClipBox,overflowClipMargin,overflowInline,overflowWrap,overflowX,overflowY,overlay,overscrollBehavior,overscrollBehaviorBlock,overscrollBehaviorInline,overscrollBehaviorX,overscrollBehaviorY,padding,paddingBlock,paddingBlockEnd,paddingBlockStart,paddingBottom,paddingInline,paddingInlineEnd,paddingInlineStart,paddingLeft,paddingRight,paddingTop,page,pageBreakAfter,pageBreakBefore,pageBreakInside,paintOrder,perspective,perspectiveOrigin,placeContent,placeItems,placeSelf,pointerEvents,position,positionAnchor,positionArea,positionTry,positionTryFallbacks,positionTryOrder,positionVisibility,printColorAdjust,quotes,r,resize,right,rotate,rowGap,rubyAlign,rubyMerge,rubyPosition,rx,ry,scale,scrollBehavior,scrollMargin,scrollMarginBlock,scrollMarginBlockEnd,scrollMarginBlockStart,scrollMarginBottom,scrollMarginInline,scrollMarginInlineEnd,scrollMarginInlineStart,scrollMarginLeft,scrollMarginRight,scrollMarginTop,scrollPadding,scrollPaddingBlock,scrollPaddingBlockEnd,scrollPaddingBlockStart,scrollPaddingBottom,scrollPaddingInline,scrollPaddingInlineEnd,scrollPaddingInlineStart,scrollPaddingLeft,scrollPaddingRight,scrollPaddingTop,scrollSnapAlign,scrollSnapCoordinate,scrollSnapDestination,scrollSnapPointsX,scrollSnapPointsY,scrollSnapStop,scrollSnapType,scrollSnapTypeX,scrollSnapTypeY,scrollTimeline,scrollTimelineAxis,scrollTimelineName,scrollbarColor,scrollbarGutter,scrollbarWidth,shapeImageThreshold,shapeMargin,shapeOutside,shapeRendering,stopColor,stopOpacity,stroke,strokeDasharray,strokeDashoffset,strokeLinecap,strokeLinejoin,strokeMiterlimit,strokeOpacity,strokeWidth,tabSize,tableLayout,textAlign,textAlignLast,textAnchor,textBox,textBoxEdge,textBoxTrim,textCombineUpright,textDecoration,textDecorationColor,textDecorationLine,textDecorationSkip,textDecorationSkipInk,textDecorationStyle,textDecorationThickness,textEmphasis,textEmphasisColor,textEmphasisPosition,textEmphasisStyle,textIndent,textJustify,textOrientation,textOverflow,textRendering,textShadow,textSizeAdjust,textSpacingTrim,textTransform,textUnderlineOffset,textUnderlinePosition,textWrap,textWrapMode,textWrapStyle,timelineScope,top,touchAction,transform,transformBox,transformOrigin,transformStyle,transition,transitionBehavior,transitionDelay,transitionDuration,transitionProperty,transitionTimingFunction,translate,unicodeBidi,userSelect,vectorEffect,verticalAlign,viewTimeline,viewTimelineAxis,viewTimelineInset,viewTimelineName,viewTransitionName,visibility,whiteSpace,whiteSpaceCollapse,widows,width,willChange,wordBreak,wordSpacing,wordWrap,writingMode,x,y,zIndex,zoom,alignmentBaseline,baselineShift,colorInterpolation,colorRendering,glyphOrientationVertical";
var allCssProperties = cssPropertiesStr.split(",").concat(userGenerated);
var properties = new Map(allCssProperties.map((prop) => [prop, true]));
function memo3(fn) {
  const cache2 = /* @__PURE__ */ Object.create(null);
  return (arg) => {
    if (cache2[arg] === void 0)
      cache2[arg] = fn(arg);
    return cache2[arg];
  };
}
var cssPropertySelectorRegex = /&|@/;
var isCssProperty = memo3((prop) => {
  return properties.has(prop) || prop.startsWith("--") || cssPropertySelectorRegex.test(prop);
});

// node_modules/@chakra-ui/react/dist/esm/utils/walk-object.js
var isNotNullish = (element) => element != null;
function walkObject(target, predicate, options = {}) {
  const { stop, getKey } = options;
  function inner(value, path = []) {
    if (isObject(value) || Array.isArray(value)) {
      const result = {};
      for (const [prop, child] of Object.entries(value)) {
        const key = (getKey == null ? void 0 : getKey(prop, child)) ?? prop;
        const childPath = [...path, key];
        if (stop == null ? void 0 : stop(value, childPath)) {
          return predicate(value, path);
        }
        const next2 = inner(child, childPath);
        if (isNotNullish(next2)) {
          result[key] = next2;
        }
      }
      return result;
    }
    return predicate(value, path);
  }
  return inner(target);
}
function mapObject(obj, fn) {
  if (Array.isArray(obj)) return obj.map((value) => fn(value));
  if (!isObject(obj)) {
    if (obj !== null && obj !== void 0) return fn(obj);
    else return obj;
  }
  return walkObject(obj, (value) => fn(value));
}

// node_modules/@chakra-ui/react/dist/esm/utils/flatten.js
function flatten(values, stop) {
  const result = {};
  walkObject(
    values,
    (token, paths) => {
      if (token) {
        result[paths.join(".")] = token.value;
      }
    },
    { stop }
  );
  return result;
}

// node_modules/@chakra-ui/react/dist/esm/utils/memo.js
var import_fast_safe_stringify = __toESM(require_fast_safe_stringify(), 1);
var memo4 = (fn) => {
  const cache2 = /* @__PURE__ */ Object.create(null);
  function get(...args) {
    const key = args.map((v) => (0, import_fast_safe_stringify.default)(v)).join("|");
    if (cache2[key] === void 0) cache2[key] = fn(...args);
    return cache2[key];
  }
  return get;
};

// node_modules/@chakra-ui/react/dist/esm/styled-system/unit-conversion.js
var BASE_FONT_SIZE = 16;
var UNIT_PX = "px";
var UNIT_EM = "em";
var UNIT_REM = "rem";
function getUnit(value = "") {
  const DIGIT_REGEX = new RegExp(String.raw`-?\d+(?:\.\d+|\d*)`);
  const UNIT_REGEX = new RegExp(`${UNIT_PX}|${UNIT_EM}|${UNIT_REM}`);
  const unit = value.match(
    new RegExp(`${DIGIT_REGEX.source}(${UNIT_REGEX.source})`)
  );
  return unit == null ? void 0 : unit[1];
}
function toPx2(value = "") {
  if (typeof value === "number") {
    return `${value}px`;
  }
  const unit = getUnit(value);
  if (!unit) return value;
  if (unit === UNIT_PX) {
    return value;
  }
  if (unit === UNIT_EM || unit === UNIT_REM) {
    return `${parseFloat(value) * BASE_FONT_SIZE}${UNIT_PX}`;
  }
}
function toRem(value = "") {
  const unit = getUnit(value);
  if (!unit) return value;
  if (unit === UNIT_REM) {
    return value;
  }
  if (unit === UNIT_EM) {
    return `${parseFloat(value)}${UNIT_REM}`;
  }
  if (unit === UNIT_PX) {
    return `${parseFloat(value) / BASE_FONT_SIZE}${UNIT_REM}`;
  }
}

// node_modules/@chakra-ui/react/dist/esm/styled-system/breakpoints.js
var capitalize = (str) => str.charAt(0).toUpperCase() + str.slice(1);
function createBreakpoints(breakpoints2) {
  const sorted = sort(breakpoints2);
  const values = Object.fromEntries(sorted);
  function get(name) {
    return values[name];
  }
  function only(name) {
    return build(get(name));
  }
  function getRanges() {
    const breakpoints22 = Object.keys(values);
    const permuations = getPermutations(breakpoints22);
    const results = breakpoints22.flatMap((name) => {
      const value = get(name);
      const down2 = [
        `${name}Down`,
        build({ max: adjust(value.min) })
      ];
      const up2 = [name, build({ min: value.min })];
      const _only = [`${name}Only`, only(name)];
      return [up2, _only, down2];
    }).filter(([, value]) => value !== "").concat(
      permuations.map(([min4, max4]) => {
        const minValue = get(min4);
        const maxValue2 = get(max4);
        return [
          `${min4}To${capitalize(max4)}`,
          build({ min: minValue.min, max: adjust(maxValue2.min) })
        ];
      })
    );
    return Object.fromEntries(results);
  }
  function toConditions() {
    const ranges = getRanges();
    return Object.fromEntries(Object.entries(ranges));
  }
  const conditions = toConditions();
  const getCondition = (key) => {
    return conditions[key];
  };
  function keys() {
    return ["base", ...Object.keys(values)];
  }
  function up(name) {
    return build({ min: get(name).min });
  }
  function down(name) {
    return build({ max: adjust(get(name).min) });
  }
  return {
    values: Object.values(values),
    only,
    keys,
    conditions,
    getCondition,
    up,
    down
  };
}
function adjust(value) {
  const computedMax = parseFloat(toPx2(value) ?? "") - 0.04;
  return toRem(`${computedMax}px`);
}
function sort(breakpoints2) {
  const entries = Object.entries(breakpoints2).sort(([, minA], [, minB]) => {
    return parseInt(minA, 10) < parseInt(minB, 10) ? -1 : 1;
  });
  return entries.map(([name, min4], index, entries2) => {
    var _a8;
    let max4 = null;
    if (index <= entries2.length - 1) {
      max4 = (_a8 = entries2[index + 1]) == null ? void 0 : _a8[1];
    }
    if (max4 != null) {
      max4 = adjust(max4);
    }
    return [name, { name, min: toRem(min4), max: max4 }];
  });
}
function getPermutations(values) {
  const result = [];
  values.forEach((current, index) => {
    let idx = index;
    idx++;
    let next2 = values[idx];
    while (next2) {
      result.push([current, next2]);
      idx++;
      next2 = values[idx];
    }
  });
  return result;
}
function build({
  min: min4,
  max: max4
}) {
  if (min4 == null && max4 == null) return "";
  return [
    "@media screen",
    min4 && `(min-width: ${min4})`,
    max4 && `(max-width: ${max4})`
  ].filter(Boolean).join(" and ");
}

// node_modules/@chakra-ui/react/dist/esm/styled-system/conditions.js
var mapEntries = (obj, fn) => {
  return Object.fromEntries(
    Object.entries(obj).map(([key, value]) => fn(key, value))
  );
};
var createConditions = (options) => {
  const { breakpoints: breakpoints2, conditions: conds = {} } = options;
  const conditions = mapEntries(conds, (key, value) => [`_${key}`, value]);
  const values = Object.assign({}, conditions, breakpoints2.conditions);
  function keys() {
    return Object.keys(values);
  }
  function has2(key) {
    return keys().includes(key) || /^@|&|&$/.test(key) || key.startsWith("_");
  }
  function sort2(paths) {
    return paths.filter((v) => v !== "base").sort((a2, b2) => {
      const aa = has2(a2);
      const bb = has2(b2);
      if (aa && !bb) return 1;
      if (!aa && bb) return -1;
      return 0;
    });
  }
  function expandAtRule(key) {
    if (!key.startsWith("@breakpoint")) return key;
    return breakpoints2.getCondition(key.replace("@breakpoint ", ""));
  }
  function resolve(key) {
    return Reflect.get(values, key) || key;
  }
  return {
    keys,
    sort: sort2,
    has: has2,
    resolve,
    breakpoints: breakpoints2.keys(),
    expandAtRule
  };
};

// node_modules/@chakra-ui/react/dist/esm/styled-system/sort-at-params.js
var createMediaQueryRegex = (dimension) => ({
  minMax: new RegExp(
    `(!?\\(\\s*min(-device-)?-${dimension})(.|
)+\\(\\s*max(-device)?-${dimension}`,
    "i"
  ),
  min: new RegExp(`\\(\\s*min(-device)?-${dimension}`, "i"),
  maxMin: new RegExp(
    `(!?\\(\\s*max(-device)?-${dimension})(.|
)+\\(\\s*min(-device)?-${dimension}`,
    "i"
  ),
  max: new RegExp(`\\(\\s*max(-device)?-${dimension}`, "i")
});
var widthRegex = createMediaQueryRegex("width");
var heightRegex = createMediaQueryRegex("height");
var createQueryTester = (regexSet) => ({
  isMin: _testQuery(regexSet.minMax, regexSet.maxMin, regexSet.min),
  isMax: _testQuery(regexSet.maxMin, regexSet.minMax, regexSet.max)
});
var { isMin: isMinWidth, isMax: isMaxWidth } = createQueryTester(widthRegex);
var { isMin: isMinHeight, isMax: isMaxHeight } = createQueryTester(heightRegex);
var isPrint = /print/i;
var isPrintOnly = /^print$/i;
var isLength = /(-?\d*\.?\d+)(ch|em|ex|px|rem)/;
var lengthExec = /(\d)/;
var maxValue = Number.MAX_VALUE;
var multipliers = { ch: 8.8984375, em: 16, rem: 16, ex: 8.296875, px: 1 };
function getQueryLength(query2) {
  const length = isLength.exec(query2) || (isMinWidth(query2) || isMinHeight(query2) ? lengthExec.exec(query2) : null);
  if (!length) return maxValue;
  if (length[0] === "0") return 0;
  const number = parseFloat(length[1]);
  const unit = length[2];
  return number * (multipliers[unit] || 1);
}
function _testQuery(doubleTestTrue, doubleTestFalse, singleTest) {
  return (query2) => doubleTestTrue.test(query2) || !doubleTestFalse.test(query2) && singleTest.test(query2);
}
function _testIsPrint(a2, b2) {
  const isPrintA = isPrint.test(a2), isPrintOnlyA = isPrintOnly.test(a2);
  const isPrintB = isPrint.test(b2), isPrintOnlyB = isPrintOnly.test(b2);
  if (isPrintA && isPrintB) {
    if (!isPrintOnlyA && isPrintOnlyB) return 1;
    if (isPrintOnlyA && !isPrintOnlyB) return -1;
    return a2.localeCompare(b2);
  }
  return isPrintA ? 1 : isPrintB ? -1 : null;
}
var sortAtParams = memo4((a2, b2) => {
  const testIsPrint = _testIsPrint(a2, b2);
  if (testIsPrint !== null) return testIsPrint;
  const minA = isMinWidth(a2) || isMinHeight(a2), maxA = isMaxWidth(a2) || isMaxHeight(a2);
  const minB = isMinWidth(b2) || isMinHeight(b2), maxB = isMaxWidth(b2) || isMaxHeight(b2);
  if (minA && maxB) return -1;
  if (maxA && minB) return 1;
  const lengthA = getQueryLength(a2), lengthB = getQueryLength(b2);
  if (lengthA === maxValue && lengthB === maxValue) return a2.localeCompare(b2);
  if (lengthA === maxValue) return 1;
  if (lengthB === maxValue) return -1;
  if (lengthA !== lengthB) {
    return lengthA > lengthB ? maxA ? -1 : 1 : maxA ? 1 : -1;
  }
  return a2.localeCompare(b2);
});

// node_modules/@chakra-ui/react/dist/esm/styled-system/sort-at-rules.js
function sortQueries(queries) {
  return queries.sort(([a2], [b2]) => sortAtParams(a2, b2));
}
function sortAtRules(obj) {
  const mediaQueries = [];
  const containerQueries = [];
  const rest = {};
  for (const [key, value] of Object.entries(obj)) {
    if (key.startsWith("@media")) {
      mediaQueries.push([key, value]);
    } else if (key.startsWith("@container")) {
      containerQueries.push([key, value]);
    } else if (isObject(value)) {
      rest[key] = sortAtRules(value);
    } else {
      rest[key] = value;
    }
  }
  const sortedMediaQueries = sortQueries(mediaQueries);
  const sortedContainerQueries = sortQueries(containerQueries);
  return {
    ...rest,
    ...Object.fromEntries(sortedMediaQueries),
    ...Object.fromEntries(sortedContainerQueries)
  };
}

// node_modules/@chakra-ui/react/dist/esm/styled-system/css.js
var importantRegex = /\s*!(important)?/i;
var isImportant = (v) => isString(v) ? importantRegex.test(v) : false;
var withoutImportant = (v) => isString(v) ? v.replace(importantRegex, "").trim() : v;
function createCssFn(context) {
  const { transform: transform2, conditions, normalize: normalize4 } = context;
  const mergeFn = mergeCss(context);
  return memo4(function cssFn(...styleArgs) {
    const styles = mergeFn(...styleArgs);
    const normalized = normalize4(styles);
    const result = /* @__PURE__ */ Object.create(null);
    walkObject(normalized, (value, paths) => {
      const important = isImportant(value);
      if (value == null) return;
      const [prop, ...selectors] = conditions.sort(paths).map(conditions.resolve);
      if (important) {
        value = withoutImportant(value);
      }
      let transformed = transform2(prop, value) ?? /* @__PURE__ */ Object.create(null);
      transformed = walkObject(
        transformed,
        (v) => isString(v) && important ? `${v} !important` : v,
        { getKey: (prop2) => conditions.expandAtRule(prop2) }
      );
      mergeByPath(result, selectors.flat(), transformed);
    });
    return sortAtRules(result);
  });
}
function mergeByPath(target, paths, value) {
  let acc = target;
  for (const path of paths) {
    if (!path) continue;
    if (!acc[path]) acc[path] = /* @__PURE__ */ Object.create(null);
    acc = acc[path];
  }
  mergeWith(acc, value);
}
function compactFn(...styles) {
  return styles.filter(
    (style) => isObject(style) && Object.keys(compact(style)).length > 0
  );
}
function mergeCss(ctx) {
  function resolve(styles) {
    const comp = compactFn(...styles);
    if (comp.length === 1) return comp;
    return comp.map((style) => ctx.normalize(style));
  }
  return memo4(function mergeFn(...styles) {
    return mergeWith({}, ...resolve(styles));
  });
}

// node_modules/@chakra-ui/react/dist/esm/styled-system/cva.js
var defaults = (conf) => ({
  base: {},
  variants: {},
  defaultVariants: {},
  compoundVariants: [],
  ...conf
});
function createRecipeFn(options) {
  const { css: css2, conditions, normalize: normalize4, layers } = options;
  function cva(config = {}) {
    const { base, variants: variants3, defaultVariants: defaultVariants3, compoundVariants } = defaults(config);
    const getVariantCss = createCssFn({
      conditions,
      normalize: normalize4,
      transform(prop, value) {
        var _a8;
        return (_a8 = variants3[prop]) == null ? void 0 : _a8[value];
      }
    });
    const resolve = (props43 = {}) => {
      const variantSelections = normalize4({
        ...defaultVariants3,
        ...compact(props43)
      });
      let variantCss = { ...base };
      mergeWith(variantCss, getVariantCss(variantSelections));
      const compoundVariantCss = getCompoundVariantCss(
        compoundVariants,
        variantSelections
      );
      return layers.wrap("recipes", css2(variantCss, compoundVariantCss));
    };
    const variantKeys = Object.keys(variants3);
    const splitVariantProps = (props43) => {
      const restProps = omit(props43, ["recipe"]);
      const [recipeProps, localProps] = splitProps(restProps, variantKeys);
      if (!variantKeys.includes("colorPalette")) {
        recipeProps.colorPalette = props43.colorPalette || defaultVariants3.colorPalette;
      }
      if (variantKeys.includes("orientation")) {
        localProps.orientation = props43.orientation;
      }
      return [recipeProps, localProps];
    };
    const variantMap = Object.fromEntries(
      Object.entries(variants3).map(([key, value]) => [
        key,
        Object.keys(value)
      ])
    );
    const cvaFn = (props43) => css2(resolve(props43));
    return Object.assign(cvaFn, {
      className: config.className,
      __cva__: true,
      variantMap,
      variantKeys,
      raw: resolve,
      config,
      splitVariantProps,
      merge(other) {
        return cva(mergeCva2(options)(this, other));
      }
    });
  }
  function getCompoundVariantCss(cvs, vm) {
    let result = {};
    cvs.forEach((cv) => {
      const isMatching = Object.entries(cv).every(([key, value]) => {
        if (key === "css") return true;
        const values = Array.isArray(value) ? value : [value];
        return values.some((value2) => vm[key] === value2);
      });
      if (isMatching) {
        result = css2(result, cv.css);
      }
    });
    return result;
  }
  return cva;
}
function mergeCva2(opts) {
  const { css: css2 } = opts;
  return function mergeCva22(cvaA, cvaB) {
    const override = defaults(cvaB.config);
    const variantKeys = uniq(cvaA.variantKeys, Object.keys(cvaB.variants));
    const base = css2(cvaA.base, override.base);
    const variants3 = Object.fromEntries(
      variantKeys.map((key) => [
        key,
        css2(cvaA.config.variants[key], override.variants[key])
      ])
    );
    const defaultVariants3 = mergeWith(
      cvaA.config.defaultVariants,
      override.defaultVariants
    );
    const compoundVariants = [
      ...cvaA.compoundVariants,
      ...override.compoundVariants
    ];
    const className = cx(cvaA.className, cvaB.className);
    return {
      className,
      base,
      variants: variants3,
      defaultVariants: defaultVariants3,
      compoundVariants
    };
  };
}

// node_modules/@chakra-ui/react/dist/esm/styled-system/layers.js
var defaultLayers = {
  reset: "reset",
  base: "base",
  tokens: "tokens",
  recipes: "recipes"
};
var layerOrder = {
  reset: 0,
  base: 1,
  tokens: 2,
  recipes: 3
};
function createLayers(config) {
  const layers = config.layers ?? defaultLayers;
  const values = Object.values(layers);
  const names = values.sort((a2, b2) => layerOrder[a2] - layerOrder[b2]);
  return {
    names,
    atRule: `@layer ${names.join(", ")};`,
    wrap(layer, styles) {
      if (config.disableLayers) return styles;
      const params = layers[layer];
      return { [`@layer ${params}`]: styles };
    }
  };
}

// node_modules/@chakra-ui/react/dist/esm/styled-system/normalize.js
function createNormalizeFn(context) {
  const { utility, normalize: normalize4 } = context;
  const { hasShorthand, resolveShorthand } = utility;
  return function(styles) {
    return walkObject(styles, normalize4, {
      stop: (value) => Array.isArray(value),
      getKey: hasShorthand ? resolveShorthand : void 0
    });
  };
}

// node_modules/@chakra-ui/react/dist/esm/styled-system/preflight.js
function createPreflight(options) {
  const { preflight } = options;
  if (!preflight) return {};
  const { scope = "", level = "parent" } = isObject(preflight) ? preflight : {};
  let selector = "";
  if (scope && level === "parent") {
    selector = `${scope} `;
  } else if (scope && level === "element") {
    selector = `&${scope}`;
  }
  const scoped = {
    "*": {
      margin: "0px",
      padding: "0px",
      font: "inherit",
      wordWrap: "break-word",
      WebkitTapHighlightColor: "transparent"
    },
    "*, *::before, *::after, *::backdrop": {
      boxSizing: "border-box",
      borderWidth: "0px",
      borderStyle: "solid",
      borderColor: "var(--global-color-border, currentColor)"
    },
    hr: {
      height: "0px",
      color: "inherit",
      borderTopWidth: "1px"
    },
    body: {
      minHeight: "100dvh",
      position: "relative"
    },
    img: {
      borderStyle: "none"
    },
    "img, svg, video, canvas, audio, iframe, embed, object": {
      display: "block",
      verticalAlign: "middle"
    },
    iframe: { border: "none" },
    "img, video": { maxWidth: "100%", height: "auto" },
    "p, h1, h2, h3, h4, h5, h6": { overflowWrap: "break-word" },
    "ol, ul": { listStyle: "none" },
    "code, kbd, pre, samp": { fontSize: "1em" },
    "button, [type='button'], [type='reset'], [type='submit']": {
      WebkitAppearance: "button",
      backgroundColor: "transparent",
      backgroundImage: "none"
    },
    "button, input, optgroup, select, textarea": { color: "inherit" },
    "button, select": { textTransform: "none" },
    table: {
      textIndent: "0px",
      borderColor: "inherit",
      borderCollapse: "collapse"
    },
    "*::placeholder": {
      opacity: "unset",
      color: "#9ca3af",
      userSelect: "none"
    },
    textarea: {
      resize: "vertical"
    },
    summary: {
      display: "list-item"
    },
    small: {
      fontSize: "80%"
    },
    "sub, sup": {
      fontSize: "75%",
      lineHeight: 0,
      position: "relative",
      verticalAlign: "baseline"
    },
    sub: {
      bottom: "-0.25em"
    },
    sup: {
      top: "-0.5em"
    },
    dialog: {
      padding: "0px"
    },
    a: {
      color: "inherit",
      textDecoration: "inherit"
    },
    "abbr:where([title])": {
      textDecoration: "underline dotted"
    },
    "b, strong": {
      fontWeight: "bolder"
    },
    "code, kbd, samp, pre": {
      fontSize: "1em",
      "--font-mono-fallback": "ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New'",
      fontFamily: "var(--global-font-mono, var(--font-mono-fallback))"
    },
    'input[type="text"], input[type="email"], input[type="search"], input[type="password"]': {
      WebkitAppearance: "none",
      MozAppearance: "none"
    },
    "input[type='search']": {
      WebkitAppearance: "textfield",
      outlineOffset: "-2px"
    },
    "::-webkit-search-decoration, ::-webkit-search-cancel-button": {
      WebkitAppearance: "none"
    },
    "::-webkit-file-upload-button": {
      WebkitAppearance: "button",
      font: "inherit"
    },
    'input[type="number"]::-webkit-inner-spin-button, input[type="number"]::-webkit-outer-spin-button': {
      height: "auto"
    },
    "input[type='number']": {
      MozAppearance: "textfield"
    },
    ":-moz-ui-invalid": {
      boxShadow: "none"
    },
    ":-moz-focusring": {
      outline: "auto"
    },
    "[hidden]:where(:not([hidden='until-found']))": {
      display: "none !important"
    }
  };
  const preflightCss = {
    [scope || "html"]: {
      lineHeight: 1.5,
      "--font-fallback": "ui-sans-serif, system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, 'Noto Sans', sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol', 'Noto Color Emoji'",
      WebkitTextSizeAdjust: "100%",
      WebkitFontSmoothing: "antialiased",
      MozOsxFontSmoothing: "grayscale",
      textRendering: "optimizeLegibility",
      touchAction: "manipulation",
      MozTabSize: "4",
      tabSize: "4",
      fontFamily: "var(--global-font-body, var(--font-fallback))"
    }
  };
  if (level === "element") {
    const modified = Object.entries(scoped).reduce((acc, [k, v]) => {
      acc[k] = { [selector]: v };
      return acc;
    }, {});
    Object.assign(preflightCss, modified);
  } else if (selector) {
    preflightCss[selector] = scoped;
  } else {
    Object.assign(preflightCss, scoped);
  }
  return preflightCss;
}

// node_modules/@chakra-ui/react/dist/esm/styled-system/serialize.js
function createSerializeFn(options) {
  const { conditions, isValidProperty } = options;
  return function serialize2(styles) {
    return walkObject(styles, (value) => value, {
      getKey: (prop, value) => {
        if (!isObject(value)) return prop;
        if (!conditions.has(prop) && !isValidProperty(prop)) {
          return parseSelectors(prop).map((s) => "&" + s).join(", ");
        }
        return prop;
      }
    });
  };
}
function parseSelectors(selector) {
  const result = [];
  let parenCount = 0;
  let currentSelector = "";
  let inEscape = false;
  for (let i = 0; i < selector.length; i++) {
    const char = selector[i];
    if (char === "\\" && !inEscape) {
      inEscape = true;
      currentSelector += char;
      continue;
    }
    if (inEscape) {
      inEscape = false;
      currentSelector += char;
      continue;
    }
    if (char === "(") {
      parenCount++;
    } else if (char === ")") {
      parenCount--;
    }
    if (char === "," && parenCount === 0) {
      result.push(currentSelector.trim());
      currentSelector = "";
    } else {
      currentSelector += char;
    }
  }
  if (currentSelector) {
    result.push(currentSelector.trim());
  }
  return result;
}

// node_modules/@chakra-ui/react/dist/esm/styled-system/sva.js
var getSlotRecipes = (config = {}) => {
  const init = (slot) => {
    var _a8;
    return {
      base: ((_a8 = config.base) == null ? void 0 : _a8[slot]) ?? {},
      variants: {},
      defaultVariants: config.defaultVariants ?? {},
      compoundVariants: config.compoundVariants ? getSlotCompoundVariant(config.compoundVariants, slot) : []
    };
  };
  const slots = config.slots ?? [];
  const entries = slots.map((slot) => [slot, init(slot)]);
  for (const [variantsKey, variantsSpec] of Object.entries(
    config.variants ?? {}
  )) {
    for (const [variantKey, variantSpec] of Object.entries(
      variantsSpec
    )) {
      entries.forEach(([slot, slotRecipe]) => {
        var _a8;
        (_a8 = slotRecipe.variants)[variantsKey] ?? (_a8[variantsKey] = {});
        slotRecipe.variants[variantsKey][variantKey] = variantSpec[slot] ?? {};
      });
    }
  }
  return Object.fromEntries(entries);
};
var getSlotCompoundVariant = (compoundVariants, slotName) => compoundVariants.filter((compoundVariant) => compoundVariant.css[slotName]).map((compoundVariant) => ({
  ...compoundVariant,
  css: compoundVariant.css[slotName]
}));
function createSlotRecipeFn(options) {
  const { cva } = options;
  return function sva(config = {}) {
    const slots = Object.entries(getSlotRecipes(config)).map(
      ([slot, slotCva]) => [slot, cva(slotCva)]
    );
    function svaFn(props43) {
      const result = slots.map(([slot, cvaFn]) => [slot, cvaFn(props43)]);
      return Object.fromEntries(result);
    }
    const variants3 = config.variants ?? {};
    const variantKeys = Object.keys(variants3);
    function splitVariantProps(props43) {
      var _a8;
      const restProps = omit(props43, ["recipe"]);
      const [recipeProps, localProps] = splitProps(restProps, variantKeys);
      if (!variantKeys.includes("colorPalette")) {
        recipeProps.colorPalette = props43.colorPalette || ((_a8 = config.defaultVariants) == null ? void 0 : _a8.colorPalette);
      }
      if (variantKeys.includes("orientation")) {
        localProps.orientation = props43.orientation;
      }
      return [recipeProps, localProps];
    }
    const variantMap = Object.fromEntries(
      Object.entries(variants3).map(([key, value]) => [key, Object.keys(value)])
    );
    let classNameMap = {};
    if (config.className) {
      classNameMap = Object.fromEntries(
        config.slots.map((slot) => [
          slot,
          `${config.className}__${slot}`
        ])
      );
    }
    return Object.assign(svaFn, {
      variantMap,
      variantKeys,
      splitVariantProps,
      classNameMap
    });
  };
}

// node_modules/@chakra-ui/react/dist/esm/utils/create-props.js
var createProps2 = () => (props43) => Array.from(new Set(props43));

// node_modules/@chakra-ui/react/dist/esm/styled-system/esc.js
var rcssescape = /([\0-\x1f\x7f]|^-?\d)|^-$|^-|[^\x80-\uFFFF\w-]/g;
var fcssescape = function(ch, asCodePoint) {
  if (!asCodePoint) return "\\" + ch;
  if (ch === "\0") return "";
  if (ch === "-" && ch.length === 1) return "\\-";
  return ch.slice(0, -1) + "\\" + ch.charCodeAt(ch.length - 1).toString(16);
};
var esc2 = (sel) => {
  return (sel + "").replace(rcssescape, fcssescape);
};

// node_modules/@chakra-ui/react/dist/esm/styled-system/expand-reference.js
var expandTokenReferences = (str, resolve) => {
  let expanded = "";
  let index = 0;
  let state2 = "char";
  let tokenPath = "";
  let fallback4 = "";
  const currentStates = [];
  while (index < str.length) {
    const char = str[index];
    if (char === "{") {
      const endIndex = str.indexOf("}", index);
      if (endIndex === -1) {
        break;
      }
      const path = str.slice(index + 1, endIndex);
      const resolved = resolve(path);
      expanded += resolved ?? path;
      index = endIndex + 1;
      continue;
    }
    if (state2 === "token") {
      if (char === ",") {
        if (str[index] === "") {
          index++;
        }
        state2 = "fallback";
        currentStates.push(state2);
        const resolved = resolve(tokenPath);
        if (resolved == null ? void 0 : resolved.endsWith(")")) {
          expanded += resolved.slice(0, -1);
        }
        tokenPath = "";
        fallback4 = "";
        continue;
      }
    }
    if (state2 === "fallback") {
      const nextFallback = fallback4 + char;
      if (nextFallback === ", var(") {
        const innerEndIndex = cssVarParser(str.slice(index + 1));
        const endIndex = innerEndIndex + index + 1;
        const cssVar2 = str.slice(index + 1, endIndex);
        if (endIndex === -1) {
          break;
        }
        expanded += ", var(" + cssVar2 + ")";
        index = endIndex + 1;
        state2 = currentStates.pop() ?? state2;
        fallback4 = "";
        continue;
      }
    }
    if (state2 === "token" || state2 === "fallback") {
      index++;
      if (char === ")") {
        state2 = currentStates.pop() ?? state2 ?? "char";
        fallback4 += char;
        const resolved = tokenPath ? resolve(tokenPath) ?? esc2(tokenPath) : tokenPath;
        if (fallback4) {
          fallback4 = fallback4.slice(1).trim();
          if (!fallback4.startsWith("token(") && fallback4.endsWith(")")) {
            fallback4 = fallback4.slice(0, -1);
          }
          if (fallback4.includes("token(")) {
            const parsed = expandTokenReferences(fallback4, resolve);
            if (parsed) {
              fallback4 = parsed.slice(0, -1);
            }
          } else if (fallback4) {
            const resolvedFallback = resolve(fallback4);
            if (resolvedFallback) {
              fallback4 = resolvedFallback;
            }
          }
        }
        const lastChar = expanded.at(-1);
        if (fallback4) {
          if (lastChar == null ? void 0 : lastChar.trim()) {
            expanded += resolved.slice(0, -1) + (", " + fallback4 + ")");
          } else {
            expanded += fallback4;
          }
        } else {
          expanded += resolved || ")";
        }
        tokenPath = "";
        fallback4 = "";
        state2 = "char";
        continue;
      }
      if (state2 === "token") {
        tokenPath += char;
      }
      if (state2 === "fallback") {
        fallback4 += char;
      }
      continue;
    }
    const tokenIndex = str.indexOf("token(", index);
    if (tokenIndex !== -1) {
      const innerTokenIndex = tokenIndex + "token(".length;
      expanded += str.slice(index, tokenIndex);
      index = innerTokenIndex;
      state2 = "token";
      currentStates.push(state2);
      continue;
    }
    expanded += char;
    index++;
  }
  return expanded;
};
var cssVarParser = (str) => {
  let index = 0;
  const openedParenthesises = ["("];
  while (index < str.length) {
    const char = str[index];
    if (char === "(") {
      openedParenthesises.push(char);
    } else if (char === ")") {
      openedParenthesises.pop();
      if (openedParenthesises.length === 0) {
        return index;
      }
    }
    index++;
  }
  return index;
};

// node_modules/@chakra-ui/react/dist/esm/styled-system/map-to-json.js
function mapToJson(map2) {
  const obj = {};
  map2.forEach((value, key) => {
    if (value instanceof Map) {
      obj[key] = Object.fromEntries(value);
    } else {
      obj[key] = value;
    }
  });
  return obj;
}

// node_modules/@chakra-ui/react/dist/esm/styled-system/references.js
var REFERENCE_REGEX = /({([^}]*)})/g;
var CURLY_REGEX = /[{}]/g;
var TOKEN_PATH_REGEX = /\w+\.\w+/;
var getReferences = (value) => {
  if (!isString(value)) return [];
  const matches = value.match(REFERENCE_REGEX);
  if (!matches) return [];
  return matches.map((match4) => match4.replace(CURLY_REGEX, "")).map((value2) => value2.trim());
};
var hasReference = (value) => REFERENCE_REGEX.test(value);
function expandReferences(token) {
  var _a8, _b7, _c6;
  if (!((_a8 = token.extensions) == null ? void 0 : _a8.references)) {
    return ((_c6 = (_b7 = token.extensions) == null ? void 0 : _b7.cssVar) == null ? void 0 : _c6.ref) ?? token.value;
  }
  const references = token.extensions.references ?? {};
  token.value = Object.keys(references).reduce((valueStr, key) => {
    const referenceToken = references[key];
    if (referenceToken.extensions.conditions) {
      return valueStr;
    }
    const value = expandReferences(referenceToken);
    return valueStr.replace(`{${key}}`, value);
  }, token.value);
  delete token.extensions.references;
  return token.value;
}

// node_modules/@chakra-ui/react/dist/esm/styled-system/calc.js
function resolveReference(operand) {
  if (isObject(operand) && operand.reference) {
    return operand.reference;
  }
  return String(operand);
}
var toExpression = (operator, ...operands) => operands.map(resolveReference).join(` ${operator} `).replace(/calc/g, "");
var add2 = (...operands) => `calc(${toExpression("+", ...operands)})`;
var subtract = (...operands) => `calc(${toExpression("-", ...operands)})`;
var multiply = (...operands) => `calc(${toExpression("*", ...operands)})`;
var divide = (...operands) => `calc(${toExpression("/", ...operands)})`;
var negate = (x) => {
  const value = resolveReference(x);
  if (value != null && !Number.isNaN(parseFloat(value))) {
    return String(value).startsWith("-") ? String(value).slice(1) : `-${value}`;
  }
  return multiply(value, -1);
};
var calc = Object.assign(
  (x) => ({
    add: (...operands) => calc(add2(x, ...operands)),
    subtract: (...operands) => calc(subtract(x, ...operands)),
    multiply: (...operands) => calc(multiply(x, ...operands)),
    divide: (...operands) => calc(divide(x, ...operands)),
    negate: () => calc(negate(x)),
    toString: () => x.toString()
  }),
  {
    add: add2,
    subtract,
    multiply,
    divide,
    negate
  }
);

// node_modules/@chakra-ui/react/dist/esm/styled-system/token-middleware.js
var addNegativeTokens = {
  enforce: "pre",
  transform(dictionary) {
    const { prefix, allTokens, formatCssVar, formatTokenName, registerToken } = dictionary;
    const tokens = allTokens.filter(
      ({ extensions }) => extensions.category === "spacing"
    );
    tokens.forEach((token) => {
      const originalPath = token.path.slice();
      const originalVar = formatCssVar(originalPath, prefix);
      if (isString(token.value) && token.value === "0rem") {
        return;
      }
      const nextToken = structuredClone(token);
      Object.assign(nextToken.extensions, {
        negative: true,
        prop: `-${token.extensions.prop}`,
        originalPath
      });
      nextToken.value = calc.negate(originalVar.ref);
      const lastPath = nextToken.path[nextToken.path.length - 1];
      if (lastPath != null) {
        nextToken.path[nextToken.path.length - 1] = `-${lastPath}`;
      }
      if (nextToken.path) {
        nextToken.name = formatTokenName(nextToken.path);
      }
      registerToken(nextToken);
    });
  }
};
var units = /* @__PURE__ */ new Set([
  "spacing",
  "sizes",
  "borderWidths",
  "fontSizes",
  "radii"
]);
var addPixelUnit = {
  enforce: "post",
  transform(dictionary) {
    const tokens = dictionary.allTokens.filter((token) => {
      return units.has(token.extensions.category) && !token.extensions.negative;
    });
    tokens.forEach((token) => {
      Object.assign(token.extensions, {
        pixelValue: toPx2(token.value)
      });
    });
  }
};
var addVirtualPalette = {
  enforce: "post",
  transform(dictionary) {
    const { allTokens, registerToken, formatTokenName } = dictionary;
    const tokens = allTokens.filter(
      ({ extensions }) => extensions.category === "colors"
    );
    const keys = /* @__PURE__ */ new Map();
    const colorPalettes = /* @__PURE__ */ new Map();
    tokens.forEach((token) => {
      const { colorPalette } = token.extensions;
      if (!colorPalette) return;
      colorPalette.keys.forEach((keyPath) => {
        keys.set(formatTokenName(keyPath), keyPath);
      });
      colorPalette.roots.forEach((colorPaletteRoot) => {
        var _a8;
        const name = formatTokenName(colorPaletteRoot);
        const colorPaletteList = colorPalettes.get(name) || [];
        colorPaletteList.push(token);
        colorPalettes.set(name, colorPaletteList);
        if (token.extensions.default && colorPaletteRoot.length === 1) {
          const keyPath = (_a8 = colorPalette.keys[0]) == null ? void 0 : _a8.filter(Boolean);
          if (!keyPath.length) return;
          const path = colorPaletteRoot.concat(keyPath);
          keys.set(formatTokenName(path), []);
        }
      });
    });
    keys.forEach((segments) => {
      const path = ["colors", "colorPalette", ...segments].filter(Boolean);
      const name = formatTokenName(path);
      const prop = formatTokenName(path.slice(1));
      const token = {
        name,
        value: name,
        originalValue: name,
        path,
        extensions: {
          condition: "base",
          originalPath: path,
          category: "colors",
          prop,
          virtual: true
        }
      };
      registerToken(token, "pre");
    });
  }
};
var removeEmptyTokens = {
  enforce: "post",
  transform(dictionary) {
    dictionary.allTokens = dictionary.allTokens.filter(
      (token) => token.value !== ""
    );
  }
};
var tokenMiddlewares = [
  addNegativeTokens,
  addVirtualPalette,
  addPixelUnit,
  removeEmptyTokens
];

// node_modules/@chakra-ui/react/dist/esm/styled-system/token-transforms.js
var addCssVariables = {
  type: "extensions",
  enforce: "pre",
  name: "tokens/css-var",
  transform(token, dictionary) {
    const { prefix, formatCssVar } = dictionary;
    const { negative, originalPath } = token.extensions;
    const path = negative ? originalPath : token.path;
    return {
      cssVar: formatCssVar(path.filter(Boolean), prefix)
    };
  }
};
var addConditionalCssVariables = {
  enforce: "post",
  type: "value",
  name: "tokens/conditionals",
  transform(token, dictionary) {
    const { prefix, formatCssVar } = dictionary;
    const refs = getReferences(token.value);
    if (!refs.length) return token.value;
    refs.forEach((ref) => {
      const variable = formatCssVar(ref.split("."), prefix);
      token.value = token.value.replace(`{${variable.ref}}`, variable);
    });
    return token.value;
  }
};
var addColorPalette = {
  type: "extensions",
  enforce: "pre",
  name: "tokens/colors/colorPalette",
  match(token) {
    return token.extensions.category === "colors" && !token.extensions.virtual;
  },
  transform(token, dict) {
    let path = token.path.slice();
    path.pop();
    path.shift();
    if (path.length === 0) {
      const newPath = [...token.path];
      newPath.shift();
      path = newPath;
    }
    if (path.length === 0) {
      return {};
    }
    const roots = path.reduce((acc, _, i, arr) => {
      const next2 = arr.slice(0, i + 1);
      acc.push(next2);
      return acc;
    }, []);
    const root = path[0];
    const value = dict.formatTokenName(path);
    const keys = token.path.slice(token.path.indexOf(root) + 1).reduce((acc, _, i, arr) => {
      acc.push(arr.slice(i));
      return acc;
    }, []);
    if (keys.length === 0) {
      keys.push([""]);
    }
    return {
      colorPalette: { value, roots, keys }
    };
  }
};
var tokenTransforms = [
  addCssVariables,
  addConditionalCssVariables,
  addColorPalette
];

// node_modules/@chakra-ui/react/dist/esm/styled-system/token-dictionary.js
var isToken = (value) => {
  return isObject(value) && Object.prototype.hasOwnProperty.call(value, "value");
};
function expandBreakpoints(breakpoints2) {
  if (!breakpoints2) return { breakpoints: {}, sizes: {} };
  return {
    breakpoints: mapObject(breakpoints2, (value) => ({ value })),
    sizes: Object.fromEntries(
      Object.entries(breakpoints2).map(([key, value]) => [
        `breakpoint-${key}`,
        { value }
      ])
    )
  };
}
function createTokenDictionary(options) {
  const {
    prefix = "",
    tokens = {},
    semanticTokens = {},
    breakpoints: breakpoints2 = {}
  } = options;
  const formatTokenName = (path) => path.join(".");
  const formatCssVar = (path, prefix2) => cssVar(path.join("-"), { prefix: prefix2 });
  const allTokens = [];
  const tokenNameMap = /* @__PURE__ */ new Map();
  const conditionMap = /* @__PURE__ */ new Map();
  const cssVarMap = /* @__PURE__ */ new Map();
  const colorPaletteMap = /* @__PURE__ */ new Map();
  const flatMap2 = /* @__PURE__ */ new Map();
  const byCategory = /* @__PURE__ */ new Map();
  const categoryMap = /* @__PURE__ */ new Map();
  const transforms = /* @__PURE__ */ new Map();
  const middlewares = [];
  function registerToken(token, phase) {
    allTokens.push(token);
    tokenNameMap.set(token.name, token);
    if (phase) {
      transforms.forEach((fn) => {
        if (fn.enforce === phase) transformToken(fn, token);
      });
    }
  }
  const breakpointTokens = expandBreakpoints(breakpoints2);
  const computedTokens = compact({
    ...tokens,
    breakpoints: breakpointTokens.breakpoints,
    sizes: {
      ...tokens.sizes,
      ...breakpointTokens.sizes
    }
  });
  function registerTokens() {
    walkObject(
      computedTokens,
      (entry, path) => {
        const isDefault = path.includes("DEFAULT");
        path = filterDefault(path);
        const category = path[0];
        const name = formatTokenName(path);
        const t = isString(entry) ? { value: entry } : entry;
        const token = {
          value: t.value,
          originalValue: t.value,
          name,
          path,
          extensions: {
            condition: "base",
            originalPath: path,
            category,
            prop: formatTokenName(path.slice(1))
          }
        };
        if (isDefault) {
          token.extensions.default = true;
        }
        registerToken(token);
      },
      { stop: isToken }
    );
    walkObject(
      semanticTokens,
      (entry, path) => {
        const isDefault = path.includes("DEFAULT");
        path = filterBaseCondition(filterDefault(path));
        const category = path[0];
        const name = formatTokenName(path);
        const t = isString(entry.value) ? { value: { base: entry.value } } : entry;
        const token = {
          value: t.value.base || "",
          originalValue: t.value.base || "",
          name,
          path,
          extensions: {
            originalPath: path,
            category,
            conditions: t.value,
            condition: "base",
            prop: formatTokenName(path.slice(1))
          }
        };
        if (isDefault) {
          token.extensions.default = true;
        }
        registerToken(token);
      },
      { stop: isToken }
    );
  }
  function getByName(name) {
    return tokenNameMap.get(name);
  }
  function buildConditionMap(token) {
    const { condition } = token.extensions;
    if (!condition) return;
    if (!conditionMap.has(condition)) {
      conditionMap.set(condition, /* @__PURE__ */ new Set());
    }
    conditionMap.get(condition).add(token);
  }
  function buildCategoryMap(token) {
    const { category, prop } = token.extensions;
    if (!category) return;
    if (!categoryMap.has(category)) {
      categoryMap.set(category, /* @__PURE__ */ new Map());
    }
    categoryMap.get(category).set(prop, token);
  }
  function buildCssVars(token) {
    const { condition, negative, virtual, cssVar: cssVar2 } = token.extensions;
    if (negative || virtual || !condition || !cssVar2) return;
    if (!cssVarMap.has(condition)) {
      cssVarMap.set(condition, /* @__PURE__ */ new Map());
    }
    cssVarMap.get(condition).set(cssVar2.var, token.value);
  }
  function buildFlatMap(token) {
    const { category, prop, cssVar: cssVar2, negative } = token.extensions;
    if (!category) return;
    if (!byCategory.has(category)) {
      byCategory.set(category, /* @__PURE__ */ new Map());
    }
    const value = negative ? token.extensions.conditions ? token.originalValue : token.value : cssVar2.ref;
    byCategory.get(category).set(prop, value);
    flatMap2.set([category, prop].join("."), value);
  }
  function buildColorPalette(token) {
    const { colorPalette, virtual, default: isDefault } = token.extensions;
    if (!colorPalette || virtual) return;
    colorPalette.roots.forEach((root) => {
      var _a8;
      const name = formatTokenName(root);
      if (!colorPaletteMap.has(name)) {
        colorPaletteMap.set(name, /* @__PURE__ */ new Map());
      }
      const virtualPath = replaceRootWithColorPalette(
        [...token.path],
        [...root]
      );
      const virtualName = formatTokenName(virtualPath);
      const virtualToken = getByName(virtualName);
      if (!virtualToken || !virtualToken.extensions.cssVar) return;
      const { var: virtualVar } = virtualToken.extensions.cssVar;
      colorPaletteMap.get(name).set(virtualVar, token.extensions.cssVar.ref);
      if (isDefault && root.length === 1) {
        const colorPaletteName = formatTokenName(["colors", "colorPalette"]);
        const colorPaletteToken = getByName(colorPaletteName);
        if (!colorPaletteToken) return;
        const name2 = formatTokenName(token.path);
        const virtualToken2 = getByName(name2);
        if (!virtualToken2) return;
        const keyPath = (_a8 = colorPalette.keys[0]) == null ? void 0 : _a8.filter(Boolean);
        if (!keyPath.length) return;
        const computedName = formatTokenName(root.concat(keyPath));
        if (!colorPaletteMap.has(computedName)) {
          colorPaletteMap.set(computedName, /* @__PURE__ */ new Map());
        }
        colorPaletteMap.get(computedName).set(
          colorPaletteToken.extensions.cssVar.var,
          virtualToken2.extensions.cssVar.ref
        );
      }
    });
  }
  let byCategoryJson = {};
  function setupViews() {
    allTokens.forEach((token) => {
      buildConditionMap(token);
      buildCategoryMap(token);
      buildCssVars(token);
      buildFlatMap(token);
      buildColorPalette(token);
    });
    byCategoryJson = mapToJson(byCategory);
  }
  const colorMix2 = (value, tokenFn) => {
    var _a8;
    if (!value || typeof value !== "string") return { invalid: true, value };
    const [colorPath, rawOpacity] = value.split("/");
    if (!colorPath || !rawOpacity) {
      return { invalid: true, value: colorPath };
    }
    const colorToken = tokenFn(colorPath);
    const opacityToken = (_a8 = getByName(`opacity.${rawOpacity}`)) == null ? void 0 : _a8.value;
    if (!opacityToken && isNaN(Number(rawOpacity))) {
      return { invalid: true, value: colorPath };
    }
    const percent = opacityToken ? Number(opacityToken) * 100 + "%" : `${rawOpacity}%`;
    const color = colorToken ?? colorPath;
    return {
      invalid: false,
      color,
      value: `color-mix(in srgb, ${color} ${percent}, transparent)`
    };
  };
  const getVar = memo4((value, fallback4) => {
    return flatMap2.get(value) ?? fallback4;
  });
  const getCategoryValues = memo4((category) => {
    return byCategoryJson[category] || null;
  });
  const expandReferenceInValue = memo4((value) => {
    return expandTokenReferences(value, (path) => {
      if (!path) return;
      if (path.includes("/")) {
        const mix = colorMix2(path, (v) => getVar(v));
        if (mix.invalid) {
          throw new Error("Invalid color mix at " + path + ": " + mix.value);
        }
        return mix.value;
      }
      const resolved = getVar(path);
      if (resolved) return resolved;
      return TOKEN_PATH_REGEX.test(path) ? esc2(path) : path;
    });
  });
  const dictionary = {
    prefix,
    allTokens,
    tokenMap: tokenNameMap,
    registerToken,
    getByName,
    formatTokenName,
    formatCssVar,
    flatMap: flatMap2,
    cssVarMap,
    categoryMap,
    colorPaletteMap,
    getVar,
    getCategoryValues,
    expandReferenceInValue
  };
  function registerTransform(...fns) {
    fns.forEach((fn) => {
      transforms.set(fn.name, fn);
    });
  }
  function registerMiddleware(...fns) {
    middlewares.push(...fns);
  }
  function transformToken(transform2, token) {
    if (token.extensions.references) return;
    if (isFunction(transform2.match) && !transform2.match(token)) return;
    const fn = (v) => transform2.transform(v, dictionary);
    const transformed = fn(token);
    switch (true) {
      case transform2.type === "extensions":
        Object.assign(token.extensions, transformed);
        break;
      case transform2.type === "value":
        token.value = transformed;
        break;
      default:
        token[transform2.type] = transformed;
        break;
    }
  }
  function applyMiddlewares(enforce) {
    middlewares.forEach((middleware) => {
      if (middleware.enforce === enforce) {
        middleware.transform(dictionary);
      }
    });
  }
  function applyTransforms(enforce) {
    transforms.forEach((transform2) => {
      if (transform2.enforce === enforce) {
        allTokens.forEach((token) => {
          transformToken(transform2, token);
        });
      }
    });
  }
  function addConditionalTokens() {
    allTokens.forEach((token) => {
      const tokens2 = getConditionalTokens(token);
      if (!tokens2 || tokens2.length === 0) return;
      tokens2.forEach((token2) => {
        registerToken(token2);
      });
    });
  }
  function getTokenReferences(value) {
    const refs = getReferences(value);
    return refs.map((ref) => getByName(ref)).filter(Boolean);
  }
  function addReferences() {
    allTokens.forEach((token) => {
      if (!hasReference(token.value)) return;
      const references = getTokenReferences(token.value);
      token.extensions.references = references.reduce((acc, ref) => {
        acc[ref.name] = ref;
        return acc;
      }, {});
    });
  }
  function expandTokenReferences$1() {
    allTokens.forEach((token) => {
      expandReferences(token);
    });
  }
  function build2() {
    applyMiddlewares("pre");
    applyTransforms("pre");
    addConditionalTokens();
    addReferences();
    expandTokenReferences$1();
    applyMiddlewares("post");
    applyTransforms("post");
    setupViews();
  }
  registerTokens();
  registerTransform(...tokenTransforms);
  registerMiddleware(...tokenMiddlewares);
  build2();
  return dictionary;
}
function filterDefault(path) {
  if (path[0] === "DEFAULT") return path;
  return path.filter((item) => item !== "DEFAULT");
}
function filterBaseCondition(path) {
  return path.filter((item) => item !== "base");
}
function getConditionalTokens(token) {
  if (!token.extensions.conditions) return;
  const { conditions } = token.extensions;
  const tokens = [];
  walkObject(conditions, (value, path) => {
    const nextPath = filterBaseCondition(path);
    if (!nextPath.length) return;
    const nextToken = structuredClone(token);
    nextToken.value = value;
    nextToken.extensions.condition = nextPath.join(":");
    tokens.push(nextToken);
  });
  return tokens;
}
function replaceRootWithColorPalette(path, roots) {
  const startIndex = path.findIndex(
    (_, index) => roots.every(
      (rootElement, rootIndex) => path[index + rootIndex] === rootElement
    )
  );
  if (startIndex === -1) {
    return path;
  }
  path.splice(startIndex, roots.length);
  path.splice(startIndex, 0, "colorPalette");
  return path;
}
var tokenCategories = createProps2()([
  "aspectRatios",
  "zIndex",
  "opacity",
  "colors",
  "fonts",
  "fontSizes",
  "fontWeights",
  "lineHeights",
  "letterSpacings",
  "sizes",
  "shadows",
  "spacing",
  "radii",
  "cursor",
  "borders",
  "borderWidths",
  "borderStyles",
  "durations",
  "easings",
  "animations",
  "blurs",
  "gradients",
  "breakpoints",
  "assets"
]);

// node_modules/@chakra-ui/react/dist/esm/styled-system/utility.js
function normalize2(config) {
  return config;
}
function normalizeConfig(config) {
  return Object.fromEntries(
    Object.entries(config).map(([property, propertyConfig]) => {
      return [property, normalize2(propertyConfig)];
    })
  );
}
function createUtility(options) {
  const configs = normalizeConfig(options.config);
  const tokens = options.tokens;
  const shorthands = /* @__PURE__ */ new Map();
  const propValues = /* @__PURE__ */ new Map();
  function register(property, config) {
    configs[property] = normalize2(config);
    assignProperty(property, config);
  }
  const assignProperty = (property, config) => {
    const values = getPropertyValues(config);
    if (!values) return;
    propValues.set(property, values);
    assignPropertyType(property, config);
  };
  const assignProperties = () => {
    for (const [prop, config] of Object.entries(configs)) {
      if (!config) continue;
      assignProperty(prop, config);
    }
  };
  const assignShorthands = () => {
    for (const [property, config] of Object.entries(configs)) {
      const { shorthand } = config ?? {};
      if (!shorthand) continue;
      const values = Array.isArray(shorthand) ? shorthand : [shorthand];
      values.forEach((name) => shorthands.set(name, property));
    }
  };
  const assignColorPaletteProperty = () => {
    const values = mapToJson(tokens.colorPaletteMap);
    register("colorPalette", {
      values: Object.keys(values),
      transform: memo4((value) => values[value])
    });
  };
  const propTypes = /* @__PURE__ */ new Map();
  const assignPropertyType = (property, config) => {
    if (!config) return;
    const values = getPropertyValues(config, (key) => `type:Tokens["${key}"]`);
    if (typeof values === "object" && values.type) {
      propTypes.set(property, /* @__PURE__ */ new Set([`type:${values.type}`]));
      return;
    }
    if (values) {
      const keys2 = new Set(Object.keys(values));
      propTypes.set(property, keys2);
    }
    const set = propTypes.get(property) ?? /* @__PURE__ */ new Set();
    if (config.property) {
      propTypes.set(property, set.add(`CssProperties["${config.property}"]`));
    }
  };
  const assignPropertyTypes = () => {
    for (const [property, propertyConfig] of Object.entries(configs)) {
      if (!propertyConfig) continue;
      assignPropertyType(property, propertyConfig);
    }
  };
  const addPropertyType = (property, type) => {
    const set = propTypes.get(property) ?? /* @__PURE__ */ new Set();
    propTypes.set(property, /* @__PURE__ */ new Set([...set, ...type]));
  };
  const getTypes = () => {
    const map2 = /* @__PURE__ */ new Map();
    for (const [prop, values] of propTypes.entries()) {
      if (values.size === 0) {
        map2.set(prop, ["string"]);
        continue;
      }
      const typeValues = Array.from(values).map((key) => {
        if (key.startsWith("CssProperties")) return key;
        if (key.startsWith("type:")) return key.replace("type:", "");
        return JSON.stringify(key);
      });
      map2.set(prop, typeValues);
    }
    return map2;
  };
  const getPropertyValues = (config, resolveFn) => {
    const { values } = config;
    const fn = (key) => {
      const value = resolveFn == null ? void 0 : resolveFn(key);
      return value ? { [value]: value } : void 0;
    };
    if (isString(values)) {
      return (fn == null ? void 0 : fn(values)) ?? tokens.getCategoryValues(values) ?? {};
    }
    if (Array.isArray(values)) {
      return values.reduce((result, value) => {
        result[value] = value;
        return result;
      }, {});
    }
    if (isFunction(values)) {
      return values(resolveFn ? fn : tokens.getCategoryValues);
    }
    return values;
  };
  const defaultTransform = memo4((prop, value) => {
    return {
      [prop]: prop.startsWith("--") ? tokens.getVar(value, value) : value
    };
  });
  const tokenFn = Object.assign(tokens.getVar, {
    raw: (path) => tokens.getByName(path)
  });
  const transform2 = memo4((prop, raw) => {
    var _a8;
    const key = resolveShorthand(prop);
    if (isString(raw) && !raw.includes("_EMO_")) {
      raw = tokens.expandReferenceInValue(raw);
    }
    const config = configs[key];
    if (!config) {
      return defaultTransform(key, raw);
    }
    const value = (_a8 = propValues.get(key)) == null ? void 0 : _a8[raw];
    if (!config.transform) {
      return defaultTransform(prop, value ?? raw);
    }
    const _colorMix = (value2) => colorMix(value2, tokenFn);
    return config.transform(value ?? raw, {
      raw,
      token: tokenFn,
      utils: { colorMix: _colorMix }
    });
  });
  function build2() {
    assignShorthands();
    assignColorPaletteProperty();
    assignProperties();
    assignPropertyTypes();
  }
  build2();
  const hasShorthand = shorthands.size > 0;
  const resolveShorthand = memo4((prop) => {
    return shorthands.get(prop) ?? prop;
  });
  const keys = () => {
    return [...Array.from(shorthands.keys()), ...Object.keys(configs)];
  };
  const instance = {
    keys,
    hasShorthand,
    transform: transform2,
    shorthands,
    resolveShorthand,
    register,
    getTypes,
    addPropertyType
  };
  return instance;
}

// node_modules/@chakra-ui/react/dist/esm/styled-system/system.js
function createSystem(...configs) {
  const config = mergeConfigs(...configs);
  const {
    theme = {},
    utilities = {},
    globalCss: globalCss2 = {},
    cssVarsRoot = ":where(:root, :host)",
    cssVarsPrefix = "chakra",
    preflight
  } = config;
  const layers = createLayers(config);
  const tokens = createTokenDictionary({
    breakpoints: theme.breakpoints,
    tokens: theme.tokens,
    semanticTokens: theme.semanticTokens,
    prefix: cssVarsPrefix
  });
  const breakpoints2 = createBreakpoints(theme.breakpoints ?? {});
  const conditions = createConditions({
    conditions: config.conditions ?? {},
    breakpoints: breakpoints2
  });
  const utility = createUtility({
    config: utilities,
    tokens
  });
  function assignComposition() {
    const { textStyles: textStyles2, layerStyles: layerStyles2, animationStyles: animationStyles2 } = theme;
    const compositions = compact({
      textStyle: textStyles2,
      layerStyle: layerStyles2,
      animationStyle: animationStyles2
    });
    for (const [key, values] of Object.entries(compositions)) {
      const flatValues = flatten(
        values ?? {},
        (v) => isObject(v) && "value" in v
      );
      utility.register(key, {
        values: Object.keys(flatValues),
        transform(value) {
          return css2(flatValues[value]);
        }
      });
    }
  }
  assignComposition();
  utility.addPropertyType("animationName", Object.keys(theme.keyframes ?? {}));
  const properties2 = /* @__PURE__ */ new Set(["css", ...utility.keys(), ...conditions.keys()]);
  const isValidProperty = memo4(
    (prop) => properties2.has(prop) || isCssProperty(prop)
  );
  const normalizeValue2 = (value) => {
    if (Array.isArray(value)) {
      return value.reduce((acc, current, index) => {
        const key = conditions.breakpoints[index];
        if (current != null) acc[key] = current;
        return acc;
      }, {});
    }
    return value;
  };
  const normalizeFn = createNormalizeFn({
    utility,
    normalize: normalizeValue2
  });
  const serialize2 = createSerializeFn({
    conditions,
    isValidProperty
  });
  const css2 = createCssFn({
    transform: utility.transform,
    conditions,
    normalize: normalizeFn
  });
  const cva = createRecipeFn({
    css: css2,
    conditions,
    normalize: normalizeFn,
    layers
  });
  const sva = createSlotRecipeFn({ cva });
  function getTokenCss() {
    const result = {};
    for (const [key, values] of tokens.cssVarMap.entries()) {
      const varsObj = Object.fromEntries(values);
      if (Object.keys(varsObj).length === 0) continue;
      const selector = key === "base" ? cssVarsRoot : conditions.resolve(key);
      const isAtRule = selector.startsWith("@");
      const cssObject = css2(
        serialize2({
          [selector]: isAtRule ? { [cssVarsRoot]: varsObj } : varsObj
        })
      );
      mergeWith(result, cssObject);
    }
    return layers.wrap("tokens", result);
  }
  function getGlobalCss() {
    const keyframes2 = Object.fromEntries(
      Object.entries(theme.keyframes ?? {}).map(([key, value]) => [
        `@keyframes ${key}`,
        value
      ])
    );
    const result = Object.assign({}, keyframes2, css2(serialize2(globalCss2)));
    return layers.wrap("base", result);
  }
  function splitCssProps(props43) {
    return splitProps(props43, isValidProperty);
  }
  function getPreflightCss() {
    const result = createPreflight({ preflight });
    return layers.wrap("reset", result);
  }
  const tokenMap = getTokenMap(tokens);
  const tokenFn = (path, fallback4) => {
    var _a8;
    return ((_a8 = tokenMap.get(path)) == null ? void 0 : _a8.value) || fallback4;
  };
  tokenFn.var = (path, fallback4) => {
    var _a8;
    return ((_a8 = tokenMap.get(path)) == null ? void 0 : _a8.variable) || fallback4;
  };
  function getRecipe(key, fallback4) {
    var _a8;
    return ((_a8 = theme.recipes) == null ? void 0 : _a8[key]) ?? fallback4;
  }
  function getSlotRecipe(key, fallback4) {
    var _a8;
    return ((_a8 = theme.slotRecipes) == null ? void 0 : _a8[key]) ?? fallback4;
  }
  function isRecipe(key) {
    return Object.hasOwnProperty.call(theme.recipes ?? {}, key);
  }
  function isSlotRecipe(key) {
    return Object.hasOwnProperty.call(theme.slotRecipes ?? {}, key);
  }
  function hasRecipe(key) {
    return isRecipe(key) || isSlotRecipe(key);
  }
  const _global = [getPreflightCss(), getGlobalCss(), getTokenCss()];
  return {
    $$chakra: true,
    _config: config,
    _global,
    breakpoints: breakpoints2,
    tokens,
    conditions,
    utility,
    token: tokenFn,
    properties: properties2,
    layers,
    isValidProperty,
    splitCssProps,
    normalizeValue: normalizeValue2,
    getTokenCss,
    getGlobalCss,
    getPreflightCss,
    css: css2,
    cva,
    sva,
    getRecipe,
    getSlotRecipe,
    hasRecipe,
    isRecipe,
    isSlotRecipe
  };
}
function getTokenMap(tokens) {
  const map2 = /* @__PURE__ */ new Map();
  tokens.allTokens.forEach((token) => {
    const { cssVar: cssVar2, virtual, conditions } = token.extensions;
    const value = !!conditions || virtual ? cssVar2.ref : token.value;
    map2.set(token.name, { value, variable: cssVar2.ref });
  });
  return map2;
}
var isValidSystem = (mod2) => {
  return isObject(mod2) && !!Reflect.get(mod2, "$$chakra");
};

// node_modules/@chakra-ui/react/dist/esm/theme/breakpoints.js
var breakpoints = {
  sm: "480px",
  md: "768px",
  lg: "1024px",
  xl: "1280px",
  "2xl": "1536px"
};

// node_modules/@chakra-ui/react/dist/esm/theme/global-css.js
var empty = "var(--chakra-empty,/*!*/ /*!*/)";
var globalCss = defineGlobalStyles({
  "*": {
    fontFeatureSettings: '"cv11"',
    "--ring-inset": empty,
    "--ring-offset-width": "0px",
    "--ring-offset-color": "#fff",
    "--ring-color": "rgba(66, 153, 225, 0.6)",
    "--ring-offset-shadow": "0 0 #0000",
    "--ring-shadow": "0 0 #0000",
    ...Object.fromEntries(
      [
        "brightness",
        "contrast",
        "grayscale",
        "hue-rotate",
        "invert",
        "saturate",
        "sepia",
        "drop-shadow"
      ].map((prop) => [`--${prop}`, empty])
    ),
    ...Object.fromEntries(
      [
        "blur",
        "brightness",
        "contrast",
        "grayscale",
        "hue-rotate",
        "invert",
        "opacity",
        "saturate",
        "sepia"
      ].map((prop) => [`--backdrop-${prop}`, empty])
    ),
    "--global-font-mono": "fonts.mono",
    "--global-font-body": "fonts.body",
    "--global-color-border": "colors.border"
  },
  html: {
    color: "fg",
    bg: "bg",
    lineHeight: "1.5",
    colorPalette: "gray"
  },
  "*::placeholder, *[data-placeholder]": {
    color: "fg.muted/80"
  },
  "*::selection": {
    bg: "colorPalette.emphasized/80"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/layer-styles.js
var layerStyles = defineLayerStyles({
  // fill: some background color + color combination
  "fill.muted": {
    value: {
      background: "colorPalette.muted",
      color: "colorPalette.fg"
    }
  },
  "fill.subtle": {
    value: {
      background: "colorPalette.subtle",
      color: "colorPalette.fg"
    }
  },
  "fill.surface": {
    value: {
      background: "colorPalette.subtle",
      color: "colorPalette.fg",
      boxShadow: "0 0 0px 1px var(--shadow-color)",
      boxShadowColor: "colorPalette.muted"
    }
  },
  "fill.solid": {
    value: {
      background: "colorPalette.solid",
      color: "colorPalette.contrast"
    }
  },
  // outline: some border color + color combination
  "outline.subtle": {
    value: {
      color: "colorPalette.fg",
      boxShadow: "inset 0 0 0px 1px var(--shadow-color)",
      boxShadowColor: "colorPalette.subtle"
    }
  },
  "outline.solid": {
    value: {
      borderWidth: "1px",
      borderColor: "colorPalette.solid",
      color: "colorPalette.fg"
    }
  },
  // indicator: floating border color or left/bottom border
  "indicator.bottom": {
    value: {
      position: "relative",
      "--indicator-color-fallback": "colors.colorPalette.solid",
      _before: {
        content: `""`,
        position: "absolute",
        bottom: "var(--indicator-offset-y, 0)",
        insetInline: "var(--indicator-offset-x, 0)",
        height: "var(--indicator-thickness, 2px)",
        background: "var(--indicator-color, var(--indicator-color-fallback))"
      }
    }
  },
  "indicator.top": {
    value: {
      position: "relative",
      "--indicator-color-fallback": "colors.colorPalette.solid",
      _before: {
        content: `""`,
        position: "absolute",
        top: "var(--indicator-offset-y, 0)",
        insetInline: "var(--indicator-offset-x, 0)",
        height: "var(--indicator-thickness, 2px)",
        background: "var(--indicator-color, var(--indicator-color-fallback))"
      }
    }
  },
  "indicator.start": {
    value: {
      position: "relative",
      "--indicator-color-fallback": "colors.colorPalette.solid",
      _before: {
        content: `""`,
        position: "absolute",
        insetInlineStart: "var(--indicator-offset-x, 0)",
        insetBlock: "var(--indicator-offset-y, 0)",
        width: "var(--indicator-thickness, 2px)",
        background: "var(--indicator-color, var(--indicator-color-fallback))"
      }
    }
  },
  "indicator.end": {
    value: {
      position: "relative",
      "--indicator-color-fallback": "colors.colorPalette.solid",
      _before: {
        content: `""`,
        position: "absolute",
        insetInlineEnd: "var(--indicator-offset-x, 0)",
        insetBlock: "var(--indicator-offset-y, 0)",
        width: "var(--indicator-thickness, 2px)",
        background: "var(--indicator-color, var(--indicator-color-fallback))"
      }
    }
  },
  disabled: {
    value: {
      opacity: "0.5",
      cursor: "not-allowed"
    }
  },
  none: {
    value: {}
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/motion-styles.js
var animationStyles = defineAnimationStyles({
  "slide-fade-in": {
    value: {
      transformOrigin: "var(--transform-origin)",
      "&[data-placement^=top]": {
        animationName: "slide-from-bottom, fade-in"
      },
      "&[data-placement^=bottom]": {
        animationName: "slide-from-top, fade-in"
      },
      "&[data-placement^=left]": {
        animationName: "slide-from-right, fade-in"
      },
      "&[data-placement^=right]": {
        animationName: "slide-from-left, fade-in"
      }
    }
  },
  "slide-fade-out": {
    value: {
      transformOrigin: "var(--transform-origin)",
      "&[data-placement^=top]": {
        animationName: "slide-to-bottom, fade-out"
      },
      "&[data-placement^=bottom]": {
        animationName: "slide-to-top, fade-out"
      },
      "&[data-placement^=left]": {
        animationName: "slide-to-right, fade-out"
      },
      "&[data-placement^=right]": {
        animationName: "slide-to-left, fade-out"
      }
    }
  },
  "scale-fade-in": {
    value: {
      transformOrigin: "var(--transform-origin)",
      animationName: "scale-in, fade-in"
    }
  },
  "scale-fade-out": {
    value: {
      transformOrigin: "var(--transform-origin)",
      animationName: "scale-out, fade-out"
    }
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/badge.js
var badgeRecipe = defineRecipe({
  className: "chakra-badge",
  base: {
    display: "inline-flex",
    alignItems: "center",
    borderRadius: "l2",
    gap: "1",
    fontWeight: "medium",
    fontVariantNumeric: "tabular-nums",
    whiteSpace: "nowrap",
    userSelect: "none"
  },
  variants: {
    variant: {
      solid: {
        bg: "colorPalette.solid",
        color: "colorPalette.contrast"
      },
      subtle: {
        bg: "colorPalette.subtle",
        color: "colorPalette.fg"
      },
      outline: {
        color: "colorPalette.fg",
        shadow: "inset 0 0 0px 1px var(--shadow-color)",
        shadowColor: "colorPalette.muted"
      },
      surface: {
        bg: "colorPalette.subtle",
        color: "colorPalette.fg",
        shadow: "inset 0 0 0px 1px var(--shadow-color)",
        shadowColor: "colorPalette.muted"
      },
      plain: {
        color: "colorPalette.fg"
      }
    },
    size: {
      xs: {
        textStyle: "2xs",
        px: "1",
        minH: "4"
      },
      sm: {
        textStyle: "xs",
        px: "1.5",
        minH: "5"
      },
      md: {
        textStyle: "sm",
        px: "2",
        minH: "6"
      },
      lg: {
        textStyle: "sm",
        px: "2.5",
        minH: "7"
      }
    }
  },
  defaultVariants: {
    variant: "subtle",
    size: "sm"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/button.js
var buttonRecipe = defineRecipe({
  className: "chakra-button",
  base: {
    display: "inline-flex",
    appearance: "none",
    alignItems: "center",
    justifyContent: "center",
    userSelect: "none",
    position: "relative",
    borderRadius: "l2",
    whiteSpace: "nowrap",
    verticalAlign: "middle",
    borderWidth: "1px",
    borderColor: "transparent",
    cursor: "button",
    flexShrink: "0",
    outline: "0",
    lineHeight: "1.2",
    isolation: "isolate",
    fontWeight: "medium",
    transitionProperty: "common",
    transitionDuration: "moderate",
    focusVisibleRing: "outside",
    _disabled: {
      layerStyle: "disabled"
    },
    _icon: {
      flexShrink: "0"
    }
  },
  variants: {
    size: {
      "2xs": {
        h: "6",
        minW: "6",
        textStyle: "xs",
        px: "2",
        gap: "1",
        _icon: {
          width: "3.5",
          height: "3.5"
        }
      },
      xs: {
        h: "8",
        minW: "8",
        textStyle: "xs",
        px: "2.5",
        gap: "1",
        _icon: {
          width: "4",
          height: "4"
        }
      },
      sm: {
        h: "9",
        minW: "9",
        px: "3.5",
        textStyle: "sm",
        gap: "2",
        _icon: {
          width: "4",
          height: "4"
        }
      },
      md: {
        h: "10",
        minW: "10",
        textStyle: "sm",
        px: "4",
        gap: "2",
        _icon: {
          width: "5",
          height: "5"
        }
      },
      lg: {
        h: "11",
        minW: "11",
        textStyle: "md",
        px: "5",
        gap: "3",
        _icon: {
          width: "5",
          height: "5"
        }
      },
      xl: {
        h: "12",
        minW: "12",
        textStyle: "md",
        px: "5",
        gap: "2.5",
        _icon: {
          width: "5",
          height: "5"
        }
      },
      "2xl": {
        h: "16",
        minW: "16",
        textStyle: "lg",
        px: "7",
        gap: "3",
        _icon: {
          width: "6",
          height: "6"
        }
      }
    },
    variant: {
      solid: {
        bg: "colorPalette.solid",
        color: "colorPalette.contrast",
        borderColor: "transparent",
        _hover: {
          bg: "colorPalette.solid/90"
        },
        _expanded: {
          bg: "colorPalette.solid/90"
        }
      },
      subtle: {
        bg: "colorPalette.subtle",
        color: "colorPalette.fg",
        borderColor: "transparent",
        _hover: {
          bg: "colorPalette.muted"
        },
        _expanded: {
          bg: "colorPalette.muted"
        }
      },
      surface: {
        bg: "colorPalette.subtle",
        color: "colorPalette.fg",
        shadow: "0 0 0px 1px var(--shadow-color)",
        shadowColor: "colorPalette.muted",
        _hover: {
          bg: "colorPalette.muted"
        },
        _expanded: {
          bg: "colorPalette.muted"
        }
      },
      outline: {
        borderWidth: "1px",
        borderColor: "colorPalette.muted",
        color: "colorPalette.fg",
        _hover: {
          bg: "colorPalette.subtle"
        },
        _expanded: {
          bg: "colorPalette.subtle"
        }
      },
      ghost: {
        bg: "transparent",
        color: "colorPalette.fg",
        _hover: {
          bg: "colorPalette.subtle"
        },
        _expanded: {
          bg: "colorPalette.subtle"
        }
      },
      plain: {
        color: "colorPalette.fg"
      }
    }
  },
  defaultVariants: {
    size: "md",
    variant: "solid"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/checkmark.js
var checkmarkRecipe = defineRecipe({
  className: "chakra-checkmark",
  base: {
    display: "inline-flex",
    alignItems: "center",
    justifyContent: "center",
    flexShrink: "0",
    color: "white",
    borderWidth: "1px",
    borderColor: "transparent",
    borderRadius: "l1",
    cursor: "checkbox",
    focusVisibleRing: "outside",
    _icon: {
      boxSize: "full"
    },
    _invalid: {
      colorPalette: "red",
      borderColor: "border.error"
    },
    _disabled: {
      opacity: "0.5",
      cursor: "disabled"
    }
  },
  variants: {
    size: {
      xs: {
        boxSize: "3"
      },
      sm: {
        boxSize: "4"
      },
      md: {
        boxSize: "5",
        p: "0.5"
      },
      lg: {
        boxSize: "6",
        p: "0.5"
      }
    },
    variant: {
      solid: {
        borderColor: "border",
        "&:is([data-state=checked], [data-state=indeterminate])": {
          bg: "colorPalette.solid",
          color: "colorPalette.contrast",
          borderColor: "colorPalette.solid"
        }
      },
      outline: {
        borderColor: "border",
        "&:is([data-state=checked], [data-state=indeterminate])": {
          color: "colorPalette.fg",
          borderColor: "colorPalette.solid"
        }
      },
      subtle: {
        bg: "colorPalette.muted",
        borderColor: "colorPalette.muted",
        "&:is([data-state=checked], [data-state=indeterminate])": {
          color: "colorPalette.fg"
        }
      },
      plain: {
        "&:is([data-state=checked], [data-state=indeterminate])": {
          color: "colorPalette.fg"
        }
      },
      inverted: {
        borderColor: "border",
        color: "colorPalette.fg",
        "&:is([data-state=checked], [data-state=indeterminate])": {
          borderColor: "colorPalette.solid"
        }
      }
    }
  },
  defaultVariants: {
    variant: "solid",
    size: "md"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/code.js
var { variants, defaultVariants } = badgeRecipe;
var codeRecipe = defineRecipe({
  className: "chakra-code",
  base: {
    fontFamily: "mono",
    alignItems: "center",
    display: "inline-flex",
    borderRadius: "l2"
  },
  variants,
  defaultVariants
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/color-swatch.js
var colorSwatchRecipe = defineRecipe({
  className: "color-swatch",
  base: {
    boxSize: "var(--swatch-size)",
    shadow: "inset 0 0 0 1px rgba(0, 0, 0, 0.1)",
    "--checker-size": "8px",
    "--checker-bg": "colors.bg",
    "--checker-fg": "colors.bg.emphasized",
    background: "linear-gradient(var(--color), var(--color)), repeating-conic-gradient(var(--checker-fg) 0%, var(--checker-fg) 25%, var(--checker-bg) 0%, var(--checker-bg) 50%) 0% 50% / var(--checker-size) var(--checker-size) !important",
    display: "inline-flex",
    alignItems: "center",
    justifyContent: "center",
    flexShrink: "0"
  },
  variants: {
    size: {
      "2xs": { "--swatch-size": "sizes.3.5" },
      xs: { "--swatch-size": "sizes.4" },
      sm: { "--swatch-size": "sizes.4.5" },
      md: { "--swatch-size": "sizes.5" },
      lg: { "--swatch-size": "sizes.6" },
      xl: { "--swatch-size": "sizes.7" },
      "2xl": { "--swatch-size": "sizes.8" },
      inherit: { "--swatch-size": "inherit" },
      full: { "--swatch-size": "100%" }
    },
    shape: {
      square: { borderRadius: "none" },
      circle: { borderRadius: "full" },
      rounded: { borderRadius: "l1" }
    }
  },
  defaultVariants: {
    size: "md",
    shape: "rounded"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/container.js
var containerRecipe = defineRecipe({
  className: "chakra-container",
  base: {
    position: "relative",
    maxWidth: "8xl",
    w: "100%",
    mx: "auto",
    px: { base: "4", md: "6", lg: "8" }
  },
  variants: {
    centerContent: {
      true: {
        display: "flex",
        flexDirection: "column",
        alignItems: "center"
      }
    },
    fluid: {
      true: {
        maxWidth: "full"
      }
    }
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/heading.js
var headingRecipe = defineRecipe({
  className: "chakra-heading",
  base: {
    fontFamily: "heading",
    fontWeight: "semibold"
  },
  variants: {
    size: {
      xs: { textStyle: "xs" },
      sm: { textStyle: "sm" },
      md: { textStyle: "md" },
      lg: { textStyle: "lg" },
      xl: { textStyle: "xl" },
      "2xl": { textStyle: "2xl" },
      "3xl": { textStyle: "3xl" },
      "4xl": { textStyle: "4xl" },
      "5xl": { textStyle: "5xl" },
      "6xl": { textStyle: "6xl" },
      "7xl": { textStyle: "7xl" }
    }
  },
  defaultVariants: {
    size: "xl"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/icon.js
var iconRecipe = defineRecipe({
  className: "chakra-icon",
  base: {
    display: "inline-block",
    lineHeight: "1em",
    flexShrink: "0",
    color: "currentcolor",
    verticalAlign: "middle"
  },
  variants: {
    size: {
      inherit: {},
      xs: { boxSize: "3" },
      sm: { boxSize: "4" },
      md: { boxSize: "5" },
      lg: { boxSize: "6" },
      xl: { boxSize: "7" },
      "2xl": { boxSize: "8" }
    }
  },
  defaultVariants: {
    size: "inherit"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/input.js
var inputRecipe = defineRecipe({
  className: "chakra-input",
  base: {
    width: "100%",
    minWidth: "0",
    outline: "0",
    position: "relative",
    appearance: "none",
    textAlign: "start",
    borderRadius: "l2",
    _disabled: {
      layerStyle: "disabled"
    },
    height: "var(--input-height)",
    minW: "var(--input-height)",
    "--focus-color": "colors.colorPalette.focusRing",
    "--error-color": "colors.border.error",
    _invalid: {
      focusRingColor: "var(--error-color)",
      borderColor: "var(--error-color)"
    }
  },
  variants: {
    size: {
      "2xs": {
        textStyle: "xs",
        px: "2",
        "--input-height": "sizes.7"
      },
      xs: {
        textStyle: "xs",
        px: "2",
        "--input-height": "sizes.8"
      },
      sm: {
        textStyle: "sm",
        px: "2.5",
        "--input-height": "sizes.9"
      },
      md: {
        textStyle: "sm",
        px: "3",
        "--input-height": "sizes.10"
      },
      lg: {
        textStyle: "md",
        px: "4",
        "--input-height": "sizes.11"
      },
      xl: {
        textStyle: "md",
        px: "4.5",
        "--input-height": "sizes.12"
      },
      "2xl": {
        textStyle: "lg",
        px: "5",
        "--input-height": "sizes.16"
      }
    },
    variant: {
      outline: {
        bg: "transparent",
        borderWidth: "1px",
        borderColor: "border",
        focusVisibleRing: "inside",
        focusRingColor: "var(--focus-color)"
      },
      subtle: {
        borderWidth: "1px",
        borderColor: "transparent",
        bg: "bg.muted",
        focusVisibleRing: "inside",
        focusRingColor: "var(--focus-color)"
      },
      flushed: {
        bg: "transparent",
        borderBottomWidth: "1px",
        borderBottomColor: "border",
        borderRadius: "0",
        px: "0",
        _focusVisible: {
          borderColor: "var(--focus-color)",
          boxShadow: "0px 1px 0px 0px var(--focus-color)",
          _invalid: {
            borderColor: "var(--error-color)",
            boxShadow: "0px 1px 0px 0px var(--error-color)"
          }
        }
      }
    }
  },
  defaultVariants: {
    size: "md",
    variant: "outline"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/input-addon.js
var inputAddonRecipe = defineRecipe({
  className: "chakra-input-addon",
  base: {
    flex: "0 0 auto",
    width: "auto",
    display: "flex",
    alignItems: "center",
    whiteSpace: "nowrap",
    alignSelf: "stretch",
    borderRadius: "l2"
  },
  variants: {
    size: inputRecipe.variants.size,
    variant: {
      outline: {
        borderWidth: "1px",
        borderColor: "border",
        bg: "bg.muted"
      },
      subtle: {
        borderWidth: "1px",
        borderColor: "transparent",
        bg: "bg.emphasized"
      },
      flushed: {
        borderBottom: "1px solid",
        borderColor: "inherit",
        borderRadius: "0",
        px: "0",
        bg: "transparent"
      }
    }
  },
  defaultVariants: {
    size: "md",
    variant: "outline"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/kbd.js
var kbdRecipe = defineRecipe({
  className: "chakra-kbd",
  base: {
    display: "inline-flex",
    alignItems: "center",
    fontWeight: "medium",
    fontFamily: "mono",
    flexShrink: "0",
    whiteSpace: "nowrap",
    wordSpacing: "-0.5em",
    userSelect: "none",
    px: "1",
    borderRadius: "l2"
  },
  variants: {
    variant: {
      raised: {
        bg: "colorPalette.subtle",
        color: "colorPalette.fg",
        borderWidth: "1px",
        borderBottomWidth: "2px",
        borderColor: "colorPalette.muted"
      },
      outline: {
        borderWidth: "1px",
        color: "colorPalette.fg"
      },
      subtle: {
        bg: "colorPalette.muted",
        color: "colorPalette.fg"
      },
      plain: {
        color: "colorPalette.fg"
      }
    },
    size: {
      sm: {
        textStyle: "xs",
        height: "4.5"
      },
      md: {
        textStyle: "sm",
        height: "5"
      },
      lg: {
        textStyle: "md",
        height: "6"
      }
    }
  },
  defaultVariants: {
    size: "md",
    variant: "raised"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/link.js
var linkRecipe = defineRecipe({
  className: "chakra-link",
  base: {
    display: "inline-flex",
    alignItems: "center",
    outline: "none",
    gap: "1.5",
    cursor: "pointer",
    borderRadius: "l1",
    focusRing: "outside"
  },
  variants: {
    variant: {
      underline: {
        color: "colorPalette.fg",
        textDecoration: "underline",
        textUnderlineOffset: "3px",
        textDecorationColor: "currentColor/20"
      },
      plain: {
        color: "colorPalette.fg",
        _hover: {
          textDecoration: "underline",
          textUnderlineOffset: "3px",
          textDecorationColor: "currentColor/20"
        }
      }
    }
  },
  defaultVariants: {
    variant: "plain"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/mark.js
var markRecipe = defineRecipe({
  className: "chakra-mark",
  base: {
    bg: "transparent",
    color: "inherit",
    whiteSpace: "nowrap"
  },
  variants: {
    variant: {
      subtle: {
        bg: "colorPalette.subtle",
        color: "inherit"
      },
      solid: {
        bg: "colorPalette.solid",
        color: "colorPalette.contrast"
      },
      text: {
        fontWeight: "medium"
      },
      plain: {}
    }
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/radiomark.js
var radiomarkRecipe = defineRecipe({
  className: "chakra-radiomark",
  base: {
    display: "inline-flex",
    alignItems: "center",
    justifyContent: "center",
    flexShrink: 0,
    verticalAlign: "top",
    color: "white",
    borderWidth: "1px",
    borderColor: "transparent",
    borderRadius: "full",
    cursor: "radio",
    _focusVisible: {
      outline: "2px solid",
      outlineColor: "colorPalette.focusRing",
      outlineOffset: "2px"
    },
    _invalid: {
      colorPalette: "red",
      borderColor: "red.500"
    },
    _disabled: {
      opacity: "0.5",
      cursor: "disabled"
    },
    "& .dot": {
      height: "100%",
      width: "100%",
      borderRadius: "full",
      bg: "currentColor",
      scale: "0.4"
    }
  },
  variants: {
    variant: {
      solid: {
        borderWidth: "1px",
        borderColor: "border",
        _checked: {
          bg: "colorPalette.solid",
          color: "colorPalette.contrast",
          borderColor: "colorPalette.solid"
        }
      },
      subtle: {
        borderWidth: "1px",
        bg: "colorPalette.muted",
        borderColor: "colorPalette.muted",
        color: "transparent",
        _checked: {
          color: "colorPalette.fg"
        }
      },
      outline: {
        borderWidth: "1px",
        borderColor: "inherit",
        _checked: {
          color: "colorPalette.fg",
          borderColor: "colorPalette.solid"
        },
        "& .dot": {
          scale: "0.6"
        }
      },
      inverted: {
        bg: "bg",
        borderWidth: "1px",
        borderColor: "inherit",
        _checked: {
          color: "colorPalette.solid",
          borderColor: "currentcolor"
        }
      }
    },
    size: {
      xs: {
        boxSize: "3"
      },
      sm: {
        boxSize: "4"
      },
      md: {
        boxSize: "5"
      },
      lg: {
        boxSize: "6"
      }
    }
  },
  defaultVariants: {
    variant: "solid",
    size: "md"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/separator.js
var separatorRecipe = defineRecipe({
  className: "chakra-separator",
  base: {
    display: "block",
    borderColor: "border"
  },
  variants: {
    variant: {
      solid: {
        borderStyle: "solid"
      },
      dashed: {
        borderStyle: "dashed"
      },
      dotted: {
        borderStyle: "dotted"
      }
    },
    orientation: {
      vertical: {
        borderInlineStartWidth: "var(--separator-thickness)"
      },
      horizontal: {
        borderTopWidth: "var(--separator-thickness)"
      }
    },
    size: {
      xs: {
        "--separator-thickness": "0.5px"
      },
      sm: {
        "--separator-thickness": "1px"
      },
      md: {
        "--separator-thickness": "2px"
      },
      lg: {
        "--separator-thickness": "3px"
      }
    }
  },
  defaultVariants: {
    size: "sm",
    variant: "solid",
    orientation: "horizontal"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/skeleton.js
var skeletonRecipe = defineRecipe({
  className: "chakra-skeleton",
  base: {},
  variants: {
    loading: {
      true: {
        borderRadius: "l2",
        boxShadow: "none",
        backgroundClip: "padding-box",
        cursor: "default",
        color: "transparent",
        pointerEvents: "none",
        userSelect: "none",
        flexShrink: "0",
        "&::before, &::after, *": {
          visibility: "hidden"
        }
      },
      false: {
        background: "unset",
        animation: "fade-in var(--fade-duration, 0.1s) ease-out !important"
      }
    },
    variant: {
      pulse: {
        background: "bg.emphasized",
        animation: "pulse",
        animationDuration: "var(--duration, 1.2s)"
      },
      shine: {
        "--animate-from": "200%",
        "--animate-to": "-200%",
        "--start-color": "colors.bg.muted",
        "--end-color": "colors.bg.emphasized",
        backgroundImage: "linear-gradient(270deg,var(--start-color),var(--end-color),var(--end-color),var(--start-color))",
        backgroundSize: "400% 100%",
        animation: "bg-position var(--duration, 5s) ease-in-out infinite"
      },
      none: {
        animation: "none"
      }
    }
  },
  defaultVariants: {
    variant: "pulse",
    loading: true
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/skip-nav-link.js
var skipNavLinkRecipe = defineRecipe({
  className: "chakra-skip-nav",
  base: {
    display: "inline-flex",
    bg: "bg.panel",
    padding: "2.5",
    borderRadius: "l2",
    fontWeight: "semibold",
    focusVisibleRing: "outside",
    textStyle: "sm",
    // visually hidden
    userSelect: "none",
    border: "0",
    height: "1px",
    width: "1px",
    margin: "-1px",
    outline: "0",
    overflow: "hidden",
    position: "absolute",
    clip: "rect(0 0 0 0)",
    _focusVisible: {
      clip: "auto",
      width: "auto",
      height: "auto",
      position: "fixed",
      top: "6",
      insetStart: "6"
    }
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/spinner.js
var spinnerRecipe = defineRecipe({
  className: "chakra-spinner",
  base: {
    display: "inline-block",
    borderColor: "currentColor",
    borderStyle: "solid",
    borderWidth: "2px",
    borderRadius: "full",
    width: "var(--spinner-size)",
    height: "var(--spinner-size)",
    animation: "spin",
    animationDuration: "slowest",
    "--spinner-track-color": "transparent",
    borderBottomColor: "var(--spinner-track-color)",
    borderInlineStartColor: "var(--spinner-track-color)"
  },
  variants: {
    size: {
      inherit: { "--spinner-size": "1em" },
      xs: { "--spinner-size": "sizes.3" },
      sm: { "--spinner-size": "sizes.4" },
      md: { "--spinner-size": "sizes.5" },
      lg: { "--spinner-size": "sizes.8" },
      xl: { "--spinner-size": "sizes.10" }
    }
  },
  defaultVariants: {
    size: "md"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/textarea.js
var textareaRecipe = defineRecipe({
  className: "chakra-textarea",
  base: {
    width: "100%",
    minWidth: "0",
    outline: "0",
    position: "relative",
    appearance: "none",
    textAlign: "start",
    borderRadius: "l2",
    _disabled: {
      layerStyle: "disabled"
    },
    "--focus-color": "colors.colorPalette.focusRing",
    "--error-color": "colors.border.error",
    _invalid: {
      focusRingColor: "var(--error-color)",
      borderColor: "var(--error-color)"
    }
  },
  variants: {
    size: {
      xs: {
        textStyle: "xs",
        px: "2",
        py: "1.5",
        scrollPaddingBottom: "1.5"
      },
      sm: {
        textStyle: "sm",
        px: "2.5",
        py: "2",
        scrollPaddingBottom: "2"
      },
      md: {
        textStyle: "sm",
        px: "3",
        py: "2",
        scrollPaddingBottom: "2"
      },
      lg: {
        textStyle: "md",
        px: "4",
        py: "3",
        scrollPaddingBottom: "3"
      },
      xl: {
        textStyle: "md",
        px: "4.5",
        py: "3.5",
        scrollPaddingBottom: "3.5"
      }
    },
    variant: {
      outline: {
        bg: "transparent",
        borderWidth: "1px",
        borderColor: "border",
        focusVisibleRing: "inside"
      },
      subtle: {
        borderWidth: "1px",
        borderColor: "transparent",
        bg: "bg.muted",
        focusVisibleRing: "inside"
      },
      flushed: {
        bg: "transparent",
        borderBottomWidth: "1px",
        borderBottomColor: "border",
        borderRadius: "0",
        px: "0",
        _focusVisible: {
          borderColor: "var(--focus-color)",
          boxShadow: "0px 1px 0px 0px var(--focus-color)"
        }
      }
    }
  },
  defaultVariants: {
    size: "md",
    variant: "outline"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes.js
var recipes = {
  badge: badgeRecipe,
  button: buttonRecipe,
  code: codeRecipe,
  container: containerRecipe,
  heading: headingRecipe,
  input: inputRecipe,
  inputAddon: inputAddonRecipe,
  kbd: kbdRecipe,
  link: linkRecipe,
  mark: markRecipe,
  separator: separatorRecipe,
  skeleton: skeletonRecipe,
  skipNavLink: skipNavLinkRecipe,
  spinner: spinnerRecipe,
  textarea: textareaRecipe,
  icon: iconRecipe,
  checkmark: checkmarkRecipe,
  radiomark: radiomarkRecipe,
  colorSwatch: colorSwatchRecipe
};

// node_modules/@chakra-ui/react/dist/esm/theme/semantic-tokens/colors.js
var semanticColors = defineSemanticTokens.colors({
  bg: {
    DEFAULT: {
      value: { _light: "{colors.white}", _dark: "{colors.black}" }
    },
    subtle: {
      value: { _light: "{colors.gray.50}", _dark: "{colors.gray.950}" }
    },
    muted: {
      value: { _light: "{colors.gray.100}", _dark: "{colors.gray.900}" }
    },
    emphasized: {
      value: { _light: "{colors.gray.200}", _dark: "{colors.gray.800}" }
    },
    inverted: {
      value: { _light: "{colors.black}", _dark: "{colors.white}" }
    },
    panel: {
      value: { _light: "{colors.white}", _dark: "{colors.gray.950}" }
    },
    error: {
      value: { _light: "{colors.red.50}", _dark: "{colors.red.950}" }
    },
    warning: {
      value: { _light: "{colors.orange.50}", _dark: "{colors.orange.950}" }
    },
    success: {
      value: { _light: "{colors.green.50}", _dark: "{colors.green.950}" }
    },
    info: {
      value: { _light: "{colors.blue.50}", _dark: "{colors.blue.950}" }
    }
  },
  fg: {
    DEFAULT: {
      value: { _light: "{colors.black}", _dark: "{colors.gray.50}" }
    },
    muted: {
      value: { _light: "{colors.gray.600}", _dark: "{colors.gray.400}" }
    },
    subtle: {
      value: { _light: "{colors.gray.400}", _dark: "{colors.gray.500}" }
    },
    inverted: {
      value: { _light: "{colors.gray.50}", _dark: "{colors.black}" }
    },
    error: {
      value: { _light: "{colors.red.500}", _dark: "{colors.red.400}" }
    },
    warning: {
      value: { _light: "{colors.orange.600}", _dark: "{colors.orange.300}" }
    },
    success: {
      value: { _light: "{colors.green.600}", _dark: "{colors.green.300}" }
    },
    info: {
      value: { _light: "{colors.blue.600}", _dark: "{colors.blue.300}" }
    }
  },
  border: {
    DEFAULT: {
      value: { _light: "{colors.gray.200}", _dark: "{colors.gray.800}" }
    },
    muted: {
      value: { _light: "{colors.gray.100}", _dark: "{colors.gray.900}" }
    },
    subtle: {
      value: { _light: "{colors.gray.50}", _dark: "{colors.gray.950}" }
    },
    emphasized: {
      value: { _light: "{colors.gray.300}", _dark: "{colors.gray.700}" }
    },
    inverted: {
      value: { _light: "{colors.gray.800}", _dark: "{colors.gray.200}" }
    },
    error: {
      value: { _light: "{colors.red.500}", _dark: "{colors.red.400}" }
    },
    warning: {
      value: { _light: "{colors.orange.500}", _dark: "{colors.orange.400}" }
    },
    success: {
      value: { _light: "{colors.green.500}", _dark: "{colors.green.400}" }
    },
    info: {
      value: { _light: "{colors.blue.500}", _dark: "{colors.blue.400}" }
    }
  },
  gray: {
    contrast: {
      value: { _light: "{colors.white}", _dark: "{colors.black}" }
    },
    fg: {
      value: { _light: "{colors.gray.800}", _dark: "{colors.gray.200}" }
    },
    subtle: {
      value: { _light: "{colors.gray.100}", _dark: "{colors.gray.900}" }
    },
    muted: {
      value: { _light: "{colors.gray.200}", _dark: "{colors.gray.800}" }
    },
    emphasized: {
      value: { _light: "{colors.gray.300}", _dark: "{colors.gray.700}" }
    },
    solid: {
      value: { _light: "{colors.gray.900}", _dark: "{colors.white}" }
    },
    focusRing: {
      value: { _light: "{colors.gray.400}", _dark: "{colors.gray.400}" }
    }
  },
  red: {
    contrast: {
      value: { _light: "white", _dark: "white" }
    },
    fg: {
      value: { _light: "{colors.red.700}", _dark: "{colors.red.300}" }
    },
    subtle: {
      value: { _light: "{colors.red.100}", _dark: "{colors.red.900}" }
    },
    muted: {
      value: { _light: "{colors.red.200}", _dark: "{colors.red.800}" }
    },
    emphasized: {
      value: { _light: "{colors.red.300}", _dark: "{colors.red.700}" }
    },
    solid: {
      value: { _light: "{colors.red.600}", _dark: "{colors.red.600}" }
    },
    focusRing: {
      value: { _light: "{colors.red.500}", _dark: "{colors.red.500}" }
    }
  },
  orange: {
    contrast: {
      value: { _light: "white", _dark: "black" }
    },
    fg: {
      value: { _light: "{colors.orange.700}", _dark: "{colors.orange.300}" }
    },
    subtle: {
      value: { _light: "{colors.orange.100}", _dark: "{colors.orange.900}" }
    },
    muted: {
      value: { _light: "{colors.orange.200}", _dark: "{colors.orange.800}" }
    },
    emphasized: {
      value: { _light: "{colors.orange.300}", _dark: "{colors.orange.700}" }
    },
    solid: {
      value: { _light: "{colors.orange.600}", _dark: "{colors.orange.500}" }
    },
    focusRing: {
      value: { _light: "{colors.orange.500}", _dark: "{colors.orange.500}" }
    }
  },
  green: {
    contrast: {
      value: { _light: "white", _dark: "white" }
    },
    fg: {
      value: { _light: "{colors.green.700}", _dark: "{colors.green.300}" }
    },
    subtle: {
      value: { _light: "{colors.green.100}", _dark: "{colors.green.900}" }
    },
    muted: {
      value: { _light: "{colors.green.200}", _dark: "{colors.green.800}" }
    },
    emphasized: {
      value: { _light: "{colors.green.300}", _dark: "{colors.green.700}" }
    },
    solid: {
      value: { _light: "{colors.green.600}", _dark: "{colors.green.600}" }
    },
    focusRing: {
      value: { _light: "{colors.green.500}", _dark: "{colors.green.500}" }
    }
  },
  blue: {
    contrast: {
      value: { _light: "white", _dark: "white" }
    },
    fg: {
      value: { _light: "{colors.blue.700}", _dark: "{colors.blue.300}" }
    },
    subtle: {
      value: { _light: "{colors.blue.100}", _dark: "{colors.blue.900}" }
    },
    muted: {
      value: { _light: "{colors.blue.200}", _dark: "{colors.blue.800}" }
    },
    emphasized: {
      value: { _light: "{colors.blue.300}", _dark: "{colors.blue.700}" }
    },
    solid: {
      value: { _light: "{colors.blue.600}", _dark: "{colors.blue.600}" }
    },
    focusRing: {
      value: { _light: "{colors.blue.500}", _dark: "{colors.blue.500}" }
    }
  },
  yellow: {
    contrast: {
      value: { _light: "black", _dark: "black" }
    },
    fg: {
      value: { _light: "{colors.yellow.800}", _dark: "{colors.yellow.300}" }
    },
    subtle: {
      value: { _light: "{colors.yellow.100}", _dark: "{colors.yellow.900}" }
    },
    muted: {
      value: { _light: "{colors.yellow.200}", _dark: "{colors.yellow.800}" }
    },
    emphasized: {
      value: { _light: "{colors.yellow.300}", _dark: "{colors.yellow.700}" }
    },
    solid: {
      value: { _light: "{colors.yellow.300}", _dark: "{colors.yellow.300}" }
    },
    focusRing: {
      value: { _light: "{colors.yellow.500}", _dark: "{colors.yellow.500}" }
    }
  },
  teal: {
    contrast: {
      value: { _light: "white", _dark: "white" }
    },
    fg: {
      value: { _light: "{colors.teal.700}", _dark: "{colors.teal.300}" }
    },
    subtle: {
      value: { _light: "{colors.teal.100}", _dark: "{colors.teal.900}" }
    },
    muted: {
      value: { _light: "{colors.teal.200}", _dark: "{colors.teal.800}" }
    },
    emphasized: {
      value: { _light: "{colors.teal.300}", _dark: "{colors.teal.700}" }
    },
    solid: {
      value: { _light: "{colors.teal.600}", _dark: "{colors.teal.600}" }
    },
    focusRing: {
      value: { _light: "{colors.teal.500}", _dark: "{colors.teal.500}" }
    }
  },
  purple: {
    contrast: {
      value: { _light: "white", _dark: "white" }
    },
    fg: {
      value: { _light: "{colors.purple.700}", _dark: "{colors.purple.300}" }
    },
    subtle: {
      value: { _light: "{colors.purple.100}", _dark: "{colors.purple.900}" }
    },
    muted: {
      value: { _light: "{colors.purple.200}", _dark: "{colors.purple.800}" }
    },
    emphasized: {
      value: { _light: "{colors.purple.300}", _dark: "{colors.purple.700}" }
    },
    solid: {
      value: { _light: "{colors.purple.600}", _dark: "{colors.purple.600}" }
    },
    focusRing: {
      value: { _light: "{colors.purple.500}", _dark: "{colors.purple.500}" }
    }
  },
  pink: {
    contrast: {
      value: { _light: "white", _dark: "white" }
    },
    fg: {
      value: { _light: "{colors.pink.700}", _dark: "{colors.pink.300}" }
    },
    subtle: {
      value: { _light: "{colors.pink.100}", _dark: "{colors.pink.900}" }
    },
    muted: {
      value: { _light: "{colors.pink.200}", _dark: "{colors.pink.800}" }
    },
    emphasized: {
      value: { _light: "{colors.pink.300}", _dark: "{colors.pink.700}" }
    },
    solid: {
      value: { _light: "{colors.pink.600}", _dark: "{colors.pink.600}" }
    },
    focusRing: {
      value: { _light: "{colors.pink.500}", _dark: "{colors.pink.500}" }
    }
  },
  cyan: {
    contrast: {
      value: { _light: "white", _dark: "white" }
    },
    fg: {
      value: { _light: "{colors.cyan.700}", _dark: "{colors.cyan.300}" }
    },
    subtle: {
      value: { _light: "{colors.cyan.100}", _dark: "{colors.cyan.900}" }
    },
    muted: {
      value: { _light: "{colors.cyan.200}", _dark: "{colors.cyan.800}" }
    },
    emphasized: {
      value: { _light: "{colors.cyan.300}", _dark: "{colors.cyan.700}" }
    },
    solid: {
      value: { _light: "{colors.cyan.600}", _dark: "{colors.cyan.600}" }
    },
    focusRing: {
      value: { _light: "{colors.cyan.500}", _dark: "{colors.cyan.500}" }
    }
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/semantic-tokens/radii.js
var semanticRadii = defineSemanticTokens.radii({
  l1: { value: "{radii.xs}" },
  l2: { value: "{radii.sm}" },
  l3: { value: "{radii.md}" }
});

// node_modules/@chakra-ui/react/dist/esm/theme/semantic-tokens/shadows.js
var semanticShadows = defineSemanticTokens.shadows({
  xs: {
    value: {
      _light: "0px 1px 2px {colors.gray.900/10}, 0px 0px 1px {colors.gray.900/20}",
      _dark: "0px 1px 1px {black/64}, 0px 0px 1px inset {colors.gray.300/20}"
    }
  },
  sm: {
    value: {
      _light: "0px 2px 4px {colors.gray.900/10}, 0px 0px 1px {colors.gray.900/30}",
      _dark: "0px 2px 4px {black/64}, 0px 0px 1px inset {colors.gray.300/30}"
    }
  },
  md: {
    value: {
      _light: "0px 4px 8px {colors.gray.900/10}, 0px 0px 1px {colors.gray.900/30}",
      _dark: "0px 4px 8px {black/64}, 0px 0px 1px inset {colors.gray.300/30}"
    }
  },
  lg: {
    value: {
      _light: "0px 8px 16px {colors.gray.900/10}, 0px 0px 1px {colors.gray.900/30}",
      _dark: "0px 8px 16px {black/64}, 0px 0px 1px inset {colors.gray.300/30}"
    }
  },
  xl: {
    value: {
      _light: "0px 16px 24px {colors.gray.900/10}, 0px 0px 1px {colors.gray.900/30}",
      _dark: "0px 16px 24px {black/64}, 0px 0px 1px inset {colors.gray.300/30}"
    }
  },
  "2xl": {
    value: {
      _light: "0px 24px 40px {colors.gray.900/16}, 0px 0px 1px {colors.gray.900/30}",
      _dark: "0px 24px 40px {black/64}, 0px 0px 1px inset {colors.gray.300/30}"
    }
  },
  inner: {
    value: {
      _light: "inset 0 2px 4px 0 {black/5}",
      _dark: "inset 0 2px 4px 0 black"
    }
  },
  inset: {
    value: {
      _light: "inset 0 0 0 1px {black/5}",
      _dark: "inset 0 0 0 1px {colors.gray.300/5}"
    }
  }
});

// node_modules/@chakra-ui/react/dist/esm/anatomy.js
var accordionAnatomy = anatomy4.extendWith("itemBody");
var actionBarAnatomy = createAnatomy("action-bar").parts(
  "positioner",
  "content",
  "separator",
  "selectionTrigger",
  "closeTrigger"
);
var alertAnatomy = createAnatomy("alert").parts(
  "title",
  "description",
  "root",
  "indicator",
  "content"
);
var breadcrumbAnatomy = createAnatomy("breadcrumb").parts(
  "link",
  "currentLink",
  "item",
  "list",
  "root",
  "ellipsis",
  "separator"
);
var blockquoteAnatomy = createAnatomy("blockquote").parts(
  "root",
  "icon",
  "content",
  "caption"
);
var cardAnatomy = createAnatomy("card").parts(
  "root",
  "header",
  "body",
  "footer",
  "title",
  "description"
);
var checkboxCardAnatomy = createAnatomy("checkbox-card", [
  "root",
  "control",
  "label",
  "description",
  "addon",
  "indicator",
  "content"
]);
var dataListAnatomy = createAnatomy("data-list").parts(
  "root",
  "item",
  "itemLabel",
  "itemValue"
);
var dialogAnatomy = anatomy11.extendWith(
  "header",
  "body",
  "footer",
  "backdrop"
);
var drawerAnatomy = anatomy11.extendWith(
  "header",
  "body",
  "footer",
  "backdrop"
);
var editableAnatomy = anatomy12.extendWith("textarea");
var emptyStateAnatomy = createAnatomy("empty-state", [
  "root",
  "content",
  "indicator",
  "title",
  "description"
]);
var fieldAnatomy2 = fieldAnatomy.extendWith("requiredIndicator");
var fieldsetAnatomy2 = fieldsetAnatomy.extendWith("content");
var fileUploadAnatomy = anatomy13.extendWith(
  "itemContent",
  "dropzoneContent",
  "fileText"
);
var listAnatomy = createAnatomy("list").parts(
  "root",
  "item",
  "indicator"
);
var menuAnatomy = anatomy17.extendWith("itemCommand");
var nativeSelectAnatomy = createAnatomy("select").parts(
  "root",
  "field",
  "indicator"
);
var popoverAnatomy = anatomy22.extendWith(
  "header",
  "body",
  "footer"
);
var radioGroupAnatomy = anatomy25.extendWith(
  "itemAddon",
  "itemIndicator"
);
var radioCardAnatomy = radioGroupAnatomy.extendWith(
  "itemContent",
  "itemDescription"
);
var ratingGroupAnatomy = anatomy26.extendWith("itemIndicator");
var selectAnatomy = anatomy27.extendWith("indicatorGroup");
var comboboxAnatomy = anatomy10.extendWith(
  "indicatorGroup",
  "empty"
);
var sliderAnatomy = anatomy29.extendWith("markerIndicator");
var statAnatomy = createAnatomy("stat").parts(
  "root",
  "label",
  "helpText",
  "valueText",
  "valueUnit",
  "indicator"
);
var statusAnatomy = createAnatomy("status").parts("root", "indicator");
var stepsAnatomy = createAnatomy("steps", [
  "root",
  "list",
  "item",
  "trigger",
  "indicator",
  "separator",
  "content",
  "title",
  "description",
  "nextTrigger",
  "prevTrigger",
  "progress"
]);
var switchAnatomy = anatomy32.extendWith("indicator");
var tableAnatomy = createAnatomy("table").parts(
  "root",
  "header",
  "body",
  "row",
  "columnHeader",
  "cell",
  "footer",
  "caption"
);
var toastAnatomy = createAnatomy("toast").parts(
  "root",
  "title",
  "description",
  "indicator",
  "closeTrigger",
  "actionTrigger"
);
var tabsAnatomy = createAnatomy("tabs").parts(
  "root",
  "trigger",
  "list",
  "content",
  "contentGroup",
  "indicator"
);
var tagAnatomy = createAnatomy("tag").parts(
  "root",
  "label",
  "closeTrigger",
  "startElement",
  "endElement"
);
var timelineAnatomy = createAnatomy("timeline").parts(
  "root",
  "item",
  "content",
  "separator",
  "indicator",
  "connector",
  "title",
  "description"
);
var colorPickerAnatomy2 = colorPickerAnatomy.extendWith("channelText");

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/accordion.js
var accordionSlotRecipe = defineSlotRecipe({
  className: "chakra-accordion",
  slots: accordionAnatomy.keys(),
  base: {
    root: {
      width: "full",
      "--accordion-radius": "radii.l2"
    },
    item: {
      overflowAnchor: "none"
    },
    itemTrigger: {
      display: "flex",
      alignItems: "center",
      textAlign: "start",
      width: "full",
      outline: "0",
      gap: "3",
      fontWeight: "medium",
      borderRadius: "var(--accordion-radius)",
      _focusVisible: {
        outline: "2px solid",
        outlineColor: "colorPalette.focusRing"
      },
      _disabled: {
        layerStyle: "disabled"
      }
    },
    itemBody: {
      pt: "var(--accordion-padding-y)",
      pb: "calc(var(--accordion-padding-y) * 2)"
    },
    itemContent: {
      overflow: "hidden",
      borderRadius: "var(--accordion-radius)",
      _open: {
        animationName: "expand-height, fade-in",
        animationDuration: "moderate"
      },
      _closed: {
        animationName: "collapse-height, fade-out",
        animationDuration: "moderate"
      }
    },
    itemIndicator: {
      transition: "rotate 0.2s",
      transformOrigin: "center",
      color: "fg.subtle",
      _open: {
        rotate: "180deg"
      },
      _icon: {
        width: "1.2em",
        height: "1.2em"
      }
    }
  },
  variants: {
    variant: {
      outline: {
        item: {
          borderBottomWidth: "1px"
        }
      },
      subtle: {
        itemTrigger: {
          px: "var(--accordion-padding-x)"
        },
        itemContent: {
          px: "var(--accordion-padding-x)"
        },
        item: {
          borderRadius: "var(--accordion-radius)",
          _open: {
            bg: "colorPalette.subtle"
          }
        }
      },
      enclosed: {
        root: {
          borderWidth: "1px",
          borderRadius: "var(--accordion-radius)",
          divideY: "1px",
          overflow: "hidden"
        },
        itemTrigger: {
          px: "var(--accordion-padding-x)"
        },
        itemContent: {
          px: "var(--accordion-padding-x)"
        },
        item: {
          _open: {
            bg: "bg.subtle"
          }
        }
      },
      plain: {}
    },
    size: {
      sm: {
        root: {
          "--accordion-padding-x": "spacing.3",
          "--accordion-padding-y": "spacing.2"
        },
        itemTrigger: {
          textStyle: "sm",
          py: "var(--accordion-padding-y)"
        }
      },
      md: {
        root: {
          "--accordion-padding-x": "spacing.4",
          "--accordion-padding-y": "spacing.2"
        },
        itemTrigger: {
          textStyle: "md",
          py: "var(--accordion-padding-y)"
        }
      },
      lg: {
        root: {
          "--accordion-padding-x": "spacing.4.5",
          "--accordion-padding-y": "spacing.2.5"
        },
        itemTrigger: {
          textStyle: "lg",
          py: "var(--accordion-padding-y)"
        }
      }
    }
  },
  defaultVariants: {
    size: "md",
    variant: "outline"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/action-bar.js
var actionBarSlotRecipe = defineSlotRecipe({
  className: "chakra-action-bar",
  slots: actionBarAnatomy.keys(),
  base: {
    positioner: {
      position: "fixed",
      display: "flex",
      justifyContent: "center",
      pointerEvents: "none",
      insetInline: "0",
      top: "unset",
      bottom: "calc(env(safe-area-inset-bottom) + 20px)"
    },
    content: {
      bg: "bg.panel",
      shadow: "md",
      display: "flex",
      alignItems: "center",
      gap: "3",
      borderRadius: "l3",
      py: "2.5",
      px: "3",
      pointerEvents: "auto",
      // Stabilize the position of the action bar when the scrollbar is hidden
      // by using the scrollbar width to offset the position.
      translate: "calc(-1 * var(--scrollbar-width) / 2) 0px",
      _open: {
        animationName: "slide-from-bottom, fade-in",
        animationDuration: "moderate"
      },
      _closed: {
        animationName: "slide-to-bottom, fade-out",
        animationDuration: "faster"
      }
    },
    separator: {
      width: "1px",
      height: "5",
      bg: "border"
    },
    selectionTrigger: {
      display: "inline-flex",
      alignItems: "center",
      gap: "2",
      alignSelf: "stretch",
      textStyle: "sm",
      px: "4",
      py: "1",
      borderRadius: "l2",
      borderWidth: "1px",
      borderStyle: "dashed"
    }
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/alert.js
var alertSlotRecipe = defineSlotRecipe({
  slots: alertAnatomy.keys(),
  className: "chakra-alert",
  base: {
    root: {
      width: "full",
      display: "flex",
      alignItems: "flex-start",
      position: "relative",
      borderRadius: "l3"
    },
    title: {
      fontWeight: "medium"
    },
    description: {
      display: "inline"
    },
    indicator: {
      display: "inline-flex",
      alignItems: "center",
      justifyContent: "center",
      flexShrink: "0",
      width: "1em",
      height: "1em",
      _icon: { boxSize: "full" }
    },
    content: {
      display: "flex",
      flex: "1",
      gap: "1"
    }
  },
  variants: {
    status: {
      info: {
        root: { colorPalette: "blue" }
      },
      warning: {
        root: { colorPalette: "orange" }
      },
      success: {
        root: { colorPalette: "green" }
      },
      error: {
        root: { colorPalette: "red" }
      },
      neutral: {
        root: { colorPalette: "gray" }
      }
    },
    inline: {
      true: {
        content: {
          display: "inline-flex",
          flexDirection: "row",
          alignItems: "center"
        }
      },
      false: {
        content: {
          display: "flex",
          flexDirection: "column"
        }
      }
    },
    variant: {
      subtle: {
        root: {
          bg: "colorPalette.subtle",
          color: "colorPalette.fg"
        }
      },
      surface: {
        root: {
          bg: "colorPalette.subtle",
          color: "colorPalette.fg",
          shadow: "inset 0 0 0px 1px var(--shadow-color)",
          shadowColor: "colorPalette.muted"
        },
        indicator: {
          color: "colorPalette.fg"
        }
      },
      outline: {
        root: {
          color: "colorPalette.fg",
          shadow: "inset 0 0 0px 1px var(--shadow-color)",
          shadowColor: "colorPalette.muted"
        },
        indicator: {
          color: "colorPalette.fg"
        }
      },
      solid: {
        root: {
          bg: "colorPalette.solid",
          color: "colorPalette.contrast"
        },
        indicator: {
          color: "colorPalette.contrast"
        }
      }
    },
    size: {
      sm: {
        root: {
          gap: "2",
          px: "3",
          py: "3",
          textStyle: "xs"
        },
        indicator: {
          textStyle: "lg"
        }
      },
      md: {
        root: {
          gap: "3",
          px: "4",
          py: "4",
          textStyle: "sm"
        },
        indicator: {
          textStyle: "xl"
        }
      },
      lg: {
        root: {
          gap: "3",
          px: "4",
          py: "4",
          textStyle: "md"
        },
        indicator: {
          textStyle: "2xl"
        }
      }
    }
  },
  defaultVariants: {
    status: "info",
    variant: "subtle",
    size: "md",
    inline: false
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/avatar.js
var avatarSlotRecipe = defineSlotRecipe({
  slots: anatomy6.keys(),
  className: "chakra-avatar",
  base: {
    root: {
      display: "inline-flex",
      alignItems: "center",
      justifyContent: "center",
      fontWeight: "medium",
      position: "relative",
      verticalAlign: "top",
      flexShrink: "0",
      userSelect: "none",
      width: "var(--avatar-size)",
      height: "var(--avatar-size)",
      fontSize: "var(--avatar-font-size)",
      borderRadius: "var(--avatar-radius)",
      "&[data-group-item]": {
        borderWidth: "2px",
        borderColor: "bg"
      }
    },
    image: {
      width: "100%",
      height: "100%",
      objectFit: "cover",
      borderRadius: "var(--avatar-radius)"
    },
    fallback: {
      lineHeight: "1",
      textTransform: "uppercase",
      fontWeight: "medium",
      fontSize: "var(--avatar-font-size)",
      borderRadius: "var(--avatar-radius)"
    }
  },
  variants: {
    size: {
      full: {
        root: {
          "--avatar-size": "100%",
          "--avatar-font-size": "100%"
        }
      },
      "2xs": {
        root: {
          "--avatar-font-size": "fontSizes.2xs",
          "--avatar-size": "sizes.6"
        }
      },
      xs: {
        root: {
          "--avatar-font-size": "fontSizes.xs",
          "--avatar-size": "sizes.8"
        }
      },
      sm: {
        root: {
          "--avatar-font-size": "fontSizes.sm",
          "--avatar-size": "sizes.9"
        }
      },
      md: {
        root: {
          "--avatar-font-size": "fontSizes.md",
          "--avatar-size": "sizes.10"
        }
      },
      lg: {
        root: {
          "--avatar-font-size": "fontSizes.md",
          "--avatar-size": "sizes.11"
        }
      },
      xl: {
        root: {
          "--avatar-font-size": "fontSizes.lg",
          "--avatar-size": "sizes.12"
        }
      },
      "2xl": {
        root: {
          "--avatar-font-size": "fontSizes.xl",
          "--avatar-size": "sizes.16"
        }
      }
    },
    variant: {
      solid: {
        root: {
          bg: "colorPalette.solid",
          color: "colorPalette.contrast"
        }
      },
      subtle: {
        root: {
          bg: "colorPalette.muted",
          color: "colorPalette.fg"
        }
      },
      outline: {
        root: {
          color: "colorPalette.fg",
          borderWidth: "1px",
          borderColor: "colorPalette.muted"
        }
      }
    },
    shape: {
      square: {},
      rounded: {
        root: { "--avatar-radius": "radii.l3" }
      },
      full: {
        root: { "--avatar-radius": "radii.full" }
      }
    },
    borderless: {
      true: {
        root: {
          "&[data-group-item]": {
            borderWidth: "0px"
          }
        }
      }
    }
  },
  defaultVariants: {
    size: "md",
    shape: "full",
    variant: "subtle"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/blockquote.js
var blockquoteSlotRecipe = defineSlotRecipe({
  className: "chakra-blockquote",
  slots: blockquoteAnatomy.keys(),
  base: {
    root: {
      position: "relative",
      display: "flex",
      flexDirection: "column",
      gap: "2"
    },
    caption: {
      textStyle: "sm",
      color: "fg.muted"
    },
    icon: {
      boxSize: "5"
    }
  },
  variants: {
    justify: {
      start: {
        root: {
          alignItems: "flex-start",
          textAlign: "start"
        }
      },
      center: {
        root: {
          alignItems: "center",
          textAlign: "center"
        }
      },
      end: {
        root: {
          alignItems: "flex-end",
          textAlign: "end"
        }
      }
    },
    variant: {
      subtle: {
        root: {
          paddingX: "5",
          borderStartWidth: "4px",
          borderStartColor: "colorPalette.muted"
        },
        icon: {
          color: "colorPalette.fg"
        }
      },
      solid: {
        root: {
          paddingX: "5",
          borderStartWidth: "4px",
          borderStartColor: "colorPalette.solid"
        },
        icon: {
          color: "colorPalette.solid"
        }
      },
      plain: {
        root: {
          paddingX: "5"
        },
        icon: {
          color: "colorPalette.solid"
        }
      }
    }
  },
  defaultVariants: {
    variant: "subtle",
    justify: "start"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/breadcrumb.js
var breadcrumbSlotRecipe = defineSlotRecipe({
  className: "chakra-breadcrumb",
  slots: breadcrumbAnatomy.keys(),
  base: {
    list: {
      display: "flex",
      alignItems: "center",
      wordBreak: "break-word",
      color: "fg.muted",
      listStyle: "none"
    },
    link: {
      outline: "0",
      textDecoration: "none",
      borderRadius: "l1",
      focusRing: "outside",
      display: "inline-flex",
      alignItems: "center",
      gap: "2"
    },
    item: {
      display: "inline-flex",
      alignItems: "center"
    },
    separator: {
      color: "fg.muted",
      opacity: "0.8",
      _icon: {
        boxSize: "1em"
      },
      _rtl: {
        rotate: "180deg"
      }
    },
    ellipsis: {
      display: "inline-flex",
      alignItems: "center",
      justifyContent: "center",
      _icon: {
        boxSize: "1em"
      }
    }
  },
  variants: {
    variant: {
      underline: {
        link: {
          color: "colorPalette.fg",
          textDecoration: "underline",
          textUnderlineOffset: "0.2em",
          textDecorationColor: "colorPalette.muted"
        },
        currentLink: {
          color: "colorPalette.fg"
        }
      },
      plain: {
        link: {
          color: "fg.muted",
          _hover: { color: "fg" }
        },
        currentLink: {
          color: "fg"
        }
      }
    },
    size: {
      sm: {
        list: {
          gap: "1",
          textStyle: "xs"
        }
      },
      md: {
        list: {
          gap: "1.5",
          textStyle: "sm"
        }
      },
      lg: {
        list: {
          gap: "2",
          textStyle: "md"
        }
      }
    }
  },
  defaultVariants: {
    variant: "plain",
    size: "md"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/card.js
var cardSlotRecipe = defineSlotRecipe({
  className: "chakra-card",
  slots: cardAnatomy.keys(),
  base: {
    root: {
      display: "flex",
      flexDirection: "column",
      position: "relative",
      minWidth: "0",
      wordWrap: "break-word",
      borderRadius: "l3",
      color: "fg",
      textAlign: "start"
    },
    title: {
      fontWeight: "semibold"
    },
    description: {
      color: "fg.muted",
      fontSize: "sm"
    },
    header: {
      paddingInline: "var(--card-padding)",
      paddingTop: "var(--card-padding)",
      display: "flex",
      flexDirection: "column",
      gap: "1.5"
    },
    body: {
      padding: "var(--card-padding)",
      flex: "1",
      display: "flex",
      flexDirection: "column"
    },
    footer: {
      display: "flex",
      alignItems: "center",
      gap: "2",
      paddingInline: "var(--card-padding)",
      paddingBottom: "var(--card-padding)"
    }
  },
  variants: {
    size: {
      sm: {
        root: {
          "--card-padding": "spacing.4"
        },
        title: {
          textStyle: "md"
        }
      },
      md: {
        root: {
          "--card-padding": "spacing.6"
        },
        title: {
          textStyle: "lg"
        }
      },
      lg: {
        root: {
          "--card-padding": "spacing.7"
        },
        title: {
          textStyle: "xl"
        }
      }
    },
    variant: {
      elevated: {
        root: {
          bg: "bg.panel",
          boxShadow: "md"
        }
      },
      outline: {
        root: {
          bg: "bg.panel",
          borderWidth: "1px",
          borderColor: "border"
        }
      },
      subtle: {
        root: {
          bg: "bg.muted"
        }
      }
    }
  },
  defaultVariants: {
    variant: "outline",
    size: "md"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/checkbox.js
var _a, _b, _c, _d, _e2, _f, _g, _h, _i, _j, _k, _l, _m, _n;
var checkboxSlotRecipe = defineSlotRecipe({
  slots: checkboxAnatomy.keys(),
  className: "chakra-checkbox",
  base: {
    root: {
      display: "inline-flex",
      gap: "2",
      alignItems: "center",
      verticalAlign: "top",
      position: "relative"
    },
    control: checkmarkRecipe.base,
    label: {
      fontWeight: "medium",
      userSelect: "none",
      _disabled: {
        opacity: "0.5"
      }
    }
  },
  variants: {
    size: {
      xs: {
        root: { gap: "1.5" },
        label: { textStyle: "xs" },
        control: (_b = (_a = checkmarkRecipe.variants) == null ? void 0 : _a.size) == null ? void 0 : _b.xs
      },
      sm: {
        root: { gap: "2" },
        label: { textStyle: "sm" },
        control: (_d = (_c = checkmarkRecipe.variants) == null ? void 0 : _c.size) == null ? void 0 : _d.sm
      },
      md: {
        root: { gap: "2.5" },
        label: { textStyle: "sm" },
        control: (_f = (_e2 = checkmarkRecipe.variants) == null ? void 0 : _e2.size) == null ? void 0 : _f.md
      },
      lg: {
        root: { gap: "3" },
        label: { textStyle: "md" },
        control: (_h = (_g = checkmarkRecipe.variants) == null ? void 0 : _g.size) == null ? void 0 : _h.lg
      }
    },
    variant: {
      outline: {
        control: (_j = (_i = checkmarkRecipe.variants) == null ? void 0 : _i.variant) == null ? void 0 : _j.outline
      },
      solid: {
        control: (_l = (_k = checkmarkRecipe.variants) == null ? void 0 : _k.variant) == null ? void 0 : _l.solid
      },
      subtle: {
        control: (_n = (_m = checkmarkRecipe.variants) == null ? void 0 : _m.variant) == null ? void 0 : _n.subtle
      }
    }
  },
  defaultVariants: {
    variant: "solid",
    size: "md"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/checkbox-card.js
var _a2, _b2, _c2, _d2, _e3, _f2, _g2;
var checkboxCardSlotRecipe = defineSlotRecipe({
  slots: checkboxCardAnatomy.keys(),
  className: "chakra-checkbox-card",
  base: {
    root: {
      display: "flex",
      flexDirection: "column",
      userSelect: "none",
      position: "relative",
      borderRadius: "l2",
      flex: "1",
      focusVisibleRing: "outside",
      _disabled: {
        opacity: "0.8"
      },
      _invalid: {
        outline: "2px solid",
        outlineColor: "border.error"
      }
    },
    control: {
      display: "inline-flex",
      flex: "1",
      position: "relative",
      borderRadius: "inherit",
      justifyContent: "var(--checkbox-card-justify)",
      alignItems: "var(--checkbox-card-align)"
    },
    label: {
      fontWeight: "medium",
      display: "flex",
      alignItems: "center",
      gap: "2",
      flex: "1",
      _disabled: {
        opacity: "0.5"
      }
    },
    description: {
      opacity: "0.64",
      textStyle: "sm",
      _disabled: {
        opacity: "0.5"
      }
    },
    addon: {
      _disabled: {
        opacity: "0.5"
      }
    },
    indicator: checkmarkRecipe.base,
    content: {
      display: "flex",
      flexDirection: "column",
      flex: "1",
      gap: "1",
      justifyContent: "var(--checkbox-card-justify)",
      alignItems: "var(--checkbox-card-align)"
    }
  },
  variants: {
    size: {
      sm: {
        root: {
          textStyle: "sm"
        },
        control: {
          padding: "3",
          gap: "1.5"
        },
        addon: {
          px: "3",
          py: "1.5",
          borderTopWidth: "1px"
        },
        indicator: (_a2 = checkmarkRecipe.variants) == null ? void 0 : _a2.size.sm
      },
      md: {
        root: {
          textStyle: "sm"
        },
        control: {
          padding: "4",
          gap: "2.5"
        },
        addon: {
          px: "4",
          py: "2",
          borderTopWidth: "1px"
        },
        indicator: (_b2 = checkmarkRecipe.variants) == null ? void 0 : _b2.size.md
      },
      lg: {
        root: {
          textStyle: "md"
        },
        control: {
          padding: "4",
          gap: "3.5"
        },
        addon: {
          px: "4",
          py: "2",
          borderTopWidth: "1px"
        },
        indicator: (_c2 = checkmarkRecipe.variants) == null ? void 0 : _c2.size.lg
      }
    },
    variant: {
      surface: {
        root: {
          borderWidth: "1px",
          borderColor: "border",
          _checked: {
            bg: "colorPalette.subtle",
            color: "colorPalette.fg",
            borderColor: "colorPalette.muted"
          },
          _disabled: {
            bg: "bg.muted"
          }
        },
        indicator: (_d2 = checkmarkRecipe.variants) == null ? void 0 : _d2.variant.solid
      },
      subtle: {
        root: {
          bg: "bg.muted"
        },
        control: {
          _checked: {
            bg: "colorPalette.muted",
            color: "colorPalette.fg"
          }
        },
        indicator: (_e3 = checkmarkRecipe.variants) == null ? void 0 : _e3.variant.plain
      },
      outline: {
        root: {
          borderWidth: "1px",
          borderColor: "border",
          _checked: {
            boxShadow: "0 0 0 1px var(--shadow-color)",
            boxShadowColor: "colorPalette.solid",
            borderColor: "colorPalette.solid"
          }
        },
        indicator: (_f2 = checkmarkRecipe.variants) == null ? void 0 : _f2.variant.solid
      },
      solid: {
        root: {
          borderWidth: "1px",
          _checked: {
            bg: "colorPalette.solid",
            color: "colorPalette.contrast",
            borderColor: "colorPalette.solid"
          }
        },
        indicator: (_g2 = checkmarkRecipe.variants) == null ? void 0 : _g2.variant.inverted
      }
    },
    justify: {
      start: {
        root: { "--checkbox-card-justify": "flex-start" }
      },
      end: {
        root: { "--checkbox-card-justify": "flex-end" }
      },
      center: {
        root: { "--checkbox-card-justify": "center" }
      }
    },
    align: {
      start: {
        root: { "--checkbox-card-align": "flex-start" },
        content: { textAlign: "start" }
      },
      end: {
        root: { "--checkbox-card-align": "flex-end" },
        content: { textAlign: "end" }
      },
      center: {
        root: { "--checkbox-card-align": "center" },
        content: { textAlign: "center" }
      }
    },
    orientation: {
      vertical: {
        control: { flexDirection: "column" }
      },
      horizontal: {
        control: { flexDirection: "row" }
      }
    }
  },
  defaultVariants: {
    size: "md",
    variant: "outline",
    align: "start",
    orientation: "horizontal"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/collapsible.js
var collapsibleSlotRecipe = defineSlotRecipe({
  slots: anatomy.keys(),
  className: "chakra-collapsible",
  base: {
    content: {
      overflow: "hidden",
      _open: {
        animationName: "expand-height, fade-in",
        animationDuration: "moderate"
      },
      _closed: {
        animationName: "collapse-height, fade-out",
        animationDuration: "moderate"
      }
    }
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/color-picker.js
var _a3, _b3, _c3, _d3, _e4, _f3, _g3, _h2, _i2, _j2, _k2, _l2, _m2, _n2, _o, _p, _q, _r;
var colorPickerSlotRecipe = defineSlotRecipe({
  className: "colorPicker",
  slots: colorPickerAnatomy2.keys(),
  base: {
    root: {
      display: "flex",
      flexDirection: "column",
      gap: "1.5"
    },
    label: {
      color: "fg",
      fontWeight: "medium",
      textStyle: "sm",
      _disabled: {
        opacity: "0.5"
      }
    },
    valueText: {
      textAlign: "start"
    },
    control: {
      display: "flex",
      alignItems: "center",
      flexDirection: "row",
      gap: "2",
      position: "relative"
    },
    swatchTrigger: {
      display: "flex",
      alignItems: "center",
      justifyContent: "center"
    },
    trigger: {
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      flexDirection: "row",
      flexShrink: "0",
      gap: "2",
      textStyle: "sm",
      minH: "var(--input-height)",
      minW: "var(--input-height)",
      px: "1",
      rounded: "l2",
      _disabled: { opacity: "0.5" },
      "--focus-color": "colors.colorPalette.focusRing",
      "&:focus-visible": {
        borderColor: "var(--focus-color)",
        outline: "1px solid var(--focus-color)"
      },
      "&[data-fit-content]": {
        "--input-height": "unset",
        px: "0",
        border: "0"
      }
    },
    content: {
      display: "flex",
      flexDirection: "column",
      bg: "bg.panel",
      borderRadius: "l3",
      boxShadow: "lg",
      width: "64",
      p: "4",
      gap: "3",
      zIndex: "dropdown",
      _open: {
        animationStyle: "slide-fade-in",
        animationDuration: "fast"
      },
      _closed: {
        animationStyle: "slide-fade-out",
        animationDuration: "faster"
      }
    },
    area: {
      height: "180px",
      borderRadius: "l2",
      overflow: "hidden"
    },
    areaThumb: {
      borderRadius: "full",
      height: "var(--thumb-size)",
      width: "var(--thumb-size)",
      borderWidth: "2px",
      borderColor: "white",
      shadow: "sm",
      focusVisibleRing: "mixed",
      focusRingColor: "white"
    },
    areaBackground: {
      height: "full"
    },
    channelSlider: {
      borderRadius: "l2",
      flex: "1"
    },
    channelSliderTrack: {
      height: "var(--slider-height)",
      borderRadius: "inherit",
      boxShadow: "inset 0 0 0 1px rgba(0,0,0,0.1)"
    },
    channelText: {
      textStyle: "xs",
      color: "fg.muted",
      fontWeight: "medium",
      textTransform: "capitalize"
    },
    swatchGroup: {
      display: "flex",
      flexDirection: "row",
      flexWrap: "wrap",
      gap: "2"
    },
    swatch: {
      ...colorSwatchRecipe.base,
      borderRadius: "l1"
    },
    swatchIndicator: {
      color: "white",
      rounded: "full"
    },
    channelSliderThumb: {
      borderRadius: "full",
      height: "var(--thumb-size)",
      width: "var(--thumb-size)",
      borderWidth: "2px",
      borderColor: "white",
      shadow: "sm",
      transform: "translate(-50%, -50%)",
      focusVisibleRing: "outside",
      focusRingOffset: "1px"
    },
    channelInput: {
      ...inputRecipe.base,
      "&::-webkit-inner-spin-button, &::-webkit-outer-spin-button": {
        WebkitAppearance: "none",
        margin: 0
      }
    },
    formatSelect: {
      textStyle: "xs",
      textTransform: "uppercase",
      borderWidth: "1px",
      minH: "6",
      focusRing: "inside",
      rounded: "l2"
    },
    transparencyGrid: {
      borderRadius: "l2"
    },
    view: {
      display: "flex",
      flexDirection: "column",
      gap: "2"
    }
  },
  variants: {
    size: {
      "2xs": {
        channelInput: (_b3 = (_a3 = inputRecipe.variants) == null ? void 0 : _a3.size) == null ? void 0 : _b3["2xs"],
        swatch: { "--swatch-size": "sizes.4.5" },
        trigger: { "--input-height": "sizes.7" },
        area: { "--thumb-size": "sizes.3" },
        channelSlider: {
          "--slider-height": "sizes.3",
          "--thumb-size": "sizes.3"
        }
      },
      xs: {
        channelInput: (_d3 = (_c3 = inputRecipe.variants) == null ? void 0 : _c3.size) == null ? void 0 : _d3.xs,
        swatch: { "--swatch-size": "sizes.5" },
        trigger: { "--input-height": "sizes.8" },
        area: { "--thumb-size": "sizes.3.5" },
        channelSlider: {
          "--slider-height": "sizes.3.5",
          "--thumb-size": "sizes.3.5"
        }
      },
      sm: {
        channelInput: (_f3 = (_e4 = inputRecipe.variants) == null ? void 0 : _e4.size) == null ? void 0 : _f3.sm,
        swatch: { "--swatch-size": "sizes.6" },
        trigger: { "--input-height": "sizes.9" },
        area: { "--thumb-size": "sizes.3.5" },
        channelSlider: {
          "--slider-height": "sizes.3.5",
          "--thumb-size": "sizes.3.5"
        }
      },
      md: {
        channelInput: (_h2 = (_g3 = inputRecipe.variants) == null ? void 0 : _g3.size) == null ? void 0 : _h2.md,
        swatch: { "--swatch-size": "sizes.7" },
        trigger: { "--input-height": "sizes.10" },
        area: { "--thumb-size": "sizes.3.5" },
        channelSlider: {
          "--slider-height": "sizes.3.5",
          "--thumb-size": "sizes.3.5"
        }
      },
      lg: {
        channelInput: (_j2 = (_i2 = inputRecipe.variants) == null ? void 0 : _i2.size) == null ? void 0 : _j2.lg,
        swatch: { "--swatch-size": "sizes.7" },
        trigger: { "--input-height": "sizes.11" },
        area: { "--thumb-size": "sizes.3.5" },
        channelSlider: {
          "--slider-height": "sizes.3.5",
          "--thumb-size": "sizes.3.5"
        }
      },
      xl: {
        channelInput: (_l2 = (_k2 = inputRecipe.variants) == null ? void 0 : _k2.size) == null ? void 0 : _l2.xl,
        swatch: { "--swatch-size": "sizes.8" },
        trigger: { "--input-height": "sizes.12" },
        area: { "--thumb-size": "sizes.3.5" },
        channelSlider: {
          "--slider-height": "sizes.3.5",
          "--thumb-size": "sizes.3.5"
        }
      },
      "2xl": {
        channelInput: (_n2 = (_m2 = inputRecipe.variants) == null ? void 0 : _m2.size) == null ? void 0 : _n2["2xl"],
        swatch: { "--swatch-size": "sizes.10" },
        trigger: { "--input-height": "sizes.16" },
        area: { "--thumb-size": "sizes.3.5" },
        channelSlider: {
          "--slider-height": "sizes.3.5",
          "--thumb-size": "sizes.3.5"
        }
      }
    },
    variant: {
      outline: {
        channelInput: (_p = (_o = inputRecipe.variants) == null ? void 0 : _o.variant) == null ? void 0 : _p.outline,
        trigger: {
          borderWidth: "1px"
        }
      },
      subtle: {
        channelInput: (_r = (_q = inputRecipe.variants) == null ? void 0 : _q.variant) == null ? void 0 : _r.subtle,
        trigger: {
          borderWidth: "1px",
          borderColor: "transparent",
          bg: "bg.muted"
        }
      }
    }
  },
  defaultVariants: {
    size: "md",
    variant: "outline"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/combobox.js
var comboboxSlotRecipe = defineSlotRecipe({
  className: "chakra-combobox",
  slots: comboboxAnatomy.keys(),
  base: {
    root: {
      display: "flex",
      flexDirection: "column",
      gap: "1.5",
      width: "full"
    },
    label: {
      fontWeight: "medium",
      userSelect: "none",
      textStyle: "sm",
      _disabled: {
        layerStyle: "disabled"
      }
    },
    input: {
      display: "flex",
      alignItems: "center",
      justifyContent: "space-between",
      background: "bg.panel",
      width: "full",
      minH: "var(--combobox-input-height)",
      px: "var(--combobox-input-padding-x)",
      "--input-height": "var(--combobox-input-height)",
      borderRadius: "l2",
      outline: 0,
      userSelect: "none",
      textAlign: "start",
      _placeholderShown: {
        color: "fg.muted"
      },
      _disabled: {
        layerStyle: "disabled"
      },
      "--focus-color": "colors.colorPalette.focusRing",
      "--error-color": "colors.border.error",
      _invalid: {
        focusRingColor: "var(--error-color)",
        borderColor: "var(--error-color)"
      }
    },
    trigger: {
      display: "inline-flex",
      alignItems: "center",
      justifyContent: "center",
      "--input-height": "var(--combobox-input-height)"
    },
    clearTrigger: {
      color: "fg.muted",
      pointerEvents: "auto",
      focusVisibleRing: "inside",
      focusRingWidth: "2px",
      rounded: "l1"
    },
    control: {
      pos: "relative"
    },
    indicatorGroup: {
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      gap: "1",
      pos: "absolute",
      insetEnd: "0",
      top: "0",
      bottom: "0",
      px: "var(--combobox-input-padding-x)",
      _icon: {
        boxSize: "var(--combobox-indicator-size)"
      },
      "[data-disabled] &": {
        opacity: 0.5
      }
    },
    content: {
      background: "bg.panel",
      display: "flex",
      flexDirection: "column",
      zIndex: "dropdown",
      borderRadius: "l2",
      outline: 0,
      maxH: "96",
      overflowY: "auto",
      boxShadow: "md",
      _open: {
        animationStyle: "slide-fade-in",
        animationDuration: "fast"
      },
      _closed: {
        animationStyle: "slide-fade-out",
        animationDuration: "0s"
      },
      "&[data-empty]:not(:has([data-scope=combobox][data-part=empty]))": {
        opacity: 0
      }
    },
    item: {
      position: "relative",
      userSelect: "none",
      display: "flex",
      alignItems: "center",
      gap: "2",
      py: "var(--combobox-item-padding-y)",
      px: "var(--combobox-item-padding-x)",
      cursor: "option",
      justifyContent: "space-between",
      flex: "1",
      textAlign: "start",
      borderRadius: "l1",
      _highlighted: {
        bg: "bg.emphasized/60"
      },
      _disabled: {
        pointerEvents: "none",
        opacity: "0.5"
      },
      _icon: {
        boxSize: "var(--combobox-indicator-size)"
      }
    },
    empty: {
      py: "var(--combobox-item-padding-y)",
      px: "var(--combobox-item-padding-x)"
    },
    itemText: {
      flex: "1"
    },
    itemGroup: {
      pb: "var(--combobox-item-padding-y)",
      _last: {
        pb: "0"
      }
    },
    itemGroupLabel: {
      fontWeight: "medium",
      py: "var(--combobox-item-padding-y)",
      px: "var(--combobox-item-padding-x)"
    }
  },
  variants: {
    variant: {
      outline: {
        input: {
          bg: "transparent",
          borderWidth: "1px",
          borderColor: "border",
          focusVisibleRing: "inside"
        }
      },
      subtle: {
        input: {
          borderWidth: "1px",
          borderColor: "transparent",
          bg: "bg.muted",
          focusVisibleRing: "inside"
        }
      },
      flushed: {
        input: {
          bg: "transparent",
          borderBottomWidth: "1px",
          borderBottomColor: "border",
          borderRadius: "0",
          px: "0",
          _focusVisible: {
            borderColor: "var(--focus-color)",
            boxShadow: "0px 1px 0px 0px var(--focus-color)"
          }
        },
        indicatorGroup: {
          px: "0"
        }
      }
    },
    size: {
      xs: {
        root: {
          "--combobox-input-height": "sizes.8",
          "--combobox-input-padding-x": "spacing.2",
          "--combobox-indicator-size": "sizes.3.5"
        },
        input: {
          textStyle: "xs"
        },
        content: {
          "--combobox-item-padding-x": "spacing.1.5",
          "--combobox-item-padding-y": "spacing.1",
          "--combobox-indicator-size": "sizes.3.5",
          p: "1",
          textStyle: "xs"
        },
        trigger: {
          textStyle: "xs",
          gap: "1"
        }
      },
      sm: {
        root: {
          "--combobox-input-height": "sizes.9",
          "--combobox-input-padding-x": "spacing.2.5",
          "--combobox-indicator-size": "sizes.4"
        },
        input: {
          textStyle: "sm"
        },
        content: {
          "--combobox-item-padding-x": "spacing.2",
          "--combobox-item-padding-y": "spacing.1.5",
          "--combobox-indicator-size": "sizes.4",
          p: "1",
          textStyle: "sm"
        },
        trigger: {
          textStyle: "sm",
          gap: "1"
        }
      },
      md: {
        root: {
          "--combobox-input-height": "sizes.10",
          "--combobox-input-padding-x": "spacing.3",
          "--combobox-indicator-size": "sizes.4"
        },
        input: {
          textStyle: "sm"
        },
        content: {
          "--combobox-item-padding-x": "spacing.2",
          "--combobox-item-padding-y": "spacing.1.5",
          "--combobox-indicator-size": "sizes.4",
          p: "1",
          textStyle: "sm"
        },
        itemIndicator: {
          display: "flex",
          alignItems: "center",
          justifyContent: "center"
        },
        trigger: {
          textStyle: "sm",
          gap: "2"
        }
      },
      lg: {
        root: {
          "--combobox-input-height": "sizes.12",
          "--combobox-input-padding-x": "spacing.4",
          "--combobox-indicator-size": "sizes.5"
        },
        input: {
          textStyle: "md"
        },
        content: {
          "--combobox-item-padding-y": "spacing.2",
          "--combobox-item-padding-x": "spacing.3",
          "--combobox-indicator-size": "sizes.5",
          p: "1.5",
          textStyle: "md"
        },
        trigger: {
          textStyle: "md",
          py: "3",
          gap: "2"
        }
      }
    }
  },
  defaultVariants: {
    size: "md",
    variant: "outline"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/data-list.js
var dataListSlotRecipe = defineSlotRecipe({
  slots: dataListAnatomy.keys(),
  className: "chakra-data-list",
  base: {
    itemLabel: {
      display: "flex",
      alignItems: "center",
      gap: "1"
    },
    itemValue: {
      display: "flex",
      minWidth: "0",
      flex: "1"
    }
  },
  variants: {
    orientation: {
      horizontal: {
        root: {
          display: "flex",
          flexDirection: "column"
        },
        item: {
          display: "inline-flex",
          alignItems: "center",
          gap: "4"
        },
        itemLabel: {
          minWidth: "120px"
        }
      },
      vertical: {
        root: {
          display: "flex",
          flexDirection: "column"
        },
        item: {
          display: "flex",
          flexDirection: "column",
          gap: "1"
        }
      }
    },
    size: {
      sm: {
        root: {
          gap: "3"
        },
        item: {
          textStyle: "xs"
        }
      },
      md: {
        root: {
          gap: "4"
        },
        item: {
          textStyle: "sm"
        }
      },
      lg: {
        root: {
          gap: "5"
        },
        item: {
          textStyle: "md"
        }
      }
    },
    variant: {
      subtle: {
        itemLabel: {
          color: "fg.muted"
        }
      },
      bold: {
        itemLabel: {
          fontWeight: "medium"
        },
        itemValue: {
          color: "fg.muted"
        }
      }
    }
  },
  defaultVariants: {
    size: "md",
    orientation: "vertical",
    variant: "subtle"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/dialog.js
var dialogSlotRecipe = defineSlotRecipe({
  slots: dialogAnatomy.keys(),
  className: "chakra-dialog",
  base: {
    backdrop: {
      bg: "blackAlpha.500",
      pos: "fixed",
      left: 0,
      top: 0,
      w: "100vw",
      h: "100dvh",
      zIndex: "overlay",
      _open: {
        animationName: "fade-in",
        animationDuration: "slow"
      },
      _closed: {
        animationName: "fade-out",
        animationDuration: "moderate"
      }
    },
    positioner: {
      display: "flex",
      width: "100vw",
      height: "100dvh",
      position: "fixed",
      left: 0,
      top: 0,
      "--dialog-z-index": "zIndex.modal",
      zIndex: "calc(var(--dialog-z-index) + var(--layer-index, 0))",
      justifyContent: "center",
      overscrollBehaviorY: "none"
    },
    content: {
      display: "flex",
      flexDirection: "column",
      position: "relative",
      width: "100%",
      outline: 0,
      borderRadius: "l3",
      textStyle: "sm",
      my: "var(--dialog-margin, var(--dialog-base-margin))",
      "--dialog-z-index": "zIndex.modal",
      zIndex: "calc(var(--dialog-z-index) + var(--layer-index, 0))",
      bg: "bg.panel",
      boxShadow: "lg",
      _open: {
        animationDuration: "moderate"
      },
      _closed: {
        animationDuration: "faster"
      }
    },
    header: {
      display: "flex",
      gap: "2",
      flex: 0,
      px: "6",
      pt: "6",
      pb: "4"
    },
    body: {
      flex: "1",
      px: "6",
      pt: "2",
      pb: "6"
    },
    footer: {
      display: "flex",
      alignItems: "center",
      justifyContent: "flex-end",
      gap: "3",
      px: "6",
      pt: "2",
      pb: "4"
    },
    title: {
      textStyle: "lg",
      fontWeight: "semibold"
    },
    description: {
      color: "fg.muted"
    },
    closeTrigger: {
      pos: "absolute",
      top: "2",
      insetEnd: "2"
    }
  },
  variants: {
    placement: {
      center: {
        positioner: {
          alignItems: "center"
        },
        content: {
          "--dialog-base-margin": "auto",
          mx: "auto"
        }
      },
      top: {
        positioner: {
          alignItems: "flex-start"
        },
        content: {
          "--dialog-base-margin": "spacing.16",
          mx: "auto"
        }
      },
      bottom: {
        positioner: {
          alignItems: "flex-end"
        },
        content: {
          "--dialog-base-margin": "spacing.16",
          mx: "auto"
        }
      }
    },
    scrollBehavior: {
      inside: {
        positioner: {
          overflow: "hidden"
        },
        content: {
          maxH: "calc(100% - 7.5rem)"
        },
        body: {
          overflow: "auto"
        }
      },
      outside: {
        positioner: {
          overflow: "auto",
          pointerEvents: "auto"
        }
      }
    },
    size: {
      xs: {
        content: {
          maxW: "sm"
        }
      },
      sm: {
        content: {
          maxW: "md"
        }
      },
      md: {
        content: {
          maxW: "lg"
        }
      },
      lg: {
        content: {
          maxW: "2xl"
        }
      },
      xl: {
        content: {
          maxW: "4xl"
        }
      },
      cover: {
        positioner: {
          padding: "10"
        },
        content: {
          width: "100%",
          height: "100%",
          "--dialog-margin": "0"
        }
      },
      full: {
        content: {
          maxW: "100vw",
          minH: "100vh",
          "--dialog-margin": "0",
          borderRadius: "0"
        }
      }
    },
    motionPreset: {
      scale: {
        content: {
          _open: { animationName: "scale-in, fade-in" },
          _closed: { animationName: "scale-out, fade-out" }
        }
      },
      "slide-in-bottom": {
        content: {
          _open: { animationName: "slide-from-bottom, fade-in" },
          _closed: { animationName: "slide-to-bottom, fade-out" }
        }
      },
      "slide-in-top": {
        content: {
          _open: { animationName: "slide-from-top, fade-in" },
          _closed: { animationName: "slide-to-top, fade-out" }
        }
      },
      "slide-in-left": {
        content: {
          _open: { animationName: "slide-from-left, fade-in" },
          _closed: { animationName: "slide-to-left, fade-out" }
        }
      },
      "slide-in-right": {
        content: {
          _open: { animationName: "slide-from-right, fade-in" },
          _closed: { animationName: "slide-to-right, fade-out" }
        }
      },
      none: {}
    }
  },
  defaultVariants: {
    size: "md",
    scrollBehavior: "outside",
    placement: "top",
    motionPreset: "scale"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/drawer.js
var drawerSlotRecipe = defineSlotRecipe({
  slots: drawerAnatomy.keys(),
  className: "chakra-drawer",
  base: {
    backdrop: {
      bg: "blackAlpha.500",
      pos: "fixed",
      insetInlineStart: 0,
      top: 0,
      w: "100vw",
      h: "100dvh",
      zIndex: "overlay",
      _open: {
        animationName: "fade-in",
        animationDuration: "slow"
      },
      _closed: {
        animationName: "fade-out",
        animationDuration: "moderate"
      }
    },
    positioner: {
      display: "flex",
      width: "100vw",
      height: "100dvh",
      position: "fixed",
      insetInlineStart: 0,
      top: 0,
      zIndex: "modal",
      overscrollBehaviorY: "none"
    },
    content: {
      display: "flex",
      flexDirection: "column",
      position: "relative",
      width: "100%",
      outline: 0,
      zIndex: "modal",
      textStyle: "sm",
      maxH: "100dvh",
      color: "inherit",
      bg: "bg.panel",
      boxShadow: "lg",
      _open: {
        animationDuration: "slowest",
        animationTimingFunction: "ease-in-smooth"
      },
      _closed: {
        animationDuration: "slower",
        animationTimingFunction: "ease-in-smooth"
      }
    },
    header: {
      display: "flex",
      alignItems: "center",
      gap: "2",
      flex: 0,
      px: "6",
      pt: "6",
      pb: "4"
    },
    body: {
      px: "6",
      py: "2",
      flex: "1",
      overflow: "auto"
    },
    footer: {
      display: "flex",
      alignItems: "center",
      justifyContent: "flex-end",
      gap: "3",
      px: "6",
      pt: "2",
      pb: "4"
    },
    title: {
      flex: "1",
      textStyle: "lg",
      fontWeight: "semibold"
    },
    description: {
      color: "fg.muted"
    },
    closeTrigger: {
      pos: "absolute",
      top: "3",
      insetEnd: "2"
    }
  },
  variants: {
    size: {
      xs: {
        content: {
          maxW: "xs"
        }
      },
      sm: {
        content: {
          maxW: "md"
        }
      },
      md: {
        content: {
          maxW: "lg"
        }
      },
      lg: {
        content: {
          maxW: "2xl"
        }
      },
      xl: {
        content: {
          maxW: "4xl"
        }
      },
      full: {
        content: {
          maxW: "100vw",
          h: "100dvh"
        }
      }
    },
    placement: {
      start: {
        positioner: {
          justifyContent: "flex-start"
        },
        content: {
          _open: {
            animationName: {
              base: "slide-from-left-full, fade-in",
              _rtl: "slide-from-right-full, fade-in"
            }
          },
          _closed: {
            animationName: {
              base: "slide-to-left-full, fade-out",
              _rtl: "slide-to-right-full, fade-out"
            }
          }
        }
      },
      end: {
        positioner: {
          justifyContent: "flex-end"
        },
        content: {
          _open: {
            animationName: {
              base: "slide-from-right-full, fade-in",
              _rtl: "slide-from-left-full, fade-in"
            }
          },
          _closed: {
            animationName: {
              base: "slide-to-right-full, fade-out",
              _rtl: "slide-to-left-full, fade-out"
            }
          }
        }
      },
      top: {
        positioner: {
          alignItems: "flex-start"
        },
        content: {
          maxW: "100%",
          _open: { animationName: "slide-from-top-full, fade-in" },
          _closed: { animationName: "slide-to-top-full, fade-out" }
        }
      },
      bottom: {
        positioner: {
          alignItems: "flex-end"
        },
        content: {
          maxW: "100%",
          _open: { animationName: "slide-from-bottom-full, fade-in" },
          _closed: { animationName: "slide-to-bottom-full, fade-out" }
        }
      }
    },
    contained: {
      true: {
        positioner: {
          padding: "4"
        },
        content: {
          borderRadius: "l3"
        }
      }
    }
  },
  defaultVariants: {
    size: "xs",
    placement: "end"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/editable.js
var sharedStyles = defineStyle({
  fontSize: "inherit",
  fontWeight: "inherit",
  textAlign: "inherit",
  bg: "transparent",
  borderRadius: "l2"
});
var editableSlotRecipe = defineSlotRecipe({
  slots: editableAnatomy.keys(),
  className: "chakra-editable",
  base: {
    root: {
      display: "inline-flex",
      alignItems: "center",
      position: "relative",
      gap: "1.5",
      width: "full"
    },
    preview: {
      ...sharedStyles,
      py: "1",
      px: "1",
      display: "inline-flex",
      alignItems: "center",
      transitionProperty: "common",
      transitionDuration: "normal",
      cursor: "text",
      _hover: {
        bg: "bg.muted"
      },
      _disabled: {
        userSelect: "none"
      }
    },
    input: {
      ...sharedStyles,
      outline: "0",
      py: "1",
      px: "1",
      transitionProperty: "common",
      transitionDuration: "normal",
      width: "full",
      focusVisibleRing: "inside",
      focusRingWidth: "2px",
      _placeholder: { opacity: 0.6 }
    },
    control: {
      display: "inline-flex",
      alignItems: "center",
      gap: "1.5"
    }
  },
  variants: {
    size: {
      sm: {
        root: {
          textStyle: "sm"
        },
        preview: { minH: "8" },
        input: { minH: "8" }
      },
      md: {
        root: {
          textStyle: "sm"
        },
        preview: { minH: "9" },
        input: { minH: "9" }
      },
      lg: {
        root: {
          textStyle: "md"
        },
        preview: { minH: "10" },
        input: { minH: "10" }
      }
    }
  },
  defaultVariants: {
    size: "md"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/empty-state.js
var emptyStateSlotRecipe = defineSlotRecipe({
  slots: emptyStateAnatomy.keys(),
  className: "chakra-empty-state",
  base: {
    root: {
      width: "full"
    },
    content: {
      display: "flex",
      flexDirection: "column",
      alignItems: "center",
      justifyContent: "center"
    },
    indicator: {
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      color: "fg.subtle",
      _icon: {
        boxSize: "1em"
      }
    },
    title: {
      fontWeight: "semibold"
    },
    description: {
      textStyle: "sm",
      color: "fg.muted"
    }
  },
  variants: {
    size: {
      sm: {
        root: {
          px: "4",
          py: "6"
        },
        title: {
          textStyle: "md"
        },
        content: {
          gap: "4"
        },
        indicator: {
          textStyle: "2xl"
        }
      },
      md: {
        root: {
          px: "8",
          py: "12"
        },
        title: {
          textStyle: "lg"
        },
        content: {
          gap: "6"
        },
        indicator: {
          textStyle: "4xl"
        }
      },
      lg: {
        root: {
          px: "12",
          py: "16"
        },
        title: {
          textStyle: "xl"
        },
        content: {
          gap: "8"
        },
        indicator: {
          textStyle: "6xl"
        }
      }
    }
  },
  defaultVariants: {
    size: "md"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/field.js
var fieldSlotRecipe = defineSlotRecipe({
  className: "chakra-field",
  slots: fieldAnatomy2.keys(),
  base: {
    requiredIndicator: {
      color: "fg.error",
      lineHeight: "1"
    },
    root: {
      display: "flex",
      width: "100%",
      position: "relative",
      gap: "1.5"
    },
    label: {
      display: "flex",
      alignItems: "center",
      textAlign: "start",
      textStyle: "sm",
      fontWeight: "medium",
      gap: "1",
      userSelect: "none",
      _disabled: {
        opacity: "0.5"
      }
    },
    errorText: {
      display: "inline-flex",
      alignItems: "center",
      fontWeight: "medium",
      gap: "1",
      color: "fg.error",
      textStyle: "xs"
    },
    helperText: {
      color: "fg.muted",
      textStyle: "xs"
    }
  },
  variants: {
    orientation: {
      vertical: {
        root: {
          flexDirection: "column",
          alignItems: "flex-start"
        }
      },
      horizontal: {
        root: {
          flexDirection: "row",
          alignItems: "center",
          justifyContent: "space-between"
        },
        label: {
          flex: "0 0 var(--field-label-width, 80px)"
        }
      }
    }
  },
  defaultVariants: {
    orientation: "vertical"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/fieldset.js
var fieldsetSlotRecipe = defineSlotRecipe({
  className: "fieldset",
  slots: fieldsetAnatomy2.keys(),
  base: {
    root: {
      display: "flex",
      flexDirection: "column",
      width: "full"
    },
    content: {
      display: "flex",
      flexDirection: "column",
      width: "full"
    },
    legend: {
      color: "fg",
      fontWeight: "medium",
      _disabled: {
        opacity: "0.5"
      }
    },
    helperText: {
      color: "fg.muted",
      textStyle: "sm"
    },
    errorText: {
      display: "inline-flex",
      alignItems: "center",
      color: "fg.error",
      gap: "2",
      fontWeight: "medium",
      textStyle: "sm"
    }
  },
  variants: {
    size: {
      sm: {
        root: { spaceY: "2" },
        content: { gap: "1.5" },
        legend: { textStyle: "sm" }
      },
      md: {
        root: { spaceY: "4" },
        content: { gap: "4" },
        legend: { textStyle: "sm" }
      },
      lg: {
        root: { spaceY: "6" },
        content: { gap: "4" },
        legend: { textStyle: "md" }
      }
    }
  },
  defaultVariants: {
    size: "md"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/file-upload.js
var fileUploadSlotRecipe = defineSlotRecipe({
  className: "chakra-file-upload",
  slots: fileUploadAnatomy.keys(),
  base: {
    root: {
      display: "flex",
      flexDirection: "column",
      gap: "4",
      width: "100%",
      alignItems: "flex-start"
    },
    label: {
      fontWeight: "medium",
      textStyle: "sm"
    },
    dropzone: {
      background: "bg",
      borderRadius: "l3",
      borderWidth: "2px",
      borderStyle: "dashed",
      display: "flex",
      alignItems: "center",
      flexDirection: "column",
      gap: "4",
      justifyContent: "center",
      minHeight: "2xs",
      px: "3",
      py: "2",
      transition: "backgrounds",
      focusVisibleRing: "outside",
      _hover: {
        bg: "bg.subtle"
      },
      _dragging: {
        bg: "colorPalette.subtle",
        borderStyle: "solid",
        borderColor: "colorPalette.solid"
      }
    },
    dropzoneContent: {
      display: "flex",
      flexDirection: "column",
      alignItems: "center",
      textAlign: "center",
      gap: "1",
      textStyle: "sm"
    },
    item: {
      pos: "relative",
      textStyle: "sm",
      animationName: "fade-in",
      animationDuration: "moderate",
      background: "bg",
      borderRadius: "l2",
      borderWidth: "1px",
      width: "100%",
      display: "flex",
      alignItems: "center",
      gap: "3",
      p: "4"
    },
    itemGroup: {
      width: "100%",
      display: "flex",
      flexDirection: "column",
      gap: "3",
      _empty: {
        display: "none"
      }
    },
    itemName: {
      color: "fg",
      fontWeight: "medium",
      lineClamp: "1"
    },
    itemContent: {
      display: "flex",
      flexDirection: "column",
      gap: "0.5",
      flex: "1"
    },
    itemSizeText: {
      color: "fg.muted",
      textStyle: "xs"
    },
    itemDeleteTrigger: {
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      alignSelf: "flex-start",
      boxSize: "5",
      p: "2px",
      color: "fg.muted",
      cursor: "button"
    },
    itemPreview: {
      color: "fg.muted",
      _icon: {
        boxSize: "4.5"
      }
    }
  },
  defaultVariants: {}
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/hover-card.js
var hoverCardSlotRecipe = defineSlotRecipe({
  className: "chakra-hover-card",
  slots: anatomy15.keys(),
  base: {
    content: {
      position: "relative",
      display: "flex",
      flexDirection: "column",
      textStyle: "sm",
      "--hovercard-bg": "colors.bg.panel",
      bg: "var(--hovercard-bg)",
      boxShadow: "lg",
      maxWidth: "80",
      borderRadius: "l3",
      zIndex: "popover",
      transformOrigin: "var(--transform-origin)",
      outline: "0",
      _open: {
        animationStyle: "slide-fade-in",
        animationDuration: "fast"
      },
      _closed: {
        animationStyle: "slide-fade-out",
        animationDuration: "faster"
      }
    },
    arrow: {
      "--arrow-size": "sizes.3",
      "--arrow-background": "var(--hovercard-bg)"
    },
    arrowTip: {
      borderTopWidth: "0.5px",
      borderInlineStartWidth: "0.5px"
    }
  },
  variants: {
    size: {
      xs: {
        content: {
          padding: "3"
        }
      },
      sm: {
        content: {
          padding: "4"
        }
      },
      md: {
        content: {
          padding: "5"
        }
      },
      lg: {
        content: {
          padding: "6"
        }
      }
    }
  },
  defaultVariants: {
    size: "md"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/list.js
var listSlotRecipe = defineSlotRecipe({
  className: "chakra-list",
  slots: listAnatomy.keys(),
  base: {
    root: {
      display: "flex",
      flexDirection: "column",
      gap: "var(--list-gap)",
      "& :where(ul, ol)": {
        marginTop: "var(--list-gap)"
      }
    },
    item: {
      whiteSpace: "normal",
      display: "list-item"
    },
    indicator: {
      marginEnd: "2",
      minHeight: "1lh",
      flexShrink: 0,
      display: "inline-block",
      verticalAlign: "middle"
    }
  },
  variants: {
    variant: {
      marker: {
        root: {
          listStyle: "revert"
        },
        item: {
          _marker: {
            color: "fg.subtle"
          }
        }
      },
      plain: {
        item: {
          alignItems: "flex-start",
          display: "inline-flex"
        }
      }
    },
    align: {
      center: {
        item: { alignItems: "center" }
      },
      start: {
        item: { alignItems: "flex-start" }
      },
      end: {
        item: { alignItems: "flex-end" }
      }
    }
  },
  defaultVariants: {
    variant: "marker"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/menu.js
var menuSlotRecipe = defineSlotRecipe({
  className: "chakra-menu",
  slots: menuAnatomy.keys(),
  base: {
    content: {
      outline: 0,
      bg: "bg.panel",
      boxShadow: "lg",
      color: "fg",
      maxHeight: "var(--available-height)",
      "--menu-z-index": "zIndex.dropdown",
      zIndex: "calc(var(--menu-z-index) + var(--layer-index, 0))",
      borderRadius: "l2",
      overflow: "hidden",
      overflowY: "auto",
      _open: {
        animationStyle: "slide-fade-in",
        animationDuration: "fast"
      },
      _closed: {
        animationStyle: "slide-fade-out",
        animationDuration: "faster"
      }
    },
    item: {
      textDecoration: "none",
      color: "fg",
      userSelect: "none",
      borderRadius: "l1",
      width: "100%",
      display: "flex",
      cursor: "menuitem",
      alignItems: "center",
      textAlign: "start",
      position: "relative",
      flex: "0 0 auto",
      outline: 0,
      _disabled: {
        layerStyle: "disabled"
      },
      "&[data-type]": {
        ps: "8"
      }
    },
    itemText: {
      flex: "1"
    },
    itemIndicator: {
      position: "absolute",
      insetStart: "2",
      transform: "translateY(-50%)",
      top: "50%"
    },
    itemGroupLabel: {
      px: "2",
      py: "1.5",
      fontWeight: "semibold",
      textStyle: "sm"
    },
    indicator: {
      display: "inline-flex",
      alignItems: "center",
      justifyContent: "center",
      flexShrink: "0"
    },
    itemCommand: {
      opacity: "0.6",
      textStyle: "xs",
      ms: "auto",
      ps: "4",
      letterSpacing: "widest",
      fontFamily: "inherit"
    },
    separator: {
      height: "1px",
      bg: "bg.muted",
      my: "1",
      mx: "-1"
    }
  },
  variants: {
    variant: {
      subtle: {
        item: {
          _highlighted: {
            bg: "bg.emphasized/60"
          }
        }
      },
      solid: {
        item: {
          _highlighted: {
            bg: "colorPalette.solid",
            color: "colorPalette.contrast"
          }
        }
      }
    },
    size: {
      sm: {
        content: {
          minW: "8rem",
          padding: "1"
        },
        item: {
          gap: "1",
          textStyle: "xs",
          py: "1",
          px: "1.5"
        }
      },
      md: {
        content: {
          minW: "8rem",
          padding: "1.5"
        },
        item: {
          gap: "2",
          textStyle: "sm",
          py: "1.5",
          px: "2"
        }
      }
    }
  },
  defaultVariants: {
    size: "md",
    variant: "subtle"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/select.js
var selectSlotRecipe = defineSlotRecipe({
  className: "chakra-select",
  slots: selectAnatomy.keys(),
  base: {
    root: {
      display: "flex",
      flexDirection: "column",
      gap: "1.5",
      width: "full"
    },
    trigger: {
      display: "flex",
      alignItems: "center",
      justifyContent: "space-between",
      width: "full",
      minH: "var(--select-trigger-height)",
      "--input-height": "var(--select-trigger-height)",
      px: "var(--select-trigger-padding-x)",
      borderRadius: "l2",
      userSelect: "none",
      textAlign: "start",
      focusVisibleRing: "inside",
      _placeholderShown: {
        color: "fg.muted/80"
      },
      _disabled: {
        layerStyle: "disabled"
      },
      _invalid: {
        borderColor: "border.error"
      }
    },
    indicatorGroup: {
      display: "flex",
      alignItems: "center",
      gap: "1",
      pos: "absolute",
      insetEnd: "0",
      top: "0",
      bottom: "0",
      px: "var(--select-trigger-padding-x)",
      pointerEvents: "none"
    },
    indicator: {
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      color: { base: "fg.muted", _disabled: "fg.subtle", _invalid: "fg.error" }
    },
    content: {
      background: "bg.panel",
      display: "flex",
      flexDirection: "column",
      zIndex: "dropdown",
      borderRadius: "l2",
      outline: 0,
      maxH: "96",
      overflowY: "auto",
      boxShadow: "md",
      _open: {
        animationStyle: "slide-fade-in",
        animationDuration: "fast"
      },
      _closed: {
        animationStyle: "slide-fade-out",
        animationDuration: "fastest"
      }
    },
    item: {
      position: "relative",
      userSelect: "none",
      display: "flex",
      alignItems: "center",
      gap: "2",
      cursor: "option",
      justifyContent: "space-between",
      flex: "1",
      textAlign: "start",
      borderRadius: "l1",
      _highlighted: {
        bg: "bg.emphasized/60"
      },
      _disabled: {
        pointerEvents: "none",
        opacity: "0.5"
      },
      _icon: {
        width: "4",
        height: "4"
      }
    },
    control: {
      pos: "relative"
    },
    itemText: {
      flex: "1"
    },
    itemGroup: {
      _first: { mt: "0" }
    },
    itemGroupLabel: {
      py: "1",
      fontWeight: "medium"
    },
    label: {
      fontWeight: "medium",
      userSelect: "none",
      textStyle: "sm",
      _disabled: {
        layerStyle: "disabled"
      }
    },
    valueText: {
      lineClamp: "1",
      maxW: "80%"
    },
    clearTrigger: {
      color: "fg.muted",
      pointerEvents: "auto",
      focusVisibleRing: "inside",
      focusRingWidth: "2px",
      rounded: "l1"
    }
  },
  variants: {
    variant: {
      outline: {
        trigger: {
          bg: "transparent",
          borderWidth: "1px",
          borderColor: "border",
          _expanded: {
            borderColor: "border.emphasized"
          }
        }
      },
      subtle: {
        trigger: {
          borderWidth: "1px",
          borderColor: "transparent",
          bg: "bg.muted"
        }
      }
    },
    size: {
      xs: {
        root: {
          "--select-trigger-height": "sizes.8",
          "--select-trigger-padding-x": "spacing.2"
        },
        content: {
          p: "1",
          gap: "1",
          textStyle: "xs"
        },
        trigger: {
          textStyle: "xs",
          gap: "1"
        },
        item: {
          py: "1",
          px: "2"
        },
        itemGroupLabel: {
          py: "1",
          px: "2"
        },
        indicator: {
          _icon: {
            width: "3.5",
            height: "3.5"
          }
        }
      },
      sm: {
        root: {
          "--select-trigger-height": "sizes.9",
          "--select-trigger-padding-x": "spacing.2.5"
        },
        content: {
          p: "1",
          textStyle: "sm"
        },
        trigger: {
          textStyle: "sm",
          gap: "1"
        },
        indicator: {
          _icon: {
            width: "4",
            height: "4"
          }
        },
        item: {
          py: "1",
          px: "1.5"
        },
        itemGroup: {
          mt: "1"
        },
        itemGroupLabel: {
          py: "1",
          px: "1.5"
        }
      },
      md: {
        root: {
          "--select-trigger-height": "sizes.10",
          "--select-trigger-padding-x": "spacing.3"
        },
        content: {
          p: "1",
          textStyle: "sm"
        },
        itemGroup: {
          mt: "1.5"
        },
        item: {
          py: "1.5",
          px: "2"
        },
        itemIndicator: {
          display: "flex",
          alignItems: "center",
          justifyContent: "center"
        },
        itemGroupLabel: {
          py: "1.5",
          px: "2"
        },
        trigger: {
          textStyle: "sm",
          gap: "2"
        },
        indicator: {
          _icon: {
            width: "4",
            height: "4"
          }
        }
      },
      lg: {
        root: {
          "--select-trigger-height": "sizes.12",
          "--select-trigger-padding-x": "spacing.4"
        },
        content: {
          p: "1.5",
          textStyle: "md"
        },
        itemGroup: {
          mt: "2"
        },
        item: {
          py: "2",
          px: "3"
        },
        itemGroupLabel: {
          py: "2",
          px: "3"
        },
        trigger: {
          textStyle: "md",
          py: "3",
          gap: "2"
        },
        indicator: {
          _icon: {
            width: "5",
            height: "5"
          }
        }
      }
    }
  },
  defaultVariants: {
    size: "md",
    variant: "outline"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/native-select.js
var _a4, _b4;
var nativeSelectSlotRecipe = defineSlotRecipe({
  className: "chakra-native-select",
  slots: nativeSelectAnatomy.keys(),
  base: {
    root: {
      height: "fit-content",
      display: "flex",
      width: "100%",
      position: "relative"
    },
    field: {
      width: "100%",
      minWidth: "0",
      outline: "0",
      appearance: "none",
      borderRadius: "l2",
      "--error-color": "colors.border.error",
      _disabled: {
        layerStyle: "disabled"
      },
      _invalid: {
        focusRingColor: "var(--error-color)",
        borderColor: "var(--error-color)"
      },
      focusVisibleRing: "inside",
      lineHeight: "normal",
      "& > option, & > optgroup": {
        bg: "bg"
      }
    },
    indicator: {
      position: "absolute",
      display: "inline-flex",
      alignItems: "center",
      justifyContent: "center",
      pointerEvents: "none",
      top: "50%",
      transform: "translateY(-50%)",
      height: "100%",
      color: "fg.muted",
      _disabled: {
        opacity: "0.5"
      },
      _invalid: {
        color: "fg.error"
      },
      _icon: {
        width: "1em",
        height: "1em"
      }
    }
  },
  variants: {
    variant: {
      outline: {
        field: (_a4 = selectSlotRecipe.variants) == null ? void 0 : _a4.variant.outline.trigger
      },
      subtle: {
        field: (_b4 = selectSlotRecipe.variants) == null ? void 0 : _b4.variant.subtle.trigger
      },
      plain: {
        field: {
          bg: "transparent",
          color: "fg",
          focusRingWidth: "2px"
        }
      }
    },
    size: {
      xs: {
        field: {
          textStyle: "xs",
          ps: "2",
          pe: "6",
          height: "6"
        },
        indicator: {
          textStyle: "sm",
          insetEnd: "1.5"
        }
      },
      sm: {
        field: {
          textStyle: "sm",
          ps: "2.5",
          pe: "8",
          height: "8"
        },
        indicator: {
          textStyle: "md",
          insetEnd: "2"
        }
      },
      md: {
        field: {
          textStyle: "sm",
          ps: "3",
          pe: "8",
          height: "10"
        },
        indicator: {
          textStyle: "lg",
          insetEnd: "2"
        }
      },
      lg: {
        field: {
          textStyle: "md",
          ps: "4",
          pe: "8",
          height: "11"
        },
        indicator: {
          textStyle: "xl",
          insetEnd: "3"
        }
      },
      xl: {
        field: {
          textStyle: "md",
          ps: "4.5",
          pe: "10",
          height: "12"
        },
        indicator: {
          textStyle: "xl",
          insetEnd: "3"
        }
      }
    }
  },
  defaultVariants: selectSlotRecipe.defaultVariants
});

// node_modules/@chakra-ui/react/dist/esm/utils/entries.js
function mapEntries2(obj, f) {
  const result = {};
  for (const key in obj) {
    const kv = f(key, obj[key]);
    result[kv[0]] = kv[1];
  }
  return result;
}

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/number-input.js
var triggerStyle = defineStyle({
  display: "flex",
  justifyContent: "center",
  alignItems: "center",
  flex: "1",
  userSelect: "none",
  cursor: "button",
  lineHeight: "1",
  color: "fg.muted",
  "--stepper-base-radius": "radii.l1",
  "--stepper-radius": "calc(var(--stepper-base-radius) + 1px)",
  _icon: {
    boxSize: "1em"
  },
  _disabled: {
    opacity: "0.5"
  },
  _hover: {
    bg: "bg.muted"
  },
  _active: {
    bg: "bg.emphasized"
  }
});
var numberInputSlotRecipe = defineSlotRecipe({
  className: "chakra-number-input",
  slots: anatomy18.keys(),
  base: {
    root: {
      position: "relative",
      zIndex: "0",
      isolation: "isolate"
    },
    input: {
      ...inputRecipe.base,
      verticalAlign: "top",
      pe: "calc(var(--stepper-width) + 0.5rem)"
    },
    control: {
      display: "flex",
      flexDirection: "column",
      position: "absolute",
      top: "0",
      insetEnd: "0px",
      margin: "1px",
      width: "var(--stepper-width)",
      height: "calc(100% - 2px)",
      zIndex: "1",
      borderStartWidth: "1px",
      divideY: "1px"
    },
    incrementTrigger: {
      ...triggerStyle,
      borderTopEndRadius: "var(--stepper-radius)"
    },
    decrementTrigger: {
      ...triggerStyle,
      borderBottomEndRadius: "var(--stepper-radius)"
    },
    valueText: {
      fontWeight: "medium",
      fontFeatureSettings: "pnum",
      fontVariantNumeric: "proportional-nums"
    }
  },
  variants: {
    size: {
      xs: {
        input: inputRecipe.variants.size.xs,
        control: {
          fontSize: "2xs",
          "--stepper-width": "sizes.4"
        }
      },
      sm: {
        input: inputRecipe.variants.size.sm,
        control: {
          fontSize: "xs",
          "--stepper-width": "sizes.5"
        }
      },
      md: {
        input: inputRecipe.variants.size.md,
        control: {
          fontSize: "sm",
          "--stepper-width": "sizes.6"
        }
      },
      lg: {
        input: inputRecipe.variants.size.lg,
        control: {
          fontSize: "sm",
          "--stepper-width": "sizes.6"
        }
      }
    },
    variant: mapEntries2(inputRecipe.variants.variant, (key, variantStyles) => [
      key,
      { input: variantStyles }
    ])
  },
  defaultVariants: {
    size: "md",
    variant: "outline"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/pin-input.js
var { variants: variants2, defaultVariants: defaultVariants2 } = inputRecipe;
var pinInputSlotRecipe = defineSlotRecipe({
  className: "chakra-pin-input",
  slots: anatomy21.keys(),
  base: {
    input: {
      ...inputRecipe.base,
      textAlign: "center",
      width: "var(--input-height)"
    },
    control: {
      display: "inline-flex",
      gap: "2",
      isolation: "isolate"
    }
  },
  variants: {
    size: mapEntries2(variants2.size, (key, value) => [
      key,
      { input: { ...value, px: "1" } }
    ]),
    variant: mapEntries2(variants2.variant, (key, value) => [
      key,
      { input: value }
    ]),
    attached: {
      true: {
        control: {
          gap: "0",
          spaceX: "-1px"
        },
        input: {
          _notFirst: { borderStartRadius: "0" },
          _notLast: { borderEndRadius: "0" },
          _focusVisible: { zIndex: "1" }
        }
      }
    }
  },
  defaultVariants: defaultVariants2
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/popover.js
var popoverSlotRecipe = defineSlotRecipe({
  className: "chakra-popover",
  slots: popoverAnatomy.keys(),
  base: {
    content: {
      position: "relative",
      display: "flex",
      flexDirection: "column",
      textStyle: "sm",
      "--popover-bg": "colors.bg.panel",
      bg: "var(--popover-bg)",
      boxShadow: "lg",
      "--popover-size": "sizes.xs",
      "--popover-mobile-size": "calc(100dvw - 1rem)",
      width: {
        base: "min(var(--popover-mobile-size), var(--popover-size))",
        sm: "var(--popover-size)"
      },
      borderRadius: "l3",
      "--popover-z-index": "zIndex.popover",
      zIndex: "calc(var(--popover-z-index) + var(--layer-index, 0))",
      outline: "0",
      transformOrigin: "var(--transform-origin)",
      maxHeight: "var(--available-height)",
      _open: {
        animationStyle: "scale-fade-in",
        animationDuration: "fast"
      },
      _closed: {
        animationStyle: "scale-fade-out",
        animationDuration: "faster"
      }
    },
    header: {
      paddingInline: "var(--popover-padding)",
      paddingTop: "var(--popover-padding)"
    },
    body: {
      padding: "var(--popover-padding)",
      flex: "1"
    },
    footer: {
      display: "flex",
      alignItems: "center",
      paddingInline: "var(--popover-padding)",
      paddingBottom: "var(--popover-padding)"
    },
    arrow: {
      "--arrow-size": "sizes.3",
      "--arrow-background": "var(--popover-bg)"
    },
    arrowTip: {
      borderTopWidth: "1px",
      borderInlineStartWidth: "1px"
    }
  },
  variants: {
    size: {
      xs: {
        content: {
          "--popover-padding": "spacing.3"
        }
      },
      sm: {
        content: {
          "--popover-padding": "spacing.4"
        }
      },
      md: {
        content: {
          "--popover-padding": "spacing.5"
        }
      },
      lg: {
        content: {
          "--popover-padding": "spacing.6"
        }
      }
    }
  },
  defaultVariants: {
    size: "md"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/progress.js
var progressSlotRecipe = defineSlotRecipe({
  slots: anatomy23.keys(),
  className: "chakra-progress",
  base: {
    root: {
      textStyle: "sm",
      position: "relative"
    },
    track: {
      overflow: "hidden",
      position: "relative"
    },
    range: {
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      transitionProperty: "width, height",
      transitionDuration: "slow",
      height: "100%",
      bgColor: "var(--track-color)",
      _indeterminate: {
        "--animate-from-x": "-40%",
        "--animate-to-x": "100%",
        position: "absolute",
        willChange: "left",
        minWidth: "50%",
        animation: "position 1s ease infinite normal none running",
        backgroundImage: `linear-gradient(to right, transparent 0%, var(--track-color) 50%, transparent 100%)`
      }
    },
    label: {
      display: "inline-flex",
      fontWeight: "medium",
      alignItems: "center",
      gap: "1"
    },
    valueText: {
      textStyle: "xs",
      lineHeight: "1",
      fontWeight: "medium"
    }
  },
  variants: {
    variant: {
      outline: {
        track: {
          shadow: "inset",
          bgColor: "bg.muted"
        },
        range: {
          bgColor: "colorPalette.solid"
        }
      },
      subtle: {
        track: {
          bgColor: "colorPalette.muted"
        },
        range: {
          bgColor: "colorPalette.solid/72"
        }
      }
    },
    shape: {
      square: {},
      rounded: {
        track: {
          borderRadius: "l1"
        }
      },
      full: {
        track: {
          borderRadius: "full"
        }
      }
    },
    striped: {
      true: {
        range: {
          backgroundImage: `linear-gradient(45deg, var(--stripe-color) 25%, transparent 25%, transparent 50%, var(--stripe-color) 50%, var(--stripe-color) 75%, transparent 75%, transparent)`,
          backgroundSize: `var(--stripe-size) var(--stripe-size)`,
          "--stripe-size": "1rem",
          "--stripe-color": {
            _light: "rgba(255, 255, 255, 0.3)",
            _dark: "rgba(0, 0, 0, 0.3)"
          }
        }
      }
    },
    animated: {
      true: {
        range: {
          "--animate-from": "var(--stripe-size)",
          animation: "bg-position 1s linear infinite"
        }
      }
    },
    size: {
      xs: {
        track: { h: "1.5" }
      },
      sm: {
        track: { h: "2" }
      },
      md: {
        track: { h: "2.5" }
      },
      lg: {
        track: { h: "3" }
      },
      xl: {
        track: { h: "4" }
      }
    }
  },
  defaultVariants: {
    variant: "outline",
    size: "md",
    shape: "rounded"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/progress-circle.js
var progressCircleSlotRecipe = defineSlotRecipe({
  className: "chakra-progress-circle",
  slots: anatomy23.keys(),
  base: {
    root: {
      display: "inline-flex",
      textStyle: "sm",
      position: "relative"
    },
    circle: {
      _indeterminate: {
        animation: "spin 2s linear infinite"
      }
    },
    circleTrack: {
      "--track-color": "colors.colorPalette.muted",
      stroke: "var(--track-color)"
    },
    circleRange: {
      stroke: "colorPalette.solid",
      transitionProperty: "stroke-dashoffset, stroke-dasharray",
      transitionDuration: "0.6s",
      _indeterminate: {
        animation: "circular-progress 1.5s linear infinite"
      }
    },
    label: {
      display: "inline-flex"
    },
    valueText: {
      lineHeight: "1",
      fontWeight: "medium",
      letterSpacing: "tight",
      fontVariantNumeric: "tabular-nums"
    }
  },
  variants: {
    size: {
      xs: {
        circle: {
          "--size": "24px",
          "--thickness": "4px"
        },
        valueText: {
          textStyle: "2xs"
        }
      },
      sm: {
        circle: {
          "--size": "32px",
          "--thickness": "5px"
        },
        valueText: {
          textStyle: "2xs"
        }
      },
      md: {
        circle: {
          "--size": "40px",
          "--thickness": "6px"
        },
        valueText: {
          textStyle: "xs"
        }
      },
      lg: {
        circle: {
          "--size": "48px",
          "--thickness": "7px"
        },
        valueText: {
          textStyle: "sm"
        }
      },
      xl: {
        circle: {
          "--size": "64px",
          "--thickness": "8px"
        },
        valueText: {
          textStyle: "sm"
        }
      }
    }
  },
  defaultVariants: {
    size: "md"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/qr-code.js
var qrCodeSlotRecipe = defineSlotRecipe({
  slots: anatomy24.keys(),
  className: "chakra-qr-code",
  base: {
    root: {
      position: "relative",
      width: "fit-content",
      "--qr-code-overlay-size": "calc(var(--qr-code-size) / 3)"
    },
    frame: {
      width: "var(--qr-code-size)",
      height: "var(--qr-code-size)",
      fill: "currentColor"
    },
    overlay: {
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      width: "var(--qr-code-overlay-size)",
      height: "var(--qr-code-overlay-size)",
      padding: "1",
      bg: "bg",
      rounded: "l1"
    }
  },
  variants: {
    size: {
      "2xs": {
        root: { "--qr-code-size": "40px" }
      },
      xs: {
        root: { "--qr-code-size": "64px" }
      },
      sm: {
        root: { "--qr-code-size": "80px" }
      },
      md: {
        root: { "--qr-code-size": "120px" }
      },
      lg: {
        root: { "--qr-code-size": "160px" }
      },
      xl: {
        root: { "--qr-code-size": "200px" }
      },
      "2xl": {
        root: { "--qr-code-size": "240px" }
      },
      full: {
        root: { "--qr-code-size": "100%" }
      }
    }
  },
  defaultVariants: {
    size: "md"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/radio-card.js
var _a5, _b5, _c4, _d4, _e5, _f4, _g4;
var radioCardSlotRecipe = defineSlotRecipe({
  className: "chakra-radio-card",
  slots: radioCardAnatomy.keys(),
  base: {
    root: {
      display: "flex",
      flexDirection: "column",
      gap: "1.5",
      isolation: "isolate"
    },
    item: {
      flex: "1",
      display: "flex",
      flexDirection: "column",
      userSelect: "none",
      position: "relative",
      borderRadius: "l2",
      _focus: {
        bg: "colorPalette.muted/20"
      },
      _disabled: {
        opacity: "0.8",
        borderColor: "border.disabled"
      },
      _checked: {
        zIndex: "1"
      }
    },
    label: {
      display: "inline-flex",
      fontWeight: "medium",
      textStyle: "sm",
      _disabled: {
        opacity: "0.5"
      }
    },
    itemText: {
      fontWeight: "medium",
      flex: "1"
    },
    itemDescription: {
      opacity: "0.64",
      textStyle: "sm"
    },
    itemControl: {
      display: "inline-flex",
      flex: "1",
      pos: "relative",
      rounded: "inherit",
      justifyContent: "var(--radio-card-justify)",
      alignItems: "var(--radio-card-align)",
      _disabled: {
        bg: "bg.muted"
      }
    },
    itemIndicator: radiomarkRecipe.base,
    itemAddon: {
      roundedBottom: "inherit",
      _disabled: {
        color: "fg.muted"
      }
    },
    itemContent: {
      display: "flex",
      flexDirection: "column",
      flex: "1",
      gap: "1",
      justifyContent: "var(--radio-card-justify)",
      alignItems: "var(--radio-card-align)"
    }
  },
  variants: {
    size: {
      sm: {
        item: {
          textStyle: "sm"
        },
        itemControl: {
          padding: "3",
          gap: "1.5"
        },
        itemAddon: {
          px: "3",
          py: "1.5",
          borderTopWidth: "1px"
        },
        itemIndicator: (_a5 = radiomarkRecipe.variants) == null ? void 0 : _a5.size.sm
      },
      md: {
        item: {
          textStyle: "sm"
        },
        itemControl: {
          padding: "4",
          gap: "2.5"
        },
        itemAddon: {
          px: "4",
          py: "2",
          borderTopWidth: "1px"
        },
        itemIndicator: (_b5 = radiomarkRecipe.variants) == null ? void 0 : _b5.size.md
      },
      lg: {
        item: {
          textStyle: "md"
        },
        itemControl: {
          padding: "4",
          gap: "3.5"
        },
        itemAddon: {
          px: "4",
          py: "2",
          borderTopWidth: "1px"
        },
        itemIndicator: (_c4 = radiomarkRecipe.variants) == null ? void 0 : _c4.size.lg
      }
    },
    variant: {
      surface: {
        item: {
          borderWidth: "1px",
          _checked: {
            bg: "colorPalette.subtle",
            color: "colorPalette.fg",
            borderColor: "colorPalette.muted"
          }
        },
        itemIndicator: (_d4 = radiomarkRecipe.variants) == null ? void 0 : _d4.variant.solid
      },
      subtle: {
        item: {
          bg: "bg.muted"
        },
        itemControl: {
          _checked: {
            bg: "colorPalette.muted",
            color: "colorPalette.fg"
          }
        },
        itemIndicator: (_e5 = radiomarkRecipe.variants) == null ? void 0 : _e5.variant.outline
      },
      outline: {
        item: {
          borderWidth: "1px",
          _checked: {
            boxShadow: "0 0 0 1px var(--shadow-color)",
            boxShadowColor: "colorPalette.solid",
            borderColor: "colorPalette.solid"
          }
        },
        itemIndicator: (_f4 = radiomarkRecipe.variants) == null ? void 0 : _f4.variant.solid
      },
      solid: {
        item: {
          borderWidth: "1px",
          _checked: {
            bg: "colorPalette.solid",
            color: "colorPalette.contrast",
            borderColor: "colorPalette.solid"
          }
        },
        itemIndicator: (_g4 = radiomarkRecipe.variants) == null ? void 0 : _g4.variant.inverted
      }
    },
    justify: {
      start: {
        item: { "--radio-card-justify": "flex-start" }
      },
      end: {
        item: { "--radio-card-justify": "flex-end" }
      },
      center: {
        item: { "--radio-card-justify": "center" }
      }
    },
    align: {
      start: {
        item: { "--radio-card-align": "flex-start" },
        itemControl: { textAlign: "start" }
      },
      end: {
        item: { "--radio-card-align": "flex-end" },
        itemControl: { textAlign: "end" }
      },
      center: {
        item: { "--radio-card-align": "center" },
        itemControl: { textAlign: "center" }
      }
    },
    orientation: {
      vertical: {
        itemControl: { flexDirection: "column" }
      },
      horizontal: {
        itemControl: { flexDirection: "row" }
      }
    }
  },
  defaultVariants: {
    size: "md",
    variant: "outline",
    align: "start",
    orientation: "horizontal"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/radio-group.js
var _a6, _b6, _c5, _d5, _e6, _f5, _g5, _h3, _i3, _j3, _k3, _l3, _m3, _n3;
var radioGroupSlotRecipe = defineSlotRecipe({
  className: "chakra-radio-group",
  slots: radioGroupAnatomy.keys(),
  base: {
    item: {
      display: "inline-flex",
      alignItems: "center",
      position: "relative",
      fontWeight: "medium",
      _disabled: {
        cursor: "disabled"
      }
    },
    itemControl: radiomarkRecipe.base,
    label: {
      userSelect: "none",
      textStyle: "sm",
      _disabled: {
        opacity: "0.5"
      }
    }
  },
  variants: {
    variant: {
      outline: {
        itemControl: (_b6 = (_a6 = radiomarkRecipe.variants) == null ? void 0 : _a6.variant) == null ? void 0 : _b6.outline
      },
      subtle: {
        itemControl: (_d5 = (_c5 = radiomarkRecipe.variants) == null ? void 0 : _c5.variant) == null ? void 0 : _d5.subtle
      },
      solid: {
        itemControl: (_f5 = (_e6 = radiomarkRecipe.variants) == null ? void 0 : _e6.variant) == null ? void 0 : _f5.solid
      }
    },
    size: {
      xs: {
        item: { textStyle: "xs", gap: "1.5" },
        itemControl: (_h3 = (_g5 = radiomarkRecipe.variants) == null ? void 0 : _g5.size) == null ? void 0 : _h3.xs
      },
      sm: {
        item: { textStyle: "sm", gap: "2" },
        itemControl: (_j3 = (_i3 = radiomarkRecipe.variants) == null ? void 0 : _i3.size) == null ? void 0 : _j3.sm
      },
      md: {
        item: { textStyle: "sm", gap: "2.5" },
        itemControl: (_l3 = (_k3 = radiomarkRecipe.variants) == null ? void 0 : _k3.size) == null ? void 0 : _l3.md
      },
      lg: {
        item: { textStyle: "md", gap: "3" },
        itemControl: (_n3 = (_m3 = radiomarkRecipe.variants) == null ? void 0 : _m3.size) == null ? void 0 : _n3.lg
      }
    }
  },
  defaultVariants: {
    size: "md",
    variant: "solid"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/rating-group.js
var ratingGroupSlotRecipe = defineSlotRecipe({
  className: "chakra-rating-group",
  slots: ratingGroupAnatomy.keys(),
  base: {
    root: {
      display: "inline-flex"
    },
    control: {
      display: "inline-flex",
      alignItems: "center"
    },
    item: {
      display: "inline-flex",
      alignItems: "center",
      justifyContent: "center",
      userSelect: "none"
    },
    itemIndicator: {
      display: "inline-flex",
      alignItems: "center",
      justifyContent: "center",
      width: "1em",
      height: "1em",
      position: "relative",
      "--clip-path": { base: "inset(0 50% 0 0)", _rtl: "inset(0 0 0 50%)" },
      _icon: {
        stroke: "currentColor",
        width: "100%",
        height: "100%",
        display: "inline-block",
        flexShrink: 0,
        position: "absolute",
        left: 0,
        top: 0
      },
      "& [data-bg]": {
        color: "bg.emphasized"
      },
      "& [data-fg]": {
        color: "transparent"
      },
      "&[data-highlighted]:not([data-half])": {
        "& [data-fg]": {
          color: "colorPalette.solid"
        }
      },
      "&[data-half]": {
        "& [data-fg]": {
          color: "colorPalette.solid",
          clipPath: "var(--clip-path)"
        }
      }
    }
  },
  variants: {
    size: {
      xs: {
        item: {
          textStyle: "sm"
        }
      },
      sm: {
        item: {
          textStyle: "md"
        }
      },
      md: {
        item: {
          textStyle: "xl"
        }
      },
      lg: {
        item: {
          textStyle: "2xl"
        }
      }
    }
  },
  defaultVariants: {
    size: "md"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/segment-group.js
var segmentGroupSlotRecipe = defineSlotRecipe({
  className: "chakra-segment-group",
  slots: segmentGroupAnatomy.keys(),
  base: {
    root: {
      "--segment-radius": "radii.l2",
      borderRadius: "l2",
      display: "inline-flex",
      boxShadow: "inset",
      minW: "max-content",
      textAlign: "center",
      position: "relative",
      isolation: "isolate",
      bg: "bg.muted",
      _vertical: {
        flexDirection: "column"
      }
    },
    item: {
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      userSelect: "none",
      fontSize: "sm",
      position: "relative",
      color: "fg",
      borderRadius: "var(--segment-radius)",
      _disabled: {
        opacity: "0.5"
      },
      "&:has(input:focus-visible)": {
        focusRing: "outside"
      },
      _before: {
        content: '""',
        position: "absolute",
        bg: "border",
        transition: "opacity 0.2s"
      },
      _horizontal: {
        _before: {
          insetInlineStart: 0,
          insetBlock: "1.5",
          width: "1px"
        }
      },
      _vertical: {
        _before: {
          insetBlockStart: 0,
          insetInline: "1.5",
          height: "1px"
        }
      },
      "& + &[data-state=checked], &[data-state=checked] + &, &:first-of-type": {
        _before: {
          opacity: "0"
        }
      },
      "&[data-state=checked][data-ssr]": {
        shadow: "sm",
        bg: "bg",
        borderRadius: "var(--segment-radius)"
      }
    },
    indicator: {
      shadow: "sm",
      pos: "absolute",
      bg: { _light: "bg", _dark: "bg.emphasized" },
      width: "var(--width)",
      height: "var(--height)",
      top: "var(--top)",
      left: "var(--left)",
      zIndex: -1,
      borderRadius: "var(--segment-radius)"
    }
  },
  variants: {
    size: {
      xs: {
        item: {
          textStyle: "xs",
          px: "3",
          gap: "1",
          height: "6"
        }
      },
      sm: {
        item: {
          textStyle: "sm",
          px: "4",
          gap: "2",
          height: "8"
        }
      },
      md: {
        item: {
          textStyle: "sm",
          px: "4",
          gap: "2",
          height: "10"
        }
      },
      lg: {
        item: {
          textStyle: "md",
          px: "4.5",
          gap: "3",
          height: "11"
        }
      }
    }
  },
  defaultVariants: {
    size: "md"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/slider.js
var sliderSlotRecipe = defineSlotRecipe({
  className: "chakra-slider",
  slots: sliderAnatomy.keys(),
  base: {
    root: {
      display: "flex",
      flexDirection: "column",
      gap: "1",
      textStyle: "sm",
      position: "relative",
      isolation: "isolate",
      touchAction: "none"
    },
    label: {
      fontWeight: "medium",
      textStyle: "sm"
    },
    control: {
      display: "inline-flex",
      alignItems: "center",
      position: "relative"
    },
    track: {
      overflow: "hidden",
      borderRadius: "full",
      flex: "1"
    },
    range: {
      width: "inherit",
      height: "inherit",
      _disabled: { bg: "border.emphasized!" }
    },
    markerGroup: {
      position: "absolute!",
      zIndex: "1"
    },
    marker: {
      "--marker-bg": { base: "white", _underValue: "colors.bg" },
      display: "flex",
      alignItems: "center",
      gap: "calc(var(--slider-thumb-size) / 2)",
      color: "fg.muted",
      textStyle: "xs"
    },
    markerIndicator: {
      width: "var(--slider-marker-size)",
      height: "var(--slider-marker-size)",
      borderRadius: "full",
      bg: "var(--marker-bg)"
    },
    thumb: {
      width: "var(--slider-thumb-size)",
      height: "var(--slider-thumb-size)",
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      outline: 0,
      zIndex: "2",
      borderRadius: "full",
      _focusVisible: {
        ring: "2px",
        ringColor: "colorPalette.focusRing",
        ringOffset: "2px",
        ringOffsetColor: "bg"
      }
    }
  },
  variants: {
    size: {
      sm: {
        root: {
          "--slider-thumb-size": "sizes.4",
          "--slider-track-size": "sizes.1.5",
          "--slider-marker-center": "6px",
          "--slider-marker-size": "sizes.1",
          "--slider-marker-inset": "3px"
        }
      },
      md: {
        root: {
          "--slider-thumb-size": "sizes.5",
          "--slider-track-size": "sizes.2",
          "--slider-marker-center": "8px",
          "--slider-marker-size": "sizes.1",
          "--slider-marker-inset": "4px"
        }
      },
      lg: {
        root: {
          "--slider-thumb-size": "sizes.6",
          "--slider-track-size": "sizes.2.5",
          "--slider-marker-center": "9px",
          "--slider-marker-size": "sizes.1.5",
          "--slider-marker-inset": "5px"
        }
      }
    },
    variant: {
      outline: {
        track: {
          shadow: "inset",
          bg: "bg.emphasized/72"
        },
        range: {
          bg: "colorPalette.solid"
        },
        thumb: {
          borderWidth: "2px",
          borderColor: "colorPalette.solid",
          bg: "bg",
          _disabled: {
            bg: "border.emphasized",
            borderColor: "border.emphasized"
          }
        }
      },
      solid: {
        track: {
          bg: "colorPalette.subtle",
          _disabled: {
            bg: "bg.muted"
          }
        },
        range: {
          bg: "colorPalette.solid"
        },
        thumb: {
          bg: "colorPalette.solid",
          _disabled: {
            bg: "border.emphasized"
          }
        }
      }
    },
    orientation: {
      vertical: {
        root: {
          display: "inline-flex"
        },
        control: {
          flexDirection: "column",
          height: "100%",
          minWidth: "var(--slider-thumb-size)",
          "&[data-has-mark-label], &:has(.chakra-slider__marker-label)": {
            marginEnd: "4"
          }
        },
        track: {
          width: "var(--slider-track-size)"
        },
        thumb: {
          left: "50%",
          translate: "-50% 0"
        },
        markerGroup: {
          insetStart: "var(--slider-marker-center)",
          insetBlock: "var(--slider-marker-inset)"
        },
        marker: {
          flexDirection: "row"
        }
      },
      horizontal: {
        control: {
          flexDirection: "row",
          width: "100%",
          minHeight: "var(--slider-thumb-size)",
          "&[data-has-mark-label], &:has(.chakra-slider__marker-label)": {
            marginBottom: "4"
          }
        },
        track: {
          height: "var(--slider-track-size)"
        },
        thumb: {
          top: "50%",
          translate: "0 -50%"
        },
        markerGroup: {
          top: "var(--slider-marker-center)",
          insetInline: "var(--slider-marker-inset)"
        },
        marker: {
          flexDirection: "column"
        }
      }
    }
  },
  defaultVariants: {
    size: "md",
    variant: "outline",
    orientation: "horizontal"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/stat.js
var statSlotRecipe = defineSlotRecipe({
  className: "chakra-stat",
  slots: statAnatomy.keys(),
  base: {
    root: {
      display: "flex",
      flexDirection: "column",
      gap: "1",
      position: "relative",
      flex: "1"
    },
    label: {
      display: "inline-flex",
      gap: "1.5",
      alignItems: "center",
      color: "fg.muted",
      textStyle: "sm"
    },
    helpText: {
      color: "fg.muted",
      textStyle: "xs"
    },
    valueUnit: {
      color: "fg.muted",
      textStyle: "xs",
      fontWeight: "initial",
      letterSpacing: "initial"
    },
    valueText: {
      verticalAlign: "baseline",
      fontWeight: "semibold",
      letterSpacing: "tight",
      fontFeatureSettings: "pnum",
      fontVariantNumeric: "proportional-nums",
      display: "inline-flex",
      gap: "1"
    },
    indicator: {
      display: "inline-flex",
      alignItems: "center",
      justifyContent: "center",
      marginEnd: 1,
      "& :where(svg)": {
        w: "1em",
        h: "1em"
      },
      "&[data-type=up]": {
        color: "fg.success"
      },
      "&[data-type=down]": {
        color: "fg.error"
      }
    }
  },
  variants: {
    size: {
      sm: {
        valueText: {
          textStyle: "xl"
        }
      },
      md: {
        valueText: {
          textStyle: "2xl"
        }
      },
      lg: {
        valueText: {
          textStyle: "3xl"
        }
      }
    }
  },
  defaultVariants: {
    size: "md"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/status.js
var statusSlotRecipe = defineSlotRecipe({
  className: "chakra-status",
  slots: statusAnatomy.keys(),
  base: {
    root: {
      display: "inline-flex",
      alignItems: "center",
      gap: "2"
    },
    indicator: {
      width: "0.64em",
      height: "0.64em",
      flexShrink: 0,
      borderRadius: "full",
      forcedColorAdjust: "none",
      bg: "colorPalette.solid"
    }
  },
  variants: {
    size: {
      sm: {
        root: {
          textStyle: "xs"
        }
      },
      md: {
        root: {
          textStyle: "sm"
        }
      },
      lg: {
        root: {
          textStyle: "md"
        }
      }
    }
  },
  defaultVariants: {
    size: "md"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/steps.js
var stepsSlotRecipe = defineSlotRecipe({
  className: "chakra-steps",
  slots: stepsAnatomy.keys(),
  base: {
    root: {
      display: "flex",
      width: "full"
    },
    list: {
      display: "flex",
      justifyContent: "space-between",
      "--steps-gutter": "spacing.3",
      "--steps-thickness": "2px"
    },
    title: {
      fontWeight: "medium",
      color: "fg"
    },
    description: {
      color: "fg.muted"
    },
    separator: {
      bg: "border",
      flex: "1"
    },
    indicator: {
      display: "flex",
      justifyContent: "center",
      alignItems: "center",
      flexShrink: "0",
      borderRadius: "full",
      fontWeight: "medium",
      width: "var(--steps-size)",
      height: "var(--steps-size)",
      _icon: {
        flexShrink: "0",
        width: "var(--steps-icon-size)",
        height: "var(--steps-icon-size)"
      }
    },
    item: {
      position: "relative",
      display: "flex",
      gap: "3",
      flex: "1 0 0",
      "&:last-of-type": {
        flex: "initial",
        "& [data-part=separator]": {
          display: "none"
        }
      }
    },
    trigger: {
      display: "flex",
      alignItems: "center",
      gap: "3",
      textAlign: "start",
      focusVisibleRing: "outside",
      borderRadius: "l2"
    },
    content: {
      focusVisibleRing: "outside"
    }
  },
  variants: {
    orientation: {
      vertical: {
        root: {
          flexDirection: "row",
          height: "100%"
        },
        list: {
          flexDirection: "column",
          alignItems: "flex-start"
        },
        separator: {
          position: "absolute",
          width: "var(--steps-thickness)",
          height: "100%",
          maxHeight: "calc(100% - var(--steps-size) - var(--steps-gutter) * 2)",
          top: "calc(var(--steps-size) + var(--steps-gutter))",
          insetStart: "calc(var(--steps-size) / 2 - 1px)"
        },
        item: {
          alignItems: "flex-start"
        }
      },
      horizontal: {
        root: {
          flexDirection: "column",
          width: "100%"
        },
        list: {
          flexDirection: "row",
          alignItems: "center"
        },
        separator: {
          width: "100%",
          height: "var(--steps-thickness)",
          marginX: "var(--steps-gutter)"
        },
        item: {
          alignItems: "center"
        }
      }
    },
    variant: {
      solid: {
        indicator: {
          _incomplete: {
            borderWidth: "var(--steps-thickness)"
          },
          _current: {
            bg: "colorPalette.muted",
            borderWidth: "var(--steps-thickness)",
            borderColor: "colorPalette.solid",
            color: "colorPalette.fg"
          },
          _complete: {
            bg: "colorPalette.solid",
            borderColor: "colorPalette.solid",
            color: "colorPalette.contrast"
          }
        },
        separator: {
          _complete: {
            bg: "colorPalette.solid"
          }
        }
      },
      subtle: {
        indicator: {
          _incomplete: {
            bg: "bg.muted"
          },
          _current: {
            bg: "colorPalette.muted",
            color: "colorPalette.fg"
          },
          _complete: {
            bg: "colorPalette.emphasized",
            color: "colorPalette.fg"
          }
        },
        separator: {
          _complete: {
            bg: "colorPalette.emphasized"
          }
        }
      }
    },
    size: {
      xs: {
        root: {
          gap: "2.5"
        },
        list: {
          "--steps-size": "sizes.6",
          "--steps-icon-size": "sizes.3.5",
          textStyle: "xs"
        },
        title: {
          textStyle: "sm"
        }
      },
      sm: {
        root: {
          gap: "3"
        },
        list: {
          "--steps-size": "sizes.8",
          "--steps-icon-size": "sizes.4",
          textStyle: "xs"
        },
        title: {
          textStyle: "sm"
        }
      },
      md: {
        root: {
          gap: "4"
        },
        list: {
          "--steps-size": "sizes.10",
          "--steps-icon-size": "sizes.4",
          textStyle: "sm"
        },
        title: {
          textStyle: "sm"
        }
      },
      lg: {
        root: {
          gap: "6"
        },
        list: {
          "--steps-size": "sizes.11",
          "--steps-icon-size": "sizes.5",
          textStyle: "md"
        },
        title: {
          textStyle: "md"
        }
      }
    }
  },
  defaultVariants: {
    size: "md",
    variant: "solid",
    orientation: "horizontal"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/switch.js
var switchSlotRecipe = defineSlotRecipe({
  slots: switchAnatomy.keys(),
  className: "chakra-switch",
  base: {
    root: {
      display: "inline-flex",
      gap: "2.5",
      alignItems: "center",
      position: "relative",
      verticalAlign: "middle",
      "--switch-diff": "calc(var(--switch-width) - var(--switch-height))",
      "--switch-x": {
        base: "var(--switch-diff)",
        _rtl: "calc(var(--switch-diff) * -1)"
      }
    },
    label: {
      lineHeight: "1",
      userSelect: "none",
      fontSize: "sm",
      fontWeight: "medium",
      _disabled: {
        opacity: "0.5"
      }
    },
    indicator: {
      position: "absolute",
      height: "var(--switch-height)",
      width: "var(--switch-height)",
      fontSize: "var(--switch-indicator-font-size)",
      fontWeight: "medium",
      flexShrink: 0,
      userSelect: "none",
      display: "grid",
      placeContent: "center",
      transition: "inset-inline-start 0.12s ease",
      insetInlineStart: "calc(var(--switch-x) - 2px)",
      _checked: {
        insetInlineStart: "2px"
      }
    },
    control: {
      display: "inline-flex",
      gap: "0.5rem",
      flexShrink: 0,
      justifyContent: "flex-start",
      cursor: "switch",
      borderRadius: "full",
      position: "relative",
      width: "var(--switch-width)",
      height: "var(--switch-height)",
      transition: "backgrounds",
      _disabled: {
        opacity: "0.5",
        cursor: "not-allowed"
      },
      _invalid: {
        outline: "2px solid",
        outlineColor: "border.error",
        outlineOffset: "2px"
      }
    },
    thumb: {
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      flexShrink: 0,
      transitionProperty: "translate",
      transitionDuration: "fast",
      borderRadius: "inherit",
      _checked: {
        translate: "var(--switch-x) 0"
      }
    }
  },
  variants: {
    variant: {
      solid: {
        control: {
          borderRadius: "full",
          bg: "bg.emphasized",
          focusVisibleRing: "outside",
          _checked: {
            bg: "colorPalette.solid"
          }
        },
        thumb: {
          bg: "white",
          width: "var(--switch-height)",
          height: "var(--switch-height)",
          scale: "0.8",
          boxShadow: "sm",
          _checked: {
            bg: "colorPalette.contrast"
          }
        }
      },
      raised: {
        control: {
          borderRadius: "full",
          height: "calc(var(--switch-height) / 2)",
          bg: "bg.muted",
          boxShadow: "inset",
          _checked: {
            bg: "colorPalette.solid/60"
          }
        },
        thumb: {
          width: "var(--switch-height)",
          height: "var(--switch-height)",
          position: "relative",
          top: "calc(var(--switch-height) * -0.25)",
          bg: "white",
          boxShadow: "xs",
          focusVisibleRing: "outside",
          _checked: {
            bg: "colorPalette.solid"
          }
        }
      }
    },
    size: {
      xs: {
        root: {
          "--switch-width": "sizes.6",
          "--switch-height": "sizes.3",
          "--switch-indicator-font-size": "fontSizes.xs"
        }
      },
      sm: {
        root: {
          "--switch-width": "sizes.8",
          "--switch-height": "sizes.4",
          "--switch-indicator-font-size": "fontSizes.xs"
        }
      },
      md: {
        root: {
          "--switch-width": "sizes.10",
          "--switch-height": "sizes.5",
          "--switch-indicator-font-size": "fontSizes.sm"
        }
      },
      lg: {
        root: {
          "--switch-width": "sizes.12",
          "--switch-height": "sizes.6",
          "--switch-indicator-font-size": "fontSizes.md"
        }
      }
    }
  },
  defaultVariants: {
    variant: "solid",
    size: "md"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/table.js
var tableSlotRecipe = defineSlotRecipe({
  className: "chakra-table",
  slots: tableAnatomy.keys(),
  base: {
    root: {
      fontVariantNumeric: "lining-nums tabular-nums",
      borderCollapse: "collapse",
      width: "full",
      textAlign: "start",
      verticalAlign: "top"
    },
    row: {
      _selected: {
        bg: "colorPalette.subtle"
      }
    },
    cell: {
      textAlign: "start",
      alignItems: "center"
    },
    columnHeader: {
      fontWeight: "medium",
      textAlign: "start",
      color: "fg"
    },
    caption: {
      fontWeight: "medium",
      textStyle: "xs"
    },
    footer: {
      fontWeight: "medium"
    }
  },
  variants: {
    interactive: {
      true: {
        body: {
          "& tr": {
            _hover: {
              bg: "colorPalette.subtle"
            }
          }
        }
      }
    },
    stickyHeader: {
      true: {
        header: {
          "& :where(tr)": {
            top: "var(--table-sticky-offset, 0)",
            position: "sticky",
            zIndex: 1
          }
        }
      }
    },
    striped: {
      true: {
        row: {
          "&:nth-of-type(odd) td": {
            bg: "bg.muted"
          }
        }
      }
    },
    showColumnBorder: {
      true: {
        columnHeader: {
          "&:not(:last-of-type)": {
            borderInlineEndWidth: "1px"
          }
        },
        cell: {
          "&:not(:last-of-type)": {
            borderInlineEndWidth: "1px"
          }
        }
      }
    },
    variant: {
      line: {
        columnHeader: {
          borderBottomWidth: "1px"
        },
        cell: {
          borderBottomWidth: "1px"
        },
        row: {
          bg: "bg"
        }
      },
      outline: {
        root: {
          boxShadow: "0 0 0 1px {colors.border}",
          overflow: "hidden"
        },
        columnHeader: {
          borderBottomWidth: "1px"
        },
        header: {
          bg: "bg.muted"
        },
        row: {
          "&:not(:last-of-type)": {
            borderBottomWidth: "1px"
          }
        },
        footer: {
          borderTopWidth: "1px"
        }
      }
    },
    size: {
      sm: {
        root: {
          textStyle: "sm"
        },
        columnHeader: {
          px: "2",
          py: "2"
        },
        cell: {
          px: "2",
          py: "2"
        }
      },
      md: {
        root: {
          textStyle: "sm"
        },
        columnHeader: {
          px: "3",
          py: "3"
        },
        cell: {
          px: "3",
          py: "3"
        }
      },
      lg: {
        root: {
          textStyle: "md"
        },
        columnHeader: {
          px: "4",
          py: "3"
        },
        cell: {
          px: "4",
          py: "3"
        }
      }
    }
  },
  defaultVariants: {
    variant: "line",
    size: "md"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/tabs.js
var tabsSlotRecipe = defineSlotRecipe({
  slots: tabsAnatomy.keys(),
  className: "chakra-tabs",
  base: {
    root: {
      "--tabs-trigger-radius": "radii.l2",
      position: "relative",
      _horizontal: {
        display: "block"
      },
      _vertical: {
        display: "flex"
      }
    },
    list: {
      display: "inline-flex",
      position: "relative",
      isolation: "isolate",
      "--tabs-indicator-shadow": "shadows.xs",
      "--tabs-indicator-bg": "colors.bg",
      minH: "var(--tabs-height)",
      _horizontal: {
        flexDirection: "row"
      },
      _vertical: {
        flexDirection: "column"
      }
    },
    trigger: {
      outline: "0",
      minW: "var(--tabs-height)",
      height: "var(--tabs-height)",
      display: "flex",
      alignItems: "center",
      fontWeight: "medium",
      position: "relative",
      cursor: "button",
      gap: "2",
      _focusVisible: {
        zIndex: 1,
        outline: "2px solid",
        outlineColor: "colorPalette.focusRing"
      },
      _disabled: {
        cursor: "not-allowed",
        opacity: 0.5
      }
    },
    content: {
      focusVisibleRing: "inside",
      _horizontal: {
        width: "100%",
        pt: "var(--tabs-content-padding)"
      },
      _vertical: {
        height: "100%",
        ps: "var(--tabs-content-padding)"
      }
    },
    indicator: {
      width: "var(--width)",
      height: "var(--height)",
      borderRadius: "var(--tabs-indicator-radius)",
      bg: "var(--tabs-indicator-bg)",
      shadow: "var(--tabs-indicator-shadow)",
      zIndex: -1
    }
  },
  variants: {
    fitted: {
      true: {
        list: {
          display: "flex"
        },
        trigger: {
          flex: 1,
          textAlign: "center",
          justifyContent: "center"
        }
      }
    },
    justify: {
      start: {
        list: {
          justifyContent: "flex-start"
        }
      },
      center: {
        list: {
          justifyContent: "center"
        }
      },
      end: {
        list: {
          justifyContent: "flex-end"
        }
      }
    },
    size: {
      sm: {
        root: {
          "--tabs-height": "sizes.9",
          "--tabs-content-padding": "spacing.3"
        },
        trigger: {
          py: "1",
          px: "3",
          textStyle: "sm"
        }
      },
      md: {
        root: {
          "--tabs-height": "sizes.10",
          "--tabs-content-padding": "spacing.4"
        },
        trigger: {
          py: "2",
          px: "4",
          textStyle: "sm"
        }
      },
      lg: {
        root: {
          "--tabs-height": "sizes.11",
          "--tabs-content-padding": "spacing.4.5"
        },
        trigger: {
          py: "2",
          px: "4.5",
          textStyle: "md"
        }
      }
    },
    variant: {
      line: {
        list: {
          display: "flex",
          borderColor: "border",
          _horizontal: {
            borderBottomWidth: "1px"
          },
          _vertical: {
            borderEndWidth: "1px"
          }
        },
        trigger: {
          color: "fg.muted",
          _disabled: {
            _active: { bg: "initial" }
          },
          _selected: {
            color: "fg",
            _horizontal: {
              layerStyle: "indicator.bottom",
              "--indicator-offset-y": "-1px",
              "--indicator-color": "colors.colorPalette.solid"
            },
            _vertical: {
              layerStyle: "indicator.end",
              "--indicator-offset-x": "-1px"
            }
          }
        }
      },
      subtle: {
        trigger: {
          borderRadius: "var(--tabs-trigger-radius)",
          color: "fg.muted",
          _selected: {
            bg: "colorPalette.subtle",
            color: "colorPalette.fg"
          }
        }
      },
      enclosed: {
        list: {
          bg: "bg.muted",
          padding: "1",
          borderRadius: "l3",
          minH: "calc(var(--tabs-height) - 4px)"
        },
        trigger: {
          justifyContent: "center",
          color: "fg.muted",
          borderRadius: "var(--tabs-trigger-radius)",
          _selected: {
            bg: "bg",
            color: "colorPalette.fg",
            shadow: "xs"
          }
        }
      },
      outline: {
        list: {
          "--line-thickness": "1px",
          "--line-offset": "calc(var(--line-thickness) * -1)",
          borderColor: "border",
          display: "flex",
          _horizontal: {
            _before: {
              content: '""',
              position: "absolute",
              bottom: "0px",
              width: "100%",
              borderBottomWidth: "var(--line-thickness)",
              borderBottomColor: "border"
            }
          },
          _vertical: {
            _before: {
              content: '""',
              position: "absolute",
              insetInline: "var(--line-offset)",
              height: "calc(100% - calc(var(--line-thickness) * 2))",
              borderEndWidth: "var(--line-thickness)",
              borderEndColor: "border"
            }
          }
        },
        trigger: {
          color: "fg.muted",
          borderWidth: "1px",
          borderColor: "transparent",
          _selected: {
            bg: "currentBg",
            color: "colorPalette.fg"
          },
          _horizontal: {
            borderTopRadius: "var(--tabs-trigger-radius)",
            marginBottom: "var(--line-offset)",
            marginEnd: { _notLast: "var(--line-offset)" },
            _selected: {
              borderColor: "border",
              borderBottomColor: "transparent"
            }
          },
          _vertical: {
            borderStartRadius: "var(--tabs-trigger-radius)",
            marginEnd: "var(--line-offset)",
            marginBottom: { _notLast: "var(--line-offset)" },
            _selected: {
              borderColor: "border",
              borderEndColor: "transparent"
            }
          }
        }
      },
      plain: {
        trigger: {
          color: "fg.muted",
          _selected: {
            color: "colorPalette.fg"
          },
          borderRadius: "var(--tabs-trigger-radius)",
          "&[data-selected][data-ssr]": {
            bg: "var(--tabs-indicator-bg)",
            shadow: "var(--tabs-indicator-shadow)",
            borderRadius: "var(--tabs-indicator-radius)"
          }
        }
      }
    }
  },
  defaultVariants: {
    size: "md",
    variant: "line"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/tag.js
var _a7;
var badgeVariant = (_a7 = badgeRecipe.variants) == null ? void 0 : _a7.variant;
var tagSlotRecipe = defineSlotRecipe({
  slots: tagAnatomy.keys(),
  className: "chakra-tag",
  base: {
    root: {
      display: "inline-flex",
      alignItems: "center",
      verticalAlign: "top",
      maxWidth: "100%",
      userSelect: "none",
      borderRadius: "l2",
      focusVisibleRing: "outside"
    },
    label: {
      lineClamp: "1"
    },
    closeTrigger: {
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      outline: "0",
      borderRadius: "l1",
      color: "currentColor",
      focusVisibleRing: "inside",
      focusRingWidth: "2px"
    },
    startElement: {
      flexShrink: 0,
      boxSize: "var(--tag-element-size)",
      ms: "var(--tag-element-offset)",
      "&:has([data-scope=avatar])": {
        boxSize: "var(--tag-avatar-size)",
        ms: "calc(var(--tag-element-offset) * 1.5)"
      },
      _icon: { boxSize: "100%" }
    },
    endElement: {
      flexShrink: 0,
      boxSize: "var(--tag-element-size)",
      me: "var(--tag-element-offset)",
      _icon: { boxSize: "100%" },
      "&:has(button)": {
        ms: "calc(var(--tag-element-offset) * -1)"
      }
    }
  },
  variants: {
    size: {
      sm: {
        root: {
          px: "1.5",
          minH: "4.5",
          gap: "1",
          "--tag-avatar-size": "spacing.3",
          "--tag-element-size": "spacing.3",
          "--tag-element-offset": "-2px"
        },
        label: {
          textStyle: "xs"
        }
      },
      md: {
        root: {
          px: "1.5",
          minH: "5",
          gap: "1",
          "--tag-avatar-size": "spacing.3.5",
          "--tag-element-size": "spacing.3.5",
          "--tag-element-offset": "-2px"
        },
        label: {
          textStyle: "xs"
        }
      },
      lg: {
        root: {
          px: "2",
          minH: "6",
          gap: "1.5",
          "--tag-avatar-size": "spacing.4.5",
          "--tag-element-size": "spacing.4",
          "--tag-element-offset": "-3px"
        },
        label: {
          textStyle: "sm"
        }
      },
      xl: {
        root: {
          px: "2.5",
          minH: "8",
          gap: "1.5",
          "--tag-avatar-size": "spacing.6",
          "--tag-element-size": "spacing.4.5",
          "--tag-element-offset": "-4px"
        },
        label: {
          textStyle: "sm"
        }
      }
    },
    variant: {
      subtle: {
        root: badgeVariant == null ? void 0 : badgeVariant.subtle
      },
      solid: {
        root: badgeVariant == null ? void 0 : badgeVariant.solid
      },
      outline: {
        root: badgeVariant == null ? void 0 : badgeVariant.outline
      },
      surface: {
        root: badgeVariant == null ? void 0 : badgeVariant.surface
      }
    }
  },
  defaultVariants: {
    size: "md",
    variant: "surface"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/timeline.js
var timelineSlotRecipe = defineSlotRecipe({
  slots: timelineAnatomy.keys(),
  className: "chakra-timeline",
  base: {
    root: {
      display: "flex",
      flexDirection: "column",
      width: "full",
      "--timeline-thickness": "1px",
      "--timeline-gutter": "4px"
    },
    item: {
      display: "flex",
      position: "relative",
      alignItems: "flex-start",
      flexShrink: 0,
      gap: "4",
      _last: {
        "& :where(.chakra-timeline__separator)": { display: "none" }
      }
    },
    separator: {
      position: "absolute",
      borderStartWidth: "var(--timeline-thickness)",
      ms: "calc(-1 * var(--timeline-thickness) / 2)",
      insetInlineStart: "calc(var(--timeline-indicator-size) / 2)",
      insetBlock: "0",
      borderColor: "border"
    },
    indicator: {
      outline: "2px solid {colors.bg}",
      position: "relative",
      flexShrink: "0",
      boxSize: "var(--timeline-indicator-size)",
      fontSize: "var(--timeline-font-size)",
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      borderRadius: "full",
      fontWeight: "medium"
    },
    connector: {
      alignSelf: "stretch",
      position: "relative"
    },
    content: {
      pb: "6",
      display: "flex",
      flexDirection: "column",
      width: "full",
      gap: "2"
    },
    title: {
      display: "flex",
      fontWeight: "medium",
      flexWrap: "wrap",
      gap: "1.5",
      alignItems: "center",
      mt: "var(--timeline-margin)"
    },
    description: {
      color: "fg.muted",
      textStyle: "xs"
    }
  },
  variants: {
    variant: {
      subtle: {
        indicator: {
          bg: "colorPalette.muted"
        }
      },
      solid: {
        indicator: {
          bg: "colorPalette.solid",
          color: "colorPalette.contrast"
        }
      },
      outline: {
        indicator: {
          bg: "currentBg",
          borderWidth: "1px",
          borderColor: "colorPalette.muted"
        }
      },
      plain: {}
    },
    size: {
      sm: {
        root: {
          "--timeline-indicator-size": "sizes.4",
          "--timeline-font-size": "fontSizes.2xs"
        },
        title: {
          textStyle: "xs"
        }
      },
      md: {
        root: {
          "--timeline-indicator-size": "sizes.5",
          "--timeline-font-size": "fontSizes.xs"
        },
        title: {
          textStyle: "sm"
        }
      },
      lg: {
        root: {
          "--timeline-indicator-size": "sizes.6",
          "--timeline-font-size": "fontSizes.xs"
        },
        title: {
          mt: "0.5",
          textStyle: "sm"
        }
      },
      xl: {
        root: {
          "--timeline-indicator-size": "sizes.8",
          "--timeline-font-size": "fontSizes.sm"
        },
        title: {
          mt: "1.5",
          textStyle: "sm"
        }
      }
    }
  },
  defaultVariants: {
    size: "md",
    variant: "solid"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/toast.js
var toastSlotRecipe = defineSlotRecipe({
  slots: toastAnatomy.keys(),
  className: "chakra-toast",
  base: {
    root: {
      width: "full",
      display: "flex",
      alignItems: "flex-start",
      position: "relative",
      gap: "3",
      py: "4",
      ps: "4",
      pe: "6",
      borderRadius: "l2",
      translate: "var(--x) var(--y)",
      scale: "var(--scale)",
      zIndex: "var(--z-index)",
      height: "var(--height)",
      opacity: "var(--opacity)",
      willChange: "translate, opacity, scale",
      transition: "translate 400ms, scale 400ms, opacity 400ms, height 400ms, box-shadow 200ms",
      transitionTimingFunction: "cubic-bezier(0.21, 1.02, 0.73, 1)",
      _closed: {
        transition: "translate 400ms, scale 400ms, opacity 200ms",
        transitionTimingFunction: "cubic-bezier(0.06, 0.71, 0.55, 1)"
      },
      bg: "bg.panel",
      color: "fg",
      boxShadow: "xl",
      "--toast-trigger-bg": "colors.bg.muted",
      "&[data-type=warning]": {
        bg: "orange.solid",
        color: "orange.contrast",
        "--toast-trigger-bg": "{white/10}",
        "--toast-border-color": "{white/40}"
      },
      "&[data-type=success]": {
        bg: "green.solid",
        color: "green.contrast",
        "--toast-trigger-bg": "{white/10}",
        "--toast-border-color": "{white/40}"
      },
      "&[data-type=error]": {
        bg: "red.solid",
        color: "red.contrast",
        "--toast-trigger-bg": "{white/10}",
        "--toast-border-color": "{white/40}"
      }
    },
    title: {
      fontWeight: "medium",
      textStyle: "sm",
      marginEnd: "2"
    },
    description: {
      display: "inline",
      textStyle: "sm",
      opacity: "0.8"
    },
    indicator: {
      flexShrink: "0",
      boxSize: "5"
    },
    actionTrigger: {
      textStyle: "sm",
      fontWeight: "medium",
      height: "8",
      px: "3",
      borderRadius: "l2",
      alignSelf: "center",
      borderWidth: "1px",
      borderColor: "var(--toast-border-color, inherit)",
      transition: "background 200ms",
      _hover: {
        bg: "var(--toast-trigger-bg)"
      }
    },
    closeTrigger: {
      position: "absolute",
      top: "1",
      insetEnd: "1",
      padding: "1",
      display: "inline-flex",
      alignItems: "center",
      justifyContent: "center",
      color: "{currentColor/60}",
      borderRadius: "l2",
      textStyle: "md",
      transition: "background 200ms",
      _icon: {
        boxSize: "1em"
      }
    }
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/tooltip.js
var tooltipSlotRecipe = defineSlotRecipe({
  slots: anatomy40.keys(),
  className: "chakra-tooltip",
  base: {
    content: {
      "--tooltip-bg": "colors.bg.inverted",
      bg: "var(--tooltip-bg)",
      color: "fg.inverted",
      px: "2.5",
      py: "1",
      borderRadius: "l2",
      fontWeight: "medium",
      textStyle: "xs",
      boxShadow: "md",
      maxW: "xs",
      zIndex: "tooltip",
      transformOrigin: "var(--transform-origin)",
      _open: {
        animationStyle: "scale-fade-in",
        animationDuration: "fast"
      },
      _closed: {
        animationStyle: "scale-fade-out",
        animationDuration: "fast"
      }
    },
    arrow: {
      "--arrow-size": "sizes.2",
      "--arrow-background": "var(--tooltip-bg)"
    },
    arrowTip: {
      borderTopWidth: "1px",
      borderInlineStartWidth: "1px",
      borderColor: "var(--tooltip-bg)"
    }
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/slot-recipes.js
var slotRecipes = {
  accordion: accordionSlotRecipe,
  actionBar: actionBarSlotRecipe,
  alert: alertSlotRecipe,
  avatar: avatarSlotRecipe,
  blockquote: blockquoteSlotRecipe,
  breadcrumb: breadcrumbSlotRecipe,
  card: cardSlotRecipe,
  checkbox: checkboxSlotRecipe,
  checkboxCard: checkboxCardSlotRecipe,
  collapsible: collapsibleSlotRecipe,
  dataList: dataListSlotRecipe,
  dialog: dialogSlotRecipe,
  drawer: drawerSlotRecipe,
  editable: editableSlotRecipe,
  emptyState: emptyStateSlotRecipe,
  field: fieldSlotRecipe,
  fieldset: fieldsetSlotRecipe,
  fileUpload: fileUploadSlotRecipe,
  hoverCard: hoverCardSlotRecipe,
  list: listSlotRecipe,
  menu: menuSlotRecipe,
  nativeSelect: nativeSelectSlotRecipe,
  numberInput: numberInputSlotRecipe,
  pinInput: pinInputSlotRecipe,
  popover: popoverSlotRecipe,
  progress: progressSlotRecipe,
  progressCircle: progressCircleSlotRecipe,
  radioCard: radioCardSlotRecipe,
  radioGroup: radioGroupSlotRecipe,
  ratingGroup: ratingGroupSlotRecipe,
  segmentGroup: segmentGroupSlotRecipe,
  select: selectSlotRecipe,
  combobox: comboboxSlotRecipe,
  slider: sliderSlotRecipe,
  stat: statSlotRecipe,
  steps: stepsSlotRecipe,
  switch: switchSlotRecipe,
  table: tableSlotRecipe,
  tabs: tabsSlotRecipe,
  tag: tagSlotRecipe,
  toast: toastSlotRecipe,
  tooltip: tooltipSlotRecipe,
  status: statusSlotRecipe,
  timeline: timelineSlotRecipe,
  colorPicker: colorPickerSlotRecipe,
  qrCode: qrCodeSlotRecipe
};

// node_modules/@chakra-ui/react/dist/esm/theme/text-styles.js
var textStyles = defineTextStyles({
  "2xs": { value: { fontSize: "2xs", lineHeight: "0.75rem" } },
  xs: { value: { fontSize: "xs", lineHeight: "1rem" } },
  sm: { value: { fontSize: "sm", lineHeight: "1.25rem" } },
  md: { value: { fontSize: "md", lineHeight: "1.5rem" } },
  lg: { value: { fontSize: "lg", lineHeight: "1.75rem" } },
  xl: { value: { fontSize: "xl", lineHeight: "1.875rem" } },
  "2xl": { value: { fontSize: "2xl", lineHeight: "2rem" } },
  "3xl": { value: { fontSize: "3xl", lineHeight: "2.375rem" } },
  "4xl": {
    value: {
      fontSize: "4xl",
      lineHeight: "2.75rem",
      letterSpacing: "-0.025em"
    }
  },
  "5xl": {
    value: {
      fontSize: "5xl",
      lineHeight: "3.75rem",
      letterSpacing: "-0.025em"
    }
  },
  "6xl": {
    value: { fontSize: "6xl", lineHeight: "4.5rem", letterSpacing: "-0.025em" }
  },
  "7xl": {
    value: {
      fontSize: "7xl",
      lineHeight: "5.75rem",
      letterSpacing: "-0.025em"
    }
  },
  none: {
    value: {}
  },
  label: {
    value: {
      fontSize: "sm",
      lineHeight: "1.25rem",
      fontWeight: "medium"
    }
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/tokens/animations.js
var animations = defineTokens.animations({
  spin: { value: "spin 1s linear infinite" },
  ping: { value: "ping 1s cubic-bezier(0, 0, 0.2, 1) infinite" },
  pulse: { value: "pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite" },
  bounce: { value: "bounce 1s infinite" }
});

// node_modules/@chakra-ui/react/dist/esm/theme/tokens/aspect-ratios.js
var aspectRatios = defineTokens.aspectRatios({
  square: { value: "1 / 1" },
  landscape: { value: "4 / 3" },
  portrait: { value: "3 / 4" },
  wide: { value: "16 / 9" },
  ultrawide: { value: "18 / 5" },
  golden: { value: "1.618 / 1" }
});

// node_modules/@chakra-ui/react/dist/esm/theme/tokens/blurs.js
var blurs = defineTokens.blurs({
  none: { value: " " },
  sm: { value: "4px" },
  md: { value: "8px" },
  lg: { value: "12px" },
  xl: { value: "16px" },
  "2xl": { value: "24px" },
  "3xl": { value: "40px" },
  "4xl": { value: "64px" }
});

// node_modules/@chakra-ui/react/dist/esm/theme/tokens/borders.js
var borders = defineTokens.borders({
  xs: { value: "0.5px solid" },
  sm: { value: "1px solid" },
  md: { value: "2px solid" },
  lg: { value: "4px solid" },
  xl: { value: "8px solid" }
});

// node_modules/@chakra-ui/react/dist/esm/theme/tokens/colors.js
var colors = defineTokens.colors({
  transparent: { value: "transparent" },
  current: { value: "currentColor" },
  black: { value: "#09090B" },
  white: { value: "#FFFFFF" },
  whiteAlpha: {
    50: { value: "rgba(255, 255, 255, 0.04)" },
    100: { value: "rgba(255, 255, 255, 0.06)" },
    200: { value: "rgba(255, 255, 255, 0.08)" },
    300: { value: "rgba(255, 255, 255, 0.16)" },
    400: { value: "rgba(255, 255, 255, 0.24)" },
    500: { value: "rgba(255, 255, 255, 0.36)" },
    600: { value: "rgba(255, 255, 255, 0.48)" },
    700: { value: "rgba(255, 255, 255, 0.64)" },
    800: { value: "rgba(255, 255, 255, 0.80)" },
    900: { value: "rgba(255, 255, 255, 0.92)" },
    950: { value: "rgba(255, 255, 255, 0.95)" }
  },
  blackAlpha: {
    50: { value: "rgba(0, 0, 0, 0.04)" },
    100: { value: "rgba(0, 0, 0, 0.06)" },
    200: { value: "rgba(0, 0, 0, 0.08)" },
    300: { value: "rgba(0, 0, 0, 0.16)" },
    400: { value: "rgba(0, 0, 0, 0.24)" },
    500: { value: "rgba(0, 0, 0, 0.36)" },
    600: { value: "rgba(0, 0, 0, 0.48)" },
    700: { value: "rgba(0, 0, 0, 0.64)" },
    800: { value: "rgba(0, 0, 0, 0.80)" },
    900: { value: "rgba(0, 0, 0, 0.92)" },
    950: { value: "rgba(0, 0, 0, 0.95)" }
  },
  gray: {
    50: { value: "#fafafa" },
    100: { value: "#f4f4f5" },
    200: { value: "#e4e4e7" },
    300: { value: "#d4d4d8" },
    400: { value: "#a1a1aa" },
    500: { value: "#71717a" },
    600: { value: "#52525b" },
    700: { value: "#3f3f46" },
    800: { value: "#27272a" },
    900: { value: "#18181b" },
    950: { value: "#111111" }
  },
  red: {
    50: { value: "#fef2f2" },
    100: { value: "#fee2e2" },
    200: { value: "#fecaca" },
    300: { value: "#fca5a5" },
    400: { value: "#f87171" },
    500: { value: "#ef4444" },
    600: { value: "#dc2626" },
    700: { value: "#991919" },
    800: { value: "#511111" },
    900: { value: "#300c0c" },
    950: { value: "#1f0808" }
  },
  orange: {
    50: { value: "#fff7ed" },
    100: { value: "#ffedd5" },
    200: { value: "#fed7aa" },
    300: { value: "#fdba74" },
    400: { value: "#fb923c" },
    500: { value: "#f97316" },
    600: { value: "#ea580c" },
    700: { value: "#92310a" },
    800: { value: "#6c2710" },
    900: { value: "#3b1106" },
    950: { value: "#220a04" }
  },
  yellow: {
    50: { value: "#fefce8" },
    100: { value: "#fef9c3" },
    200: { value: "#fef08a" },
    300: { value: "#fde047" },
    400: { value: "#facc15" },
    500: { value: "#eab308" },
    600: { value: "#ca8a04" },
    700: { value: "#845209" },
    800: { value: "#713f12" },
    900: { value: "#422006" },
    950: { value: "#281304" }
  },
  green: {
    50: { value: "#f0fdf4" },
    100: { value: "#dcfce7" },
    200: { value: "#bbf7d0" },
    300: { value: "#86efac" },
    400: { value: "#4ade80" },
    500: { value: "#22c55e" },
    600: { value: "#16a34a" },
    700: { value: "#116932" },
    800: { value: "#124a28" },
    900: { value: "#042713" },
    950: { value: "#03190c" }
  },
  teal: {
    50: { value: "#f0fdfa" },
    100: { value: "#ccfbf1" },
    200: { value: "#99f6e4" },
    300: { value: "#5eead4" },
    400: { value: "#2dd4bf" },
    500: { value: "#14b8a6" },
    600: { value: "#0d9488" },
    700: { value: "#0c5d56" },
    800: { value: "#114240" },
    900: { value: "#032726" },
    950: { value: "#021716" }
  },
  blue: {
    50: { value: "#eff6ff" },
    100: { value: "#dbeafe" },
    200: { value: "#bfdbfe" },
    300: { value: "#a3cfff" },
    400: { value: "#60a5fa" },
    500: { value: "#3b82f6" },
    600: { value: "#2563eb" },
    700: { value: "#173da6" },
    800: { value: "#1a3478" },
    900: { value: "#14204a" },
    950: { value: "#0c142e" }
  },
  cyan: {
    50: { value: "#ecfeff" },
    100: { value: "#cffafe" },
    200: { value: "#a5f3fc" },
    300: { value: "#67e8f9" },
    400: { value: "#22d3ee" },
    500: { value: "#06b6d4" },
    600: { value: "#0891b2" },
    700: { value: "#0c5c72" },
    800: { value: "#134152" },
    900: { value: "#072a38" },
    950: { value: "#051b24" }
  },
  purple: {
    50: { value: "#faf5ff" },
    100: { value: "#f3e8ff" },
    200: { value: "#e9d5ff" },
    300: { value: "#d8b4fe" },
    400: { value: "#c084fc" },
    500: { value: "#a855f7" },
    600: { value: "#9333ea" },
    700: { value: "#641ba3" },
    800: { value: "#4a1772" },
    900: { value: "#2f0553" },
    950: { value: "#1a032e" }
  },
  pink: {
    50: { value: "#fdf2f8" },
    100: { value: "#fce7f3" },
    200: { value: "#fbcfe8" },
    300: { value: "#f9a8d4" },
    400: { value: "#f472b6" },
    500: { value: "#ec4899" },
    600: { value: "#db2777" },
    700: { value: "#a41752" },
    800: { value: "#6d0e34" },
    900: { value: "#45061f" },
    950: { value: "#2c0514" }
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/tokens/cursor.js
var cursor = defineTokens.cursor({
  button: { value: "pointer" },
  checkbox: { value: "default" },
  disabled: { value: "not-allowed" },
  menuitem: { value: "default" },
  option: { value: "default" },
  radio: { value: "default" },
  slider: { value: "default" },
  switch: { value: "pointer" }
});

// node_modules/@chakra-ui/react/dist/esm/theme/tokens/durations.js
var durations = defineTokens.durations({
  fastest: { value: "50ms" },
  faster: { value: "100ms" },
  fast: { value: "150ms" },
  moderate: { value: "200ms" },
  slow: { value: "300ms" },
  slower: { value: "400ms" },
  slowest: { value: "500ms" }
});

// node_modules/@chakra-ui/react/dist/esm/theme/tokens/easings.js
var easings = defineTokens.easings({
  "ease-in": { value: "cubic-bezier(0.42, 0, 1, 1)" },
  "ease-out": { value: "cubic-bezier(0, 0, 0.58, 1)" },
  "ease-in-out": { value: "cubic-bezier(0.42, 0, 0.58, 1)" },
  "ease-in-smooth": { value: "cubic-bezier(0.32, 0.72, 0, 1)" }
});

// node_modules/@chakra-ui/react/dist/esm/theme/tokens/font-sizes.js
var fontSizes = defineTokens.fontSizes({
  "2xs": { value: "0.625rem" },
  xs: { value: "0.75rem" },
  sm: { value: "0.875rem" },
  md: { value: "1rem" },
  lg: { value: "1.125rem" },
  xl: { value: "1.25rem" },
  "2xl": { value: "1.5rem" },
  "3xl": { value: "1.875rem" },
  "4xl": { value: "2.25rem" },
  "5xl": { value: "3rem" },
  "6xl": { value: "3.75rem" },
  "7xl": { value: "4.5rem" },
  "8xl": { value: "6rem" },
  "9xl": { value: "8rem" }
});

// node_modules/@chakra-ui/react/dist/esm/theme/tokens/font-weights.js
var fontWeights = defineTokens.fontWeights({
  thin: { value: "100" },
  extralight: { value: "200" },
  light: { value: "300" },
  normal: { value: "400" },
  medium: { value: "500" },
  semibold: { value: "600" },
  bold: { value: "700" },
  extrabold: { value: "800" },
  black: { value: "900" }
});

// node_modules/@chakra-ui/react/dist/esm/theme/tokens/fonts.js
var fallback3 = `-apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol"`;
var fonts = defineTokens.fonts({
  heading: {
    value: `Inter, ${fallback3}`
  },
  body: {
    value: `Inter, ${fallback3}`
  },
  mono: {
    value: `SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace`
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/tokens/keyframes.js
var keyframes = defineKeyframes({
  spin: {
    "0%": { transform: "rotate(0deg)" },
    "100%": { transform: "rotate(360deg)" }
  },
  pulse: {
    "50%": { opacity: "0.5" }
  },
  ping: {
    "75%, 100%": {
      transform: "scale(2)",
      opacity: "0"
    }
  },
  bounce: {
    "0%, 100%": {
      transform: "translateY(-25%)",
      animationTimingFunction: "cubic-bezier(0.8,0,1,1)"
    },
    "50%": {
      transform: "none",
      animationTimingFunction: "cubic-bezier(0,0,0.2,1)"
    }
  },
  "bg-position": {
    from: { backgroundPosition: "var(--animate-from, 1rem) 0" },
    to: { backgroundPosition: "var(--animate-to, 0) 0" }
  },
  position: {
    from: {
      insetInlineStart: "var(--animate-from-x)",
      insetBlockStart: "var(--animate-from-y)"
    },
    to: {
      insetInlineStart: "var(--animate-to-x)",
      insetBlockStart: "var(--animate-to-y)"
    }
  },
  "circular-progress": {
    "0%": {
      strokeDasharray: "1, 400",
      strokeDashoffset: "0"
    },
    "50%": {
      strokeDasharray: "400, 400",
      strokeDashoffset: "-100%"
    },
    "100%": {
      strokeDasharray: "400, 400",
      strokeDashoffset: "-260%"
    }
  },
  // collapse
  "expand-height": {
    from: { height: "0" },
    to: { height: "var(--height)" }
  },
  "collapse-height": {
    from: { height: "var(--height)" },
    to: { height: "0" }
  },
  "expand-width": {
    from: { width: "0" },
    to: { width: "var(--width)" }
  },
  "collapse-width": {
    from: { height: "var(--width)" },
    to: { height: "0" }
  },
  // fade
  "fade-in": {
    from: { opacity: 0 },
    to: { opacity: 1 }
  },
  "fade-out": {
    from: { opacity: 1 },
    to: { opacity: 0 }
  },
  // slide from (full)
  "slide-from-left-full": {
    from: { translate: "-100% 0" },
    to: { translate: "0 0" }
  },
  "slide-from-right-full": {
    from: { translate: "100% 0" },
    to: { translate: "0 0" }
  },
  "slide-from-top-full": {
    from: { translate: "0 -100%" },
    to: { translate: "0 0" }
  },
  "slide-from-bottom-full": {
    from: { translate: "0 100%" },
    to: { translate: "0 0" }
  },
  // slide to (full)
  "slide-to-left-full": {
    from: { translate: "0 0" },
    to: { translate: "-100% 0" }
  },
  "slide-to-right-full": {
    from: { translate: "0 0" },
    to: { translate: "100% 0" }
  },
  "slide-to-top-full": {
    from: { translate: "0 0" },
    to: { translate: "0 -100%" }
  },
  "slide-to-bottom-full": {
    from: { translate: "0 0" },
    to: { translate: "0 100%" }
  },
  // slide from
  "slide-from-top": {
    "0%": { translate: "0 -0.5rem" },
    to: { translate: "0" }
  },
  "slide-from-bottom": {
    "0%": { translate: "0 0.5rem" },
    to: { translate: "0" }
  },
  "slide-from-left": {
    "0%": { translate: "-0.5rem 0" },
    to: { translate: "0" }
  },
  "slide-from-right": {
    "0%": { translate: "0.5rem 0" },
    to: { translate: "0" }
  },
  // slide to
  "slide-to-top": {
    "0%": { translate: "0" },
    to: { translate: "0 -0.5rem" }
  },
  "slide-to-bottom": {
    "0%": { translate: "0" },
    to: { translate: "0 0.5rem" }
  },
  "slide-to-left": {
    "0%": { translate: "0" },
    to: { translate: "-0.5rem 0" }
  },
  "slide-to-right": {
    "0%": { translate: "0" },
    to: { translate: "0.5rem 0" }
  },
  // scale
  "scale-in": {
    from: { scale: "0.95" },
    to: { scale: "1" }
  },
  "scale-out": {
    from: { scale: "1" },
    to: { scale: "0.95" }
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/tokens/letter-spacing.js
var letterSpacings = defineTokens.letterSpacings({
  tighter: { value: "-0.05em" },
  tight: { value: "-0.025em" },
  wide: { value: "0.025em" },
  wider: { value: "0.05em" },
  widest: { value: "0.1em" }
});

// node_modules/@chakra-ui/react/dist/esm/theme/tokens/line-heights.js
var lineHeights = defineTokens.lineHeights({
  shorter: { value: 1.25 },
  short: { value: 1.375 },
  moderate: { value: 1.5 },
  tall: { value: 1.625 },
  taller: { value: 2 }
});

// node_modules/@chakra-ui/react/dist/esm/theme/tokens/radius.js
var radii = defineTokens.radii({
  none: { value: "0" },
  "2xs": { value: "0.0625rem" },
  xs: { value: "0.125rem" },
  sm: { value: "0.25rem" },
  md: { value: "0.375rem" },
  lg: { value: "0.5rem" },
  xl: { value: "0.75rem" },
  "2xl": { value: "1rem" },
  "3xl": { value: "1.5rem" },
  "4xl": { value: "2rem" },
  full: { value: "9999px" }
});

// node_modules/@chakra-ui/react/dist/esm/theme/tokens/spacing.js
var spacing = defineTokens.spacing({
  0.5: { value: "0.125rem" },
  1: { value: "0.25rem" },
  1.5: { value: "0.375rem" },
  2: { value: "0.5rem" },
  2.5: { value: "0.625rem" },
  3: { value: "0.75rem" },
  3.5: { value: "0.875rem" },
  4: { value: "1rem" },
  4.5: { value: "1.125rem" },
  5: { value: "1.25rem" },
  6: { value: "1.5rem" },
  7: { value: "1.75rem" },
  8: { value: "2rem" },
  9: { value: "2.25rem" },
  10: { value: "2.5rem" },
  11: { value: "2.75rem" },
  12: { value: "3rem" },
  14: { value: "3.5rem" },
  16: { value: "4rem" },
  20: { value: "5rem" },
  24: { value: "6rem" },
  28: { value: "7rem" },
  32: { value: "8rem" },
  36: { value: "9rem" },
  40: { value: "10rem" },
  44: { value: "11rem" },
  48: { value: "12rem" },
  52: { value: "13rem" },
  56: { value: "14rem" },
  60: { value: "15rem" },
  64: { value: "16rem" },
  72: { value: "18rem" },
  80: { value: "20rem" },
  96: { value: "24rem" }
});

// node_modules/@chakra-ui/react/dist/esm/theme/tokens/sizes.js
var largeSizes = defineTokens.sizes({
  "3xs": { value: "14rem" },
  "2xs": { value: "16rem" },
  xs: { value: "20rem" },
  sm: { value: "24rem" },
  md: { value: "28rem" },
  lg: { value: "32rem" },
  xl: { value: "36rem" },
  "2xl": { value: "42rem" },
  "3xl": { value: "48rem" },
  "4xl": { value: "56rem" },
  "5xl": { value: "64rem" },
  "6xl": { value: "72rem" },
  "7xl": { value: "80rem" },
  "8xl": { value: "90rem" }
});
var namedSizes = defineTokens.sizes({
  max: { value: "max-content" },
  min: { value: "min-content" },
  fit: { value: "fit-content" },
  prose: { value: "60ch" },
  full: { value: "100%" },
  dvh: { value: "100dvh" },
  svh: { value: "100svh" },
  lvh: { value: "100lvh" },
  dvw: { value: "100dvw" },
  svw: { value: "100svw" },
  lvw: { value: "100lvw" },
  vw: { value: "100vw" },
  vh: { value: "100vh" }
});
var fractionalSizes = defineTokens.sizes({
  "1/2": { value: "50%" },
  "1/3": { value: "33.333333%" },
  "2/3": { value: "66.666667%" },
  "1/4": { value: "25%" },
  "3/4": { value: "75%" },
  "1/5": { value: "20%" },
  "2/5": { value: "40%" },
  "3/5": { value: "60%" },
  "4/5": { value: "80%" },
  "1/6": { value: "16.666667%" },
  "2/6": { value: "33.333333%" },
  "3/6": { value: "50%" },
  "4/6": { value: "66.666667%" },
  "5/6": { value: "83.333333%" },
  "1/12": { value: "8.333333%" },
  "2/12": { value: "16.666667%" },
  "3/12": { value: "25%" },
  "4/12": { value: "33.333333%" },
  "5/12": { value: "41.666667%" },
  "6/12": { value: "50%" },
  "7/12": { value: "58.333333%" },
  "8/12": { value: "66.666667%" },
  "9/12": { value: "75%" },
  "10/12": { value: "83.333333%" },
  "11/12": { value: "91.666667%" }
});
var sizes = defineTokens.sizes({
  ...largeSizes,
  ...spacing,
  ...fractionalSizes,
  ...namedSizes
});

// node_modules/@chakra-ui/react/dist/esm/theme/tokens/z-indices.js
var zIndices = defineTokens.zIndex({
  hide: { value: -1 },
  base: { value: 0 },
  docked: { value: 10 },
  dropdown: { value: 1e3 },
  sticky: { value: 1100 },
  banner: { value: 1200 },
  overlay: { value: 1300 },
  modal: { value: 1400 },
  popover: { value: 1500 },
  skipNav: { value: 1600 },
  toast: { value: 1700 },
  tooltip: { value: 1800 },
  max: { value: 2147483647 }
});

// node_modules/@chakra-ui/react/dist/esm/theme/index.js
var defaultThemeConfig = defineConfig({
  preflight: true,
  cssVarsPrefix: "chakra",
  cssVarsRoot: ":where(html, .chakra-theme)",
  globalCss,
  theme: {
    breakpoints,
    keyframes,
    tokens: {
      aspectRatios,
      animations,
      blurs,
      borders,
      colors,
      durations,
      easings,
      fonts,
      fontSizes,
      fontWeights,
      letterSpacings,
      lineHeights,
      radii,
      spacing,
      sizes,
      zIndex: zIndices,
      cursor
    },
    semanticTokens: {
      colors: semanticColors,
      shadows: semanticShadows,
      radii: semanticRadii
    },
    recipes,
    slotRecipes,
    textStyles,
    layerStyles,
    animationStyles
  }
});

// node_modules/@chakra-ui/react/dist/esm/preset.js
var defaultConfig = mergeConfigs(defaultBaseConfig, defaultThemeConfig);
var defaultSystem = createSystem(defaultConfig);

// node_modules/@chakra-ui/react/dist/esm/styled-system/create-slot-recipe-context.js
var import_jsx_runtime455 = __toESM(require_jsx_runtime(), 1);
var import_react984 = __toESM(require_react(), 1);

// node_modules/@chakra-ui/react/dist/esm/styled-system/use-slot-recipe.js
var import_react983 = __toESM(require_react(), 1);
function useSlotRecipe(options) {
  const { key, recipe: recipeProp } = options;
  const sys = useChakraContext();
  return (0, import_react983.useMemo)(() => {
    const recipe = recipeProp || (key != null ? sys.getSlotRecipe(key) : {});
    return sys.sva(structuredClone(recipe));
  }, [key, recipeProp, sys]);
}

// node_modules/@chakra-ui/react/dist/esm/styled-system/create-slot-recipe-context.js
var upperFirst2 = (str) => str.charAt(0).toUpperCase() + str.slice(1);
var createSlotRecipeContext = (options) => {
  const { key: recipeKey, recipe: recipeConfig } = options;
  const contextName = upperFirst2(
    recipeKey || recipeConfig.className || "Component"
  );
  const [StylesProvider2, useStyles] = createContext({
    name: `${contextName}StylesContext`,
    errorMessage: `use${contextName}Styles returned is 'undefined'. Seems you forgot to wrap the components in "<${contextName}.Root />" `
  });
  const [ClassNamesProvider2, useClassNames5] = createContext({
    name: `${contextName}ClassNameContext`,
    errorMessage: `use${contextName}ClassNames returned is 'undefined'. Seems you forgot to wrap the components in "<${contextName}.Root />" `,
    strict: false
  });
  const [PropsProvider63, usePropsContext2] = createContext({
    strict: false,
    name: `${contextName}PropsContext`,
    providerName: `${contextName}PropsContext`,
    defaultValue: {}
  });
  function useRecipeResult6(props43) {
    const { unstyled, ...restProps } = props43;
    const slotRecipe = useSlotRecipe({
      key: recipeKey,
      recipe: restProps.recipe || recipeConfig
    });
    const [variantProps, otherProps] = (0, import_react984.useMemo)(
      () => slotRecipe.splitVariantProps(restProps),
      [restProps, slotRecipe]
    );
    const styles = (0, import_react984.useMemo)(
      () => unstyled ? EMPTY_SLOT_STYLES : slotRecipe(variantProps),
      [unstyled, variantProps, slotRecipe]
    );
    return {
      styles,
      classNames: slotRecipe.classNameMap,
      props: otherProps
    };
  }
  function withRootProvider8(Component, options2 = {}) {
    const { defaultProps } = options2;
    const StyledComponent = (inProps) => {
      const propsContext = usePropsContext2();
      const props43 = (0, import_react984.useMemo)(
        () => mergeProps(defaultProps, propsContext, inProps),
        [propsContext, inProps]
      );
      const { styles, classNames, props: rootProps2 } = useRecipeResult6(props43);
      return (0, import_jsx_runtime455.jsx)(StylesProvider2, { value: styles, children: (0, import_jsx_runtime455.jsx)(ClassNamesProvider2, { value: classNames, children: (0, import_jsx_runtime455.jsx)(Component, { ...rootProps2 }) }) });
    };
    StyledComponent.displayName = Component.displayName || Component.name;
    return StyledComponent;
  }
  const withProvider42 = (Component, slot, options2) => {
    const { defaultProps, ...restOptions } = options2 ?? {};
    const SuperComponent = chakra(Component, {}, restOptions);
    const StyledComponent = (0, import_react984.forwardRef)((inProps, ref) => {
      var _a8;
      const propsContext = usePropsContext2();
      const props43 = (0, import_react984.useMemo)(
        () => mergeProps(defaultProps ?? {}, propsContext, inProps),
        [propsContext, inProps]
      );
      const { styles, props: rootProps2, classNames } = useRecipeResult6(props43);
      const className = classNames[slot];
      const element = (0, import_jsx_runtime455.jsx)(StylesProvider2, { value: styles, children: (0, import_jsx_runtime455.jsx)(ClassNamesProvider2, { value: classNames, children: (0, import_jsx_runtime455.jsx)(
        SuperComponent,
        {
          ref,
          ...rootProps2,
          css: [styles[slot], props43.css],
          className: cx(props43.className, className)
        }
      ) }) });
      return ((_a8 = options2 == null ? void 0 : options2.wrapElement) == null ? void 0 : _a8.call(options2, element, props43)) ?? element;
    });
    StyledComponent.displayName = Component.displayName || Component.name;
    return StyledComponent;
  };
  const withContext62 = (Component, slot, options2) => {
    const SuperComponent = chakra(Component, {}, options2);
    const StyledComponent = (0, import_react984.forwardRef)((props43, ref) => {
      const styles = useStyles();
      const classNames = useClassNames5();
      const className = classNames == null ? void 0 : classNames[slot];
      return (0, import_jsx_runtime455.jsx)(
        SuperComponent,
        {
          ...props43,
          css: [slot ? styles[slot] : void 0, props43.css],
          ref,
          className: cx(props43.className, className)
        }
      );
    });
    StyledComponent.displayName = Component.displayName || Component.name;
    return StyledComponent;
  };
  return {
    StylesProvider: StylesProvider2,
    ClassNamesProvider: ClassNamesProvider2,
    PropsProvider: PropsProvider63,
    usePropsContext: usePropsContext2,
    useRecipeResult: useRecipeResult6,
    withProvider: withProvider42,
    withContext: withContext62,
    withRootProvider: withRootProvider8,
    useStyles,
    useClassNames: useClassNames5
  };
};

// node_modules/@chakra-ui/react/dist/esm/styled-system/recipe-props.js
var import_jsx_runtime456 = __toESM(require_jsx_runtime(), 1);
var [RecipePropsContextProvider, useParentRecipeProps] = createContext({
  name: "RecipePropsContext",
  strict: false
});
function RecipePropsProvider(props43) {
  return (0, import_jsx_runtime456.jsx)(RecipePropsContextProvider, { value: props43.value, children: props43.children });
}

// node_modules/@chakra-ui/react/dist/esm/styled-system/use-token.js
var import_react985 = __toESM(require_react(), 1);
function useToken(category, token) {
  const sys = useChakraContext();
  return (0, import_react985.useMemo)(() => {
    const arr = Array.isArray(token) ? token : [token];
    return arr.map((t) => sys.token(`${category}.${t}`, t));
  }, [sys, category, token]);
}

// node_modules/@chakra-ui/react/dist/esm/components/accordion/accordion.js
var import_jsx_runtime458 = __toESM(require_jsx_runtime(), 1);

// node_modules/@chakra-ui/react/dist/esm/components/icons.js
var import_jsx_runtime457 = __toESM(require_jsx_runtime(), 1);
var CheckIcon = (props43) => {
  return (0, import_jsx_runtime457.jsx)(
    chakra.svg,
    {
      viewBox: "0 0 24 24",
      fill: "none",
      stroke: "currentColor",
      strokeWidth: "2",
      strokeLinecap: "round",
      strokeLinejoin: "round",
      ...props43,
      children: (0, import_jsx_runtime457.jsx)("path", { d: "M20 6 9 17l-5-5" })
    }
  );
};
var ChevronUpIcon = (props43) => (0, import_jsx_runtime457.jsx)(
  chakra.svg,
  {
    viewBox: "0 0 24 24",
    fill: "none",
    stroke: "currentColor",
    strokeWidth: "2",
    strokeLinecap: "round",
    strokeLinejoin: "round",
    ...props43,
    children: (0, import_jsx_runtime457.jsx)("path", { d: "m18 15-6-6-6 6" })
  }
);
var ChevronDownIcon = (props43) => {
  return (0, import_jsx_runtime457.jsx)(
    chakra.svg,
    {
      viewBox: "0 0 24 24",
      fill: "none",
      stroke: "currentColor",
      strokeWidth: "2",
      strokeLinecap: "round",
      strokeLinejoin: "round",
      ...props43,
      children: (0, import_jsx_runtime457.jsx)("path", { d: "m6 9 6 6 6-6" })
    }
  );
};
var ChevronRightIcon = (props43) => (0, import_jsx_runtime457.jsx)(
  chakra.svg,
  {
    viewBox: "0 0 24 24",
    fill: "none",
    stroke: "currentColor",
    strokeWidth: "2",
    strokeLinecap: "round",
    strokeLinejoin: "round",
    ...props43,
    children: (0, import_jsx_runtime457.jsx)("path", { d: "m9 18 6-6-6-6" })
  }
);
var EllpsisIcon = (props43) => (0, import_jsx_runtime457.jsxs)(
  chakra.svg,
  {
    viewBox: "0 0 24 24",
    fill: "none",
    stroke: "currentColor",
    strokeWidth: "2",
    strokeLinecap: "round",
    strokeLinejoin: "round",
    ...props43,
    children: [
      (0, import_jsx_runtime457.jsx)("circle", { cx: "12", cy: "12", r: "1" }),
      (0, import_jsx_runtime457.jsx)("circle", { cx: "19", cy: "12", r: "1" }),
      (0, import_jsx_runtime457.jsx)("circle", { cx: "5", cy: "12", r: "1" })
    ]
  }
);
var ArrowUpIcon = (props43) => (0, import_jsx_runtime457.jsxs)(
  chakra.svg,
  {
    viewBox: "0 0 24 24",
    fill: "none",
    stroke: "currentColor",
    strokeWidth: "3",
    strokeLinecap: "round",
    strokeLinejoin: "round",
    ...props43,
    children: [
      (0, import_jsx_runtime457.jsx)("path", { d: "m5 12 7-7 7 7" }),
      (0, import_jsx_runtime457.jsx)("path", { d: "M12 19V5" })
    ]
  }
);
var ArrowDownIcon = (props43) => (0, import_jsx_runtime457.jsxs)(
  chakra.svg,
  {
    viewBox: "0 0 24 24",
    fill: "none",
    stroke: "currentColor",
    strokeWidth: "3",
    strokeLinecap: "round",
    strokeLinejoin: "round",
    ...props43,
    children: [
      (0, import_jsx_runtime457.jsx)("path", { d: "M12 5v14" }),
      (0, import_jsx_runtime457.jsx)("path", { d: "m19 12-7 7-7-7" })
    ]
  }
);
var CheckCircleIcon = (props43) => (0, import_jsx_runtime457.jsx)(
  chakra.svg,
  {
    stroke: "currentColor",
    fill: "currentColor",
    strokeWidth: "0",
    viewBox: "0 0 24 24",
    ...props43,
    children: (0, import_jsx_runtime457.jsx)("path", { d: "M12 22C6.47715 22 2 17.5228 2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22ZM12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20ZM11.0026 16L6.75999 11.7574L8.17421 10.3431L11.0026 13.1716L16.6595 7.51472L18.0737 8.92893L11.0026 16Z" })
  }
);
var WarningIcon = (props43) => (0, import_jsx_runtime457.jsx)(
  chakra.svg,
  {
    stroke: "currentColor",
    fill: "currentColor",
    strokeWidth: "0",
    viewBox: "0 0 24 24",
    ...props43,
    children: (0, import_jsx_runtime457.jsx)("path", { d: "M12 22C6.47715 22 2 17.5228 2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22ZM12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20ZM11 15H13V17H11V15ZM11 7H13V13H11V7Z" })
  }
);
var InfoIcon = (props43) => (0, import_jsx_runtime457.jsx)(
  chakra.svg,
  {
    viewBox: "0 0 24 24",
    fill: "currentColor",
    stroke: "currentColor",
    strokeWidth: "0",
    ...props43,
    children: (0, import_jsx_runtime457.jsx)("path", { d: "M12 22C6.47715 22 2 17.5228 2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22ZM12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20ZM11 7H13V9H11V7ZM11 11H13V17H11V11Z" })
  }
);
var QuoteIcon = (props43) => (0, import_jsx_runtime457.jsx)(chakra.svg, { viewBox: "0 0 24 24", fill: "currentColor", ...props43, children: (0, import_jsx_runtime457.jsx)("path", { d: "M6.5 10c-.223 0-.437.034-.65.065.069-.232.14-.468.254-.68.114-.308.292-.575.469-.844.148-.291.409-.488.601-.737.201-.242.475-.403.692-.604.213-.21.492-.315.714-.463.232-.133.434-.28.65-.35l.539-.222.474-.197-.485-1.938-.597.144c-.191.048-.424.104-.689.171-.271.05-.56.187-.882.312-.318.142-.686.238-1.028.466-.344.218-.741.4-1.091.692-.339.301-.748.562-1.05.945-.33.358-.656.734-.909 1.162-.293.408-.492.856-.702 1.299-.19.443-.343.896-.468 1.336-.237.882-.343 1.72-.384 2.437-.034.718-.014 1.315.028 1.747.015.204.043.402.063.539l.025.168.026-.006A4.5 4.5 0 1 0 6.5 10zm11 0c-.223 0-.437.034-.65.065.069-.232.14-.468.254-.68.114-.308.292-.575.469-.844.148-.291.409-.488.601-.737.201-.242.475-.403.692-.604.213-.21.492-.315.714-.463.232-.133.434-.28.65-.35l.539-.222.474-.197-.485-1.938-.597.144c-.191.048-.424.104-.689.171-.271.05-.56.187-.882.312-.317.143-.686.238-1.028.467-.344.218-.741.4-1.091.692-.339.301-.748.562-1.05.944-.33.358-.656.734-.909 1.162-.293.408-.492.856-.702 1.299-.19.443-.343.896-.468 1.336-.237.882-.343 1.72-.384 2.437-.034.718-.014 1.315.028 1.747.015.204.043.402.063.539l.025.168.026-.006A4.5 4.5 0 1 0 17.5 10z" }) });
var StarIcon = (props43) => (0, import_jsx_runtime457.jsx)(chakra.svg, { viewBox: "0 0 24 24", fill: "currentColor", ...props43, children: (0, import_jsx_runtime457.jsx)("path", { d: "M12 17.27L18.18 21l-1.64-7.03L22 9.24l-7.19-.61L12 2 9.19 8.63 2 9.24l5.46 4.73L5.82 21z" }) });
var CloseIcon = (props43) => (0, import_jsx_runtime457.jsx)(chakra.svg, { viewBox: "0 0 24 24", fill: "currentColor", ...props43, children: (0, import_jsx_runtime457.jsx)(
  "path",
  {
    fillRule: "evenodd",
    clipRule: "evenodd",
    d: "M18.7071 6.70711C19.0976 6.31658 19.0976 5.68342 18.7071 5.29289C18.3166 4.90237 17.6834 4.90237 17.2929 5.29289L12 10.5858L6.70711 5.29289C6.31658 4.90237 5.68342 4.90237 5.29289 5.29289C4.90237 5.68342 4.90237 6.31658 5.29289 6.70711L10.5858 12L5.29289 17.2929C4.90237 17.6834 4.90237 18.3166 5.29289 18.7071C5.68342 19.0976 6.31658 19.0976 6.70711 18.7071L12 13.4142L17.2929 18.7071C17.6834 19.0976 18.3166 19.0976 18.7071 18.7071C19.0976 18.3166 19.0976 17.6834 18.7071 17.2929L13.4142 12L18.7071 6.70711Z"
  }
) });
var FileIcon = (props43) => (0, import_jsx_runtime457.jsxs)(
  chakra.svg,
  {
    stroke: "currentColor",
    fill: "none",
    strokeWidth: "2",
    viewBox: "0 0 24 24",
    strokeLinecap: "round",
    strokeLinejoin: "round",
    ...props43,
    children: [
      (0, import_jsx_runtime457.jsx)("path", { d: "M15 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7Z" }),
      (0, import_jsx_runtime457.jsx)("path", { d: "M14 2v4a2 2 0 0 0 2 2h4" })
    ]
  }
);
var CopyIcon = (props43) => (0, import_jsx_runtime457.jsxs)(
  chakra.svg,
  {
    stroke: "currentColor",
    fill: "none",
    strokeWidth: "2",
    viewBox: "0 0 24 24",
    strokeLinecap: "round",
    strokeLinejoin: "round",
    ...props43,
    children: [
      (0, import_jsx_runtime457.jsx)("rect", { width: "14", height: "14", x: "8", y: "8", rx: "2", ry: "2" }),
      (0, import_jsx_runtime457.jsx)("path", { d: "M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2" })
    ]
  }
);
var PipetteIcon = (props43) => (0, import_jsx_runtime457.jsxs)(
  chakra.svg,
  {
    stroke: "currentColor",
    fill: "none",
    strokeWidth: "2",
    viewBox: "0 0 24 24",
    strokeLinecap: "round",
    strokeLinejoin: "round",
    ...props43,
    children: [
      (0, import_jsx_runtime457.jsx)("path", { d: "m2 22 1-1h3l9-9" }),
      (0, import_jsx_runtime457.jsx)("path", { d: "M3 21v-3l9-9" }),
      (0, import_jsx_runtime457.jsx)("path", { d: "m15 6 3.4-3.4a2.1 2.1 0 1 1 3 3L18 9l.4.4a2.1 2.1 0 1 1-3 3l-3.8-3.8a2.1 2.1 0 1 1 3-3l.4.4Z" })
    ]
  }
);
var EllipsisIcon = (props43) => (0, import_jsx_runtime457.jsxs)(
  chakra.svg,
  {
    stroke: "currentColor",
    fill: "none",
    strokeWidth: "2",
    viewBox: "0 0 24 24",
    strokeLinecap: "round",
    strokeLinejoin: "round",
    ...props43,
    children: [
      (0, import_jsx_runtime457.jsx)("circle", { cx: "12", cy: "12", r: "1" }),
      (0, import_jsx_runtime457.jsx)("circle", { cx: "19", cy: "12", r: "1" }),
      (0, import_jsx_runtime457.jsx)("circle", { cx: "5", cy: "12", r: "1" })
    ]
  }
);

// node_modules/@chakra-ui/react/dist/esm/components/accordion/accordion.js
var {
  withProvider,
  withContext: withContext2,
  useStyles: useAccordionStyles,
  PropsProvider
} = createSlotRecipeContext({ key: "accordion" });
var AccordionRootProvider2 = withProvider(accordion_exports.RootProvider, "root", { forwardAsChild: true });
var AccordionRoot2 = withProvider(
  accordion_exports.Root,
  "root",
  { forwardAsChild: true }
);
var AccordionPropsProvider = PropsProvider;
var AccordionItem2 = withContext2(
  accordion_exports.Item,
  "item",
  { forwardAsChild: true }
);
var AccordionItemContent2 = withContext2(accordion_exports.ItemContent, "itemContent", { forwardAsChild: true });
var AccordionItemBody = withContext2("div", "itemBody");
var AccordionItemTrigger2 = withContext2(accordion_exports.ItemTrigger, "itemTrigger", { forwardAsChild: true });
var AccordionItemIndicator2 = withContext2(accordion_exports.ItemIndicator, "itemIndicator", {
  forwardAsChild: true,
  defaultProps: {
    children: (0, import_jsx_runtime458.jsx)(ChevronDownIcon, {})
  }
});
var AccordionContext2 = accordion_exports.Context;
var AccordionItemContext2 = accordion_exports.ItemContext;

// node_modules/@chakra-ui/react/dist/esm/components/accordion/namespace.js
var namespace_exports = {};
__export(namespace_exports, {
  Context: () => AccordionContext2,
  Item: () => AccordionItem2,
  ItemBody: () => AccordionItemBody,
  ItemContent: () => AccordionItemContent2,
  ItemContext: () => AccordionItemContext2,
  ItemIndicator: () => AccordionItemIndicator2,
  ItemTrigger: () => AccordionItemTrigger2,
  PropsProvider: () => AccordionPropsProvider,
  Root: () => AccordionRoot2,
  RootProvider: () => AccordionRootProvider2
});

// node_modules/@chakra-ui/react/dist/esm/components/action-bar/action-bar.js
var {
  withRootProvider,
  withContext: withContext3,
  useStyles: useActionBarStyles,
  PropsProvider: PropsProvider2
} = createSlotRecipeContext({ key: "actionBar" });
var ActionBarRootProvider = withRootProvider(popover_exports.RootProvider, {
  defaultProps: {
    lazyMount: true,
    unmountOnExit: true
  }
});
var ActionBarRoot = withRootProvider(
  popover_exports.Root,
  {
    defaultProps: {
      autoFocus: false,
      lazyMount: true,
      unmountOnExit: true
    }
  }
);
var ActionBarPropsProvider = PropsProvider2;
var ActionBarPositioner = withContext3("div", "positioner", { forwardAsChild: true });
var ActionBarContent = withContext3(popover_exports.Content, "content", { forwardAsChild: true });
var ActionBarSeparator = withContext3("div", "separator");
var ActionBarSelectionTrigger = withContext3("button", "selectionTrigger");
var ActionBarCloseTrigger = withContext3(popover_exports.CloseTrigger, "closeTrigger", { forwardAsChild: true });
var ActionBarContext = popover_exports.Context;

// node_modules/@chakra-ui/react/dist/esm/components/action-bar/namespace.js
var namespace_exports2 = {};
__export(namespace_exports2, {
  CloseTrigger: () => ActionBarCloseTrigger,
  Content: () => ActionBarContent,
  Context: () => ActionBarContext,
  Positioner: () => ActionBarPositioner,
  PropsProvider: () => ActionBarPropsProvider,
  Root: () => ActionBarRoot,
  RootProvider: () => ActionBarRootProvider,
  SelectionTrigger: () => ActionBarSelectionTrigger,
  Separator: () => ActionBarSeparator
});

// node_modules/@chakra-ui/react/dist/esm/components/alert/alert.js
var import_jsx_runtime459 = __toESM(require_jsx_runtime(), 1);
var import_react986 = __toESM(require_react(), 1);
var [AlertStatusProvider, useAlertStatusContext] = createContext({
  name: "AlertStatusContext",
  hookName: "useAlertStatusContext",
  providerName: "<Alert />"
});
var {
  withProvider: withProvider2,
  withContext: withContext4,
  useStyles: useAlertStyles,
  PropsProvider: PropsProvider3
} = createSlotRecipeContext({ key: "alert" });
var AlertRoot = withProvider2(
  "div",
  "root",
  {
    forwardAsChild: true,
    wrapElement(element, props43) {
      return (
        // @ts-ignore fix later
        (0, import_jsx_runtime459.jsx)(AlertStatusProvider, { value: { status: props43.status || "info" }, children: element })
      );
    }
  }
);
var AlertPropsProvider = PropsProvider3;
var AlertTitle = withContext4(
  "div",
  "title"
);
var AlertDescription = withContext4("div", "description");
var AlertContent = withContext4(
  "div",
  "content"
);
var iconMap = {
  info: InfoIcon,
  warning: WarningIcon,
  success: CheckCircleIcon,
  error: WarningIcon,
  neutral: InfoIcon
};
var AlertIndicator = (0, import_react986.forwardRef)(
  function AlertIndicator2(props43, ref) {
    const api = useAlertStatusContext();
    const styles = useAlertStyles();
    const Icon3 = typeof api.status === "string" ? iconMap[api.status] : import_react986.Fragment;
    const { children = (0, import_jsx_runtime459.jsx)(Icon3, {}), ...rest } = props43;
    return (0, import_jsx_runtime459.jsx)(chakra.span, { ref, ...rest, css: [styles.indicator, props43.css], children });
  }
);

// node_modules/@chakra-ui/react/dist/esm/components/alert/namespace.js
var namespace_exports3 = {};
__export(namespace_exports3, {
  Content: () => AlertContent,
  Description: () => AlertDescription,
  Indicator: () => AlertIndicator,
  Root: () => AlertRoot,
  RootPropsProvider: () => AlertPropsProvider,
  Title: () => AlertTitle
});

// node_modules/@chakra-ui/react/dist/esm/components/aspect-ratio/aspect-ratio.js
var import_jsx_runtime460 = __toESM(require_jsx_runtime(), 1);
var import_react987 = __toESM(require_react(), 1);
var baseStyle = defineStyle({
  "& > *:not(style)": {
    overflow: "hidden",
    position: "absolute",
    top: "0",
    right: "0",
    bottom: "0",
    left: "0",
    display: "flex",
    justifyContent: "center",
    alignItems: "center",
    width: "100%",
    height: "100%"
  },
  "& > img, & > video": {
    objectFit: "cover"
  }
});
var AspectRatio = (0, import_react987.forwardRef)(
  function AspectRatio2(props43, ref) {
    const { ratio = 4 / 3, children, className, ...rest } = props43;
    const child = import_react987.Children.only(children);
    return (0, import_jsx_runtime460.jsx)(
      chakra.div,
      {
        ref,
        position: "relative",
        className: cx("chakra-aspect-ratio", className),
        _before: {
          height: 0,
          content: `""`,
          display: "block",
          paddingBottom: mapObject(ratio, (r) => `${1 / r * 100}%`)
        },
        ...rest,
        css: [baseStyle, props43.css],
        children: child
      }
    );
  }
);

// node_modules/@chakra-ui/react/dist/esm/components/avatar/avatar.js
var import_jsx_runtime462 = __toESM(require_jsx_runtime(), 1);
var import_react989 = __toESM(require_react(), 1);

// node_modules/@chakra-ui/react/dist/esm/components/group/group.js
var import_jsx_runtime461 = __toESM(require_jsx_runtime(), 1);
var import_react988 = __toESM(require_react(), 1);

// node_modules/@chakra-ui/react/dist/esm/utils/attr.js
var dataAttr2 = (condition) => condition ? "" : void 0;

// node_modules/@chakra-ui/react/dist/esm/components/group/group.js
var StyledGroup = chakra("div", {
  base: {
    display: "inline-flex",
    gap: "0.5rem",
    isolation: "isolate",
    position: "relative",
    "& [data-group-item]": {
      _focusVisible: {
        zIndex: 1
      }
    }
  },
  variants: {
    orientation: {
      horizontal: {
        flexDirection: "row"
      },
      vertical: {
        flexDirection: "column"
      }
    },
    attached: {
      true: {
        gap: "0!"
      }
    },
    grow: {
      true: {
        display: "flex",
        "& > *": {
          flex: 1
        }
      }
    },
    stacking: {
      "first-on-top": {
        "& > [data-group-item]": {
          zIndex: "calc(var(--group-count) - var(--group-index))"
        }
      },
      "last-on-top": {
        "& > [data-group-item]": {
          zIndex: "var(--group-index)"
        }
      }
    }
  },
  compoundVariants: [
    {
      orientation: "horizontal",
      attached: true,
      css: {
        "& > *[data-first]": {
          borderEndRadius: "0!",
          marginEnd: "-1px"
        },
        "& > *[data-between]": {
          borderRadius: "0!",
          marginEnd: "-1px"
        },
        "& > *[data-last]": {
          borderStartRadius: "0!"
        }
      }
    },
    {
      orientation: "vertical",
      attached: true,
      css: {
        "& > *[data-first]": {
          borderBottomRadius: "0!",
          marginBottom: "-1px"
        },
        "& > *[data-between]": {
          borderRadius: "0!",
          marginBottom: "-1px"
        },
        "& > *[data-last]": {
          borderTopRadius: "0!"
        }
      }
    }
  ],
  defaultVariants: {
    orientation: "horizontal"
  }
});
var Group = (0, import_react988.memo)(
  (0, import_react988.forwardRef)(function Group2(props43, ref) {
    const {
      align = "center",
      justify = "flex-start",
      children,
      wrap: wrap5,
      skip,
      ...rest
    } = props43;
    const _children = (0, import_react988.useMemo)(() => {
      let childArray = import_react988.Children.toArray(children).filter(import_react988.isValidElement);
      if (childArray.length === 1) return childArray;
      const validChildArray = childArray.filter((child) => !(skip == null ? void 0 : skip(child)));
      const validChildCount = validChildArray.length;
      if (validChildArray.length === 1) return childArray;
      return childArray.map((child) => {
        const childProps = child.props;
        if (skip == null ? void 0 : skip(child)) return child;
        const index = validChildArray.indexOf(child);
        return (0, import_react988.cloneElement)(child, {
          ...childProps,
          "data-group-item": "",
          "data-first": dataAttr2(index === 0),
          "data-last": dataAttr2(index === validChildCount - 1),
          "data-between": dataAttr2(index > 0 && index < validChildCount - 1),
          style: {
            "--group-count": validChildCount,
            "--group-index": index,
            ...(childProps == null ? void 0 : childProps.style) ?? {}
          }
        });
      });
    }, [children, skip]);
    return (0, import_jsx_runtime461.jsx)(
      StyledGroup,
      {
        ref,
        alignItems: align,
        justifyContent: justify,
        flexWrap: wrap5,
        ...rest,
        className: cx("chakra-group", props43.className),
        children: _children
      }
    );
  })
);

// node_modules/@chakra-ui/react/dist/esm/components/avatar/avatar.js
var {
  withProvider: withProvider3,
  withContext: withContext5,
  useStyles: useAvatarStyles,
  useClassNames,
  PropsProvider: PropsProvider4
} = createSlotRecipeContext({ key: "avatar" });
var AvatarRootProvider2 = withProvider3(avatar_exports.RootProvider, "root", { forwardAsChild: true });
var AvatarRoot2 = withProvider3(
  avatar_exports.Root,
  "root",
  { forwardAsChild: true }
);
var AvatarPropsProvider = PropsProvider4;
var StyledFallback = chakra(avatar_exports.Fallback, {}, { forwardAsChild: true });
function getFallbackChildren(props43) {
  if (props43.children || props43.asChild) return props43.children;
  if (props43.name) return getInitials(props43.name);
  return (0, import_jsx_runtime462.jsx)(AvatarIcon, {});
}
function getInitials(name) {
  const names = name.trim().split(" ");
  const firstName = names[0] != null ? names[0] : "";
  const lastName = names.length > 1 ? names[names.length - 1] : "";
  return firstName && lastName ? `${firstName.charAt(0)}${lastName.charAt(0)}` : firstName.charAt(0);
}
var AvatarFallback2 = (0, import_react989.forwardRef)(
  function AvatarFallback22(props43, ref) {
    const styles = useAvatarStyles();
    const classNames = useClassNames();
    const { name: _, ...rest } = props43;
    return (0, import_jsx_runtime462.jsx)(
      StyledFallback,
      {
        ref,
        ...rest,
        className: cx(props43.className, classNames.fallback),
        css: [styles.fallback, props43.css],
        children: getFallbackChildren(props43)
      }
    );
  }
);
var AvatarImage2 = withContext5(
  avatar_exports.Image,
  "image",
  {
    forwardAsChild: true,
    defaultProps: {
      draggable: "false",
      referrerPolicy: "no-referrer"
    }
  }
);
var AvatarIcon = (0, import_react989.forwardRef)(
  function AvatarIcon2(props43, ref) {
    return (0, import_jsx_runtime462.jsx)(
      chakra.svg,
      {
        stroke: "currentColor",
        fill: "currentColor",
        strokeWidth: "0",
        viewBox: "0 0 24 24",
        height: "1.2em",
        width: "1.2em",
        ref,
        ...props43,
        children: (0, import_jsx_runtime462.jsx)("path", { d: "M20 22H18V20C18 18.3431 16.6569 17 15 17H9C7.34315 17 6 18.3431 6 20V22H4V20C4 17.2386 6.23858 15 9 15H15C17.7614 15 20 17.2386 20 20V22ZM12 13C8.68629 13 6 10.3137 6 7C6 3.68629 8.68629 1 12 1C15.3137 1 18 3.68629 18 7C18 10.3137 15.3137 13 12 13ZM12 11C14.2091 11 16 9.20914 16 7C16 4.79086 14.2091 3 12 3C9.79086 3 8 4.79086 8 7C8 9.20914 9.79086 11 12 11Z" })
      }
    );
  }
);
var AvatarContext2 = avatar_exports.Context;
var AvatarGroup = (0, import_react989.forwardRef)(
  function AvatarGroup2(props43, ref) {
    const recipe = useSlotRecipe({ key: "avatar" });
    const [variantProps, localProps] = (0, import_react989.useMemo)(
      () => recipe.splitVariantProps(props43),
      [props43, recipe]
    );
    return (0, import_jsx_runtime462.jsx)(PropsProvider4, { value: variantProps, children: (0, import_jsx_runtime462.jsx)(Group, { gap: "0", spaceX: "-3", ref, ...localProps }) });
  }
);

// node_modules/@chakra-ui/react/dist/esm/components/avatar/namespace.js
var namespace_exports4 = {};
__export(namespace_exports4, {
  Context: () => AvatarContext2,
  Fallback: () => AvatarFallback2,
  Icon: () => AvatarIcon,
  Image: () => AvatarImage2,
  PropsProvider: () => AvatarPropsProvider,
  Root: () => AvatarRoot2,
  RootProvider: () => AvatarRootProvider2
});

// node_modules/@chakra-ui/react/dist/esm/components/badge/badge.js
var { PropsProvider: PropsProvider5, withContext: withContext6 } = createRecipeContext({
  key: "badge"
});
var Badge = withContext6("span");
var BadgePropsProvider = PropsProvider5;

// node_modules/@chakra-ui/react/dist/esm/components/bleed/bleed.js
var import_jsx_runtime463 = __toESM(require_jsx_runtime(), 1);
var import_react990 = __toESM(require_react(), 1);

// node_modules/@chakra-ui/react/dist/esm/utils/unit.js
var lengthUnits = "cm,mm,Q,in,pc,pt,px,em,ex,ch,rem,lh,rlh,vw,vh,vmin,vmax,vb,vi,svw,svh,lvw,lvh,dvw,dvh,cqw,cqh,cqi,cqb,cqmin,cqmax,%";
var lengthUnitsPattern = `(?:${lengthUnits.split(",").join("|")})`;
var lengthRegExp = new RegExp(
  `^[+-]?[0-9]*.?[0-9]+(?:[eE][+-]?[0-9]+)?${lengthUnitsPattern}$`
);
var isCssUnit = (v) => typeof v === "string" && lengthRegExp.test(v);

// node_modules/@chakra-ui/react/dist/esm/components/bleed/bleed.js
var valueFn = (v) => isCssUnit(v) || isCssVar(v) ? v : `token(spacing.${v}, ${v})`;
var Bleed = (0, import_react990.forwardRef)(
  function Bleed2(props43, ref) {
    const {
      inline: inline2,
      inlineStart,
      inlineEnd,
      block,
      blockStart,
      blockEnd,
      ...rest
    } = props43;
    return (0, import_jsx_runtime463.jsx)(
      chakra.div,
      {
        ref,
        ...rest,
        css: {
          "--bleed-inline-start": mapObject(inline2 ?? inlineStart, valueFn),
          "--bleed-inline-end": mapObject(inline2 ?? inlineEnd, valueFn),
          "--bleed-block-start": mapObject(block ?? blockStart, valueFn),
          "--bleed-block-end": mapObject(block ?? blockEnd, valueFn),
          marginInlineStart: "calc(var(--bleed-inline-start, 0) * -1)",
          marginInlineEnd: "calc(var(--bleed-inline-end, 0) * -1)",
          marginBlockStart: "calc(var(--bleed-block-start, 0) * -1)",
          marginBlockEnd: "calc(var(--bleed-block-end, 0) * -1)"
        }
      }
    );
  }
);

// node_modules/@chakra-ui/react/dist/esm/components/blockquote/blockquote.js
var {
  withProvider: withProvider4,
  withContext: withContext7,
  useStyles: useBlockquoteStyles,
  PropsProvider: PropsProvider6
} = createSlotRecipeContext({ key: "blockquote" });
var BlockquoteRoot = withProvider4(
  "figure",
  "root"
);
var BlockquotePropsProvider = PropsProvider6;
var BlockquoteContent = withContext7("blockquote", "content");
var BlockquoteCaption = withContext7("figcaption", "caption");
var BlockquoteIcon = withContext7(
  QuoteIcon,
  "icon"
);

// node_modules/@chakra-ui/react/dist/esm/components/blockquote/namespace.js
var namespace_exports5 = {};
__export(namespace_exports5, {
  Caption: () => BlockquoteCaption,
  Content: () => BlockquoteContent,
  Icon: () => BlockquoteIcon,
  PropsProvider: () => BlockquotePropsProvider,
  Root: () => BlockquoteRoot
});

// node_modules/@chakra-ui/react/dist/esm/components/box/box.js
var Box = chakra("div");
Box.displayName = "Box";

// node_modules/@chakra-ui/react/dist/esm/components/box/square.js
var import_jsx_runtime464 = __toESM(require_jsx_runtime(), 1);
var import_react991 = __toESM(require_react(), 1);
var Square = (0, import_react991.forwardRef)(
  function Square2(props43, ref) {
    const { size: size3, ...rest } = props43;
    return (0, import_jsx_runtime464.jsx)(
      Box,
      {
        ...rest,
        ref,
        boxSize: size3,
        css: {
          display: "flex",
          alignItems: "center",
          justifyContent: "center",
          flexShrink: 0,
          flexGrow: 0,
          ...props43.css
        }
      }
    );
  }
);

// node_modules/@chakra-ui/react/dist/esm/components/box/circle.js
var import_jsx_runtime465 = __toESM(require_jsx_runtime(), 1);
var import_react992 = __toESM(require_react(), 1);
var Circle = (0, import_react992.forwardRef)(
  function Circle2(props43, ref) {
    const { size: size3, ...rest } = props43;
    return (0, import_jsx_runtime465.jsx)(Square, { size: size3, ref, borderRadius: "9999px", ...rest });
  }
);

// node_modules/@chakra-ui/react/dist/esm/components/box/span.js
var Span = chakra("span");

// node_modules/@chakra-ui/react/dist/esm/components/box/sticky.js
var Sticky = chakra("div", {
  base: {
    position: "sticky",
    top: 0
  }
});
Sticky.displayName = "Sticky";

// node_modules/@chakra-ui/react/dist/esm/components/breadcrumb/breadcrumb.js
var import_jsx_runtime466 = __toESM(require_jsx_runtime(), 1);
var {
  withProvider: withProvider5,
  withContext: withContext8,
  useStyles: useBreadcrumbStyles,
  PropsProvider: PropsProvider7
} = createSlotRecipeContext({ key: "breadcrumb" });
var BreadcrumbRoot = withProvider5(
  "nav",
  "root",
  {
    defaultProps: { "aria-label": "breadcrumb" }
  }
);
var BreadcrumbPropsProvider = PropsProvider7;
var BreadcrumbList = withContext8(
  "ol",
  "list"
);
var BreadcrumbItem = withContext8(
  "li",
  "item"
);
var BreadcrumbLink = withContext8("a", "link");
var BreadcrumbCurrentLink = withContext8("span", "currentLink", {
  defaultProps: {
    role: "link",
    "aria-current": "page"
  }
});
var BreadcrumbSeparator = withContext8("li", "separator", {
  defaultProps: {
    "aria-hidden": true,
    children: (0, import_jsx_runtime466.jsx)(ChevronRightIcon, {})
  }
});
var BreadcrumbEllipsis = withContext8("span", "ellipsis", {
  defaultProps: {
    role: "presentation",
    "aria-hidden": true,
    children: (0, import_jsx_runtime466.jsx)(EllpsisIcon, {})
  }
});

// node_modules/@chakra-ui/react/dist/esm/components/breadcrumb/namespace.js
var namespace_exports6 = {};
__export(namespace_exports6, {
  CurrentLink: () => BreadcrumbCurrentLink,
  Ellipsis: () => BreadcrumbEllipsis,
  Item: () => BreadcrumbItem,
  Link: () => BreadcrumbLink,
  List: () => BreadcrumbList,
  PropsProvider: () => BreadcrumbPropsProvider,
  Root: () => BreadcrumbRoot,
  Separator: () => BreadcrumbSeparator
});

// node_modules/@chakra-ui/react/dist/esm/components/button/button.js
var import_jsx_runtime468 = __toESM(require_jsx_runtime(), 1);
var import_react993 = __toESM(require_react(), 1);

// node_modules/@chakra-ui/react/dist/esm/components/loader/loader.js
var import_jsx_runtime467 = __toESM(require_jsx_runtime(), 1);
var React8 = __toESM(require_react(), 1);

// node_modules/@chakra-ui/react/dist/esm/components/spinner/spinner.js
var { withContext: withContext9, PropsProvider: PropsProvider8 } = createRecipeContext({
  key: "spinner"
});
var Spinner = withContext9("span");
var SpinnerPropsProvider = PropsProvider8;

// node_modules/@chakra-ui/react/dist/esm/components/center/absolute-center.js
var AbsoluteCenter = chakra("div", {
  base: {
    position: "absolute",
    display: "flex",
    alignItems: "center",
    justifyContent: "center"
  },
  variants: {
    axis: {
      horizontal: {
        insetStart: "50%",
        translate: "-50%",
        _rtl: {
          translate: "50%"
        }
      },
      vertical: {
        top: "50%",
        translate: "0 -50%"
      },
      both: {
        insetStart: "50%",
        top: "50%",
        translate: "-50% -50%",
        _rtl: {
          translate: "50% -50%"
        }
      }
    }
  },
  defaultVariants: {
    axis: "both"
  }
});
AbsoluteCenter.displayName = "AbsoluteCenter";

// node_modules/@chakra-ui/react/dist/esm/components/loader/loader.js
var Loader = React8.forwardRef(
  function Loader2(props43, ref) {
    const {
      spinner = (0, import_jsx_runtime467.jsx)(Spinner, { size: "inherit", borderWidth: "0.125em", color: "inherit" }),
      spinnerPlacement = "start",
      children,
      text,
      visible = true,
      ...rest
    } = props43;
    if (!visible) return children;
    if (text) {
      return (0, import_jsx_runtime467.jsxs)(Span, { ref, display: "contents", ...rest, children: [
        spinnerPlacement === "start" && spinner,
        text,
        spinnerPlacement === "end" && spinner
      ] });
    }
    if (spinner) {
      return (0, import_jsx_runtime467.jsxs)(Span, { ref, display: "contents", ...rest, children: [
        (0, import_jsx_runtime467.jsx)(AbsoluteCenter, { display: "inline-flex", children: spinner }),
        (0, import_jsx_runtime467.jsx)(Span, { visibility: "hidden", display: "contents", children })
      ] });
    }
    return (0, import_jsx_runtime467.jsx)(Span, { ref, display: "contents", ...rest, children });
  }
);

// node_modules/@chakra-ui/react/dist/esm/components/button/button.js
var { useRecipeResult: useRecipeResult2, PropsProvider: PropsProvider9, usePropsContext } = createRecipeContext(
  { key: "button" }
);
var Button = (0, import_react993.forwardRef)(
  function Button2(inProps, ref) {
    const propsContext = usePropsContext();
    const props43 = (0, import_react993.useMemo)(
      () => mergeProps(propsContext, inProps),
      [propsContext, inProps]
    );
    const result = useRecipeResult2(props43);
    const {
      loading,
      loadingText,
      children,
      spinner,
      spinnerPlacement,
      ...rest
    } = result.props;
    return (0, import_jsx_runtime468.jsx)(
      chakra.button,
      {
        type: "button",
        ref,
        ...rest,
        "data-loading": dataAttr2(loading),
        disabled: loading || rest.disabled,
        className: cx(result.className, props43.className),
        css: [result.styles, props43.css],
        children: !props43.asChild && loading ? (0, import_jsx_runtime468.jsx)(
          Loader,
          {
            spinner,
            text: loadingText,
            spinnerPlacement,
            children
          }
        ) : children
      }
    );
  }
);
var ButtonPropsProvider = PropsProvider9;

// node_modules/@chakra-ui/react/dist/esm/components/button/icon-button.js
var import_jsx_runtime469 = __toESM(require_jsx_runtime(), 1);
var import_react994 = __toESM(require_react(), 1);
var IconButton = (0, import_react994.forwardRef)(
  function IconButton2(props43, ref) {
    return (0, import_jsx_runtime469.jsx)(
      Button,
      {
        px: "0",
        py: "0",
        _icon: { fontSize: "1.2em" },
        ref,
        ...props43
      }
    );
  }
);

// node_modules/@chakra-ui/react/dist/esm/components/button/button-group.js
var import_jsx_runtime470 = __toESM(require_jsx_runtime(), 1);
var import_react995 = __toESM(require_react(), 1);
var ButtonGroup = (0, import_react995.forwardRef)(
  function ButtonGroup2(props43, ref) {
    const recipe = useRecipe({ key: "button" });
    const [variantProps, otherProps] = (0, import_react995.useMemo)(
      () => recipe.splitVariantProps(props43),
      [props43, recipe]
    );
    return (0, import_jsx_runtime470.jsx)(ButtonPropsProvider, { value: variantProps, children: (0, import_jsx_runtime470.jsx)(Group, { ref, ...otherProps }) });
  }
);

// node_modules/@chakra-ui/react/dist/esm/components/button/close-button.js
var import_jsx_runtime471 = __toESM(require_jsx_runtime(), 1);
var React9 = __toESM(require_react(), 1);
var CloseButton = React9.forwardRef(function CloseButton2(props43, ref) {
  return (0, import_jsx_runtime471.jsx)(IconButton, { variant: "ghost", "aria-label": "Close", ref, ...props43, children: props43.children ?? (0, import_jsx_runtime471.jsx)(CloseIcon, {}) });
});

// node_modules/@chakra-ui/react/dist/esm/components/card/card.js
var {
  withProvider: withProvider6,
  withContext: withContext10,
  useStyles: useCardStyles,
  PropsProvider: PropsProvider10
} = createSlotRecipeContext({ key: "card" });
var CardRoot = withProvider6(
  "div",
  "root"
);
var CardPropsProvider = PropsProvider10;
var CardBody = withContext10(
  "div",
  "body"
);
var CardHeader = withContext10(
  "div",
  "header"
);
var CardFooter = withContext10(
  "div",
  "footer"
);
var CardTitle = withContext10(
  "h3",
  "title"
);
var CardDescription = withContext10("p", "description");

// node_modules/@chakra-ui/react/dist/esm/components/card/namespace.js
var namespace_exports7 = {};
__export(namespace_exports7, {
  Body: () => CardBody,
  Description: () => CardDescription,
  Footer: () => CardFooter,
  Header: () => CardHeader,
  PropsProvider: () => CardPropsProvider,
  Root: () => CardRoot,
  Title: () => CardTitle
});

// node_modules/@chakra-ui/react/dist/esm/components/center/center.js
var Center = chakra("div", {
  base: {
    display: "flex",
    alignItems: "center",
    justifyContent: "center"
  },
  variants: {
    inline: {
      true: {
        display: "inline-flex"
      }
    }
  }
});
Center.displayName = "Center";

// node_modules/@chakra-ui/react/dist/esm/components/checkbox/checkbox.js
var import_jsx_runtime473 = __toESM(require_jsx_runtime(), 1);
var import_react997 = __toESM(require_react(), 1);

// node_modules/@chakra-ui/react/dist/esm/components/checkmark/checkmark.js
var import_jsx_runtime472 = __toESM(require_jsx_runtime(), 1);
var import_react996 = __toESM(require_react(), 1);
var Checkmark = (0, import_react996.forwardRef)(
  function Checkmark2(props43, ref) {
    const recipe = useRecipe({ key: "checkmark", recipe: props43.recipe });
    const [variantProps, restProps] = recipe.splitVariantProps(props43);
    const { checked, indeterminate, disabled, unstyled, children, ...rest } = restProps;
    const styles = unstyled ? EMPTY_STYLES : recipe(variantProps);
    return (0, import_jsx_runtime472.jsx)(
      chakra.svg,
      {
        ref,
        viewBox: "0 0 24 24",
        fill: "none",
        stroke: "currentColor",
        strokeWidth: "3px",
        strokeLinecap: "round",
        strokeLinejoin: "round",
        "data-state": indeterminate ? "indeterminate" : checked ? "checked" : "unchecked",
        "data-disabled": dataAttr2(disabled),
        css: [styles, props43.css],
        ...rest,
        children: indeterminate ? (0, import_jsx_runtime472.jsx)("path", { d: "M5 12h14" }) : checked ? (0, import_jsx_runtime472.jsx)("polyline", { points: "20 6 9 17 4 12" }) : null
      }
    );
  }
);

// node_modules/@chakra-ui/react/dist/esm/components/checkbox/checkbox.js
var {
  withProvider: withProvider7,
  withContext: withContext11,
  useStyles: useCheckboxStyles,
  PropsProvider: PropsProvider11
} = createSlotRecipeContext({ key: "checkbox" });
var CheckboxRootProvider2 = withProvider7(checkbox_exports.RootProvider, "root", { forwardAsChild: true });
var CheckboxRoot2 = withProvider7(
  checkbox_exports.Root,
  "root",
  { forwardAsChild: true }
);
var CheckboxPropsProvider = PropsProvider11;
var CheckboxLabel2 = withContext11(
  checkbox_exports.Label,
  "label",
  { forwardAsChild: true }
);
var CheckboxIndicator2 = (0, import_react997.forwardRef)(function CheckboxIndicator22(props43, ref) {
  const { checked, indeterminate, ...rest } = props43;
  const api = useCheckboxContext();
  const styles = useCheckboxStyles();
  if (checked && api.checked) {
    return (0, import_jsx_runtime473.jsx)(
      chakra.svg,
      {
        ref,
        asChild: true,
        ...rest,
        css: [styles.indicator, props43.css],
        children: checked
      }
    );
  }
  if (indeterminate && api.indeterminate) {
    return (0, import_jsx_runtime473.jsx)(
      chakra.svg,
      {
        ref,
        asChild: true,
        ...rest,
        css: [styles.indicator, props43.css],
        children: indeterminate
      }
    );
  }
  return (0, import_jsx_runtime473.jsx)(
    Checkmark,
    {
      ref,
      checked: api.checked,
      indeterminate: api.indeterminate,
      disabled: api.disabled,
      unstyled: true,
      ...rest,
      css: [styles.indicator, props43.css]
    }
  );
});
var CheckboxControl2 = withContext11(
  checkbox_exports.Control,
  "control",
  {
    forwardAsChild: true,
    defaultProps: { children: (0, import_jsx_runtime473.jsx)(CheckboxIndicator2, {}) }
  }
);
var CheckboxGroup2 = chakra(
  checkbox_exports.Group,
  {
    base: {
      display: "flex",
      flexDirection: "column",
      gap: "1.5"
    }
  },
  { forwardAsChild: true }
);
var CheckboxContext2 = checkbox_exports.Context;
var CheckboxHiddenInput2 = checkbox_exports.HiddenInput;

// node_modules/@chakra-ui/react/dist/esm/components/checkbox/namespace.js
var namespace_exports8 = {};
__export(namespace_exports8, {
  Context: () => CheckboxContext2,
  Control: () => CheckboxControl2,
  Group: () => CheckboxGroup2,
  HiddenInput: () => CheckboxHiddenInput2,
  Indicator: () => CheckboxIndicator2,
  Label: () => CheckboxLabel2,
  PropsProvider: () => CheckboxPropsProvider,
  Root: () => CheckboxRoot2,
  RootProvider: () => CheckboxRootProvider2
});

// node_modules/@chakra-ui/react/dist/esm/components/checkbox-card/checkbox-card.js
var import_jsx_runtime474 = __toESM(require_jsx_runtime(), 1);
var import_react998 = __toESM(require_react(), 1);
var {
  withProvider: withProvider8,
  withContext: withContext12,
  useStyles: useCheckboxCardStyles,
  PropsProvider: PropsProvider12
} = createSlotRecipeContext({ key: "checkboxCard" });
var CheckboxCardRootProvider = withProvider8(checkbox_exports.RootProvider, "root", { forwardAsChild: true });
var CheckboxCardRoot = withProvider8(checkbox_exports.Root, "root", { forwardAsChild: true });
var CheckboxCardRootPropsProvider = PropsProvider12;
var CheckboxCardLabel = withContext12(checkbox_exports.Label, "label", { forwardAsChild: true });
var CheckboxCardDescription = (0, import_react998.forwardRef)(function CheckboxCardDescription2(props43, ref) {
  const styles = useCheckboxCardStyles();
  const api = useCheckboxContext();
  return (0, import_jsx_runtime474.jsx)(
    chakra.div,
    {
      ref,
      ...props43,
      css: [styles.description, props43.css],
      "data-disabled": api.disabled ? "" : void 0,
      "data-state": api.checked ? "checked" : "unchecked"
    }
  );
});
var CheckboxCardControl = withContext12(checkbox_exports.Control, "control", { forwardAsChild: true });
var CheckboxCardContent = withContext12("div", "content");
var CheckboxCardIndicator = (0, import_react998.forwardRef)(function CheckboxCardIndicator2(props43, ref) {
  const api = useCheckboxContext();
  const styles = useCheckboxCardStyles();
  return (0, import_jsx_runtime474.jsx)(
    Checkmark,
    {
      ref,
      checked: api.checked,
      indeterminate: api.indeterminate,
      disabled: api.disabled,
      unstyled: true,
      ...props43,
      css: [styles.indicator, props43.css]
    }
  );
});
var CheckboxCardAddon = withContext12("div", "addon");
var CheckboxCardContext = checkbox_exports.Context;
var CheckboxCardHiddenInput = checkbox_exports.HiddenInput;

// node_modules/@chakra-ui/react/dist/esm/components/checkbox-card/namespace.js
var namespace_exports9 = {};
__export(namespace_exports9, {
  Addon: () => CheckboxCardAddon,
  Content: () => CheckboxCardContent,
  Context: () => CheckboxCardContext,
  Control: () => CheckboxCardControl,
  Description: () => CheckboxCardDescription,
  HiddenInput: () => CheckboxCardHiddenInput,
  Indicator: () => CheckboxCardIndicator,
  Label: () => CheckboxCardLabel,
  Root: () => CheckboxCardRoot,
  RootPropsProvider: () => CheckboxCardRootPropsProvider,
  RootProvider: () => CheckboxCardRootProvider
});

// node_modules/@chakra-ui/react/dist/esm/components/client-only/client-only.js
var import_jsx_runtime476 = __toESM(require_jsx_runtime(), 1);
var import_react1000 = __toESM(require_react(), 1);

// node_modules/@chakra-ui/react/dist/esm/components/show/show.js
var import_jsx_runtime475 = __toESM(require_jsx_runtime(), 1);
var import_react999 = __toESM(require_react(), 1);
function Show(props43) {
  const { when, fallback: fallback4, children } = props43;
  let result;
  if (!when) {
    result = fallback4;
  } else {
    result = typeof children === "function" ? children(when) : children;
  }
  return (0, import_react999.isValidElement)(result) ? result : (0, import_jsx_runtime475.jsx)(import_jsx_runtime475.Fragment, { children: result });
}

// node_modules/@chakra-ui/react/dist/esm/components/client-only/client-only.js
var ClientOnly2 = (props43) => {
  const { children, fallback: fallback4 } = props43;
  const [hasMounted, setHasMounted] = (0, import_react1000.useState)(false);
  (0, import_react1000.useEffect)(() => {
    setHasMounted(true);
  }, []);
  return (0, import_jsx_runtime476.jsx)(Show, { when: hasMounted, fallback: fallback4, children });
};

// node_modules/@chakra-ui/react/dist/esm/components/clipboard/clipboard.js
var import_jsx_runtime477 = __toESM(require_jsx_runtime(), 1);
var import_react1001 = __toESM(require_react(), 1);
var {
  withProvider: withProvider9,
  withContext: withContext13,
  useStyles: useClipboardStyles,
  PropsProvider: PropsProvider13
} = createSlotRecipeContext({ key: "clipboard" });
var ClipboardRootProvider2 = withProvider9(clipboard_exports.RootProvider, "root", { forwardAsChild: true });
var ClipboardRoot2 = withProvider9(
  clipboard_exports.Root,
  "root",
  { forwardAsChild: true }
);
var ClipboardPropsProvider = PropsProvider13;
var ClipboardTrigger2 = withContext13(clipboard_exports.Trigger, "trigger", { forwardAsChild: true });
var ClipboardControl2 = withContext13(clipboard_exports.Control, "control", { forwardAsChild: true });
var ClipboardIndicator2 = withContext13(clipboard_exports.Indicator, "indicator", {
  forwardAsChild: true,
  defaultProps: {
    copied: (0, import_jsx_runtime477.jsx)(CheckIcon, { boxSize: "1em" }),
    children: (0, import_jsx_runtime477.jsx)(CopyIcon, { boxSize: "1em" })
  }
});
var ClipboardInput2 = withContext13(clipboard_exports.Input, "input", { forwardAsChild: true });
var ClipboardLabel2 = withContext13(clipboard_exports.Label, "label", { forwardAsChild: true });
var ClipboardContext2 = clipboard_exports.Context;
var ClipboardValueText2 = withContext13(clipboard_exports.ValueText, "valueText", { forwardAsChild: true });
var ClipboardCopyText = (0, import_react1001.forwardRef)(function ClipboardCopyText2(props43, ref) {
  return (0, import_jsx_runtime477.jsx)(ClipboardIndicator2, { copied: "Copied", ...props43, ref, children: "Copy" });
});

// node_modules/@chakra-ui/react/dist/esm/components/clipboard/namespace.js
var namespace_exports10 = {};
__export(namespace_exports10, {
  Context: () => ClipboardContext2,
  Control: () => ClipboardControl2,
  CopyText: () => ClipboardCopyText,
  Indicator: () => ClipboardIndicator2,
  Input: () => ClipboardInput2,
  Label: () => ClipboardLabel2,
  PropsProvider: () => ClipboardPropsProvider,
  Root: () => ClipboardRoot2,
  RootProvider: () => ClipboardRootProvider2,
  Trigger: () => ClipboardTrigger2,
  ValueText: () => ClipboardValueText2
});

// node_modules/@chakra-ui/react/dist/esm/components/code/code.js
var { withContext: withContext14, PropsProvider: PropsProvider14 } = createRecipeContext({
  key: "code"
});
var Code = withContext14("code");
var CodePropsProvider = PropsProvider14;

// node_modules/@chakra-ui/react/dist/esm/components/collapsible/collapsible.js
var {
  withProvider: withProvider10,
  withContext: withContext15,
  useStyles: useCollapsibleStyles,
  PropsProvider: PropsProvider15
} = createSlotRecipeContext({ key: "collapsible" });
var CollapsibleRootProvider2 = withProvider10(collapsible_exports.RootProvider, "root", { forwardAsChild: true });
var CollapsibleRoot2 = withProvider10(collapsible_exports.Root, "root", { forwardAsChild: true });
var CollapsiblePropsProvider = PropsProvider15;
var CollapsibleTrigger2 = withContext15(collapsible_exports.Trigger, "trigger", { forwardAsChild: true });
var CollapsibleContent2 = withContext15(collapsible_exports.Content, "content", { forwardAsChild: true });
var CollapsibleContext2 = collapsible_exports.Context;

// node_modules/@chakra-ui/react/dist/esm/components/collapsible/namespace.js
var namespace_exports11 = {};
__export(namespace_exports11, {
  Content: () => CollapsibleContent2,
  Context: () => CollapsibleContext2,
  PropsProvider: () => CollapsiblePropsProvider,
  Root: () => CollapsibleRoot2,
  RootProvider: () => CollapsibleRootProvider2,
  Trigger: () => CollapsibleTrigger2
});

// node_modules/@chakra-ui/react/dist/esm/components/combobox/combobox.js
var import_jsx_runtime478 = __toESM(require_jsx_runtime(), 1);
var import_react1002 = __toESM(require_react(), 1);
var {
  withProvider: withProvider11,
  withContext: withContext16,
  useStyles: useComboboxStyles,
  useClassNames: useClassNames2,
  PropsProvider: PropsProvider16
} = createSlotRecipeContext({ key: "combobox" });
var ComboboxRootProvider2 = withProvider11(combobox_exports.RootProvider, "root", {
  forwardAsChild: true
});
var ComboboxRoot2 = withProvider11(
  combobox_exports.Root,
  "root",
  { forwardAsChild: true }
);
var ComboboxPropsProvider = PropsProvider16;
var ComboboxTrigger2 = withContext16(combobox_exports.Trigger, "trigger", {
  forwardAsChild: true,
  forwardProps: ["focusable"],
  defaultProps: {
    children: (0, import_jsx_runtime478.jsx)(ChevronDownIcon, {})
  }
});
var ComboboxPositioner2 = withContext16(combobox_exports.Positioner, "positioner", { forwardAsChild: true });
var ComboboxContent2 = withContext16(combobox_exports.Content, "content", { forwardAsChild: true });
var ComboboxInput2 = withContext16(
  combobox_exports.Input,
  "input",
  { forwardAsChild: true }
);
var ComboboxClearTrigger2 = withContext16(combobox_exports.ClearTrigger, "clearTrigger", {
  forwardAsChild: true,
  defaultProps: {
    children: (0, import_jsx_runtime478.jsx)(CloseIcon, {})
  }
});
var ComboboxIndicatorGroup = withContext16("div", "indicatorGroup");
var ComboboxItemGroup2 = withContext16(combobox_exports.ItemGroup, "itemGroup", { forwardAsChild: true });
var ComboboxItemGroupLabel2 = withContext16(combobox_exports.ItemGroupLabel, "itemGroupLabel", { forwardAsChild: true });
var ComboboxItem2 = withContext16(
  combobox_exports.Item,
  "item",
  { forwardAsChild: true }
);
var ComboboxItemText2 = withContext16(combobox_exports.ItemText, "itemText", { forwardAsChild: true });
var ComboboxItemIndicator2 = withContext16(combobox_exports.ItemIndicator, "itemIndicator", {
  forwardAsChild: true,
  defaultProps: {
    children: (0, import_jsx_runtime478.jsx)(CheckIcon, {})
  }
});
var ComboboxControl2 = withContext16(combobox_exports.Control, "control", { forwardAsChild: true });
var ComboboxLabel2 = withContext16(
  combobox_exports.Label,
  "label",
  { forwardAsChild: true }
);
var ComboboxEmpty = (0, import_react1002.forwardRef)(
  function ComboboxEmpty2(props43, ref) {
    const combobox = useComboboxContext();
    const styles = useComboboxStyles();
    const classNames = useClassNames2();
    if (combobox.collection.size !== 0) return null;
    return (0, import_jsx_runtime478.jsx)(
      chakra.div,
      {
        ref,
        ...props43,
        role: "presentation",
        "data-scope": "combobox",
        "data-part": "empty",
        className: cx(classNames.empty, props43.className),
        css: [styles.empty, props43.css]
      }
    );
  }
);
var ComboboxContext2 = combobox_exports.Context;
var ComboboxItemContext2 = combobox_exports.ItemContext;

// node_modules/@chakra-ui/react/dist/esm/components/combobox/namespace.js
var namespace_exports12 = {};
__export(namespace_exports12, {
  ClearTrigger: () => ComboboxClearTrigger2,
  Content: () => ComboboxContent2,
  Context: () => ComboboxContext2,
  Control: () => ComboboxControl2,
  Empty: () => ComboboxEmpty,
  Indicator: () => ComboboxItemIndicator2,
  IndicatorGroup: () => ComboboxIndicatorGroup,
  Input: () => ComboboxInput2,
  Item: () => ComboboxItem2,
  ItemContext: () => ComboboxItemContext2,
  ItemGroup: () => ComboboxItemGroup2,
  ItemGroupLabel: () => ComboboxItemGroupLabel2,
  ItemIndicator: () => ComboboxItemIndicator2,
  ItemText: () => ComboboxItemText2,
  Label: () => ComboboxLabel2,
  Positioner: () => ComboboxPositioner2,
  PropsProvider: () => ComboboxPropsProvider,
  Root: () => ComboboxRoot2,
  RootProvider: () => ComboboxRootProvider2,
  Trigger: () => ComboboxTrigger2
});

// node_modules/@chakra-ui/react/dist/esm/components/color-picker/color-picker.js
var import_jsx_runtime480 = __toESM(require_jsx_runtime(), 1);
var import_react1004 = __toESM(require_react(), 1);

// node_modules/@chakra-ui/react/dist/esm/components/stack/stack.js
var import_jsx_runtime479 = __toESM(require_jsx_runtime(), 1);
var import_react1003 = __toESM(require_react(), 1);

// node_modules/@chakra-ui/react/dist/esm/components/stack/get-separator-style.js
function getSeparatorStyles(options) {
  const { gap, direction } = options;
  const styles = {
    column: {
      marginY: gap,
      marginX: 0,
      borderInlineStartWidth: 0,
      borderTopWidth: "1px"
    },
    "column-reverse": {
      marginY: gap,
      marginX: 0,
      borderInlineStartWidth: 0,
      borderTopWidth: "1px"
    },
    row: {
      marginX: gap,
      marginY: 0,
      borderInlineStartWidth: "1px",
      borderTopWidth: 0
    },
    "row-reverse": {
      marginX: gap,
      marginY: 0,
      borderInlineStartWidth: "1px",
      borderTopWidth: 0
    }
  };
  return {
    "&": mapObject(direction, (value) => styles[value])
  };
}

// node_modules/@chakra-ui/react/dist/esm/components/stack/stack.js
function getValidChildren(children) {
  return import_react1003.Children.toArray(children).filter(
    (child) => (0, import_react1003.isValidElement)(child)
  );
}
var Stack = (0, import_react1003.forwardRef)(
  function Stack2(props43, ref) {
    const {
      direction = "column",
      align,
      justify,
      gap = "0.5rem",
      wrap: wrap5,
      children,
      separator,
      className,
      ...rest
    } = props43;
    const separatorStyle = (0, import_react1003.useMemo)(
      () => getSeparatorStyles({ gap, direction }),
      [gap, direction]
    );
    const clones = (0, import_react1003.useMemo)(() => {
      if (!separator) return children;
      return getValidChildren(children).map((child, index, arr) => {
        const key = typeof child.key !== "undefined" ? child.key : index;
        const sep = (0, import_react1003.cloneElement)(separator, {
          css: [separatorStyle, separator.props.css]
        });
        return (0, import_jsx_runtime479.jsxs)(import_react1003.Fragment, { children: [
          child,
          index === arr.length - 1 ? null : sep
        ] }, key);
      });
    }, [children, separator, separatorStyle]);
    return (0, import_jsx_runtime479.jsx)(
      chakra.div,
      {
        ref,
        display: "flex",
        alignItems: align,
        justifyContent: justify,
        flexDirection: direction,
        flexWrap: wrap5,
        gap: separator ? void 0 : gap,
        className: cx("chakra-stack", className),
        ...rest,
        children: clones
      }
    );
  }
);

// node_modules/@chakra-ui/react/dist/esm/components/color-picker/color-picker.js
var {
  withProvider: withProvider12,
  withContext: withContext17,
  useStyles: useColorPickerStyles,
  PropsProvider: PropsProvider17
} = createSlotRecipeContext({ key: "colorPicker" });
var ColorPickerRootProvider2 = withProvider12(color_picker_exports.RootProvider, "root", { forwardAsChild: true });
var ColorPickerRoot2 = withProvider12(color_picker_exports.Root, "root", { forwardAsChild: true });
var ColorPickerPropsProvider = PropsProvider17;
var ColorPickerLabel2 = withContext17(color_picker_exports.Label, "label", { forwardAsChild: true });
var ColorPickerControl2 = withContext17(color_picker_exports.Control, "control", { forwardAsChild: true });
var ColorPickerValueSwatch2 = withContext17(color_picker_exports.ValueSwatch, "swatch", { forwardAsChild: true });
var ColorPickerTrigger2 = withContext17(color_picker_exports.Trigger, "trigger", {
  forwardAsChild: true,
  defaultProps: {
    children: (0, import_jsx_runtime480.jsx)(ColorPickerValueSwatch2, {})
  }
});
var ColorPickerPositioner2 = withContext17(color_picker_exports.Positioner, "positioner", { forwardAsChild: true });
var ColorPickerContent2 = withContext17(color_picker_exports.Content, "content", { forwardAsChild: true });
var ColorPickerAreaBackground2 = withContext17(color_picker_exports.AreaBackground, "areaBackground", { forwardAsChild: true });
var ColorPickerAreaThumb2 = withContext17(color_picker_exports.AreaThumb, "areaThumb", { forwardAsChild: true });
var ColorPickerArea2 = withContext17(color_picker_exports.Area, "area", {
  forwardAsChild: true,
  defaultProps: {
    children: (0, import_jsx_runtime480.jsxs)(import_jsx_runtime480.Fragment, { children: [
      (0, import_jsx_runtime480.jsx)(ColorPickerAreaBackground2, {}),
      (0, import_jsx_runtime480.jsx)(ColorPickerAreaThumb2, {})
    ] })
  }
});
var ColorPickerChannelSliderTrack2 = withContext17(color_picker_exports.ChannelSliderTrack, "channelSliderTrack", {
  forwardAsChild: true
});
var ColorPickerChannelSliderThumb2 = withContext17(color_picker_exports.ChannelSliderThumb, "channelSliderThumb", {
  forwardAsChild: true
});
var ColorPickerTransparencyGrid2 = withContext17(color_picker_exports.TransparencyGrid, "transparencyGrid", { forwardAsChild: true });
var ColorPickerChannelSlider2 = withContext17(color_picker_exports.ChannelSlider, "channelSlider", {
  forwardAsChild: true,
  defaultProps: {
    children: (0, import_jsx_runtime480.jsxs)(import_jsx_runtime480.Fragment, { children: [
      (0, import_jsx_runtime480.jsx)(ColorPickerTransparencyGrid2, { size: "0.6rem" }),
      (0, import_jsx_runtime480.jsx)(ColorPickerChannelSliderTrack2, {}),
      (0, import_jsx_runtime480.jsx)(ColorPickerChannelSliderThumb2, {})
    ] })
  }
});
var ColorPickerSliders = (0, import_react1004.forwardRef)(
  function ColorPickerSliders2(props43, ref) {
    return (0, import_jsx_runtime480.jsxs)(Stack, { gap: "1", flex: "1", px: "1", ref, ...props43, children: [
      (0, import_jsx_runtime480.jsx)(ColorPickerChannelSlider2, { channel: "hue" }),
      (0, import_jsx_runtime480.jsx)(ColorPickerChannelSlider2, { channel: "alpha" })
    ] });
  }
);
var ColorPickerChannelInput2 = withContext17(color_picker_exports.ChannelInput, "channelInput", { forwardAsChild: true });
var ColorPickerInput = (0, import_react1004.forwardRef)(function ColorHexInput(props43, ref) {
  return (0, import_jsx_runtime480.jsx)(ColorPickerChannelInput2, { channel: "hex", ref, ...props43 });
});
var ColorPickerSwatchGroup2 = withContext17(color_picker_exports.SwatchGroup, "swatchGroup", { forwardAsChild: true });
var ColorPickerSwatchTrigger2 = withContext17(color_picker_exports.SwatchTrigger, "swatchTrigger", { forwardAsChild: true });
var ColorPickerSwatch2 = withContext17(color_picker_exports.Swatch, "swatch", { forwardAsChild: true });
var ColorPickerSwatchIndicator2 = withContext17(color_picker_exports.SwatchIndicator, "swatchIndicator", { forwardAsChild: true });
var ColorPickerValueText2 = withContext17(color_picker_exports.ValueText, "valueText", { forwardAsChild: true });
var ColorPickerView2 = withContext17(color_picker_exports.View, "view", { forwardAsChild: true });
var ColorPickerFormatTrigger2 = withContext17(color_picker_exports.FormatTrigger, "formatTrigger", { forwardAsChild: true });
var ColorPickerFormatSelect2 = withContext17(color_picker_exports.FormatSelect, "formatSelect", { forwardAsChild: true });
var ColorPickerEyeDropperTrigger2 = withContext17(color_picker_exports.EyeDropperTrigger, "eyeDropperTrigger", {
  forwardAsChild: true
});
var ColorPickerEyeDropper = (0, import_react1004.forwardRef)(function ColorPickerEyeDropper2(props43, ref) {
  const { children = (0, import_jsx_runtime480.jsx)(PipetteIcon, {}), ...rest } = props43;
  const picker = useColorPickerContext();
  const localProps = mergeProps(picker.getEyeDropperTriggerProps(), rest);
  return (0, import_jsx_runtime480.jsx)(IconButton, { ref, ...localProps, children });
});
var ColorPickerChannelSliderValueText2 = withContext17(color_picker_exports.ChannelSliderValueText, "channelSliderValueText", {
  forwardAsChild: true
});
var ColorPickerChannelSliderLabel2 = withContext17(color_picker_exports.ChannelSliderLabel, "channelSliderLabel", {
  forwardAsChild: true
});
var ColorPickerHiddenInput2 = (0, import_react1004.forwardRef)(function ColorPickerHiddenInput22(props43, ref) {
  return (0, import_jsx_runtime480.jsx)(color_picker_exports.HiddenInput, { tabIndex: -1, ref, ...props43 });
});
var ColorPickerContext2 = color_picker_exports.Context;
var ColorPickerChannelText = withContext17("span", "channelText", {
  forwardAsChild: true
});
var formatMap = {
  rgba: ["red", "green", "blue", "alpha"],
  hsla: ["hue", "saturation", "lightness", "alpha"],
  hsba: ["hue", "saturation", "brightness", "alpha"],
  hexa: ["hex", "alpha"]
};
var getColorChannels = (format) => formatMap[format];

// node_modules/@chakra-ui/react/dist/esm/components/color-picker/namespace.js
var namespace_exports13 = {};
__export(namespace_exports13, {
  Area: () => ColorPickerArea2,
  AreaBackground: () => ColorPickerAreaBackground2,
  AreaThumb: () => ColorPickerAreaThumb2,
  ChannelInput: () => ColorPickerChannelInput2,
  ChannelSlider: () => ColorPickerChannelSlider2,
  ChannelSliderLabel: () => ColorPickerChannelSliderLabel2,
  ChannelSliderThumb: () => ColorPickerChannelSliderThumb2,
  ChannelSliderTrack: () => ColorPickerChannelSliderTrack2,
  ChannelSliderValueText: () => ColorPickerChannelSliderValueText2,
  ChannelText: () => ColorPickerChannelText,
  Content: () => ColorPickerContent2,
  Context: () => ColorPickerContext2,
  Control: () => ColorPickerControl2,
  EyeDropper: () => ColorPickerEyeDropper,
  EyeDropperTrigger: () => ColorPickerEyeDropperTrigger2,
  FormatSelect: () => ColorPickerFormatSelect2,
  FormatTrigger: () => ColorPickerFormatTrigger2,
  HiddenInput: () => ColorPickerHiddenInput2,
  Input: () => ColorPickerInput,
  Label: () => ColorPickerLabel2,
  Positioner: () => ColorPickerPositioner2,
  PropsProvider: () => ColorPickerPropsProvider,
  Root: () => ColorPickerRoot2,
  RootProvider: () => ColorPickerRootProvider2,
  Sliders: () => ColorPickerSliders,
  Swatch: () => ColorPickerSwatch2,
  SwatchGroup: () => ColorPickerSwatchGroup2,
  SwatchIndicator: () => ColorPickerSwatchIndicator2,
  SwatchTrigger: () => ColorPickerSwatchTrigger2,
  TransparencyGrid: () => ColorPickerTransparencyGrid2,
  Trigger: () => ColorPickerTrigger2,
  ValueSwatch: () => ColorPickerValueSwatch2,
  ValueText: () => ColorPickerValueText2,
  View: () => ColorPickerView2
});

// node_modules/@chakra-ui/react/dist/esm/components/container/container.js
var { withContext: withContext18, PropsProvider: PropsProvider18 } = createRecipeContext({
  key: "container"
});
var Container = withContext18("div");
var ContainerPropsProvider = PropsProvider18;

// node_modules/@chakra-ui/react/dist/esm/components/data-list/data-list.js
var {
  withProvider: withProvider13,
  withContext: withContext19,
  useStyles: useDataListStyles,
  PropsProvider: PropsProvider19
} = createSlotRecipeContext({ key: "dataList" });
var DataListRoot = withProvider13(
  "dl",
  "root"
);
var DataListPropsProvider = PropsProvider19;
var DataListItem = withContext19(
  "div",
  "item"
);
var DataListItemLabel = withContext19("dt", "itemLabel");
var DataListItemValue = withContext19("dd", "itemValue");

// node_modules/@chakra-ui/react/dist/esm/components/data-list/namespace.js
var namespace_exports14 = {};
__export(namespace_exports14, {
  Item: () => DataListItem,
  ItemLabel: () => DataListItemLabel,
  ItemValue: () => DataListItemValue,
  PropsProvider: () => DataListPropsProvider,
  Root: () => DataListRoot
});

// node_modules/@chakra-ui/react/dist/esm/components/dialog/dialog.js
var import_jsx_runtime481 = __toESM(require_jsx_runtime(), 1);
var import_react1005 = __toESM(require_react(), 1);
var {
  withRootProvider: withRootProvider2,
  withContext: withContext20,
  useStyles: useDialogStyles,
  PropsProvider: PropsProvider20
} = createSlotRecipeContext({ key: "dialog" });
var DialogRootProvider2 = withRootProvider2(
  dialog_exports.RootProvider,
  {
    defaultProps: { unmountOnExit: true, lazyMount: true }
  }
);
var DialogRoot2 = withRootProvider2(dialog_exports.Root, {
  defaultProps: { unmountOnExit: true, lazyMount: true }
});
var DialogPropsProvider = PropsProvider20;
var DialogTrigger2 = withContext20(
  dialog_exports.Trigger,
  "trigger",
  { forwardAsChild: true }
);
var DialogPositioner2 = withContext20(dialog_exports.Positioner, "positioner", { forwardAsChild: true });
var DialogContent2 = withContext20(
  dialog_exports.Content,
  "content",
  { forwardAsChild: true }
);
var DialogDescription2 = withContext20(dialog_exports.Description, "description", { forwardAsChild: true });
var DialogTitle2 = withContext20(
  dialog_exports.Title,
  "title",
  { forwardAsChild: true }
);
var DialogCloseTrigger2 = withContext20(dialog_exports.CloseTrigger, "closeTrigger", { forwardAsChild: true });
var DialogActionTrigger = (0, import_react1005.forwardRef)(function DialogActionTrigger2(props43, ref) {
  const dialog = useDialogContext();
  return (0, import_jsx_runtime481.jsx)(chakra.button, { ...props43, ref, onClick: () => dialog.setOpen(false) });
});
var DialogBackdrop2 = withContext20(
  dialog_exports.Backdrop,
  "backdrop",
  { forwardAsChild: true }
);
var DialogBody = withContext20(
  "div",
  "body"
);
var DialogFooter = withContext20(
  "div",
  "footer"
);
var DialogHeader = withContext20(
  "div",
  "header"
);
var DialogContext2 = dialog_exports.Context;

// node_modules/@chakra-ui/react/dist/esm/components/dialog/namespace.js
var namespace_exports15 = {};
__export(namespace_exports15, {
  ActionTrigger: () => DialogActionTrigger,
  Backdrop: () => DialogBackdrop2,
  Body: () => DialogBody,
  CloseTrigger: () => DialogCloseTrigger2,
  Content: () => DialogContent2,
  Context: () => DialogContext2,
  Description: () => DialogDescription2,
  Footer: () => DialogFooter,
  Header: () => DialogHeader,
  Positioner: () => DialogPositioner2,
  PropsProvider: () => DialogPropsProvider,
  Root: () => DialogRoot2,
  RootProvider: () => DialogRootProvider2,
  Title: () => DialogTitle2,
  Trigger: () => DialogTrigger2
});

// node_modules/@chakra-ui/react/dist/esm/components/drawer/drawer.js
var import_jsx_runtime482 = __toESM(require_jsx_runtime(), 1);
var import_react1006 = __toESM(require_react(), 1);
var {
  withRootProvider: withRootProvider3,
  withContext: withContext21,
  useStyles: useDrawerStyles,
  PropsProvider: PropsProvider21
} = createSlotRecipeContext({ key: "drawer" });
var DrawerRootProvider = withRootProvider3(
  dialog_exports.RootProvider,
  {
    defaultProps: { unmountOnExit: true, lazyMount: true }
  }
);
var DrawerRoot = withRootProvider3(dialog_exports.Root, {
  defaultProps: { unmountOnExit: true, lazyMount: true }
});
var DrawerRootPropsProvider = PropsProvider21;
var DrawerTrigger = withContext21(
  dialog_exports.Trigger,
  "trigger",
  { forwardAsChild: true }
);
var DrawerPositioner = withContext21(dialog_exports.Positioner, "positioner", { forwardAsChild: true });
var DrawerContent = withContext21(
  dialog_exports.Content,
  "content",
  { forwardAsChild: true }
);
var DrawerDescription = withContext21(dialog_exports.Description, "description", { forwardAsChild: true });
var DrawerTitle = withContext21(
  dialog_exports.Title,
  "title",
  { forwardAsChild: true }
);
var DrawerCloseTrigger = withContext21(dialog_exports.CloseTrigger, "closeTrigger", { forwardAsChild: true });
var DrawerActionTrigger = (0, import_react1006.forwardRef)(function DrawerActionTrigger2(props43, ref) {
  const drawer = useDialogContext();
  return (0, import_jsx_runtime482.jsx)(chakra.button, { ...props43, ref, onClick: () => drawer.setOpen(false) });
});
var DrawerBackdrop = withContext21(
  dialog_exports.Backdrop,
  "backdrop",
  { forwardAsChild: true }
);
var DrawerBody = withContext21(
  "div",
  "body"
);
var DrawerFooter = withContext21(
  "div",
  "footer"
);
var DrawerHeader = withContext21(
  "div",
  "header"
);
var DrawerContext = dialog_exports.Context;

// node_modules/@chakra-ui/react/dist/esm/components/drawer/namespace.js
var namespace_exports16 = {};
__export(namespace_exports16, {
  ActionTrigger: () => DrawerActionTrigger,
  Backdrop: () => DrawerBackdrop,
  Body: () => DrawerBody,
  CloseTrigger: () => DrawerCloseTrigger,
  Content: () => DrawerContent,
  Context: () => DrawerContext,
  Description: () => DrawerDescription,
  Footer: () => DrawerFooter,
  Header: () => DrawerHeader,
  Positioner: () => DrawerPositioner,
  Root: () => DrawerRoot,
  RootPropsProvider: () => DrawerRootPropsProvider,
  RootProvider: () => DrawerRootProvider,
  Title: () => DrawerTitle,
  Trigger: () => DrawerTrigger
});

// node_modules/@chakra-ui/react/dist/esm/components/editable/editable.js
var import_jsx_runtime483 = __toESM(require_jsx_runtime(), 1);
var import_react1007 = __toESM(require_react(), 1);
var {
  withProvider: withProvider14,
  withContext: withContext22,
  useStyles: useEditableStyles,
  PropsProvider: PropsProvider22
} = createSlotRecipeContext({ key: "editable" });
var EditableRootProvider2 = withProvider14(editable_exports.RootProvider, "root", { forwardAsChild: true });
var EditableRoot2 = withProvider14(
  editable_exports.Root,
  "root",
  { forwardAsChild: true }
);
var EditablePropsProvider = PropsProvider22;
var EditablePreview2 = withContext22(editable_exports.Preview, "preview", { forwardAsChild: true });
var EditableInput2 = withContext22(
  editable_exports.Input,
  "input",
  { forwardAsChild: true }
);
var ArkEditableTextarea = (0, import_react1007.forwardRef)(function EditableTextarea2(props43, ref) {
  const editable = useEditableContext();
  const mergedProps = mergeProps(editable.getInputProps(), props43);
  return (0, import_jsx_runtime483.jsx)(ark.textarea, { ref, ...mergedProps });
});
var EditableTextarea = withContext22(ArkEditableTextarea, "input", { forwardAsChild: true });
var EditableControl2 = withContext22(editable_exports.Control, "control", { forwardAsChild: true });
var EditableArea2 = withContext22(
  editable_exports.Area,
  "area",
  { forwardAsChild: true }
);
var EditableEditTrigger2 = withContext22(editable_exports.EditTrigger, "editTrigger", { forwardAsChild: true });
var EditableSubmitTrigger2 = withContext22(editable_exports.SubmitTrigger, "submitTrigger", { forwardAsChild: true });
var EditableCancelTrigger2 = withContext22(editable_exports.CancelTrigger, "cancelTrigger", { forwardAsChild: true });
var EditableContext2 = editable_exports.Context;

// node_modules/@chakra-ui/react/dist/esm/components/editable/namespace.js
var namespace_exports17 = {};
__export(namespace_exports17, {
  Area: () => EditableArea2,
  CancelTrigger: () => EditableCancelTrigger2,
  Context: () => EditableContext2,
  Control: () => EditableControl2,
  EditTrigger: () => EditableEditTrigger2,
  Input: () => EditableInput2,
  Preview: () => EditablePreview2,
  PropsProvider: () => EditablePropsProvider,
  Root: () => EditableRoot2,
  RootProvider: () => EditableRootProvider2,
  SubmitTrigger: () => EditableSubmitTrigger2,
  Textarea: () => EditableTextarea
});

// node_modules/@chakra-ui/react/dist/esm/components/empty-state/empty-state.js
var {
  withProvider: withProvider15,
  withContext: withContext23,
  useStyles: useEmptyStateStyles,
  PropsProvider: PropsProvider23
} = createSlotRecipeContext({ key: "emptyState" });
var EmptyStateRoot = withProvider15(
  "div",
  "root"
);
var EmptyStatePropsProvider = PropsProvider23;
var EmptyStateContent = withContext23("div", "content");
var EmptyStateIndicator = withContext23("div", "indicator");
var EmptyStateTitle = withContext23("h3", "title");
var EmptyStateDescription = withContext23("p", "description");

// node_modules/@chakra-ui/react/dist/esm/components/empty-state/namespace.js
var namespace_exports18 = {};
__export(namespace_exports18, {
  Content: () => EmptyStateContent,
  Description: () => EmptyStateDescription,
  Indicator: () => EmptyStateIndicator,
  PropsProvider: () => EmptyStatePropsProvider,
  Root: () => EmptyStateRoot,
  Title: () => EmptyStateTitle
});

// node_modules/@chakra-ui/react/dist/esm/components/field/field.js
var import_jsx_runtime486 = __toESM(require_jsx_runtime(), 1);
var import_react1009 = __toESM(require_react(), 1);

// node_modules/@chakra-ui/react/dist/esm/components/icon/create-icon.js
var import_jsx_runtime485 = __toESM(require_jsx_runtime(), 1);
var import_react1008 = __toESM(require_react(), 1);

// node_modules/@chakra-ui/react/dist/esm/components/icon/icon.js
var import_jsx_runtime484 = __toESM(require_jsx_runtime(), 1);
var React10 = __toESM(require_react(), 1);
var { useRecipeResult: useRecipeResult3, PropsProvider: PropsProvider24 } = createRecipeContext({ key: "icon" });
var Icon = React10.forwardRef(
  function Icon2(props43, ref) {
    const {
      styles,
      className,
      props: otherProps
    } = useRecipeResult3({ asChild: !props43.as, ...props43 });
    return (0, import_jsx_runtime484.jsx)(
      chakra.svg,
      {
        ref,
        focusable: false,
        "aria-hidden": "true",
        ...otherProps,
        css: [styles, props43.css],
        className: cx(className, props43.className)
      }
    );
  }
);
var IconPropsProvider = PropsProvider24;

// node_modules/@chakra-ui/react/dist/esm/components/icon/create-icon.js
function createIcon(options) {
  const {
    viewBox = "0 0 24 24",
    d: pathDefinition,
    displayName,
    defaultProps = {}
  } = options;
  const path = import_react1008.Children.toArray(options.path);
  const Comp = (0, import_react1008.forwardRef)((props43, ref) => (0, import_jsx_runtime485.jsx)(
    Icon,
    {
      ref,
      asChild: false,
      viewBox,
      ...defaultProps,
      ...props43,
      children: path.length ? path : (0, import_jsx_runtime485.jsx)("path", { fill: "currentColor", d: pathDefinition })
    }
  ));
  Comp.displayName = displayName;
  return Comp;
}

// node_modules/@chakra-ui/react/dist/esm/components/field/field.js
var {
  withProvider: withProvider16,
  withContext: withContext24,
  useStyles: useFieldStyles,
  useClassNames: useClassNames3,
  PropsProvider: PropsProvider25
} = createSlotRecipeContext({ key: "field" });
var FieldRoot2 = withProvider16(
  field_exports.Root,
  "root",
  { forwardAsChild: true }
);
var FieldPropsProvider = PropsProvider25;
var FieldLabel2 = withContext24(
  field_exports.Label,
  "label",
  { forwardAsChild: true }
);
var FieldHelperText2 = withContext24(field_exports.HelperText, "helperText", { forwardAsChild: true });
var FieldErrorText2 = withContext24(
  field_exports.ErrorText,
  "errorText",
  { forwardAsChild: true }
);
var FieldErrorIcon = createIcon({
  d: "M11.983,0a12.206,12.206,0,0,0-8.51,3.653A11.8,11.8,0,0,0,0,12.207,11.779,11.779,0,0,0,11.8,24h.214A12.111,12.111,0,0,0,24,11.791h0A11.766,11.766,0,0,0,11.983,0ZM10.5,16.542a1.476,1.476,0,0,1,1.449-1.53h.027a1.527,1.527,0,0,1,1.523,1.47,1.475,1.475,0,0,1-1.449,1.53h-.027A1.529,1.529,0,0,1,10.5,16.542ZM11,12.5v-6a1,1,0,0,1,2,0v6a1,1,0,1,1-2,0Z"
});
var FieldRequiredIndicator2 = (0, import_react1009.forwardRef)(function RequiredIndicator(props43, ref) {
  const { fallback: fallback4, children = "*", ...restProps } = props43;
  const field = useFieldContext();
  const classNames = useClassNames3();
  const styles = useFieldStyles();
  if (!(field == null ? void 0 : field.required)) {
    return fallback4;
  }
  return (0, import_jsx_runtime486.jsx)(
    chakra.span,
    {
      ref,
      "aria-hidden": "true",
      ...restProps,
      className: cx(classNames.requiredIndicator, props43.className),
      css: [styles.requiredIndicator, props43.css],
      children
    }
  );
});

// node_modules/@chakra-ui/react/dist/esm/components/field/namespace.js
var namespace_exports19 = {};
__export(namespace_exports19, {
  ErrorIcon: () => FieldErrorIcon,
  ErrorText: () => FieldErrorText2,
  HelperText: () => FieldHelperText2,
  Label: () => FieldLabel2,
  PropsProvider: () => FieldPropsProvider,
  RequiredIndicator: () => FieldRequiredIndicator2,
  Root: () => FieldRoot2
});

// node_modules/@chakra-ui/react/dist/esm/components/fieldset/fieldset.js
var { withProvider: withProvider17, withContext: withContext25 } = createSlotRecipeContext({
  key: "fieldset"
});
var FieldsetRoot2 = withProvider17(fieldset_exports.Root, "root");
var FieldsetErrorText2 = withContext25(fieldset_exports.ErrorText, "errorText");
var FieldsetHelperText2 = withContext25(fieldset_exports.HelperText, "helperText");
var FieldsetLegend2 = withContext25(fieldset_exports.Legend, "legend");
var FieldsetContent = withContext25(ark.div, "content");
var FieldsetContext2 = fieldset_exports.Context;

// node_modules/@chakra-ui/react/dist/esm/components/fieldset/namespace.js
var namespace_exports20 = {};
__export(namespace_exports20, {
  Content: () => FieldsetContent,
  Context: () => FieldsetContext2,
  ErrorText: () => FieldsetErrorText2,
  HelperText: () => FieldsetHelperText2,
  Legend: () => FieldsetLegend2,
  Root: () => FieldsetRoot2
});

// node_modules/@chakra-ui/react/dist/esm/components/file-upload/file-upload.js
var import_jsx_runtime487 = __toESM(require_jsx_runtime(), 1);
var import_react1010 = __toESM(require_react(), 1);

// node_modules/@chakra-ui/react/dist/esm/components/for/for.js
function For(props43) {
  const { each, fallback: fallback4, children } = props43;
  if ((each == null ? void 0 : each.length) === 0) {
    return fallback4 || null;
  }
  return each == null ? void 0 : each.map(children);
}

// node_modules/@chakra-ui/react/dist/esm/components/file-upload/file-upload.js
var {
  withProvider: withProvider18,
  withContext: withContext26,
  useStyles: useFileUploadStyles,
  PropsProvider: PropsProvider26
} = createSlotRecipeContext({ key: "fileUpload" });
var FileUploadRootProvider2 = withProvider18(file_upload_exports.RootProvider, "root", { forwardAsChild: true });
var FileUploadRoot2 = withProvider18(
  file_upload_exports.Root,
  "root",
  { forwardAsChild: true }
);
var FileUploadPropsProvider = PropsProvider26;
var FileUploadClearTrigger2 = withContext26(file_upload_exports.ClearTrigger, "clearTrigger", { forwardAsChild: true });
var FileUploadDropzone2 = withContext26(file_upload_exports.Dropzone, "dropzone", { forwardAsChild: true });
var FileUploadDropzoneContent = withContext26("div", "dropzoneContent");
var FileUploadItem2 = withContext26(
  file_upload_exports.Item,
  "item",
  { forwardAsChild: true }
);
var FileUploadItemContent = withContext26("div", "itemContent");
var FileUploadItemDeleteTrigger2 = withContext26(file_upload_exports.ItemDeleteTrigger, "itemDeleteTrigger", {
  forwardAsChild: true,
  defaultProps: {
    children: (0, import_jsx_runtime487.jsx)(CloseIcon, {})
  }
});
var FileUploadItemGroup2 = withContext26(file_upload_exports.ItemGroup, "itemGroup", { forwardAsChild: true });
var FileUploadItemName2 = withContext26(file_upload_exports.ItemName, "itemName", { forwardAsChild: true });
var FileUploadItemPreview2 = withContext26(file_upload_exports.ItemPreview, "itemPreview", {
  forwardAsChild: true,
  defaultProps: {
    children: (0, import_jsx_runtime487.jsx)(FileIcon, {})
  }
});
var FileUploadItemPreviewImage2 = withContext26(file_upload_exports.ItemPreviewImage, "itemPreviewImage", { forwardAsChild: true });
var FileUploadItemSizeText2 = withContext26(file_upload_exports.ItemSizeText, "itemSizeText", { forwardAsChild: true });
var FileUploadLabel2 = withContext26(file_upload_exports.Label, "label", { forwardAsChild: true });
var FileUploadTrigger2 = withContext26(file_upload_exports.Trigger, "trigger", { forwardAsChild: true });
var FileUploadItems = (props43) => {
  const { showSize, clearable, files, ...rest } = props43;
  const fileUpload = useFileUploadContext();
  const acceptedFiles = files ?? fileUpload.acceptedFiles;
  return (0, import_jsx_runtime487.jsx)(For, { each: acceptedFiles, children: (file) => (0, import_jsx_runtime487.jsxs)(FileUploadItem2, { file, ...rest, children: [
    (0, import_jsx_runtime487.jsx)(FileUploadItemPreview2, {}),
    showSize ? (0, import_jsx_runtime487.jsxs)(FileUploadItemContent, { children: [
      (0, import_jsx_runtime487.jsx)(FileUploadItemName2, {}),
      (0, import_jsx_runtime487.jsx)(FileUploadItemSizeText2, {})
    ] }) : (0, import_jsx_runtime487.jsx)(FileUploadItemName2, { flex: "1" }),
    clearable && (0, import_jsx_runtime487.jsx)(FileUploadItemDeleteTrigger2, {})
  ] }, file.name) });
};
var FileUploadList = (0, import_react1010.forwardRef)(
  function FileUploadList2(props43, ref) {
    const { showSize, clearable, files, ...rest } = props43;
    return (0, import_jsx_runtime487.jsx)(FileUploadItemGroup2, { ref, ...rest, children: (0, import_jsx_runtime487.jsx)(
      FileUploadItems,
      {
        showSize,
        clearable,
        files
      }
    ) });
  }
);
var FileUploadFileText = (0, import_react1010.forwardRef)(function FileUploadFileText2(props43, ref) {
  const { fallback: fallback4 = "Select file(s)", ...rest } = props43;
  const fileUpload = useFileUploadContext();
  const styles = useFileUploadStyles();
  const acceptedFiles = fileUpload.acceptedFiles;
  const fileText = (0, import_react1010.useMemo)(() => {
    if (acceptedFiles.length === 1) {
      return acceptedFiles[0].name;
    }
    if (acceptedFiles.length > 1) {
      return `${acceptedFiles.length} files`;
    }
    return fallback4;
  }, [acceptedFiles, fallback4]);
  return (0, import_jsx_runtime487.jsx)(
    Span,
    {
      ref,
      "data-placeholder": fileText === fallback4 ? "" : void 0,
      ...rest,
      css: [styles.fileText, props43.css],
      children: fileText
    }
  );
});
var FileUploadContext2 = file_upload_exports.Context;
var FileUploadHiddenInput2 = file_upload_exports.HiddenInput;

// node_modules/@chakra-ui/react/dist/esm/components/file-upload/namespace.js
var namespace_exports21 = {};
__export(namespace_exports21, {
  ClearTrigger: () => FileUploadClearTrigger2,
  Context: () => FileUploadContext2,
  Dropzone: () => FileUploadDropzone2,
  DropzoneContent: () => FileUploadDropzoneContent,
  FileText: () => FileUploadFileText,
  HiddenInput: () => FileUploadHiddenInput2,
  Item: () => FileUploadItem2,
  ItemContent: () => FileUploadItemContent,
  ItemDeleteTrigger: () => FileUploadItemDeleteTrigger2,
  ItemGroup: () => FileUploadItemGroup2,
  ItemName: () => FileUploadItemName2,
  ItemPreview: () => FileUploadItemPreview2,
  ItemPreviewImage: () => FileUploadItemPreviewImage2,
  ItemSizeText: () => FileUploadItemSizeText2,
  Items: () => FileUploadItems,
  Label: () => FileUploadLabel2,
  List: () => FileUploadList,
  PropsProvider: () => FileUploadPropsProvider,
  Root: () => FileUploadRoot2,
  RootProvider: () => FileUploadRootProvider2,
  Trigger: () => FileUploadTrigger2
});

// node_modules/@chakra-ui/react/dist/esm/components/flex/flex.js
var import_jsx_runtime488 = __toESM(require_jsx_runtime(), 1);
var import_react1011 = __toESM(require_react(), 1);
var Flex = (0, import_react1011.forwardRef)(
  function Flex2(props43, ref) {
    const {
      direction,
      align,
      justify,
      wrap: wrap5,
      basis,
      grow,
      shrink,
      inline: inline2,
      ...rest
    } = props43;
    return (0, import_jsx_runtime488.jsx)(
      chakra.div,
      {
        ref,
        ...rest,
        css: {
          display: inline2 ? "inline-flex" : "flex",
          flexDirection: direction,
          alignItems: align,
          justifyContent: justify,
          flexWrap: wrap5,
          flexBasis: basis,
          flexGrow: grow,
          flexShrink: shrink,
          ...props43.css
        }
      }
    );
  }
);

// node_modules/@chakra-ui/react/dist/esm/components/float/float.js
var import_jsx_runtime489 = __toESM(require_jsx_runtime(), 1);
var import_react1012 = __toESM(require_react(), 1);
var Float = (0, import_react1012.forwardRef)(
  function Float2(props43, ref) {
    const {
      offsetX,
      offsetY,
      offset: offset4 = "0",
      placement = "top-end",
      ...rest
    } = props43;
    const styles = (0, import_react1012.useMemo)(
      () => ({
        display: "inline-flex",
        justifyContent: "center",
        alignItems: "center",
        position: "absolute",
        insetBlockStart: mapObject(placement, (v) => {
          const [side] = v.split("-");
          const map2 = {
            top: offsetY ?? offset4,
            middle: "50%",
            bottom: "auto"
          };
          return map2[side];
        }),
        insetBlockEnd: mapObject(placement, (v) => {
          const [side] = v.split("-");
          const map2 = {
            top: "auto",
            middle: "50%",
            bottom: offsetY ?? offset4
          };
          return map2[side];
        }),
        insetStart: mapObject(placement, (v) => {
          const [, align] = v.split("-");
          const map2 = {
            start: offsetX ?? offset4,
            center: "50%",
            end: "auto"
          };
          return map2[align];
        }),
        insetEnd: mapObject(placement, (v) => {
          const [, align] = v.split("-");
          const map2 = {
            start: "auto",
            center: "50%",
            end: offsetX ?? offset4
          };
          return map2[align];
        }),
        translate: mapObject(placement, (v) => {
          const [side, align] = v.split("-");
          const mapX = { start: "-50%", center: "-50%", end: "50%" };
          const mapY = { top: "-50%", middle: "-50%", bottom: "50%" };
          return `${mapX[align]} ${mapY[side]}`;
        })
      }),
      [offset4, offsetX, offsetY, placement]
    );
    return (0, import_jsx_runtime489.jsx)(chakra.div, { ref, css: styles, ...rest });
  }
);

// node_modules/@chakra-ui/react/dist/esm/components/focus-trap/focus-trap.js
var FocusTrap3 = chakra(FocusTrap2);

// node_modules/@chakra-ui/react/dist/esm/components/grid/grid-item.js
var import_jsx_runtime490 = __toESM(require_jsx_runtime(), 1);
var import_react1013 = __toESM(require_react(), 1);
function spanFn(span) {
  return mapObject(
    span,
    (value) => value === "auto" ? "auto" : `span ${value}/span ${value}`
  );
}
var GridItem = (0, import_react1013.forwardRef)(
  function GridItem2(props43, ref) {
    const {
      area,
      colSpan,
      colStart,
      colEnd,
      rowEnd,
      rowSpan,
      rowStart,
      ...rest
    } = props43;
    const styles = compact({
      gridArea: area,
      gridColumn: spanFn(colSpan),
      gridRow: spanFn(rowSpan),
      gridColumnStart: colStart,
      gridColumnEnd: colEnd,
      gridRowStart: rowStart,
      gridRowEnd: rowEnd
    });
    return (0, import_jsx_runtime490.jsx)(chakra.div, { ref, css: styles, ...rest });
  }
);

// node_modules/@chakra-ui/react/dist/esm/components/grid/simple-grid.js
var import_jsx_runtime491 = __toESM(require_jsx_runtime(), 1);
var import_react1014 = __toESM(require_react(), 1);
var SimpleGrid = (0, import_react1014.forwardRef)(
  function SimpleGrid2(props43, ref) {
    const { columns, minChildWidth, ...rest } = props43;
    const sys = useChakraContext();
    const templateColumns = minChildWidth ? widthToColumns(minChildWidth, sys) : countToColumns(columns);
    return (0, import_jsx_runtime491.jsx)(Grid, { ref, templateColumns, ...rest });
  }
);
function toPx3(n) {
  return typeof n === "number" ? `${n}px` : n;
}
function widthToColumns(width, sys) {
  return mapObject(width, (value) => {
    const _value = sys.tokens.getVar(`sizes.${value}`, toPx3(value));
    return value === null ? null : `repeat(auto-fit, minmax(${_value}, 1fr))`;
  });
}
function countToColumns(count) {
  return mapObject(
    count,
    (value) => value === null ? null : `repeat(${value}, minmax(0, 1fr))`
  );
}

// node_modules/@chakra-ui/react/dist/esm/components/highlight/highlight.js
var import_jsx_runtime492 = __toESM(require_jsx_runtime(), 1);
var import_react1015 = __toESM(require_react(), 1);

// node_modules/@chakra-ui/react/dist/esm/components/typography/mark.js
var { withContext: withContext27, PropsProvider: PropsProvider27 } = createRecipeContext({
  key: "mark"
});
var Mark = withContext27("mark");
var MarkPropsProvider = PropsProvider27;

// node_modules/@chakra-ui/react/dist/esm/components/highlight/highlight.js
function Highlight2(props43) {
  const { children, query: query2, ignoreCase, matchAll, styles } = props43;
  if (typeof children !== "string") {
    throw new Error("The children prop of Highlight must be a string");
  }
  const chunks = useHighlight({
    query: query2,
    text: children,
    matchAll,
    ignoreCase
  });
  return (0, import_jsx_runtime492.jsx)(For, { each: chunks, children: (chunk2, index) => {
    return chunk2.match ? (0, import_jsx_runtime492.jsx)(Mark, { css: styles, children: chunk2.text }, index) : (0, import_jsx_runtime492.jsx)(import_react1015.Fragment, { children: chunk2.text }, index);
  } });
}

// node_modules/@chakra-ui/react/dist/esm/components/hover-card/hover-card.js
var import_jsx_runtime493 = __toESM(require_jsx_runtime(), 1);
var {
  withRootProvider: withRootProvider4,
  withContext: withContext28,
  useStyles: useHoverCardStyles,
  PropsProvider: PropsProvider28
} = createSlotRecipeContext({ key: "hoverCard" });
var HoverCardRootProvider2 = withRootProvider4(hover_card_exports.RootProvider);
var HoverCardRoot2 = withRootProvider4(
  hover_card_exports.Root
);
var HoverCardPropsProvider = PropsProvider28;
var HoverCardTrigger2 = withContext28(hover_card_exports.Trigger, "trigger", { forwardAsChild: true });
var HoverCardPositioner2 = withContext28(hover_card_exports.Positioner, "positioner", { forwardAsChild: true });
var HoverCardContent2 = withContext28(hover_card_exports.Content, "content", { forwardAsChild: true });
var HoverCardArrowTip2 = withContext28(hover_card_exports.ArrowTip, "arrowTip", { forwardAsChild: true });
var HoverCardArrow2 = withContext28(
  hover_card_exports.Arrow,
  "arrow",
  {
    forwardAsChild: true,
    defaultProps: { children: (0, import_jsx_runtime493.jsx)(HoverCardArrowTip2, {}) }
  }
);
var HoverCardContext2 = hover_card_exports.Context;

// node_modules/@chakra-ui/react/dist/esm/components/hover-card/namespace.js
var namespace_exports22 = {};
__export(namespace_exports22, {
  Arrow: () => HoverCardArrow2,
  ArrowTip: () => HoverCardArrowTip2,
  Content: () => HoverCardContent2,
  Context: () => HoverCardContext2,
  Positioner: () => HoverCardPositioner2,
  PropsProvider: () => HoverCardPropsProvider,
  Root: () => HoverCardRoot2,
  RootProvider: () => HoverCardRootProvider2,
  Trigger: () => HoverCardTrigger2
});

// node_modules/@chakra-ui/react/dist/esm/components/image/image.js
var import_jsx_runtime494 = __toESM(require_jsx_runtime(), 1);
var import_react1016 = __toESM(require_react(), 1);
var Image = (0, import_react1016.forwardRef)(
  function Image2(props43, ref) {
    const { align, fit = "cover", ...rest } = props43;
    return (0, import_jsx_runtime494.jsx)(
      chakra.img,
      {
        ref,
        objectFit: fit,
        objectPosition: align,
        className: cx("chakra-image", props43.className),
        ...rest
      }
    );
  }
);

// node_modules/@chakra-ui/react/dist/esm/components/input/input.js
var { withContext: withContext29, PropsProvider: PropsProvider29 } = createRecipeContext({
  key: "input"
});
var Input = withContext29(field_exports.Input);
var InputPropsProvider = PropsProvider29;

// node_modules/@chakra-ui/react/dist/esm/components/input/input-addon.js
var import_jsx_runtime495 = __toESM(require_jsx_runtime(), 1);
var import_react1017 = __toESM(require_react(), 1);
var InputAddon = (0, import_react1017.forwardRef)(
  function InputAddon2({ unstyled, ...props43 }, ref) {
    const recipe = useRecipe({ key: "inputAddon", recipe: props43.recipe });
    const [variantProps, localProps] = recipe.splitVariantProps(props43);
    const styles = unstyled ? EMPTY_SLOT_STYLES : recipe(variantProps);
    return (0, import_jsx_runtime495.jsx)(chakra.div, { ref, ...localProps, css: [styles, props43.css] });
  }
);

// node_modules/@chakra-ui/react/dist/esm/components/input/input-element.js
var InputElement = chakra("div", {
  base: {
    display: "flex",
    alignItems: "center",
    justifyContent: "center",
    position: "absolute",
    zIndex: 2,
    color: "fg.muted",
    height: "full",
    fontSize: "sm",
    px: "3"
  },
  variants: {
    placement: {
      start: {
        insetInlineStart: "0"
      },
      end: {
        insetInlineEnd: "0"
      }
    }
  }
});

// node_modules/@chakra-ui/react/dist/esm/components/input/input-group.js
var import_jsx_runtime496 = __toESM(require_jsx_runtime(), 1);
var import_react1018 = __toESM(require_react(), 1);
var InputGroup = (0, import_react1018.forwardRef)(
  function InputGroup2(props43, ref) {
    const {
      startElement,
      startElementProps,
      endElement,
      endElementProps,
      startAddon,
      startAddonProps,
      endAddon,
      endAddonProps,
      children,
      startOffset = "0px",
      endOffset = "0px",
      ...rest
    } = props43;
    const child = import_react1018.Children.only(children);
    const attached = Boolean(startAddon || endAddon);
    return (0, import_jsx_runtime496.jsxs)(
      Group,
      {
        width: "full",
        ref,
        attached,
        skip: (el) => el.type === InputElement,
        ...rest,
        children: [
          startAddon && (0, import_jsx_runtime496.jsx)(InputAddon, { ...startAddonProps, children: startAddon }),
          startElement && (0, import_jsx_runtime496.jsx)(InputElement, { pointerEvents: "none", ...startElementProps, children: startElement }),
          (0, import_react1018.cloneElement)(child, {
            ...startElement && {
              ps: `calc(var(--input-height) - ${startOffset})`
            },
            ...endElement && { pe: `calc(var(--input-height) - ${endOffset})` },
            ...children.props
          }),
          endElement && (0, import_jsx_runtime496.jsx)(InputElement, { placement: "end", ...endElementProps, children: endElement }),
          endAddon && (0, import_jsx_runtime496.jsx)(InputAddon, { ...endAddonProps, children: endAddon })
        ]
      }
    );
  }
);

// node_modules/@chakra-ui/react/dist/esm/components/kbd/kbd.js
var { withContext: withContext30, PropsProvider: PropsProvider30 } = createRecipeContext({
  key: "kbd"
});
var Kbd = withContext30("kbd");

// node_modules/@chakra-ui/react/dist/esm/components/link/link.js
var { withContext: withContext31, PropsProvider: PropsProvider31 } = createRecipeContext({
  key: "link"
});
var Link = withContext31("a");
var LinkPropsProvider = PropsProvider31;

// node_modules/@chakra-ui/react/dist/esm/components/link/link-box.js
var import_jsx_runtime497 = __toESM(require_jsx_runtime(), 1);
var import_react1019 = __toESM(require_react(), 1);
var LinkOverlay = (0, import_react1019.forwardRef)(
  function LinkOverlay2(props43, ref) {
    const { rel, className, ...rest } = props43;
    return (0, import_jsx_runtime497.jsx)(
      chakra.a,
      {
        ...rest,
        ref,
        className: cx("chakra-linkbox__overlay", className),
        css: [
          {
            position: "static",
            "&::before": {
              content: "''",
              cursor: "inherit",
              display: "block",
              position: "absolute",
              top: 0,
              left: 0,
              zIndex: 0,
              width: "100%",
              height: "100%"
            }
          },
          props43.css
        ]
      }
    );
  }
);
var LinkBox = (0, import_react1019.forwardRef)(
  function LinkBox2(props43, ref) {
    const { className, ...rest } = props43;
    return (0, import_jsx_runtime497.jsx)(
      chakra.div,
      {
        ref,
        position: "relative",
        ...rest,
        className: cx("chakra-linkbox", className),
        css: [
          {
            /* Elevate the links and abbreviations up */
            "& a[href]:not(.chakra-linkbox__overlay), abbr[title]": {
              position: "relative",
              zIndex: 1
            }
          },
          props43.css
        ]
      }
    );
  }
);

// node_modules/@chakra-ui/react/dist/esm/components/list/list.js
var {
  withProvider: withProvider19,
  withContext: withContext32,
  useStyles: useListStyles,
  PropsProvider: PropsProvider32
} = createSlotRecipeContext({ key: "list" });
var ListRoot = withProvider19(
  "ul",
  "root",
  { defaultProps: { role: "list" } }
);
var ListRootPropsProvider = PropsProvider32;
var ListItem = withContext32("li", "item");
var ListIndicator = withContext32(
  "span",
  "indicator"
);

// node_modules/@chakra-ui/react/dist/esm/components/list/namespace.js
var namespace_exports23 = {};
__export(namespace_exports23, {
  Indicator: () => ListIndicator,
  Item: () => ListItem,
  Root: () => ListRoot,
  RootPropsProvider: () => ListRootPropsProvider
});

// node_modules/@chakra-ui/react/dist/esm/components/loader/loader-overlay.js
var LoaderOverlay = chakra("div", {
  base: {
    pos: "absolute",
    inset: "0",
    display: "flex",
    alignItems: "center",
    justifyContent: "center",
    boxSize: "full",
    gap: "2"
  }
});

// node_modules/@chakra-ui/react/dist/esm/components/menu/menu.js
var import_jsx_runtime498 = __toESM(require_jsx_runtime(), 1);
var {
  withRootProvider: withRootProvider5,
  withContext: withContext33,
  useStyles: useMenuStyles,
  PropsProvider: PropsProvider33
} = createSlotRecipeContext({ key: "menu" });
var MenuRootProvider2 = withRootProvider5(
  menu_exports.RootProvider
);
var MenuRoot2 = withRootProvider5(menu_exports.Root, {
  defaultProps: { lazyMount: true, unmountOnExit: true }
});
var MenuPropsProvider = PropsProvider33;
var MenuTrigger2 = withContext33(
  menu_exports.Trigger,
  "trigger",
  { forwardAsChild: true }
);
var MenuContextTrigger2 = withContext33(menu_exports.ContextTrigger, "contextTrigger", { forwardAsChild: true });
var MenuPositioner2 = withContext33(
  menu_exports.Positioner,
  "positioner",
  { forwardAsChild: true }
);
var MenuSeparator2 = withContext33(
  menu_exports.Separator,
  "separator",
  { forwardAsChild: true }
);
var MenuContent2 = withContext33(
  menu_exports.Content,
  "content",
  { forwardAsChild: true }
);
var MenuArrowTip2 = withContext33(
  menu_exports.ArrowTip,
  "arrowTip",
  { forwardAsChild: true }
);
var MenuArrow2 = withContext33(
  menu_exports.Arrow,
  "arrow",
  { forwardAsChild: true, defaultProps: { children: (0, import_jsx_runtime498.jsx)(MenuArrowTip2, {}) } }
);
var MenuIndicator2 = withContext33(
  menu_exports.Indicator,
  "indicator",
  { forwardAsChild: true }
);
var MenuItemGroup2 = withContext33(
  menu_exports.ItemGroup,
  "itemGroup",
  { forwardAsChild: true }
);
var MenuItemGroupLabel2 = withContext33(menu_exports.ItemGroupLabel, "itemGroupLabel", { forwardAsChild: true });
var MenuItem2 = withContext33(
  menu_exports.Item,
  "item",
  { forwardAsChild: true }
);
var MenuTriggerItem2 = withContext33(menu_exports.TriggerItem, "item", { forwardAsChild: true });
var MenuItemText2 = withContext33(
  menu_exports.ItemText,
  "itemText",
  { forwardAsChild: true }
);
var MenuItemCommand = withContext33(
  "kbd",
  "itemCommand"
);
var MenuItemIndicator2 = withContext33(menu_exports.ItemIndicator, "itemIndicator", {
  forwardAsChild: true,
  defaultProps: { children: (0, import_jsx_runtime498.jsx)(CheckIcon, { boxSize: "4" }) }
});
var MenuCheckboxItem2 = withContext33(menu_exports.CheckboxItem, "item", { forwardAsChild: true });
var MenuRadioItemGroup2 = withContext33(menu_exports.RadioItemGroup, "itemGroup", { forwardAsChild: true });
var MenuRadioItem2 = withContext33(
  menu_exports.RadioItem,
  "item",
  { forwardAsChild: true }
);
var MenuContext2 = menu_exports.Context;
var MenuItemContext2 = menu_exports.ItemContext;

// node_modules/@chakra-ui/react/dist/esm/components/menu/namespace.js
var namespace_exports24 = {};
__export(namespace_exports24, {
  Arrow: () => MenuArrow2,
  ArrowTip: () => MenuArrowTip2,
  CheckboxItem: () => MenuCheckboxItem2,
  Content: () => MenuContent2,
  Context: () => MenuContext2,
  ContextTrigger: () => MenuContextTrigger2,
  Indicator: () => MenuIndicator2,
  Item: () => MenuItem2,
  ItemCommand: () => MenuItemCommand,
  ItemContext: () => MenuItemContext2,
  ItemGroup: () => MenuItemGroup2,
  ItemGroupLabel: () => MenuItemGroupLabel2,
  ItemIndicator: () => MenuItemIndicator2,
  ItemText: () => MenuItemText2,
  Positioner: () => MenuPositioner2,
  RadioItem: () => MenuRadioItem2,
  RadioItemGroup: () => MenuRadioItemGroup2,
  Root: () => MenuRoot2,
  RootPropsProvider: () => MenuPropsProvider,
  RootProvider: () => MenuRootProvider2,
  Separator: () => MenuSeparator2,
  Trigger: () => MenuTrigger2,
  TriggerItem: () => MenuTriggerItem2
});

// node_modules/@chakra-ui/react/dist/esm/components/native-select/native-select.js
var import_jsx_runtime499 = __toESM(require_jsx_runtime(), 1);
var import_react1020 = __toESM(require_react(), 1);
var [NativeSelectBasePropsProvider, useNativeSelectBaseProps] = createContext({
  name: "NativeSelectBasePropsContext",
  hookName: "useNativeSelectBaseProps",
  providerName: "<NativeSelectRoot />",
  strict: false
});
var {
  withProvider: withProvider20,
  useClassNames: useClassNames4,
  useStyles: useNativeSelectStyles,
  PropsProvider: PropsProvider34
} = createSlotRecipeContext({ key: "nativeSelect" });
var NativeSelectRoot = withProvider20("div", "root", {
  wrapElement(element, props43) {
    const field = useFieldContext();
    const disabled = Boolean((field == null ? void 0 : field.disabled) ?? props43.disabled);
    const invalid = Boolean((field == null ? void 0 : field.invalid) ?? props43.invalid);
    return (0, import_jsx_runtime499.jsx)(NativeSelectBasePropsProvider, { value: { disabled, invalid }, children: element });
  }
});
var NativeSelectPropsProvider = PropsProvider34;
var StyledSelect = chakra(field_exports.Select, {}, { forwardAsChild: true });
var NativeSelectField = (0, import_react1020.forwardRef)(function NativeSelectField2(props43, ref) {
  const { children, placeholder, ...restProps } = props43;
  const { disabled, invalid } = useNativeSelectBaseProps();
  const styles = useNativeSelectStyles();
  const classNames = useClassNames4();
  return (0, import_jsx_runtime499.jsxs)(
    StyledSelect,
    {
      disabled,
      "data-invalid": dataAttr2(invalid),
      ...restProps,
      ref,
      className: cx(classNames.field, props43.className),
      css: [styles.field, props43.css],
      children: [
        placeholder && (0, import_jsx_runtime499.jsx)("option", { value: "", children: placeholder }),
        children
      ]
    }
  );
});
function NativeSelectIndicator(props43) {
  const styles = useNativeSelectStyles();
  const { disabled, invalid } = useNativeSelectBaseProps();
  const classNames = useClassNames4();
  return (0, import_jsx_runtime499.jsx)(
    chakra.div,
    {
      ...props43,
      "data-disabled": dataAttr2(disabled),
      "data-invalid": dataAttr2(invalid),
      className: cx(classNames.indicator, props43.className),
      css: [styles.indicator, props43.css],
      children: props43.children ?? (0, import_jsx_runtime499.jsx)(ChevronDownIcon, {})
    }
  );
}

// node_modules/@chakra-ui/react/dist/esm/components/native-select/namespace.js
var namespace_exports25 = {};
__export(namespace_exports25, {
  Field: () => NativeSelectField,
  Indicator: () => NativeSelectIndicator,
  PropsProvider: () => NativeSelectPropsProvider,
  Root: () => NativeSelectRoot
});

// node_modules/@chakra-ui/react/dist/esm/components/number-input/number-input.js
var import_jsx_runtime500 = __toESM(require_jsx_runtime(), 1);
var {
  withProvider: withProvider21,
  withContext: withContext34,
  useStyles: useNumberInputStyles,
  PropsProvider: PropsProvider35
} = createSlotRecipeContext({ key: "numberInput" });
var NumberInputRootProvider2 = withProvider21(number_input_exports.RootProvider, "root", { forwardAsChild: true });
var NumberInputRoot2 = withProvider21(number_input_exports.Root, "root", { forwardAsChild: true });
var NumberInputPropsProvider = PropsProvider35;
var NumberInputLabel2 = withContext34(number_input_exports.Label, "label", { forwardAsChild: true });
var NumberInputInput2 = withContext34(number_input_exports.Input, "input", { forwardAsChild: true });
var NumberInputIncrementTrigger2 = withContext34(number_input_exports.IncrementTrigger, "incrementTrigger", {
  forwardAsChild: true,
  defaultProps: { children: (0, import_jsx_runtime500.jsx)(ChevronUpIcon, {}) }
});
var NumberInputDecrementTrigger2 = withContext34(number_input_exports.DecrementTrigger, "decrementTrigger", {
  forwardAsChild: true,
  defaultProps: { children: (0, import_jsx_runtime500.jsx)(ChevronDownIcon, {}) }
});
var NumberInputControl2 = withContext34(number_input_exports.Control, "control", {
  forwardAsChild: true,
  defaultProps: {
    children: (0, import_jsx_runtime500.jsxs)(import_jsx_runtime500.Fragment, { children: [
      (0, import_jsx_runtime500.jsx)(NumberInputIncrementTrigger2, {}),
      (0, import_jsx_runtime500.jsx)(NumberInputDecrementTrigger2, {})
    ] })
  }
});
var NumberInputScrubber2 = withContext34(number_input_exports.Scrubber, "scrubber", { forwardAsChild: true });
var NumberInputValueText2 = withContext34(number_input_exports.ValueText, "valueText", { forwardAsChild: true });
var NumberInputContext2 = number_input_exports.Context;

// node_modules/@chakra-ui/react/dist/esm/components/number-input/namespace.js
var namespace_exports26 = {};
__export(namespace_exports26, {
  Context: () => NumberInputContext2,
  Control: () => NumberInputControl2,
  DecrementTrigger: () => NumberInputDecrementTrigger2,
  IncrementTrigger: () => NumberInputIncrementTrigger2,
  Input: () => NumberInputInput2,
  Label: () => NumberInputLabel2,
  PropsProvider: () => NumberInputPropsProvider,
  Root: () => NumberInputRoot2,
  RootProvider: () => NumberInputRootProvider2,
  Scrubber: () => NumberInputScrubber2,
  ValueText: () => NumberInputValueText2
});

// node_modules/@chakra-ui/react/dist/esm/components/pagination/pagination.js
var import_jsx_runtime501 = __toESM(require_jsx_runtime(), 1);
var import_react1021 = __toESM(require_react(), 1);
var {
  withProvider: withProvider22,
  withContext: withContext35,
  useStyles: usePaginationStyles,
  PropsProvider: PropsProvider36
} = createSlotRecipeContext({ key: "pagination" });
var PaginationRootProvider2 = withProvider22(pagination_exports.RootProvider, "root", {
  forwardAsChild: true,
  forwardProps: ["page"]
});
var PaginationRoot2 = withProvider22(
  pagination_exports.Root,
  "root",
  { forwardAsChild: true, forwardProps: ["page"] }
);
var PaginationPropsProvider = PropsProvider36;
var PaginationEllipsis2 = withContext35(pagination_exports.Ellipsis, "ellipsis", { forwardAsChild: true });
var PaginationItem2 = withContext35(pagination_exports.Item, "item", { forwardAsChild: true });
var PaginationNextTrigger2 = withContext35(pagination_exports.NextTrigger, "nextTrigger", { forwardAsChild: true });
var PaginationPrevTrigger2 = withContext35(pagination_exports.PrevTrigger, "prevTrigger", { forwardAsChild: true });
var PaginationContext2 = pagination_exports.Context;
var PaginationPageText = (0, import_react1021.forwardRef)(function PaginationPageText2(props43, ref) {
  const { format = "compact", ...rest } = props43;
  const { page, totalPages, pageRange, count } = usePaginationContext();
  const content = (0, import_react1021.useMemo)(() => {
    if (format === "short") return `${page} / ${totalPages}`;
    if (format === "compact") return `${page} of ${totalPages}`;
    return `${pageRange.start + 1} - ${Math.min(pageRange.end, count)} of ${count}`;
  }, [format, page, totalPages, pageRange, count]);
  return (0, import_jsx_runtime501.jsx)(Box, { fontWeight: "medium", ref, ...rest, children: content });
});
var PaginationItems = (props43) => {
  const { pages } = usePaginationContext();
  const { render, ellipsis, ...rest } = props43;
  return (0, import_jsx_runtime501.jsx)(For, { each: pages, children: (page, index) => {
    if (page.type === "ellipsis") {
      return (0, import_jsx_runtime501.jsx)(PaginationEllipsis2, { asChild: true, index, ...rest, children: ellipsis || (0, import_jsx_runtime501.jsx)(IconButton, { as: "span", children: (0, import_jsx_runtime501.jsx)(EllipsisIcon, {}) }) }, index);
    }
    return (0, import_jsx_runtime501.jsx)(
      PaginationItem2,
      {
        asChild: true,
        type: "page",
        value: page.value,
        ...rest,
        children: render(page)
      },
      index
    );
  } });
};

// node_modules/@chakra-ui/react/dist/esm/components/pagination/namespace.js
var namespace_exports27 = {};
__export(namespace_exports27, {
  Context: () => PaginationContext2,
  Ellipsis: () => PaginationEllipsis2,
  Item: () => PaginationItem2,
  Items: () => PaginationItems,
  NextTrigger: () => PaginationNextTrigger2,
  PageText: () => PaginationPageText,
  PrevTrigger: () => PaginationPrevTrigger2,
  PropsProvider: () => PaginationPropsProvider,
  Root: () => PaginationRoot2,
  RootProvider: () => PaginationRootProvider2
});

// node_modules/@chakra-ui/react/dist/esm/components/pin-input/pin-input.js
var {
  withProvider: withProvider23,
  withContext: withContext36,
  useStyles: usePinInputStyles,
  PropsProvider: PropsProvider37
} = createSlotRecipeContext({ key: "pinInput" });
var PinInputRootProvider2 = withProvider23(pin_input_exports.RootProvider, "root", { forwardAsChild: true });
var PinInputRoot2 = withProvider23(
  pin_input_exports.Root,
  "root",
  { forwardProps: ["mask"], forwardAsChild: true }
);
var PinInputPropsProvider = PropsProvider37;
var PinInputControl2 = withContext36(pin_input_exports.Control, "control", { forwardAsChild: true });
var PinInputInput2 = withContext36(
  pin_input_exports.Input,
  "input",
  { forwardAsChild: true }
);
var PinInputLabel2 = withContext36(
  pin_input_exports.Label,
  "label",
  { forwardAsChild: true }
);
var PinInputContext2 = pin_input_exports.Context;
var PinInputHiddenInput2 = pin_input_exports.HiddenInput;

// node_modules/@chakra-ui/react/dist/esm/components/pin-input/namespace.js
var namespace_exports28 = {};
__export(namespace_exports28, {
  Context: () => PinInputContext2,
  Control: () => PinInputControl2,
  HiddenInput: () => PinInputHiddenInput2,
  Input: () => PinInputInput2,
  Label: () => PinInputLabel2,
  PropsProvider: () => PinInputPropsProvider,
  Root: () => PinInputRoot2,
  RootProvider: () => PinInputRootProvider2
});

// node_modules/@chakra-ui/react/dist/esm/components/popover/popover.js
var import_jsx_runtime502 = __toESM(require_jsx_runtime(), 1);
var {
  withRootProvider: withRootProvider6,
  withContext: withContext37,
  useStyles: usePopoverStyles,
  PropsProvider: PropsProvider38
} = createSlotRecipeContext({ key: "popover" });
var PopoverRootProvider2 = withRootProvider6(
  popover_exports.RootProvider
);
var PopoverRoot2 = withRootProvider6(popover_exports.Root);
var PopoverPropsProvider = PropsProvider38;
var PopoverTrigger2 = withContext37(popover_exports.Trigger, "trigger", { forwardAsChild: true });
var PopoverPositioner2 = withContext37(popover_exports.Positioner, "positioner", { forwardAsChild: true });
var PopoverContent2 = withContext37(
  popover_exports.Content,
  "content",
  { forwardAsChild: true }
);
var PopoverArrowTip2 = withContext37(popover_exports.ArrowTip, "arrowTip", { forwardAsChild: true });
var PopoverArrow2 = withContext37(
  popover_exports.Arrow,
  "arrow",
  {
    forwardAsChild: true,
    defaultProps: { children: (0, import_jsx_runtime502.jsx)(PopoverArrowTip2, {}) }
  }
);
var PopoverCloseTrigger2 = withContext37(popover_exports.CloseTrigger, "closeTrigger", { forwardAsChild: true });
var PopoverIndicator2 = withContext37(popover_exports.Indicator, "indicator", { forwardAsChild: true });
var PopoverTitle2 = withContext37(
  popover_exports.Title,
  "title",
  { forwardAsChild: true }
);
var PopoverDescription2 = withContext37(popover_exports.Description, "description", { forwardAsChild: true });
var PopoverFooter = withContext37(
  "footer",
  "footer"
);
var PopoverHeader = withContext37(
  "header",
  "header"
);
var PopoverBody = withContext37(
  "div",
  "body"
);
var PopoverAnchor2 = withContext37(
  popover_exports.Anchor,
  void 0,
  { forwardAsChild: true }
);
var PopoverContext2 = popover_exports.Context;

// node_modules/@chakra-ui/react/dist/esm/components/popover/namespace.js
var namespace_exports29 = {};
__export(namespace_exports29, {
  Anchor: () => PopoverAnchor2,
  Arrow: () => PopoverArrow2,
  ArrowTip: () => PopoverArrowTip2,
  Body: () => PopoverBody,
  CloseTrigger: () => PopoverCloseTrigger2,
  Content: () => PopoverContent2,
  Context: () => PopoverContext2,
  Description: () => PopoverDescription2,
  Footer: () => PopoverFooter,
  Header: () => PopoverHeader,
  Positioner: () => PopoverPositioner2,
  PropsProvider: () => PopoverPropsProvider,
  Root: () => PopoverRoot2,
  RootProvider: () => PopoverRootProvider2,
  Title: () => PopoverTitle2,
  Trigger: () => PopoverTrigger2,
  usePopoverStyles: () => usePopoverStyles
});

// node_modules/@chakra-ui/react/dist/esm/components/progress/progress.js
var {
  withProvider: withProvider24,
  withContext: withContext38,
  useStyles: useProgressStyles,
  PropsProvider: PropsProvider39
} = createSlotRecipeContext({ key: "progress" });
var ProgressRootProvider2 = withProvider24(progress_exports.RootProvider, "root", { forwardAsChild: true });
var ProgressRoot2 = withProvider24(
  progress_exports.Root,
  "root"
);
var ProgressPropsProvider = PropsProvider39;
var ProgressLabel2 = withContext38(
  progress_exports.Label,
  "label",
  { forwardAsChild: true }
);
var ProgressTrack2 = withContext38(
  progress_exports.Track,
  "track",
  { forwardAsChild: true }
);
var ProgressRange2 = withContext38(
  progress_exports.Range,
  "range",
  { forwardAsChild: true }
);
var ProgressValueText2 = withContext38(progress_exports.ValueText, "valueText", { forwardAsChild: true });
var ProgressContext2 = progress_exports.Context;

// node_modules/@chakra-ui/react/dist/esm/components/progress/namespace.js
var namespace_exports30 = {};
__export(namespace_exports30, {
  Context: () => ProgressContext2,
  Label: () => ProgressLabel2,
  PropsProvider: () => ProgressPropsProvider,
  Range: () => ProgressRange2,
  Root: () => ProgressRoot2,
  RootProvider: () => ProgressRootProvider2,
  Track: () => ProgressTrack2,
  ValueText: () => ProgressValueText2
});

// node_modules/@chakra-ui/react/dist/esm/components/progress-circle/progress-circle.js
var {
  withProvider: withProvider25,
  withContext: withContext39,
  useStyles: useProgressCircleStyles,
  PropsProvider: PropsProvider40
} = createSlotRecipeContext({ key: "progressCircle" });
var ProgressCircleRootProvider = withProvider25(progress_exports.RootProvider, "root", { forwardAsChild: true });
var ProgressCircleRoot = withProvider25(progress_exports.Root, "root", { forwardAsChild: true });
var ProgressCirclePropsProvider = PropsProvider40;
var ProgressCircleLabel = withContext39(progress_exports.Label, "label", { forwardAsChild: true });
var ProgressCircleCircle = withContext39(progress_exports.Circle, "circle", { forwardAsChild: true });
var ProgressCircleTrack2 = withContext39(progress_exports.CircleTrack, "circleTrack", { forwardAsChild: true });
var ProgressCircleRange2 = withContext39(progress_exports.CircleRange, "circleRange", { forwardAsChild: true });
var ProgressCircleValueText = withContext39(progress_exports.ValueText, "valueText", { forwardAsChild: true });
var ProgressCircleContext = progress_exports.Context;

// node_modules/@chakra-ui/react/dist/esm/components/progress-circle/namespace.js
var namespace_exports31 = {};
__export(namespace_exports31, {
  Circle: () => ProgressCircleCircle,
  Label: () => ProgressCircleLabel,
  PropsProvider: () => ProgressCirclePropsProvider,
  Range: () => ProgressCircleRange2,
  Root: () => ProgressCircleRoot,
  RootProvider: () => ProgressCircleRootProvider,
  Track: () => ProgressCircleTrack2,
  ValueText: () => ProgressCircleValueText
});

// node_modules/@chakra-ui/react/dist/esm/components/qr-code/qr-code.js
var import_jsx_runtime503 = __toESM(require_jsx_runtime(), 1);
var {
  withProvider: withProvider26,
  withContext: withContext40,
  useStyles: useQrCodeStyles,
  PropsProvider: PropsProvider41
} = createSlotRecipeContext({ key: "qrCode" });
var QrCodeRoot2 = withProvider26(
  qr_code_exports.Root,
  "root",
  { forwardAsChild: true }
);
var QrCodeRootProvider2 = withProvider26(qr_code_exports.RootProvider, "root", { forwardAsChild: true });
var QrCodePropsProvider = PropsProvider41;
var QrCodePattern2 = withContext40(
  qr_code_exports.Pattern,
  "pattern",
  { forwardAsChild: true }
);
var QrCodeFrame2 = withContext40(
  qr_code_exports.Frame,
  "frame",
  {
    forwardAsChild: true,
    defaultProps: { children: (0, import_jsx_runtime503.jsx)(QrCodePattern2, {}) }
  }
);
var QrCodeOverlay2 = withContext40(
  qr_code_exports.Overlay,
  "overlay",
  { forwardAsChild: true }
);
var QrCodeDownloadTrigger2 = withContext40(qr_code_exports.DownloadTrigger, "downloadTrigger", { forwardAsChild: true });

// node_modules/@chakra-ui/react/dist/esm/components/qr-code/namespace.js
var namespace_exports32 = {};
__export(namespace_exports32, {
  Context: () => QrCodeContext,
  DownloadTrigger: () => QrCodeDownloadTrigger2,
  Frame: () => QrCodeFrame2,
  Overlay: () => QrCodeOverlay2,
  Pattern: () => QrCodePattern2,
  PropsProvider: () => QrCodePropsProvider,
  Root: () => QrCodeRoot2,
  RootProvider: () => QrCodeRootProvider2
});

// node_modules/@chakra-ui/react/dist/esm/components/radio-card/radio-card.js
var import_jsx_runtime505 = __toESM(require_jsx_runtime(), 1);
var import_react1023 = __toESM(require_react(), 1);

// node_modules/@chakra-ui/react/dist/esm/components/radiomark/radiomark.js
var import_jsx_runtime504 = __toESM(require_jsx_runtime(), 1);
var import_react1022 = __toESM(require_react(), 1);
var Radiomark = (0, import_react1022.forwardRef)(
  function Radiomark2(props43, ref) {
    const recipe = useRecipe({ key: "radiomark", recipe: props43.recipe });
    const [variantProps, restProps] = recipe.splitVariantProps(props43);
    const { checked, disabled, unstyled, children, ...rest } = restProps;
    const styles = unstyled ? EMPTY_STYLES : recipe(variantProps);
    const sharedProps = {
      ref,
      "data-checked": dataAttr2(checked),
      "data-disabled": dataAttr2(disabled),
      ...rest,
      css: [styles, props43.css]
    };
    return (0, import_jsx_runtime504.jsx)(chakra.span, { ...sharedProps, children: checked && (0, import_jsx_runtime504.jsx)("span", { className: "dot" }) });
  }
);

// node_modules/@chakra-ui/react/dist/esm/components/radio-card/radio-card.js
var {
  withProvider: withProvider27,
  withContext: withContext41,
  useStyles: useRadioCardStyles,
  PropsProvider: PropsProvider42
} = createSlotRecipeContext({ key: "radioCard" });
var RadioCardRootProvider = withProvider27(radio_group_exports.RootProvider, "root", { forwardAsChild: true });
var RadioCardRoot = withProvider27(
  radio_group_exports.Root,
  "root",
  { forwardAsChild: true }
);
var RadioCardPropsProvider = PropsProvider42;
var RadioCardLabel = withContext41(
  radio_group_exports.Label,
  "label",
  { forwardAsChild: true }
);
var RadioCardItem = withContext41(
  radio_group_exports.Item,
  "item",
  { forwardAsChild: true }
);
var RadioCardItemText = withContext41(radio_group_exports.ItemText, "itemText", { forwardAsChild: true });
var RadioCardItemDescription = withContext41("div", "itemDescription", { forwardAsChild: true });
var RadioCardItemControl = (0, import_react1023.forwardRef)(function RadioCardItemControl2(props43, ref) {
  const api = useRadioGroupItemContext();
  const styles = useRadioCardStyles();
  return (0, import_jsx_runtime505.jsx)(
    chakra.div,
    {
      ref,
      "data-focus": dataAttr2(api.focused),
      "data-disabled": dataAttr2(api.disabled),
      "data-state": api.checked ? "checked" : "unchecked",
      "data-hover": dataAttr2(api.hovered),
      "data-active": dataAttr2(api.active),
      "data-invalid": dataAttr2(api.invalid),
      ...props43,
      css: [styles["itemControl"], props43.css]
    }
  );
});
var RadioCardItemContent = withContext41("div", "itemContent");
var RadioCardItemAddon = withContext41("div", "itemAddon");
var RadioCardItemIndicator = (0, import_react1023.forwardRef)(function RadioGroupItemIndicator(props43, ref) {
  const { checked, ...rest } = props43;
  const styles = useRadioCardStyles();
  const itemContext = useRadioGroupItemContext();
  if (checked && itemContext.checked) {
    return (0, import_jsx_runtime505.jsx)(
      chakra.span,
      {
        ref,
        asChild: true,
        ...rest,
        "aria-hidden": "true",
        css: [styles["itemIndicator"], props43.css],
        children: checked
      }
    );
  }
  return (0, import_jsx_runtime505.jsx)(
    Radiomark,
    {
      ref,
      unstyled: true,
      ...props43,
      "aria-hidden": "true",
      checked: itemContext.checked,
      disabled: itemContext.disabled,
      css: [styles["itemIndicator"], props43.css]
    }
  );
});
var RadioCardContext = radio_group_exports.Context;
var RadioCardItemContext = radio_group_exports.ItemContext;
var RadioCardItemHiddenInput = radio_group_exports.ItemHiddenInput;

// node_modules/@chakra-ui/react/dist/esm/components/radio-card/namespace.js
var namespace_exports33 = {};
__export(namespace_exports33, {
  Context: () => RadioCardContext,
  Item: () => RadioCardItem,
  ItemAddon: () => RadioCardItemAddon,
  ItemContent: () => RadioCardItemContent,
  ItemContext: () => RadioCardItemContext,
  ItemControl: () => RadioCardItemControl,
  ItemDescription: () => RadioCardItemDescription,
  ItemHiddenInput: () => RadioCardItemHiddenInput,
  ItemIndicator: () => RadioCardItemIndicator,
  ItemText: () => RadioCardItemText,
  Label: () => RadioCardLabel,
  PropsProvider: () => RadioCardPropsProvider,
  Root: () => RadioCardRoot,
  RootProvider: () => RadioCardRootProvider
});

// node_modules/@chakra-ui/react/dist/esm/components/radio-group/radio-group.js
var import_jsx_runtime506 = __toESM(require_jsx_runtime(), 1);
var import_react1024 = __toESM(require_react(), 1);
var {
  withProvider: withProvider28,
  withContext: withContext42,
  useStyles: useRadioGroupStyles,
  PropsProvider: PropsProvider43
} = createSlotRecipeContext({ key: "radioGroup" });
var RadioGroupRootProvider2 = withProvider28(radio_group_exports.RootProvider, "root", { forwardAsChild: true });
var RadioGroupRoot2 = withProvider28(
  radio_group_exports.Root,
  "root",
  { forwardAsChild: true }
);
var RadioGroupPropsProvider = PropsProvider43;
var RadioGroupLabel2 = withContext42(radio_group_exports.Label, "label", { forwardAsChild: true });
var RadioGroupItem2 = withContext42(
  radio_group_exports.Item,
  "item",
  { forwardAsChild: true }
);
var RadioGroupItemText2 = withContext42(radio_group_exports.ItemText, "itemText", { forwardAsChild: true });
var RadioGroupItemControl2 = withContext42(radio_group_exports.ItemControl, "itemControl", { forwardAsChild: true });
var RadioGroupItemIndicator2 = (0, import_react1024.forwardRef)(function RadioGroupItemIndicator22(props43, ref) {
  const styles = useRadioGroupStyles();
  return (0, import_jsx_runtime506.jsx)(radio_group_exports.ItemContext, { children: (itemState) => (0, import_jsx_runtime506.jsx)(radio_group_exports.ItemControl, { asChild: true, children: (0, import_jsx_runtime506.jsx)(
    Radiomark,
    {
      ref,
      unstyled: true,
      ...props43,
      checked: itemState.checked,
      disabled: itemState.disabled,
      css: [styles["itemControl"], props43.css]
    }
  ) }) });
});
var RadioGroupContext2 = radio_group_exports.Context;
var RadioGroupItemContext2 = radio_group_exports.ItemContext;
var RadioGroupItemHiddenInput2 = radio_group_exports.ItemHiddenInput;

// node_modules/@chakra-ui/react/dist/esm/components/radio-group/namespace.js
var namespace_exports34 = {};
__export(namespace_exports34, {
  Context: () => RadioGroupContext2,
  Item: () => RadioGroupItem2,
  ItemContext: () => RadioGroupItemContext2,
  ItemControl: () => RadioGroupItemControl2,
  ItemHiddenInput: () => RadioGroupItemHiddenInput2,
  ItemIndicator: () => RadioGroupItemIndicator2,
  ItemText: () => RadioGroupItemText2,
  Label: () => RadioGroupLabel2,
  PropsProvider: () => RadioGroupPropsProvider,
  Root: () => RadioGroupRoot2,
  RootProvider: () => RadioGroupRootProvider2
});

// node_modules/@chakra-ui/react/dist/esm/components/rating-group/rating-group.js
var import_jsx_runtime507 = __toESM(require_jsx_runtime(), 1);
var import_react1025 = __toESM(require_react(), 1);
var {
  withProvider: withProvider29,
  withContext: withContext43,
  useStyles: useRatingGroupStyles,
  PropsProvider: PropsProvider44
} = createSlotRecipeContext({ key: "ratingGroup" });
var RatingGroupRootProvider2 = withProvider29(rating_group_exports.RootProvider, "root", { forwardAsChild: true });
var RatingGroupRoot2 = withProvider29(rating_group_exports.Root, "root", { forwardAsChild: true });
var RatingGroupPropsProvider = PropsProvider44;
var RatingGroupLabel2 = withContext43(rating_group_exports.Label, "label", { forwardAsChild: true });
var RatingGroupItem2 = withContext43(rating_group_exports.Item, "item", { forwardAsChild: true });
function cloneIcon(icon, type) {
  if (!(0, import_react1025.isValidElement)(icon)) return null;
  const props43 = { [`data-${type}`]: "", "aria-hidden": "" };
  return (0, import_react1025.cloneElement)(icon, props43);
}
var RatingGroupItemIndicator = (0, import_react1025.forwardRef)(function RatingGroupItemIndicator2(props43, ref) {
  const { icon = (0, import_jsx_runtime507.jsx)(StarIcon, {}), ...rest } = props43;
  const styles = useRatingGroupStyles();
  const itemState = useRatingGroupItemContext();
  return (0, import_jsx_runtime507.jsxs)(
    chakra.span,
    {
      ...rest,
      "data-highlighted": itemState.highlighted ? "" : void 0,
      "data-checked": itemState.checked ? "" : void 0,
      "data-half": itemState.half ? "" : void 0,
      css: [styles.itemIndicator, props43.css],
      ref,
      children: [
        cloneIcon(icon, "bg"),
        cloneIcon(icon, "fg")
      ]
    }
  );
});
var RatingGroupItems = (props43) => {
  const api = useRatingGroupContext();
  return (0, import_jsx_runtime507.jsx)(For, { each: api.items, children: (index) => (0, import_jsx_runtime507.jsx)(RatingGroupItem2, { index, ...props43, children: (0, import_jsx_runtime507.jsx)(RatingGroupItemIndicator, {}) }, index) });
};
var RatingGroupControl2 = withContext43(rating_group_exports.Control, "control", {
  forwardAsChild: true,
  defaultProps: { children: (0, import_jsx_runtime507.jsx)(RatingGroupItems, {}) }
});
var RatingGroupContext2 = rating_group_exports.Context;
var RatingGroupItemContext2 = rating_group_exports.ItemContext;
var RatingGroupHiddenInput2 = rating_group_exports.HiddenInput;

// node_modules/@chakra-ui/react/dist/esm/components/rating-group/namespace.js
var namespace_exports35 = {};
__export(namespace_exports35, {
  Context: () => RatingGroupContext2,
  Control: () => RatingGroupControl2,
  HiddenInput: () => RatingGroupHiddenInput2,
  Item: () => RatingGroupItem2,
  ItemContext: () => RatingGroupItemContext2,
  ItemIndicator: () => RatingGroupItemIndicator,
  Items: () => RatingGroupItems,
  Label: () => RatingGroupLabel2,
  PropsProvider: () => RatingGroupPropsProvider,
  Root: () => RatingGroupRoot2,
  RootProvider: () => RatingGroupRootProvider2,
  useRatingGroupStyles: () => useRatingGroupStyles
});

// node_modules/@chakra-ui/react/dist/esm/components/segment-group/segment-group.js
var import_jsx_runtime508 = __toESM(require_jsx_runtime(), 1);
var import_react1026 = __toESM(require_react(), 1);
var {
  withProvider: withProvider30,
  withContext: withContext44,
  useStyles: useSegmentGroupStyles,
  PropsProvider: PropsProvider45
} = createSlotRecipeContext({ key: "segmentGroup" });
var SegmentGroupRootProvider2 = withProvider30(segment_group_exports.RootProvider, "root", { forwardAsChild: true });
var SegmentGroupRoot2 = withProvider30(segment_group_exports.Root, "root", {
  forwardAsChild: true,
  forwardProps: ["orientation"],
  defaultProps: {
    orientation: "horizontal"
  }
});
var SegmentGroupPropsProvider = PropsProvider45;
var SegmentGroupItem2 = withContext44(segment_group_exports.Item, "item", { forwardAsChild: true });
var SegmentGroupItemText2 = withContext44(segment_group_exports.ItemText, "itemText", { forwardAsChild: true });
var SegmentGroupIndicator2 = withContext44(segment_group_exports.Indicator, "indicator", { forwardAsChild: true });
function normalize3(items) {
  return items.map((item) => {
    if (typeof item === "string") return { value: item, label: item };
    return item;
  });
}
var SegmentGroupItems = (props43) => {
  const { items, ...rest } = props43;
  const data = (0, import_react1026.useMemo)(() => normalize3(items), [items]);
  return (0, import_jsx_runtime508.jsx)(For, { each: data, children: (item) => (0, import_jsx_runtime508.jsxs)(
    SegmentGroupItem2,
    {
      value: item.value,
      disabled: item.disabled,
      ...rest,
      children: [
        (0, import_jsx_runtime508.jsx)(SegmentGroupItemText2, { children: item.label }),
        (0, import_jsx_runtime508.jsx)(SegmentGroupItemHiddenInput2, {})
      ]
    },
    item.value
  ) });
};
var SegmentGroupItemHiddenInput2 = segment_group_exports.ItemHiddenInput;
var SegmentGroupContext2 = segment_group_exports.Context;
var SegmentGroupItemContext2 = segment_group_exports.ItemContext;

// node_modules/@chakra-ui/react/dist/esm/components/segment-group/namespace.js
var namespace_exports36 = {};
__export(namespace_exports36, {
  Context: () => SegmentGroupContext2,
  Indicator: () => SegmentGroupIndicator2,
  Item: () => SegmentGroupItem2,
  ItemContext: () => SegmentGroupItemContext2,
  ItemHiddenInput: () => SegmentGroupItemHiddenInput2,
  ItemText: () => SegmentGroupItemText2,
  Items: () => SegmentGroupItems,
  PropsProvider: () => SegmentGroupPropsProvider,
  Root: () => SegmentGroupRoot2,
  RootProvider: () => SegmentGroupRootProvider2
});

// node_modules/@chakra-ui/react/dist/esm/components/select/select.js
var import_jsx_runtime509 = __toESM(require_jsx_runtime(), 1);
var {
  withProvider: withProvider31,
  withContext: withContext45,
  useStyles: useSelectStyles,
  PropsProvider: PropsProvider46
} = createSlotRecipeContext({ key: "select" });
var SelectRootProvider2 = withProvider31(select_exports.RootProvider, "root", {
  forwardAsChild: true
});
var SelectRoot2 = withProvider31(
  select_exports.Root,
  "root",
  {
    forwardAsChild: true,
    defaultProps: { positioning: { sameWidth: true } }
  }
);
var SelectPropsProvider = PropsProvider46;
var SelectTrigger2 = withContext45(
  select_exports.Trigger,
  "trigger",
  { forwardAsChild: true }
);
var SelectPositioner2 = withContext45(select_exports.Positioner, "positioner", { forwardAsChild: true });
var SelectContent2 = withContext45(
  select_exports.Content,
  "content",
  { forwardAsChild: true }
);
var SelectValueText2 = withContext45(select_exports.ValueText, "valueText", { forwardAsChild: true });
var SelectClearTrigger2 = withContext45(select_exports.ClearTrigger, "clearTrigger", {
  forwardAsChild: true,
  defaultProps: { children: (0, import_jsx_runtime509.jsx)(CloseIcon, { boxSize: "1em" }) }
});
var SelectItemGroup2 = withContext45(select_exports.ItemGroup, "itemGroup", { forwardAsChild: true });
var SelectItemGroupLabel2 = withContext45(select_exports.ItemGroupLabel, "itemGroupLabel", { forwardAsChild: true });
var SelectItem2 = withContext45(
  select_exports.Item,
  "item",
  { forwardAsChild: true }
);
var SelectItemText2 = withContext45(
  select_exports.ItemText,
  "itemText",
  { forwardAsChild: true }
);
var SelectItemIndicator2 = withContext45(select_exports.ItemIndicator, "itemIndicator", {
  forwardAsChild: true,
  defaultProps: {
    children: (0, import_jsx_runtime509.jsx)(CheckIcon, {})
  }
});
var SelectIndicatorGroup = withContext45("div", "indicatorGroup");
var SelectIndicator2 = withContext45(select_exports.Indicator, "indicator", {
  forwardAsChild: true,
  defaultProps: {
    children: (0, import_jsx_runtime509.jsx)(ChevronDownIcon, {})
  }
});
var SelectControl2 = withContext45(
  select_exports.Control,
  "control",
  { forwardAsChild: true }
);
var SelectLabel2 = withContext45(
  select_exports.Label,
  "label",
  { forwardAsChild: true }
);
var SelectContext2 = select_exports.Context;
var SelectHiddenSelect2 = select_exports.HiddenSelect;
var SelectItemContext2 = select_exports.ItemContext;

// node_modules/@chakra-ui/react/dist/esm/components/select/namespace.js
var namespace_exports37 = {};
__export(namespace_exports37, {
  ClearTrigger: () => SelectClearTrigger2,
  Content: () => SelectContent2,
  Context: () => SelectContext2,
  Control: () => SelectControl2,
  HiddenSelect: () => SelectHiddenSelect2,
  Indicator: () => SelectIndicator2,
  IndicatorGroup: () => SelectIndicatorGroup,
  Item: () => SelectItem2,
  ItemContext: () => SelectItemContext2,
  ItemGroup: () => SelectItemGroup2,
  ItemGroupLabel: () => SelectItemGroupLabel2,
  ItemIndicator: () => SelectItemIndicator2,
  ItemText: () => SelectItemText2,
  Label: () => SelectLabel2,
  Positioner: () => SelectPositioner2,
  PropsProvider: () => SelectPropsProvider,
  Root: () => SelectRoot2,
  RootProvider: () => SelectRootProvider2,
  Trigger: () => SelectTrigger2,
  ValueText: () => SelectValueText2
});

// node_modules/@chakra-ui/react/dist/esm/components/separator/separator.js
var import_jsx_runtime510 = __toESM(require_jsx_runtime(), 1);
var import_react1027 = __toESM(require_react(), 1);
var { useRecipeResult: useRecipeResult4, PropsProvider: PropsProvider47 } = createRecipeContext({
  key: "separator"
});
var Separator = (0, import_react1027.forwardRef)(
  function Separator2(props43, ref) {
    const { styles, className, props: otherProps } = useRecipeResult4(props43);
    const orientation = props43.orientation || "horizontal";
    return (0, import_jsx_runtime510.jsx)(
      chakra.span,
      {
        ref,
        role: isString(orientation) ? "separator" : "presentation",
        "aria-orientation": isString(orientation) ? orientation : void 0,
        ...omit(otherProps, ["orientation"]),
        className: cx(className, props43.className),
        css: [styles, props43.css]
      }
    );
  }
);
var SeparatorPropsProvider = PropsProvider47;

// node_modules/@chakra-ui/react/dist/esm/components/skeleton/skeleton.js
var import_jsx_runtime511 = __toESM(require_jsx_runtime(), 1);
var React11 = __toESM(require_react(), 1);
var { withContext: withContext46, PropsProvider: PropsProvider48 } = createRecipeContext({
  key: "skeleton"
});
var Skeleton = withContext46("div");
var SkeletonPropsProvider = PropsProvider48;
var SkeletonCircle = React11.forwardRef(function SkeletonCircle2(props43, ref) {
  const { size: size3, ...rest } = props43;
  return (0, import_jsx_runtime511.jsx)(Circle, { size: size3, asChild: true, ref, children: (0, import_jsx_runtime511.jsx)(Skeleton, { ...rest }) });
});
var SkeletonText = React11.forwardRef(
  function SkeletonText2(props43, ref) {
    const { noOfLines = 3, gap, rootProps: rootProps2, ...rest } = props43;
    return (0, import_jsx_runtime511.jsx)(Stack, { gap, width: "full", ref, ...rootProps2, children: Array.from({ length: noOfLines }).map((_, index) => (0, import_jsx_runtime511.jsx)(
      Skeleton,
      {
        height: "4",
        _last: { maxW: noOfLines === 1 ? "100%" : "80%" },
        ...rest
      },
      index
    )) });
  }
);

// node_modules/@chakra-ui/react/dist/esm/components/skip-nav/skip-nav-link.js
var import_jsx_runtime512 = __toESM(require_jsx_runtime(), 1);
var import_react1028 = __toESM(require_react(), 1);
var fallbackId = "chakra-skip-nav";
var SkipNavLink = (0, import_react1028.forwardRef)(
  function SkipNavLink2(props43, ref) {
    const recipe = useRecipe({ key: "skipNavLink", recipe: props43.recipe });
    const [variantProps, localProps] = recipe.splitVariantProps(props43);
    const styles = recipe(variantProps);
    localProps.id || (localProps.id = fallbackId);
    return (0, import_jsx_runtime512.jsx)(
      chakra.a,
      {
        ...localProps,
        ref,
        href: `#${localProps.id}`,
        css: [styles, props43.css]
      }
    );
  }
);

// node_modules/@chakra-ui/react/dist/esm/components/skip-nav/skip-nav-content.js
var import_jsx_runtime513 = __toESM(require_jsx_runtime(), 1);
var import_react1029 = __toESM(require_react(), 1);
var SkipNavContent = (0, import_react1029.forwardRef)(
  function SkipNavContent2(props43, ref) {
    const { id = fallbackId, ...rest } = props43;
    return (0, import_jsx_runtime513.jsx)(
      chakra.div,
      {
        ref,
        id,
        tabIndex: -1,
        style: { outline: 0 },
        ...rest
      }
    );
  }
);

// node_modules/@chakra-ui/react/dist/esm/components/slider/slider.js
var import_jsx_runtime514 = __toESM(require_jsx_runtime(), 1);
var import_react1030 = __toESM(require_react(), 1);
var {
  withProvider: withProvider32,
  withContext: withContext47,
  useStyles: useSliderStyles,
  PropsProvider: PropsProvider49
} = createSlotRecipeContext({ key: "slider" });
var SliderRootProvider2 = withProvider32(slider_exports.RootProvider, "root", { forwardAsChild: true });
var SliderRoot2 = withProvider32(
  slider_exports.Root,
  "root",
  { forwardAsChild: true }
);
var SliderPropsProvider = PropsProvider49;
var SliderTrack2 = withContext47(
  slider_exports.Track,
  "track",
  { forwardAsChild: true }
);
var SliderRange2 = withContext47(
  slider_exports.Range,
  "range",
  { forwardAsChild: true }
);
var SliderThumb2 = withContext47(
  slider_exports.Thumb,
  "thumb",
  { forwardAsChild: true }
);
var SliderValueText2 = withContext47(slider_exports.ValueText, "valueText", { forwardAsChild: true });
var SliderLabel2 = withContext47(
  slider_exports.Label,
  "label",
  { forwardAsChild: true }
);
var SliderMarkerGroup2 = withContext47(slider_exports.MarkerGroup, "markerGroup", { forwardAsChild: true });
var SliderMarker2 = withContext47(
  slider_exports.Marker,
  "marker",
  { forwardAsChild: true }
);
var SliderMarkerIndicator = withContext47("div", "markerIndicator");
var SliderDraggingIndicator2 = withContext47(slider_exports.DraggingIndicator, "draggingIndicator", { forwardAsChild: true });
var SliderThumbs = (props43) => {
  const api = useSliderContext();
  return (0, import_jsx_runtime514.jsx)(For, { each: api.value, children: (_, index) => (0, import_jsx_runtime514.jsx)(SliderThumb2, { index, ...props43, children: (0, import_jsx_runtime514.jsx)(SliderHiddenInput2, {}) }, index) });
};
var SliderMarks = (0, import_react1030.forwardRef)(
  function SliderMarks2(props43, ref) {
    const { marks, ...rest } = props43;
    if (!(marks == null ? void 0 : marks.length)) return null;
    return (0, import_jsx_runtime514.jsx)(SliderMarkerGroup2, { ref, ...rest, children: marks.map((mark, index) => {
      const value = typeof mark === "number" ? mark : mark.value;
      const label = typeof mark === "number" ? void 0 : mark.label;
      return (0, import_jsx_runtime514.jsxs)(SliderMarker2, { value, children: [
        (0, import_jsx_runtime514.jsx)(SliderMarkerIndicator, {}),
        label != null && (0, import_jsx_runtime514.jsx)("span", { className: "chakra-slider__marker-label", children: label })
      ] }, index);
    }) });
  }
);
var SliderControl2 = withContext47(
  slider_exports.Control,
  "control",
  { forwardAsChild: true }
);
var SliderContext2 = slider_exports.Context;
var SliderHiddenInput2 = slider_exports.HiddenInput;

// node_modules/@chakra-ui/react/dist/esm/components/slider/namespace.js
var namespace_exports38 = {};
__export(namespace_exports38, {
  Context: () => SliderContext2,
  Control: () => SliderControl2,
  DraggingIndicator: () => SliderDraggingIndicator2,
  HiddenInput: () => SliderHiddenInput2,
  Label: () => SliderLabel2,
  Marker: () => SliderMarker2,
  MarkerGroup: () => SliderMarkerGroup2,
  MarkerIndicator: () => SliderMarkerIndicator,
  Marks: () => SliderMarks,
  PropsProvider: () => SliderPropsProvider,
  Range: () => SliderRange2,
  Root: () => SliderRoot2,
  RootProvider: () => SliderRootProvider2,
  Thumb: () => SliderThumb2,
  Thumbs: () => SliderThumbs,
  Track: () => SliderTrack2,
  ValueText: () => SliderValueText2
});

// node_modules/@chakra-ui/react/dist/esm/components/spacer/spacer.js
var Spacer = chakra("div", {
  base: {
    flex: 1,
    justifySelf: "stretch",
    alignSelf: "stretch"
  }
});
Spacer.displayName = "Spacer";

// node_modules/@chakra-ui/react/dist/esm/components/stack/h-stack.js
var import_jsx_runtime515 = __toESM(require_jsx_runtime(), 1);
var import_react1031 = __toESM(require_react(), 1);
var HStack = (0, import_react1031.forwardRef)(
  function HStack2(props43, ref) {
    return (0, import_jsx_runtime515.jsx)(Stack, { align: "center", ...props43, direction: "row", ref });
  }
);

// node_modules/@chakra-ui/react/dist/esm/components/stack/v-stack.js
var import_jsx_runtime516 = __toESM(require_jsx_runtime(), 1);
var import_react1032 = __toESM(require_react(), 1);
var VStack = (0, import_react1032.forwardRef)(
  function VStack2(props43, ref) {
    return (0, import_jsx_runtime516.jsx)(Stack, { align: "center", ...props43, direction: "column", ref });
  }
);

// node_modules/@chakra-ui/react/dist/esm/components/stack/stack-separator.js
var StackSeparator = chakra("div", {
  base: {
    borderWidth: 0,
    alignSelf: "stretch",
    borderColor: "inherit",
    width: "auto",
    height: "auto"
  }
});
StackSeparator.displayName = "StackSeparator";

// node_modules/@chakra-ui/react/dist/esm/components/stat/stat.js
var import_jsx_runtime517 = __toESM(require_jsx_runtime(), 1);
var import_react1033 = __toESM(require_react(), 1);
var {
  withProvider: withProvider33,
  withContext: withContext48,
  useStyles: useStatStyles,
  PropsProvider: PropsProvider50
} = createSlotRecipeContext({ key: "stat" });
var StatRoot = withProvider33(
  "dl",
  "root"
);
var StatPropsProvider = PropsProvider50;
var StatLabel = withContext48("dt", "label");
var StatValueText = withContext48(
  "dd",
  "valueText"
);
var StatHelpText = withContext48(
  "span",
  "helpText"
);
var StatValueUnit = withContext48(
  "span",
  "valueUnit"
);
var StatUpIndicator = withContext48(
  "span",
  "indicator",
  {
    defaultProps: {
      "data-type": "up",
      children: (0, import_jsx_runtime517.jsx)(ArrowUpIcon, {})
    }
  }
);
var StatDownIndicator = withContext48("span", "indicator", {
  defaultProps: {
    "data-type": "down",
    children: (0, import_jsx_runtime517.jsx)(ArrowDownIcon, {})
  }
});
var StatGroup = (0, import_react1033.forwardRef)(
  function StatGroup2(props43, ref) {
    const recipe = useSlotRecipe({ key: "stat" });
    const [variantProps, localProps] = (0, import_react1033.useMemo)(
      () => recipe.splitVariantProps(props43),
      [props43, recipe]
    );
    return (0, import_jsx_runtime517.jsx)(PropsProvider50, { value: variantProps, children: (0, import_jsx_runtime517.jsx)(
      chakra.div,
      {
        ref,
        role: "group",
        display: "flex",
        flexWrap: "wrap",
        justifyContent: "space-around",
        alignItems: "flex-start",
        ...localProps
      }
    ) });
  }
);

// node_modules/@chakra-ui/react/dist/esm/components/stat/namespace.js
var namespace_exports39 = {};
__export(namespace_exports39, {
  DownIndicator: () => StatDownIndicator,
  HelpText: () => StatHelpText,
  Label: () => StatLabel,
  PropsProvider: () => StatPropsProvider,
  Root: () => StatRoot,
  UpIndicator: () => StatUpIndicator,
  ValueText: () => StatValueText,
  ValueUnit: () => StatValueUnit
});

// node_modules/@chakra-ui/react/dist/esm/components/status/namespace.js
var namespace_exports40 = {};
__export(namespace_exports40, {
  Indicator: () => StatusIndicator,
  PropsProvider: () => StatusPropsProvider,
  Root: () => StatusRoot
});

// node_modules/@chakra-ui/react/dist/esm/components/status/status.js
var {
  withProvider: withProvider34,
  withContext: withContext49,
  useStyles: useStatusStyles,
  PropsProvider: PropsProvider51
} = createSlotRecipeContext({ key: "status" });
var StatusRoot = withProvider34(
  "div",
  "root"
);
var StatusPropsProvider = PropsProvider51;
var StatusIndicator = withContext49("div", "indicator");

// node_modules/@chakra-ui/react/dist/esm/components/steps/steps.js
var import_jsx_runtime518 = __toESM(require_jsx_runtime(), 1);
var import_react1034 = __toESM(require_react(), 1);
var {
  withProvider: withProvider35,
  withContext: withContext50,
  useStyles: useStepsStyles,
  PropsProvider: PropsProvider52
} = createSlotRecipeContext({ key: "steps" });
var StepsRootProvider2 = withProvider35(steps_exports.RootProvider, "root", { forwardAsChild: true });
var StepsRoot2 = withProvider35(
  steps_exports.Root,
  "root",
  { forwardAsChild: true }
);
var StepsPropsProvider = PropsProvider52;
var StepsList2 = withContext50(
  steps_exports.List,
  "list",
  { forwardAsChild: true }
);
var StepsItem2 = withContext50(
  steps_exports.Item,
  "item",
  { forwardAsChild: true }
);
var StepsTrigger2 = withContext50(
  steps_exports.Trigger,
  "trigger",
  { forwardAsChild: true }
);
var StepsContent2 = withContext50(
  steps_exports.Content,
  "content",
  { forwardAsChild: true }
);
var StepsCompletedContent2 = withContext50(steps_exports.CompletedContent, "content");
var StepsNumber = (0, import_react1034.forwardRef)(
  function StepsNumber2(props43, ref) {
    return (0, import_jsx_runtime518.jsx)(steps_exports.ItemContext, { children: (api) => (0, import_jsx_runtime518.jsx)(chakra.div, { ref, ...props43, children: api.index + 1 }) });
  }
);
var StepsTitle = withContext50(
  "div",
  "title"
);
var StepsDescription = withContext50("div", "description");
var StepsSeparator2 = withContext50(
  steps_exports.Separator,
  "separator",
  { forwardAsChild: true }
);
var StepsStatus = (props43) => {
  return (0, import_jsx_runtime518.jsx)(steps_exports.ItemContext, { children: (api) => {
    if (api.current) return (0, import_jsx_runtime518.jsx)(import_jsx_runtime518.Fragment, { children: props43.current ?? props43.incomplete });
    if (api.completed) return (0, import_jsx_runtime518.jsx)(import_jsx_runtime518.Fragment, { children: props43.complete });
    return (0, import_jsx_runtime518.jsx)(import_jsx_runtime518.Fragment, { children: props43.incomplete ?? props43.current });
  } });
};
var StepsIndicator2 = withContext50(
  steps_exports.Indicator,
  "indicator",
  {
    forwardAsChild: true,
    defaultProps: {
      children: (0, import_jsx_runtime518.jsx)(StepsStatus, { complete: (0, import_jsx_runtime518.jsx)(CheckIcon, {}), incomplete: (0, import_jsx_runtime518.jsx)(StepsNumber, {}) })
    }
  }
);
var StepsNextTrigger2 = withContext50(steps_exports.NextTrigger, "nextTrigger", { forwardAsChild: true });
var StepsPrevTrigger2 = withContext50(steps_exports.PrevTrigger, "prevTrigger", { forwardAsChild: true });
var StepsContext2 = steps_exports.Context;
var StepsItemContext2 = steps_exports.ItemContext;

// node_modules/@chakra-ui/react/dist/esm/components/steps/namespace.js
var namespace_exports41 = {};
__export(namespace_exports41, {
  CompletedContent: () => StepsCompletedContent2,
  Content: () => StepsContent2,
  Context: () => StepsContext2,
  Description: () => StepsDescription,
  Indicator: () => StepsIndicator2,
  Item: () => StepsItem2,
  ItemContext: () => StepsItemContext2,
  List: () => StepsList2,
  NextTrigger: () => StepsNextTrigger2,
  Number: () => StepsNumber,
  PrevTrigger: () => StepsPrevTrigger2,
  PropsProvider: () => StepsPropsProvider,
  Root: () => StepsRoot2,
  RootProvider: () => StepsRootProvider2,
  Separator: () => StepsSeparator2,
  Status: () => StepsStatus,
  Title: () => StepsTitle,
  Trigger: () => StepsTrigger2
});

// node_modules/@chakra-ui/react/dist/esm/components/switch/switch.js
var import_jsx_runtime519 = __toESM(require_jsx_runtime(), 1);
var import_react1035 = __toESM(require_react(), 1);
var {
  withProvider: withProvider36,
  withContext: withContext51,
  useStyles: useSwitchStyles,
  PropsProvider: PropsProvider53
} = createSlotRecipeContext({ key: "switch" });
var SwitchRootProvider2 = withProvider36(switch_exports.RootProvider, "root", { forwardAsChild: true });
var SwitchRoot2 = withProvider36(
  switch_exports.Root,
  "root",
  { forwardAsChild: true }
);
var SwitchPropsProvider = PropsProvider53;
var SwitchLabel2 = withContext51(
  switch_exports.Label,
  "label",
  { forwardAsChild: true }
);
var SwitchThumb2 = withContext51(
  switch_exports.Thumb,
  "thumb",
  { forwardAsChild: true }
);
var SwitchControl2 = withContext51(
  switch_exports.Control,
  "control",
  {
    forwardAsChild: true,
    defaultProps: { children: (0, import_jsx_runtime519.jsx)(SwitchThumb2, {}) }
  }
);
var SwitchIndicator = (0, import_react1035.forwardRef)(function SwitchIndicator2(props43, ref) {
  const api = useSwitchContext();
  const styles = useSwitchStyles();
  const { fallback: fallback4, children, ...rest } = props43;
  return (0, import_jsx_runtime519.jsx)(
    chakra.span,
    {
      ref,
      "data-checked": dataAttr2(api.checked),
      ...rest,
      css: [styles.indicator, props43.css],
      children: api.checked ? children : fallback4
    }
  );
});
var SwitchThumbIndicator = (0, import_react1035.forwardRef)(function SwitchThumbIndicator2(props43, ref) {
  const api = useSwitchContext();
  const { fallback: fallback4, children, ...rest } = props43;
  return (0, import_jsx_runtime519.jsx)(chakra.span, { ref, "data-checked": dataAttr2(api.checked), ...rest, children: api.checked ? children : fallback4 });
});
var SwitchContext2 = switch_exports.Context;
var SwitchHiddenInput2 = switch_exports.HiddenInput;

// node_modules/@chakra-ui/react/dist/esm/components/switch/namespace.js
var namespace_exports42 = {};
__export(namespace_exports42, {
  Context: () => SwitchContext2,
  Control: () => SwitchControl2,
  HiddenInput: () => SwitchHiddenInput2,
  Indicator: () => SwitchIndicator,
  Label: () => SwitchLabel2,
  PropsProvider: () => SwitchPropsProvider,
  Root: () => SwitchRoot2,
  RootProvider: () => SwitchRootProvider2,
  Thumb: () => SwitchThumb2,
  ThumbIndicator: () => SwitchThumbIndicator
});

// node_modules/@chakra-ui/react/dist/esm/components/table/table.js
var import_jsx_runtime520 = __toESM(require_jsx_runtime(), 1);
var import_react1036 = __toESM(require_react(), 1);
var {
  StylesProvider,
  ClassNamesProvider,
  useRecipeResult: useRecipeResult5,
  withContext: withContext52,
  useStyles: useTableStyles,
  PropsProvider: PropsProvider54
} = createSlotRecipeContext({ key: "table" });
var TableRoot = (0, import_react1036.forwardRef)(
  function TableRoot2({ native, ...props43 }, ref) {
    const { styles, props: rootProps2, classNames } = useRecipeResult5(props43);
    const rootCss = (0, import_react1036.useMemo)(() => {
      if (!native) return styles.root;
      return {
        ...styles.root,
        "& thead": styles.header,
        "& tbody": styles.body,
        "& tfoot": styles.footer,
        "& thead th": styles.columnHeader,
        "& tr": styles.row,
        "& td": styles.cell,
        "& caption": styles.caption
      };
    }, [styles, native]);
    return (0, import_jsx_runtime520.jsx)(ClassNamesProvider, { value: classNames, children: (0, import_jsx_runtime520.jsx)(StylesProvider, { value: styles, children: (0, import_jsx_runtime520.jsx)(
      chakra.table,
      {
        ref,
        ...rootProps2,
        css: [rootCss, props43.css],
        className: cx(classNames == null ? void 0 : classNames["root"], props43.className)
      }
    ) }) });
  }
);
var TableRootPropsProvider = PropsProvider54;
var TableRow = withContext52(
  "tr",
  "row"
);
var TableScrollArea = chakra("div", {
  base: {
    display: "block",
    whiteSpace: "nowrap",
    WebkitOverflowScrolling: "touch",
    overflow: "auto",
    maxWidth: "100%"
  }
});
var TableHeader = withContext52("thead", "header");
var TableFooter = withContext52("tfoot", "footer");
var TableColumnHeader = withContext52("th", "columnHeader");
var TableCell = withContext52(
  "td",
  "cell"
);
var TableCaption = withContext52("caption", "caption", {
  defaultProps: {
    captionSide: "bottom"
  }
});
var TableBody = withContext52(
  "tbody",
  "body"
);
var TableColumnGroup = withContext52("colgroup");
var TableColumn = withContext52(
  "col"
);

// node_modules/@chakra-ui/react/dist/esm/components/table/namespace.js
var namespace_exports43 = {};
__export(namespace_exports43, {
  Body: () => TableBody,
  Caption: () => TableCaption,
  Cell: () => TableCell,
  Column: () => TableColumn,
  ColumnGroup: () => TableColumnGroup,
  ColumnHeader: () => TableColumnHeader,
  Footer: () => TableFooter,
  Header: () => TableHeader,
  Root: () => TableRoot,
  RootPropsProvider: () => TableRootPropsProvider,
  Row: () => TableRow,
  ScrollArea: () => TableScrollArea
});

// node_modules/@chakra-ui/react/dist/esm/components/tabs/tabs.js
var {
  withProvider: withProvider37,
  withContext: withContext53,
  useStyles: useTabsStyles,
  PropsProvider: PropsProvider55
} = createSlotRecipeContext({ key: "tabs" });
var TabsRootProvider2 = withProvider37(tabs_exports.RootProvider, "root", { forwardAsChild: true });
var TabsRoot2 = withProvider37(
  tabs_exports.Root,
  "root",
  { forwardAsChild: true }
);
var TabsPropsProvider = PropsProvider55;
var TabsTrigger = withContext53(
  tabs_exports.Trigger,
  "trigger",
  { forwardAsChild: true }
);
var TabsContent = withContext53(
  tabs_exports.Content,
  "content",
  { forwardAsChild: true }
);
var TabsContentGroup = withContext53("div", "contentGroup");
var TabsList = withContext53(
  tabs_exports.List,
  "list",
  { forwardAsChild: true }
);
var TabsIndicator = withContext53(
  tabs_exports.Indicator,
  "indicator",
  { forwardAsChild: true }
);
var TabsContext2 = tabs_exports.Context;

// node_modules/@chakra-ui/react/dist/esm/components/tabs/namespace.js
var namespace_exports44 = {};
__export(namespace_exports44, {
  Content: () => TabsContent,
  ContentGroup: () => TabsContentGroup,
  Context: () => TabsContext2,
  Indicator: () => TabsIndicator,
  List: () => TabsList,
  PropsProvider: () => TabsPropsProvider,
  Root: () => TabsRoot2,
  RootProvider: () => TabsRootProvider2,
  Trigger: () => TabsTrigger
});

// node_modules/@chakra-ui/react/dist/esm/components/tag/tag.js
var import_jsx_runtime521 = __toESM(require_jsx_runtime(), 1);
var {
  withProvider: withProvider38,
  withContext: withContext54,
  useStyles: useTagStyles,
  PropsProvider: PropsProvider56
} = createSlotRecipeContext({ key: "tag" });
var TagRoot = withProvider38(
  "div",
  "root"
);
var TagRootPropsProvider = PropsProvider56;
var TagLabel = withContext54(
  "span",
  "label"
);
var TagCloseTrigger = withContext54("button", "closeTrigger", { defaultProps: { children: (0, import_jsx_runtime521.jsx)(CloseIcon, {}) } });
var TagStartElement = withContext54("span", "startElement");
var TagEndElement = withContext54(
  "span",
  "endElement"
);

// node_modules/@chakra-ui/react/dist/esm/components/tag/namespace.js
var namespace_exports45 = {};
__export(namespace_exports45, {
  CloseTrigger: () => TagCloseTrigger,
  EndElement: () => TagEndElement,
  Label: () => TagLabel,
  Root: () => TagRoot,
  RootPropsProvider: () => TagRootPropsProvider,
  StartElement: () => TagStartElement
});

// node_modules/@chakra-ui/react/dist/esm/components/textarea/textarea.js
var { withContext: withContext55, PropsProvider: PropsProvider57 } = createRecipeContext({
  key: "textarea"
});
var Textarea = withContext55(
  field_exports.Textarea
);
var TextareaPropsProvider = PropsProvider57;

// node_modules/@chakra-ui/react/dist/esm/components/timeline/timeline.js
var {
  withProvider: withProvider39,
  withContext: withContext56,
  useStyles: useTimelineStyles,
  PropsProvider: PropsProvider58
} = createSlotRecipeContext({ key: "timeline" });
var TimelineRoot = withProvider39(
  "div",
  "root",
  { defaultProps: { role: "list" } }
);
var TimelineRootPropsProvider = PropsProvider58;
var TimelineItem = withContext56(
  "div",
  "item",
  { defaultProps: { role: "listitem" } }
);
var TimelineSeparator = withContext56("div", "separator");
var TimelineIndicator = withContext56("div", "indicator");
var TimelineContent = withContext56("div", "content");
var TimelineTitle = withContext56(
  "div",
  "title"
);
var TimelineDescription = withContext56("div", "description");
var TimelineConnector = withContext56("div", "connector");

// node_modules/@chakra-ui/react/dist/esm/components/timeline/namespace.js
var namespace_exports46 = {};
__export(namespace_exports46, {
  Connector: () => TimelineConnector,
  Content: () => TimelineContent,
  Description: () => TimelineDescription,
  Indicator: () => TimelineIndicator,
  Item: () => TimelineItem,
  Root: () => TimelineRoot,
  RootPropsProvider: () => TimelineRootPropsProvider,
  Separator: () => TimelineSeparator,
  Title: () => TimelineTitle
});

// node_modules/@chakra-ui/react/dist/esm/components/toast/toast.js
var import_jsx_runtime522 = __toESM(require_jsx_runtime(), 1);
var import_react1037 = __toESM(require_react(), 1);
var {
  withProvider: withProvider40,
  withContext: withContext57,
  useStyles: useToastStyles
} = createSlotRecipeContext({ key: "toast" });
var Toaster2 = chakra(
  Toaster,
  {},
  { forwardAsChild: true }
);
var ToastRoot2 = withProvider40(
  toast_exports.Root,
  "root",
  { forwardAsChild: true }
);
var ToastCloseTrigger2 = withContext57(toast_exports.CloseTrigger, "closeTrigger", {
  forwardAsChild: true,
  defaultProps: {
    children: (0, import_jsx_runtime522.jsx)(CloseIcon, {})
  }
});
var ToastTitle2 = withContext57(
  toast_exports.Title,
  "title",
  { forwardAsChild: true }
);
var ToastDescription2 = withContext57(toast_exports.Description, "description", { forwardAsChild: true });
var ToastActionTrigger2 = withContext57(toast_exports.ActionTrigger, "actionTrigger", { forwardAsChild: true });
var iconMap2 = {
  warning: WarningIcon,
  success: CheckCircleIcon,
  error: WarningIcon
};
var ToastIndicator = (0, import_react1037.forwardRef)(
  function ToastIndicator2(props43, ref) {
    const api = useToastContext();
    const styles = useToastStyles();
    const Component = iconMap2[api.type];
    if (!Component) return null;
    return (0, import_jsx_runtime522.jsx)(Component, { ref, ...props43, css: [styles.indicator, props43.css] });
  }
);

// node_modules/@chakra-ui/react/dist/esm/components/toast/namespace.js
var namespace_exports47 = {};
__export(namespace_exports47, {
  ActionTrigger: () => ToastActionTrigger2,
  CloseTrigger: () => ToastCloseTrigger2,
  Description: () => ToastDescription2,
  Indicator: () => ToastIndicator,
  Root: () => ToastRoot2,
  Title: () => ToastTitle2
});

// node_modules/@chakra-ui/react/dist/esm/components/toggle/toggle.js
var {
  withProvider: withProvider41,
  withContext: withContext58,
  useStyles: useToggleStyles,
  PropsProvider: PropsProvider59
} = createSlotRecipeContext({ key: "toggle" });
var ToggleRootProvider = withProvider41(toggle_exports.Root, "root", { forwardAsChild: true });
var ToggleRoot2 = withProvider41(
  toggle_exports.Root,
  "root",
  { forwardAsChild: true }
);
var TogglePropsProvider = PropsProvider59;
var ToggleIndicator2 = withContext58(toggle_exports.Indicator, "indicator", {
  forwardAsChild: true,
  defaultProps: { _empty: { display: "none" } }
});
var ToggleContext2 = toggle_exports.Context;

// node_modules/@chakra-ui/react/dist/esm/components/toggle/namespace.js
var namespace_exports48 = {};
__export(namespace_exports48, {
  Context: () => ToggleContext2,
  Indicator: () => ToggleIndicator2,
  PropsProvider: () => TogglePropsProvider,
  Root: () => ToggleRoot2
});

// node_modules/@chakra-ui/react/dist/esm/components/tooltip/tooltip.js
var import_jsx_runtime523 = __toESM(require_jsx_runtime(), 1);
var {
  withRootProvider: withRootProvider7,
  withContext: withContext59,
  useStyles: useTooltipStyles,
  PropsProvider: PropsProvider60
} = createSlotRecipeContext({ key: "tooltip" });
var TooltipRootProvider2 = withRootProvider7(
  tooltip_exports.RootProvider
);
var TooltipRoot2 = withRootProvider7(tooltip_exports.Root, {
  defaultProps: { lazyMount: true, unmountOnExit: true }
});
var TooltipPropsProvider = PropsProvider60;
var TooltipTrigger2 = withContext59(tooltip_exports.Trigger, "trigger", { forwardAsChild: true });
var TooltipPositioner2 = withContext59(tooltip_exports.Positioner, "positioner", { forwardAsChild: true });
var TooltipContent2 = withContext59(
  tooltip_exports.Content,
  "content",
  { forwardAsChild: true }
);
var TooltipArrowTip2 = withContext59(tooltip_exports.ArrowTip, "arrowTip", { forwardAsChild: true });
var TooltipArrow2 = withContext59(
  tooltip_exports.Arrow,
  "arrow",
  { forwardAsChild: true, defaultProps: { children: (0, import_jsx_runtime523.jsx)(TooltipArrowTip2, {}) } }
);
var TooltipContext2 = tooltip_exports.Context;

// node_modules/@chakra-ui/react/dist/esm/components/tooltip/namespace.js
var namespace_exports49 = {};
__export(namespace_exports49, {
  Arrow: () => TooltipArrow2,
  ArrowTip: () => TooltipArrowTip2,
  Content: () => TooltipContent2,
  Context: () => TooltipContext2,
  Positioner: () => TooltipPositioner2,
  PropsProvider: () => TooltipPropsProvider,
  Root: () => TooltipRoot2,
  RootProvider: () => TooltipRootProvider2,
  Trigger: () => TooltipTrigger2
});

// node_modules/@chakra-ui/react/dist/esm/components/typography/heading.js
var { withContext: withContext60, PropsProvider: PropsProvider61 } = createRecipeContext({
  key: "heading"
});
var Heading = withContext60("h2");
var HeadingPropsProvider = PropsProvider61;

// node_modules/@chakra-ui/react/dist/esm/components/typography/text.js
var { withContext: withContext61, PropsProvider: PropsProvider62 } = createRecipeContext({
  key: "text"
});
var Text = withContext61("p");
var TextPropsProvider = PropsProvider62;

// node_modules/@chakra-ui/react/dist/esm/components/typography/em.js
var Em = chakra("em", {
  base: {
    fontStyle: "italic"
  }
});

// node_modules/@chakra-ui/react/dist/esm/components/typography/strong.js
var Strong = chakra("strong", {
  base: { fontWeight: "semibold" }
});

// node_modules/@chakra-ui/react/dist/esm/components/typography/quote.js
var Quote = chakra("q", {
  base: {
    fontWeight: "bold",
    lineHeight: "1.2"
  }
});

// node_modules/@chakra-ui/react/dist/esm/components/visually-hidden/visually-hidden.js
var visuallyHiddenStyle2 = {
  border: "0",
  clip: "rect(0, 0, 0, 0)",
  height: "1px",
  width: "1px",
  margin: "-1px",
  padding: "0",
  overflow: "hidden",
  whiteSpace: "nowrap",
  position: "absolute"
};
var VisuallyHidden = chakra("span", {
  base: visuallyHiddenStyle2
});
VisuallyHidden.displayName = "VisuallyHidden";

// node_modules/@chakra-ui/react/dist/esm/components/wrap/wrap.js
var import_jsx_runtime524 = __toESM(require_jsx_runtime(), 1);
var import_react1038 = __toESM(require_react(), 1);
var Wrap = (0, import_react1038.forwardRef)(
  function Wrap2(props43, ref) {
    const { gap = "0.5rem", justify, direction, align, ...rest } = props43;
    return (0, import_jsx_runtime524.jsx)(
      chakra.div,
      {
        ref,
        display: "flex",
        flexWrap: "wrap",
        justifyContent: justify,
        alignItems: align,
        flexDirection: direction,
        gap,
        ...rest,
        className: cx("chakra-wrap", props43.className)
      }
    );
  }
);
Wrap.displayName = "Wrap";
var itemStyle = defineStyle({
  display: "flex",
  alignItems: "flex-start"
});
var WrapItem = (0, import_react1038.forwardRef)(
  function WrapItem2(props43, ref) {
    return (0, import_jsx_runtime524.jsx)(
      chakra.div,
      {
        ref,
        css: [itemStyle, props43.css],
        ...props43,
        className: cx("chakra-wrap__listitem", props43.className)
      }
    );
  }
);
export {
  AbsoluteCenter,
  namespace_exports as Accordion,
  AccordionContext2 as AccordionContext,
  AccordionItem2 as AccordionItem,
  AccordionItemBody,
  AccordionItemContent2 as AccordionItemContent,
  AccordionItemContext2 as AccordionItemContext,
  AccordionItemIndicator2 as AccordionItemIndicator,
  AccordionItemTrigger2 as AccordionItemTrigger,
  AccordionPropsProvider,
  AccordionRoot2 as AccordionRoot,
  AccordionRootProvider2 as AccordionRootProvider,
  namespace_exports2 as ActionBar,
  ActionBarCloseTrigger,
  ActionBarContent,
  ActionBarContext,
  ActionBarPositioner,
  ActionBarPropsProvider,
  ActionBarRoot,
  ActionBarRootProvider,
  ActionBarSelectionTrigger,
  ActionBarSeparator,
  namespace_exports3 as Alert,
  AlertContent,
  AlertDescription,
  AlertIndicator,
  AlertPropsProvider,
  AlertRoot,
  AlertTitle,
  AspectRatio,
  namespace_exports4 as Avatar,
  AvatarContext2 as AvatarContext,
  AvatarFallback2 as AvatarFallback,
  AvatarGroup,
  AvatarIcon,
  AvatarImage2 as AvatarImage,
  AvatarPropsProvider,
  AvatarRoot2 as AvatarRoot,
  AvatarRootProvider2 as AvatarRootProvider,
  Badge,
  BadgePropsProvider,
  Bleed,
  namespace_exports5 as Blockquote,
  BlockquoteCaption,
  BlockquoteContent,
  BlockquoteIcon,
  BlockquotePropsProvider,
  BlockquoteRoot,
  Box,
  namespace_exports6 as Breadcrumb,
  BreadcrumbCurrentLink,
  BreadcrumbEllipsis,
  BreadcrumbItem,
  BreadcrumbLink,
  BreadcrumbList,
  BreadcrumbPropsProvider,
  BreadcrumbRoot,
  BreadcrumbSeparator,
  Button,
  ButtonGroup,
  ButtonPropsProvider,
  namespace_exports7 as Card,
  CardBody,
  CardDescription,
  CardFooter,
  CardHeader,
  CardPropsProvider,
  CardRoot,
  CardTitle,
  Center,
  ChakraProvider,
  namespace_exports8 as Checkbox,
  namespace_exports9 as CheckboxCard,
  CheckboxCardAddon,
  CheckboxCardContent,
  CheckboxCardContext,
  CheckboxCardControl,
  CheckboxCardDescription,
  CheckboxCardHiddenInput,
  CheckboxCardIndicator,
  CheckboxCardLabel,
  CheckboxCardRoot,
  CheckboxCardRootPropsProvider,
  CheckboxCardRootProvider,
  CheckboxContext2 as CheckboxContext,
  CheckboxControl2 as CheckboxControl,
  CheckboxGroup2 as CheckboxGroup,
  CheckboxHiddenInput2 as CheckboxHiddenInput,
  CheckboxIndicator2 as CheckboxIndicator,
  CheckboxLabel2 as CheckboxLabel,
  CheckboxPropsProvider,
  CheckboxRoot2 as CheckboxRoot,
  CheckboxRootProvider2 as CheckboxRootProvider,
  Checkmark,
  Circle,
  ClientOnly2 as ClientOnly,
  namespace_exports10 as Clipboard,
  ClipboardContext2 as ClipboardContext,
  ClipboardControl2 as ClipboardControl,
  ClipboardCopyText,
  ClipboardIndicator2 as ClipboardIndicator,
  ClipboardInput2 as ClipboardInput,
  ClipboardLabel2 as ClipboardLabel,
  ClipboardPropsProvider,
  ClipboardRoot2 as ClipboardRoot,
  ClipboardRootProvider2 as ClipboardRootProvider,
  ClipboardTrigger2 as ClipboardTrigger,
  ClipboardValueText2 as ClipboardValueText,
  CloseButton,
  Code,
  CodePropsProvider,
  namespace_exports11 as Collapsible,
  CollapsibleContent2 as CollapsibleContent,
  CollapsibleContext2 as CollapsibleContext,
  CollapsiblePropsProvider,
  CollapsibleRoot2 as CollapsibleRoot,
  CollapsibleRootProvider2 as CollapsibleRootProvider,
  CollapsibleTrigger2 as CollapsibleTrigger,
  namespace_exports13 as ColorPicker,
  ColorPickerArea2 as ColorPickerArea,
  ColorPickerAreaBackground2 as ColorPickerAreaBackground,
  ColorPickerAreaThumb2 as ColorPickerAreaThumb,
  ColorPickerChannelInput2 as ColorPickerChannelInput,
  ColorPickerChannelSlider2 as ColorPickerChannelSlider,
  ColorPickerChannelSliderLabel2 as ColorPickerChannelSliderLabel,
  ColorPickerChannelSliderThumb2 as ColorPickerChannelSliderThumb,
  ColorPickerChannelSliderTrack2 as ColorPickerChannelSliderTrack,
  ColorPickerChannelSliderValueText2 as ColorPickerChannelSliderValueText,
  ColorPickerChannelText,
  ColorPickerContent2 as ColorPickerContent,
  ColorPickerContext2 as ColorPickerContext,
  ColorPickerControl2 as ColorPickerControl,
  ColorPickerEyeDropper,
  ColorPickerEyeDropperTrigger2 as ColorPickerEyeDropperTrigger,
  ColorPickerFormatSelect2 as ColorPickerFormatSelect,
  ColorPickerFormatTrigger2 as ColorPickerFormatTrigger,
  ColorPickerHiddenInput2 as ColorPickerHiddenInput,
  ColorPickerInput,
  ColorPickerLabel2 as ColorPickerLabel,
  ColorPickerPositioner2 as ColorPickerPositioner,
  ColorPickerPropsProvider,
  ColorPickerRoot2 as ColorPickerRoot,
  ColorPickerRootProvider2 as ColorPickerRootProvider,
  ColorPickerSliders,
  ColorPickerSwatch2 as ColorPickerSwatch,
  ColorPickerSwatchGroup2 as ColorPickerSwatchGroup,
  ColorPickerSwatchIndicator2 as ColorPickerSwatchIndicator,
  ColorPickerSwatchTrigger2 as ColorPickerSwatchTrigger,
  ColorPickerTransparencyGrid2 as ColorPickerTransparencyGrid,
  ColorPickerTrigger2 as ColorPickerTrigger,
  ColorPickerValueSwatch2 as ColorPickerValueSwatch,
  ColorPickerValueText2 as ColorPickerValueText,
  ColorPickerView2 as ColorPickerView,
  ColorSwatch,
  ColorSwatchMix,
  ColorSwatchPropsProvider,
  namespace_exports12 as Combobox,
  ComboboxClearTrigger2 as ComboboxClearTrigger,
  ComboboxContent2 as ComboboxContent,
  ComboboxContext2 as ComboboxContext,
  ComboboxControl2 as ComboboxControl,
  ComboboxEmpty,
  ComboboxIndicatorGroup,
  ComboboxInput2 as ComboboxInput,
  ComboboxItem2 as ComboboxItem,
  ComboboxItemContext2 as ComboboxItemContext,
  ComboboxItemGroup2 as ComboboxItemGroup,
  ComboboxItemGroupLabel2 as ComboboxItemGroupLabel,
  ComboboxItemIndicator2 as ComboboxItemIndicator,
  ComboboxItemText2 as ComboboxItemText,
  ComboboxLabel2 as ComboboxLabel,
  ComboboxPositioner2 as ComboboxPositioner,
  ComboboxPropsProvider,
  ComboboxRoot2 as ComboboxRoot,
  ComboboxRootProvider2 as ComboboxRootProvider,
  ComboboxTrigger2 as ComboboxTrigger,
  Container,
  ContainerPropsProvider,
  namespace_exports14 as DataList,
  DataListItem,
  DataListItemLabel,
  DataListItemValue,
  DataListPropsProvider,
  DataListRoot,
  namespace_exports15 as Dialog,
  DialogActionTrigger,
  DialogBackdrop2 as DialogBackdrop,
  DialogBody,
  DialogCloseTrigger2 as DialogCloseTrigger,
  DialogContent2 as DialogContent,
  DialogContext2 as DialogContext,
  DialogDescription2 as DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogPositioner2 as DialogPositioner,
  DialogPropsProvider,
  DialogRoot2 as DialogRoot,
  DialogRootProvider2 as DialogRootProvider,
  DialogTitle2 as DialogTitle,
  DialogTrigger2 as DialogTrigger,
  DownloadTrigger2 as DownloadTrigger,
  namespace_exports16 as Drawer,
  DrawerActionTrigger,
  DrawerBackdrop,
  DrawerBody,
  DrawerCloseTrigger,
  DrawerContent,
  DrawerContext,
  DrawerDescription,
  DrawerFooter,
  DrawerHeader,
  DrawerPositioner,
  DrawerRoot,
  DrawerRootPropsProvider,
  DrawerRootProvider,
  DrawerTitle,
  DrawerTrigger,
  EMPTY_SLOT_STYLES,
  EMPTY_STYLES,
  namespace_exports17 as Editable,
  EditableArea2 as EditableArea,
  EditableCancelTrigger2 as EditableCancelTrigger,
  EditableContext2 as EditableContext,
  EditableControl2 as EditableControl,
  EditableEditTrigger2 as EditableEditTrigger,
  EditableInput2 as EditableInput,
  EditablePreview2 as EditablePreview,
  EditablePropsProvider,
  EditableRoot2 as EditableRoot,
  EditableRootProvider2 as EditableRootProvider,
  EditableSubmitTrigger2 as EditableSubmitTrigger,
  EditableTextarea,
  Em,
  namespace_exports18 as EmptyState,
  EmptyStateContent,
  EmptyStateDescription,
  EmptyStateIndicator,
  EmptyStatePropsProvider,
  EmptyStateRoot,
  EmptyStateTitle,
  EnvironmentProvider,
  namespace_exports19 as Field,
  FieldErrorIcon,
  FieldErrorText2 as FieldErrorText,
  FieldHelperText2 as FieldHelperText,
  FieldLabel2 as FieldLabel,
  FieldPropsProvider,
  FieldRequiredIndicator2 as FieldRequiredIndicator,
  FieldRoot2 as FieldRoot,
  namespace_exports20 as Fieldset,
  FieldsetContent,
  FieldsetContext2 as FieldsetContext,
  FieldsetErrorText2 as FieldsetErrorText,
  FieldsetHelperText2 as FieldsetHelperText,
  FieldsetLegend2 as FieldsetLegend,
  FieldsetRoot2 as FieldsetRoot,
  namespace_exports21 as FileUpload,
  FileUploadClearTrigger2 as FileUploadClearTrigger,
  FileUploadContext2 as FileUploadContext,
  FileUploadDropzone2 as FileUploadDropzone,
  FileUploadDropzoneContent,
  FileUploadFileText,
  FileUploadHiddenInput2 as FileUploadHiddenInput,
  FileUploadItem2 as FileUploadItem,
  FileUploadItemContent,
  FileUploadItemDeleteTrigger2 as FileUploadItemDeleteTrigger,
  FileUploadItemGroup2 as FileUploadItemGroup,
  FileUploadItemName2 as FileUploadItemName,
  FileUploadItemPreview2 as FileUploadItemPreview,
  FileUploadItemPreviewImage2 as FileUploadItemPreviewImage,
  FileUploadItemSizeText2 as FileUploadItemSizeText,
  FileUploadItems,
  FileUploadLabel2 as FileUploadLabel,
  FileUploadList,
  FileUploadPropsProvider,
  FileUploadRoot2 as FileUploadRoot,
  FileUploadRootProvider2 as FileUploadRootProvider,
  FileUploadTrigger2 as FileUploadTrigger,
  Flex,
  Float,
  FocusTrap3 as FocusTrap,
  For,
  FormatByte2 as FormatByte,
  FormatNumber2 as FormatNumber,
  Grid,
  GridItem,
  Group,
  HStack,
  Heading,
  HeadingPropsProvider,
  Highlight2 as Highlight,
  namespace_exports22 as HoverCard,
  HoverCardArrow2 as HoverCardArrow,
  HoverCardArrowTip2 as HoverCardArrowTip,
  HoverCardContent2 as HoverCardContent,
  HoverCardContext2 as HoverCardContext,
  HoverCardPositioner2 as HoverCardPositioner,
  HoverCardPropsProvider,
  HoverCardRoot2 as HoverCardRoot,
  HoverCardRootProvider2 as HoverCardRootProvider,
  HoverCardTrigger2 as HoverCardTrigger,
  Icon,
  IconButton,
  IconPropsProvider,
  Image,
  Input,
  InputAddon,
  InputElement,
  InputGroup,
  InputPropsProvider,
  Kbd,
  Link,
  LinkBox,
  LinkOverlay,
  LinkPropsProvider,
  namespace_exports23 as List,
  ListIndicator,
  ListItem,
  ListRoot,
  ListRootPropsProvider,
  Loader,
  LoaderOverlay,
  LocaleProvider,
  Mark,
  MarkPropsProvider,
  namespace_exports24 as Menu,
  MenuArrow2 as MenuArrow,
  MenuArrowTip2 as MenuArrowTip,
  MenuCheckboxItem2 as MenuCheckboxItem,
  MenuContent2 as MenuContent,
  MenuContext2 as MenuContext,
  MenuContextTrigger2 as MenuContextTrigger,
  MenuIndicator2 as MenuIndicator,
  MenuItem2 as MenuItem,
  MenuItemCommand,
  MenuItemContext2 as MenuItemContext,
  MenuItemGroup2 as MenuItemGroup,
  MenuItemGroupLabel2 as MenuItemGroupLabel,
  MenuItemIndicator2 as MenuItemIndicator,
  MenuItemText2 as MenuItemText,
  MenuPositioner2 as MenuPositioner,
  MenuPropsProvider,
  MenuRadioItem2 as MenuRadioItem,
  MenuRadioItemGroup2 as MenuRadioItemGroup,
  MenuRoot2 as MenuRoot,
  MenuRootProvider2 as MenuRootProvider,
  MenuSeparator2 as MenuSeparator,
  MenuTrigger2 as MenuTrigger,
  MenuTriggerItem2 as MenuTriggerItem,
  namespace_exports25 as NativeSelect,
  NativeSelectField,
  NativeSelectIndicator,
  NativeSelectPropsProvider,
  NativeSelectRoot,
  namespace_exports26 as NumberInput,
  NumberInputContext2 as NumberInputContext,
  NumberInputControl2 as NumberInputControl,
  NumberInputDecrementTrigger2 as NumberInputDecrementTrigger,
  NumberInputIncrementTrigger2 as NumberInputIncrementTrigger,
  NumberInputInput2 as NumberInputInput,
  NumberInputLabel2 as NumberInputLabel,
  NumberInputPropsProvider,
  NumberInputRoot2 as NumberInputRoot,
  NumberInputRootProvider2 as NumberInputRootProvider,
  NumberInputScrubber2 as NumberInputScrubber,
  NumberInputValueText2 as NumberInputValueText,
  namespace_exports27 as Pagination,
  PaginationContext2 as PaginationContext,
  PaginationEllipsis2 as PaginationEllipsis,
  PaginationItem2 as PaginationItem,
  PaginationItems,
  PaginationNextTrigger2 as PaginationNextTrigger,
  PaginationPageText,
  PaginationPrevTrigger2 as PaginationPrevTrigger,
  PaginationPropsProvider,
  PaginationRoot2 as PaginationRoot,
  PaginationRootProvider2 as PaginationRootProvider,
  namespace_exports28 as PinInput,
  PinInputContext2 as PinInputContext,
  PinInputControl2 as PinInputControl,
  PinInputHiddenInput2 as PinInputHiddenInput,
  PinInputInput2 as PinInputInput,
  PinInputLabel2 as PinInputLabel,
  PinInputPropsProvider,
  PinInputRoot2 as PinInputRoot,
  PinInputRootProvider2 as PinInputRootProvider,
  namespace_exports29 as Popover,
  PopoverAnchor2 as PopoverAnchor,
  PopoverArrow2 as PopoverArrow,
  PopoverArrowTip2 as PopoverArrowTip,
  PopoverBody,
  PopoverCloseTrigger2 as PopoverCloseTrigger,
  PopoverContent2 as PopoverContent,
  PopoverContext2 as PopoverContext,
  PopoverDescription2 as PopoverDescription,
  PopoverFooter,
  PopoverHeader,
  PopoverPositioner2 as PopoverPositioner,
  PopoverPropsProvider,
  PopoverRoot2 as PopoverRoot,
  PopoverRootProvider2 as PopoverRootProvider,
  PopoverTitle2 as PopoverTitle,
  PopoverTrigger2 as PopoverTrigger,
  Portal,
  Presence2 as Presence,
  namespace_exports30 as Progress,
  namespace_exports31 as ProgressCircle,
  ProgressCircleCircle,
  ProgressCircleContext,
  ProgressCircleLabel,
  ProgressCirclePropsProvider,
  ProgressCircleRange2 as ProgressCircleRange,
  ProgressCircleRoot,
  ProgressCircleRootProvider,
  ProgressCircleTrack2 as ProgressCircleTrack,
  ProgressCircleValueText,
  ProgressContext2 as ProgressContext,
  ProgressLabel2 as ProgressLabel,
  ProgressPropsProvider,
  ProgressRange2 as ProgressRange,
  ProgressRoot2 as ProgressRoot,
  ProgressRootProvider2 as ProgressRootProvider,
  ProgressTrack2 as ProgressTrack,
  ProgressValueText2 as ProgressValueText,
  namespace_exports32 as QrCode,
  QrCodeFrame2 as QrCodeFrame,
  QrCodeOverlay2 as QrCodeOverlay,
  QrCodePattern2 as QrCodePattern,
  QrCodePropsProvider,
  QrCodeRoot2 as QrCodeRoot,
  QrCodeRootProvider2 as QrCodeRootProvider,
  Quote,
  namespace_exports33 as RadioCard,
  RadioCardContext,
  RadioCardItem,
  RadioCardItemAddon,
  RadioCardItemContent,
  RadioCardItemControl,
  RadioCardItemDescription,
  RadioCardItemHiddenInput,
  RadioCardItemIndicator,
  RadioCardItemText,
  RadioCardLabel,
  RadioCardPropsProvider,
  RadioCardRoot,
  RadioCardRootProvider,
  namespace_exports34 as RadioGroup,
  RadioGroupContext2 as RadioGroupContext,
  RadioGroupItem2 as RadioGroupItem,
  RadioGroupItemControl2 as RadioGroupItemControl,
  RadioGroupItemHiddenInput2 as RadioGroupItemHiddenInput,
  RadioGroupItemIndicator2 as RadioGroupItemIndicator,
  RadioGroupItemText2 as RadioGroupItemText,
  RadioGroupLabel2 as RadioGroupLabel,
  RadioGroupPropsProvider,
  RadioGroupRoot2 as RadioGroupRoot,
  RadioGroupRootProvider2 as RadioGroupRootProvider,
  Radiomark,
  namespace_exports35 as RatingGroup,
  RatingGroupContext2 as RatingGroupContext,
  RatingGroupControl2 as RatingGroupControl,
  RatingGroupHiddenInput2 as RatingGroupHiddenInput,
  RatingGroupItem2 as RatingGroupItem,
  RatingGroupItemContext2 as RatingGroupItemContext,
  RatingGroupItemIndicator,
  RatingGroupItems,
  RatingGroupLabel2 as RatingGroupLabel,
  RatingGroupPropsProvider,
  RatingGroupRoot2 as RatingGroupRoot,
  RatingGroupRootProvider2 as RatingGroupRootProvider,
  RecipePropsProvider,
  namespace_exports36 as SegmentGroup,
  SegmentGroupContext2 as SegmentGroupContext,
  SegmentGroupIndicator2 as SegmentGroupIndicator,
  SegmentGroupItem2 as SegmentGroupItem,
  SegmentGroupItemContext2 as SegmentGroupItemContext,
  SegmentGroupItemHiddenInput2 as SegmentGroupItemHiddenInput,
  SegmentGroupItemText2 as SegmentGroupItemText,
  SegmentGroupItems,
  SegmentGroupPropsProvider,
  SegmentGroupRoot2 as SegmentGroupRoot,
  SegmentGroupRootProvider2 as SegmentGroupRootProvider,
  namespace_exports37 as Select,
  SelectClearTrigger2 as SelectClearTrigger,
  SelectContent2 as SelectContent,
  SelectContext2 as SelectContext,
  SelectControl2 as SelectControl,
  SelectHiddenSelect2 as SelectHiddenSelect,
  SelectIndicator2 as SelectIndicator,
  SelectIndicatorGroup,
  SelectItem2 as SelectItem,
  SelectItemContext2 as SelectItemContext,
  SelectItemGroup2 as SelectItemGroup,
  SelectItemGroupLabel2 as SelectItemGroupLabel,
  SelectItemIndicator2 as SelectItemIndicator,
  SelectItemText2 as SelectItemText,
  SelectLabel2 as SelectLabel,
  SelectPositioner2 as SelectPositioner,
  SelectPropsProvider,
  SelectRoot2 as SelectRoot,
  SelectRootProvider2 as SelectRootProvider,
  SelectTrigger2 as SelectTrigger,
  SelectValueText2 as SelectValueText,
  Separator,
  SeparatorPropsProvider,
  Show,
  SimpleGrid,
  Skeleton,
  SkeletonCircle,
  SkeletonPropsProvider,
  SkeletonText,
  SkipNavContent,
  SkipNavLink,
  namespace_exports38 as Slider,
  SliderContext2 as SliderContext,
  SliderControl2 as SliderControl,
  SliderDraggingIndicator2 as SliderDraggingIndicator,
  SliderHiddenInput2 as SliderHiddenInput,
  SliderLabel2 as SliderLabel,
  SliderMarker2 as SliderMarker,
  SliderMarkerGroup2 as SliderMarkerGroup,
  SliderMarkerIndicator,
  SliderPropsProvider,
  SliderRange2 as SliderRange,
  SliderRoot2 as SliderRoot,
  SliderRootProvider2 as SliderRootProvider,
  SliderThumb2 as SliderThumb,
  SliderTrack2 as SliderTrack,
  SliderValueText2 as SliderValueText,
  Spacer,
  Span,
  Spinner,
  SpinnerPropsProvider,
  Square,
  Stack,
  StackSeparator,
  namespace_exports39 as Stat,
  StatDownIndicator,
  StatGroup,
  StatHelpText,
  StatLabel,
  StatPropsProvider,
  StatRoot,
  StatUpIndicator,
  StatValueText,
  StatValueUnit,
  namespace_exports40 as Status,
  StatusIndicator,
  StatusPropsProvider,
  StatusRoot,
  namespace_exports41 as Steps,
  StepsCompletedContent2 as StepsCompletedContent,
  StepsContent2 as StepsContent,
  StepsContext2 as StepsContext,
  StepsDescription,
  StepsIndicator2 as StepsIndicator,
  StepsItem2 as StepsItem,
  StepsItemContext2 as StepsItemContext,
  StepsList2 as StepsList,
  StepsNextTrigger2 as StepsNextTrigger,
  StepsNumber,
  StepsPrevTrigger2 as StepsPrevTrigger,
  StepsPropsProvider,
  StepsRoot2 as StepsRoot,
  StepsRootProvider2 as StepsRootProvider,
  StepsSeparator2 as StepsSeparator,
  StepsStatus,
  StepsTitle,
  StepsTrigger2 as StepsTrigger,
  Sticky,
  Strong,
  namespace_exports42 as Switch,
  SwitchContext2 as SwitchContext,
  SwitchControl2 as SwitchControl,
  SwitchHiddenInput2 as SwitchHiddenInput,
  SwitchIndicator,
  SwitchLabel2 as SwitchLabel,
  SwitchPropsProvider,
  SwitchRoot2 as SwitchRoot,
  SwitchRootProvider2 as SwitchRootProvider,
  SwitchThumb2 as SwitchThumb,
  SwitchThumbIndicator,
  namespace_exports43 as Table,
  TableBody,
  TableCaption,
  TableCell,
  TableColumn,
  TableColumnGroup,
  TableColumnHeader,
  TableFooter,
  TableHeader,
  TableRoot,
  TableRootPropsProvider,
  TableRow,
  TableScrollArea,
  namespace_exports44 as Tabs,
  TabsContent,
  TabsContentGroup,
  TabsContext2 as TabsContext,
  TabsIndicator,
  TabsList,
  TabsPropsProvider,
  TabsRoot2 as TabsRoot,
  TabsRootProvider2 as TabsRootProvider,
  TabsTrigger,
  namespace_exports45 as Tag,
  TagCloseTrigger,
  TagEndElement,
  TagLabel,
  TagRoot,
  TagRootPropsProvider,
  TagStartElement,
  Text,
  TextPropsProvider,
  Textarea,
  TextareaPropsProvider,
  Theme,
  namespace_exports46 as Timeline,
  TimelineConnector,
  TimelineContent,
  TimelineDescription,
  TimelineIndicator,
  TimelineItem,
  TimelineRoot,
  TimelineRootPropsProvider,
  TimelineSeparator,
  TimelineTitle,
  namespace_exports47 as Toast,
  ToastActionTrigger2 as ToastActionTrigger,
  ToastCloseTrigger2 as ToastCloseTrigger,
  ToastDescription2 as ToastDescription,
  ToastIndicator,
  ToastRoot2 as ToastRoot,
  ToastTitle2 as ToastTitle,
  Toaster2 as Toaster,
  namespace_exports48 as Toggle,
  ToggleContext2 as ToggleContext,
  ToggleIndicator2 as ToggleIndicator,
  TogglePropsProvider,
  ToggleRoot2 as ToggleRoot,
  namespace_exports49 as Tooltip,
  TooltipArrow2 as TooltipArrow,
  TooltipArrowTip2 as TooltipArrowTip,
  TooltipContent2 as TooltipContent,
  TooltipContext2 as TooltipContext,
  TooltipPositioner2 as TooltipPositioner,
  TooltipPropsProvider,
  TooltipRoot2 as TooltipRoot,
  TooltipRootProvider2 as TooltipRootProvider,
  TooltipTrigger2 as TooltipTrigger,
  VStack,
  VisuallyHidden,
  Wrap,
  WrapItem,
  chakra,
  createContext,
  createIcon,
  createListCollection,
  createOverlay,
  createRecipeContext,
  createSlotRecipeContext,
  createSystem,
  createToaster,
  defaultBaseConfig,
  defaultConfig,
  defaultSystem,
  defineAnimationStyles,
  defineConditions,
  defineConfig,
  defineGlobalStyles,
  defineKeyframes,
  defineLayerStyles,
  defineRecipe,
  defineSemanticTokens,
  defineSlotRecipe,
  defineStyle,
  defineTextStyles,
  defineTokens,
  getColorChannels,
  isValidSystem,
  mergeConfigs,
  mergeProps,
  mergeRefs,
  parse as parseColor,
  useAccordion,
  useAccordionContext,
  useAccordionItemContext,
  useAccordionStyles,
  usePopover as useActionBar,
  usePopoverContext as useActionBarContext,
  useActionBarStyles,
  useAlertStyles,
  useAvatar,
  useAvatarContext,
  useAvatarStyles,
  useBlockquoteStyles,
  useBreadcrumbStyles,
  useBreakpoint,
  useBreakpointValue,
  useCallbackRef,
  useCardStyles,
  useChakraContext,
  useCheckbox,
  useCheckbox as useCheckboxCard,
  useCheckboxContext as useCheckboxCardContext,
  useCheckboxCardStyles,
  useCheckboxContext,
  useCheckboxGroup,
  useCheckboxGroupContext,
  useCheckboxStyles,
  useClipboard,
  useClipboardContext,
  useClipboardStyles,
  useCollapsible,
  useCollapsibleContext,
  useCollapsibleStyles,
  useColorPicker,
  useColorPickerContext,
  useColorPickerStyles,
  useCombobox,
  useComboboxContext,
  useComboboxItemContext,
  useComboboxStyles,
  useConst,
  useControllableProp,
  useControllableState,
  useDataListStyles,
  useDialog,
  useDialogContext,
  useDialogStyles,
  useDisclosure,
  useDialog as useDrawer,
  useDialogContext as useDrawerContext,
  useDrawerStyles,
  useEditable,
  useEditableContext,
  useEditableStyles,
  useElementRect,
  useEmptyStateStyles,
  useEnvironmentContext,
  useFieldContext,
  useFieldStyles,
  useFieldsetContext,
  useFileUpload,
  useFileUploadContext,
  useFileUploadStyles,
  useFilter,
  useForceUpdate,
  useHighlight,
  useHoverCard,
  useHoverCardContext,
  useHoverCardStyles,
  useListCollection2 as useListCollection,
  useListStyles,
  useLiveRef2 as useLiveRef,
  useLocaleContext,
  useMediaQuery,
  useMenu,
  useMenuContext,
  useMenuItemContext,
  useMenuStyles,
  useNativeSelectStyles,
  useNumberInput,
  useNumberInputContext,
  useNumberInputStyles,
  usePagination,
  usePaginationContext,
  usePaginationStyles,
  useParentRecipeProps,
  usePinInput,
  usePinInputContext,
  usePinInputStyles,
  usePopover,
  usePopoverContext,
  usePopoverStyles,
  usePrevious,
  useProgress,
  useProgressCircleStyles,
  useProgressContext,
  useProgressStyles,
  useQrCode,
  useQrCodeContext,
  useQrCodeStyles,
  useRadioGroupContext as useRadioCardContext,
  useRadioGroup as useRadioCardGroup,
  useRadioGroupItemContext as useRadioCardItemContext,
  useRadioCardStyles,
  useRadioGroup,
  useRadioGroupContext,
  useRadioGroupItemContext,
  useRadioGroupStyles,
  useRatingGroup,
  useRatingGroupContext,
  useRatingGroupItemContext,
  useRatingGroupStyles,
  useRecipe,
  useSafeLayoutEffect3 as useSafeLayoutEffect,
  useSegmentGroup,
  useSegmentGroupContext,
  useSegmentGroupItemContext,
  useSegmentGroupStyles,
  useSelect,
  useSelectContext,
  useSelectItemContext,
  useSelectStyles,
  useSlider,
  useSliderContext,
  useSliderStyles,
  useSlotRecipe,
  useStatStyles,
  useStatusStyles,
  useSteps,
  useStepsContext,
  useStepsItemContext,
  useStepsStyles,
  useSwitch,
  useSwitchContext,
  useSwitchStyles,
  useTableStyles,
  useTabs,
  useTabsContext,
  useTabsStyles,
  useTagStyles,
  useTimelineStyles,
  useToastStyles,
  useToggle,
  useToggleContext,
  useToggleStyles,
  useToken,
  useTooltip,
  useTooltipContext,
  useTooltipStyles,
  useUpdateEffect,
  visuallyHiddenStyle2 as visuallyHiddenStyle
};
//# sourceMappingURL=@chakra-ui_react.js.map
